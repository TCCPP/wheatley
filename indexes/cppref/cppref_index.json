{
    "c": [
        {
            "title": "C11",
            "path": "en.cppreference.com/w/c/11.html",
            "wgPageName": "c/11"
        },
        {
            "title": "C17",
            "path": "en.cppreference.com/w/c/17.html",
            "wgPageName": "c/17"
        },
        {
            "title": "C23",
            "path": "en.cppreference.com/w/c/23.html",
            "wgPageName": "c/23"
        },
        {
            "title": "C95",
            "path": "en.cppreference.com/w/c/95.html",
            "wgPageName": "c/95"
        },
        {
            "title": "C99",
            "path": "en.cppreference.com/w/c/99.html",
            "wgPageName": "c/99"
        },
        {
            "title": "Algorithms",
            "path": "en.cppreference.com/w/c/algorithm.html",
            "wgPageName": "c/algorithm"
        },
        {
            "title": "bsearch, bsearch_s",
            "path": "en.cppreference.com/w/c/algorithm/bsearch.html",
            "wgPageName": "c/algorithm/bsearch",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "void* bsearch(\n    const void* key,\n    const void* ptr,\n    size_t count,\n    size_t size,\n    int (*comp)(const void*, const void*));",
            "other_declarations": 1
        },
        {
            "title": "qsort, qsort_s",
            "path": "en.cppreference.com/w/c/algorithm/qsort.html",
            "wgPageName": "c/algorithm/qsort",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "void qsort(\n    void* ptr,\n    size_t count,\n    size_t size,\n    int (*comp)(const void*, const void*));",
            "other_declarations": 1
        },
        {
            "title": "Atomic operations library",
            "path": "en.cppreference.com/w/c/atomic.html",
            "wgPageName": "c/atomic"
        },
        {
            "title": "atomic_compare_exchange_weak, atomic_compare_exchange_strong, atomic_compare_exchange_weak_explicit, atomic_compare_exchange_strong_explicit",
            "path": "en.cppreference.com/w/c/atomic/atomic_compare_exchange.html",
            "wgPageName": "c/atomic/atomic_compare_exchange",
            "headers": [
                "<stdatomic.h>"
            ],
            "sample_declaration": "_Bool atomic_compare_exchange_strong(\n    volatile A* obj,\n    C* expected,\n    C desired);",
            "other_declarations": 3
        },
        {
            "title": "atomic_exchange, atomic_exchange_explicit",
            "path": "en.cppreference.com/w/c/atomic/atomic_exchange.html",
            "wgPageName": "c/atomic/atomic_exchange",
            "headers": [
                "<stdatomic.h>"
            ],
            "sample_declaration": "C atomic_exchange(volatile A* obj, C desired);",
            "other_declarations": 1
        },
        {
            "title": "atomic_fetch_add, atomic_fetch_add_explicit",
            "path": "en.cppreference.com/w/c/atomic/atomic_fetch_add.html",
            "wgPageName": "c/atomic/atomic_fetch_add",
            "headers": [
                "<stdatomic.h>"
            ],
            "sample_declaration": "C atomic_fetch_add(volatile A* obj, M arg);",
            "other_declarations": 1
        },
        {
            "title": "atomic_fetch_and, atomic_fetch_and_explicit",
            "path": "en.cppreference.com/w/c/atomic/atomic_fetch_and.html",
            "wgPageName": "c/atomic/atomic_fetch_and",
            "headers": [
                "<stdatomic.h>"
            ],
            "sample_declaration": "C atomic_fetch_and(volatile A* obj, M arg);",
            "other_declarations": 1
        },
        {
            "title": "atomic_fetch_or, atomic_fetch_or_explicit",
            "path": "en.cppreference.com/w/c/atomic/atomic_fetch_or.html",
            "wgPageName": "c/atomic/atomic_fetch_or",
            "headers": [
                "<stdatomic.h>"
            ],
            "sample_declaration": "C atomic_fetch_or(volatile A* obj, M arg);",
            "other_declarations": 1
        },
        {
            "title": "atomic_fetch_sub, atomic_fetch_sub_explicit",
            "path": "en.cppreference.com/w/c/atomic/atomic_fetch_sub.html",
            "wgPageName": "c/atomic/atomic_fetch_sub",
            "headers": [
                "<stdatomic.h>"
            ],
            "sample_declaration": "C atomic_fetch_sub(volatile A* obj, M arg);",
            "other_declarations": 1
        },
        {
            "title": "atomic_fetch_xor, atomic_fetch_xor_explicit",
            "path": "en.cppreference.com/w/c/atomic/atomic_fetch_xor.html",
            "wgPageName": "c/atomic/atomic_fetch_xor",
            "headers": [
                "<stdatomic.h>"
            ],
            "sample_declaration": "C atomic_fetch_xor(volatile A* obj, M arg);",
            "other_declarations": 1
        },
        {
            "title": "atomic_flag_clear, atomic_flag_clear_explicit",
            "path": "en.cppreference.com/w/c/atomic/atomic_flag_clear.html",
            "wgPageName": "c/atomic/atomic_flag_clear",
            "headers": [
                "<stdatomic.h>"
            ],
            "sample_declaration": "void atomic_flag_clear(\n    volatile atomic_flag* obj);",
            "other_declarations": 1
        },
        {
            "title": "ATOMIC_FLAG_INIT",
            "path": "en.cppreference.com/w/c/atomic/ATOMIC_FLAG_INIT.html",
            "wgPageName": "c/atomic/ATOMIC_FLAG_INIT",
            "headers": [
                "<stdatomic.h>"
            ],
            "sample_declaration": "#define ATOMIC_FLAG_INIT /* unspecified */"
        },
        {
            "title": "atomic_flag_test_and_set, atomic_flag_test_and_set_explicit",
            "path": "en.cppreference.com/w/c/atomic/atomic_flag_test_and_set.html",
            "wgPageName": "c/atomic/atomic_flag_test_and_set",
            "headers": [
                "<stdatomic.h>"
            ],
            "sample_declaration": "_Bool atomic_flag_test_and_set(\n    volatile atomic_flag* obj);",
            "other_declarations": 1
        },
        {
            "title": "atomic_flag",
            "path": "en.cppreference.com/w/c/atomic/atomic_flag.html",
            "wgPageName": "c/atomic/atomic_flag",
            "headers": [
                "<stdatomic.h>"
            ],
            "sample_declaration": "struct atomic_flag;"
        },
        {
            "title": "atomic_init",
            "path": "en.cppreference.com/w/c/atomic/atomic_init.html",
            "wgPageName": "c/atomic/atomic_init",
            "headers": [
                "<stdatomic.h>"
            ],
            "sample_declaration": "void atomic_init(volatile A* obj, C desired);"
        },
        {
            "title": "atomic_is_lock_free",
            "path": "en.cppreference.com/w/c/atomic/atomic_is_lock_free.html",
            "wgPageName": "c/atomic/atomic_is_lock_free",
            "headers": [
                "<stdatomic.h>"
            ],
            "sample_declaration": "_Bool atomic_is_lock_free(\n    const volatile A* obj);"
        },
        {
            "title": "atomic_load, atomic_load_explicit",
            "path": "en.cppreference.com/w/c/atomic/atomic_load.html",
            "wgPageName": "c/atomic/atomic_load",
            "headers": [
                "<stdatomic.h>"
            ],
            "sample_declaration": "C atomic_load(const volatile A* obj);",
            "other_declarations": 1
        },
        {
            "title": "ATOMIC_*_LOCK_FREE",
            "path": "en.cppreference.com/w/c/atomic/ATOMIC_LOCK_FREE_consts.html",
            "wgPageName": "c/atomic/ATOMIC_LOCK_FREE_consts",
            "headers": [
                "<stdatomic.h>"
            ],
            "sample_declaration": "#define ATOMIC_BOOL_LOCK_FREE /* implementation-defined           \\\n                               */                                 \\\n#define ATOMIC_CHAR_LOCK_FREE /* implementation-defined         \\\n                                 */                               \\\n      #define ATOMIC_CHAR16_T_LOCK_FREE /* implementation-defined \\\n                                         */                       \\\n      #define ATOMIC_CHAR32_T_LOCK_FREE /* implementation-defined \\\n                                         */                       \\\n      #define ATOMIC_WCHAR_T_LOCK_FREE /* implementation-defined  \\\n                                        */                        \\\n      #define ATOMIC_SHORT_LOCK_FREE /* implementation-defined    \\\n                                      */                          \\\n      #define ATOMIC_INT_LOCK_FREE /* implementation-defined      \\\n                                    */                            \\\n      #define ATOMIC_LONG_LOCK_FREE /* implementation-defined     \\\n                                     */                           \\\n      #define ATOMIC_LLONG_LOCK_FREE /* implementation-defined    \\\n                                      */                          \\\n      #define ATOMIC_POINTER_LOCK_FREE /* implementation-defined  \\\n                                        */",
            "other_declarations": 1
        },
        {
            "title": "atomic_signal_fence",
            "path": "en.cppreference.com/w/c/atomic/atomic_signal_fence.html",
            "wgPageName": "c/atomic/atomic_signal_fence",
            "headers": [
                "<stdatomic.h>"
            ],
            "sample_declaration": "void atomic_signal_fence(memory_order order);"
        },
        {
            "title": "atomic_store, atomic_store_explicit",
            "path": "en.cppreference.com/w/c/atomic/atomic_store.html",
            "wgPageName": "c/atomic/atomic_store",
            "headers": [
                "<stdatomic.h>"
            ],
            "sample_declaration": "void atomic_store(volatile A* obj, C desired);",
            "other_declarations": 1
        },
        {
            "title": "atomic_thread_fence",
            "path": "en.cppreference.com/w/c/atomic/atomic_thread_fence.html",
            "wgPageName": "c/atomic/atomic_thread_fence",
            "headers": [
                "<stdatomic.h>"
            ],
            "sample_declaration": "void atomic_thread_fence(memory_order order);"
        },
        {
            "title": "ATOMIC_VAR_INIT",
            "path": "en.cppreference.com/w/c/atomic/ATOMIC_VAR_INIT.html",
            "wgPageName": "c/atomic/ATOMIC_VAR_INIT",
            "headers": [
                "<stdatomic.h>"
            ],
            "sample_declaration": "#define ATOMIC_VAR_INIT(value) /* unspecified \\\n                                */"
        },
        {
            "title": "kill_dependency",
            "path": "en.cppreference.com/w/c/atomic/kill_dependency.html",
            "wgPageName": "c/atomic/kill_dependency",
            "headers": [
                "<stdatomic.h>"
            ],
            "sample_declaration": "A kill_dependency(A y);"
        },
        {
            "title": "memory_order",
            "path": "en.cppreference.com/w/c/atomic/memory_order.html",
            "wgPageName": "c/atomic/memory_order",
            "headers": [
                "<stdatomic.h>"
            ],
            "sample_declaration": "enum memory_order {\n  memory_order_relaxed,\n  memory_order_consume,\n  memory_order_acquire,\n  memory_order_release,\n  memory_order_acq_rel,\n  memory_order_seq_cst\n};"
        },
        {
            "title": "Date and time utilities",
            "path": "en.cppreference.com/w/c/chrono.html",
            "wgPageName": "c/chrono"
        },
        {
            "title": "asctime, asctime_s",
            "path": "en.cppreference.com/w/c/chrono/asctime.html",
            "wgPageName": "c/chrono/asctime",
            "headers": [
                "<time.h>"
            ],
            "sample_declaration": "char* asctime(const struct tm* time_ptr);",
            "other_declarations": 2
        },
        {
            "title": "clock_t",
            "path": "en.cppreference.com/w/c/chrono/clock_t.html",
            "wgPageName": "c/chrono/clock_t",
            "headers": [
                "<time.h>"
            ],
            "sample_declaration": "typedef /* unspecified */ clock_t;"
        },
        {
            "title": "clock",
            "path": "en.cppreference.com/w/c/chrono/clock.html",
            "wgPageName": "c/chrono/clock",
            "headers": [
                "<time.h>"
            ],
            "sample_declaration": "clock_t clock(void);"
        },
        {
            "title": "CLOCKS_PER_SEC",
            "path": "en.cppreference.com/w/c/chrono/CLOCKS_PER_SEC.html",
            "wgPageName": "c/chrono/CLOCKS_PER_SEC",
            "headers": [
                "<time.h>"
            ],
            "sample_declaration": "#define CLOCKS_PER_SEC /*implementation \\\n                          defined*/"
        },
        {
            "title": "ctime, ctime_s",
            "path": "en.cppreference.com/w/c/chrono/ctime.html",
            "wgPageName": "c/chrono/ctime",
            "headers": [
                "<time.h>"
            ],
            "sample_declaration": "char* ctime(const time_t* timer);",
            "other_declarations": 2
        },
        {
            "title": "difftime",
            "path": "en.cppreference.com/w/c/chrono/difftime.html",
            "wgPageName": "c/chrono/difftime",
            "headers": [
                "<time.h>"
            ],
            "sample_declaration": "double difftime(\n    time_t time_end,\n    time_t time_beg);"
        },
        {
            "title": "gmtime, gmtime_r, gmtime_s",
            "path": "en.cppreference.com/w/c/chrono/gmtime.html",
            "wgPageName": "c/chrono/gmtime",
            "headers": [
                "<time.h>"
            ],
            "sample_declaration": "struct tm* gmtime(const time_t* timer);",
            "other_declarations": 2
        },
        {
            "title": "localtime, localtime_r, localtime_s",
            "path": "en.cppreference.com/w/c/chrono/localtime.html",
            "wgPageName": "c/chrono/localtime",
            "headers": [
                "<time.h>"
            ],
            "sample_declaration": "struct tm* localtime(const time_t* timer);",
            "other_declarations": 2
        },
        {
            "title": "mktime",
            "path": "en.cppreference.com/w/c/chrono/mktime.html",
            "wgPageName": "c/chrono/mktime",
            "headers": [
                "<time.h>"
            ],
            "sample_declaration": "time_t mktime(struct tm* arg);"
        },
        {
            "title": "strftime",
            "path": "en.cppreference.com/w/c/chrono/strftime.html",
            "wgPageName": "c/chrono/strftime",
            "headers": [
                "<time.h>"
            ],
            "sample_declaration": "size_t strftime(\n    char* str,\n    size_t count,\n    const char* format,\n    const struct tm* time);",
            "other_declarations": 1
        },
        {
            "title": "time_t",
            "path": "en.cppreference.com/w/c/chrono/time_t.html",
            "wgPageName": "c/chrono/time_t",
            "headers": [
                "<time.h>"
            ],
            "sample_declaration": "typedef /* unspecified */ time_t;"
        },
        {
            "title": "time",
            "path": "en.cppreference.com/w/c/chrono/time.html",
            "wgPageName": "c/chrono/time",
            "headers": [
                "<time.h>"
            ],
            "sample_declaration": "time_t time(time_t* arg);"
        },
        {
            "title": "timespec_get",
            "path": "en.cppreference.com/w/c/chrono/timespec_get.html",
            "wgPageName": "c/chrono/timespec_get",
            "headers": [
                "<time.h>"
            ],
            "sample_declaration": "int timespec_get(struct timespec* ts, int base);",
            "other_declarations": 1
        },
        {
            "title": "timespec_getres",
            "path": "en.cppreference.com/w/c/chrono/timespec_getres.html",
            "wgPageName": "c/chrono/timespec_getres",
            "headers": [
                "<time.h>"
            ],
            "sample_declaration": "int timespec_getres(\n    struct timespec* ts,\n    int base);"
        },
        {
            "title": "timespec",
            "path": "en.cppreference.com/w/c/chrono/timespec.html",
            "wgPageName": "c/chrono/timespec",
            "headers": [
                "<time.h>"
            ],
            "sample_declaration": "struct timespec;"
        },
        {
            "title": "tm",
            "path": "en.cppreference.com/w/c/chrono/tm.html",
            "wgPageName": "c/chrono/tm",
            "headers": [
                "<time.h>"
            ],
            "sample_declaration": "struct tm;"
        },
        {
            "title": "wcsftime",
            "path": "en.cppreference.com/w/c/chrono/wcsftime.html",
            "wgPageName": "c/chrono/wcsftime",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "size_t wcsftime(\n    wchar_t* str,\n    size_t count,\n    const wchar_t* format,\n    tm* time);"
        },
        {
            "title": "Comments",
            "path": "en.cppreference.com/w/c/comment.html",
            "wgPageName": "c/comment"
        },
        {
            "title": "Current Status",
            "path": "en.cppreference.com/w/c/current_status.html",
            "wgPageName": "c/current_status"
        },
        {
            "title": "Error handling",
            "path": "en.cppreference.com/w/c/error.html",
            "wgPageName": "c/error"
        },
        {
            "title": "abort_handler_s",
            "path": "en.cppreference.com/w/c/error/abort_handler_s.html",
            "wgPageName": "c/error/abort_handler_s",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "void abort_handler_s(\n    const char* restrict msg,\n    void* restrict ptr,\n    errno_t error);"
        },
        {
            "title": "assert",
            "path": "en.cppreference.com/w/c/error/assert.html",
            "wgPageName": "c/error/assert",
            "headers": [
                "<assert.h>"
            ],
            "sample_declaration": "#ifdef NDEBUG #define assert(condition)((                              \\\n    void)0) #else #define assert(condition) /*implementation defined*/ \\\n    #endif"
        },
        {
            "title": "Error numbers",
            "path": "en.cppreference.com/w/c/error/errno_macros.html",
            "wgPageName": "c/error/errno_macros"
        },
        {
            "title": "errno",
            "path": "en.cppreference.com/w/c/error/errno.html",
            "wgPageName": "c/error/errno",
            "headers": [
                "<errno.h>"
            ],
            "sample_declaration": "#define errno /*implementation-defined*/"
        },
        {
            "title": "ignore_handler_s",
            "path": "en.cppreference.com/w/c/error/ignore_handler_s.html",
            "wgPageName": "c/error/ignore_handler_s",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "void ignore_handler_s(\n    const char* restrict msg,\n    void* restrict ptr,\n    errno_t error);"
        },
        {
            "title": "set_constraint_handler_s, constraint_handler_t",
            "path": "en.cppreference.com/w/c/error/set_constraint_handler_s.html",
            "wgPageName": "c/error/set_constraint_handler_s",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "constraint_handler_t set_constraint_handler_s(\n    constraint_handler_t handler);"
        },
        {
            "title": "static_assert",
            "path": "en.cppreference.com/w/c/error/static_assert.html",
            "wgPageName": "c/error/static_assert",
            "headers": [
                "<assert.h>"
            ],
            "sample_declaration": "#define static_assert _Static_assert"
        },
        {
            "title": "Experimental C features",
            "path": "en.cppreference.com/w/c/experimental.html",
            "wgPageName": "c/experimental"
        },
        {
            "title": "Dynamic memory extensions",
            "path": "en.cppreference.com/w/c/experimental/dynamic.html",
            "wgPageName": "c/experimental/dynamic"
        },
        {
            "title": "asprintf, aswprintf, vasprintf, vaswprintf",
            "path": "en.cppreference.com/w/c/experimental/dynamic/asprintf.html",
            "wgPageName": "c/experimental/dynamic/asprintf",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "int asprintf(\n    char** restrict strp,\n    const char* restrict fmt,\n    ...);",
            "other_declarations": 3
        },
        {
            "title": "getline, getwline, getdelim, getwdelim",
            "path": "en.cppreference.com/w/c/experimental/dynamic/getline.html",
            "wgPageName": "c/experimental/dynamic/getline",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "ssize_t getline(\n    char** lineptr,\n    size_t* n,\n    FILE* stream);",
            "other_declarations": 3
        },
        {
            "title": "strdup",
            "path": "en.cppreference.com/w/c/experimental/dynamic/strdup.html",
            "wgPageName": "c/experimental/dynamic/strdup",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "char* strdup(const char* str1);"
        },
        {
            "title": "strndup",
            "path": "en.cppreference.com/w/c/experimental/dynamic/strndup.html",
            "wgPageName": "c/experimental/dynamic/strndup",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "char* strndup(const char* str, size_t size);"
        },
        {
            "title": "Floating-point extensions part 1: binary floating-point arithmetic",
            "path": "en.cppreference.com/w/c/experimental/fpext1.html",
            "wgPageName": "c/experimental/fpext1"
        },
        {
            "title": "c/experimental/fpext1/nextup",
            "path": "en.cppreference.com/w/c/experimental/fpext1/nextup.html",
            "wgPageName": "c/experimental/fpext1/nextup"
        },
        {
            "title": "Floating-point extensions part 4: supplementary functions",
            "path": "en.cppreference.com/w/c/experimental/fpext4.html",
            "wgPageName": "c/experimental/fpext4"
        },
        {
            "title": "C Standard Library header files",
            "path": "en.cppreference.com/w/c/header.html",
            "wgPageName": "c/header"
        },
        {
            "title": "Symbol Index",
            "path": "en.cppreference.com/w/c/index.html",
            "wgPageName": "c/symbol_index"
        },
        {
            "title": "File input/output",
            "path": "en.cppreference.com/w/c/io.html",
            "wgPageName": "c/io"
        },
        {
            "title": "clearerr",
            "path": "en.cppreference.com/w/c/io/clearerr.html",
            "wgPageName": "c/io/clearerr",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "void clearerr(FILE* stream);"
        },
        {
            "title": "fclose",
            "path": "en.cppreference.com/w/c/io/fclose.html",
            "wgPageName": "c/io/fclose",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "int fclose(FILE* stream);"
        },
        {
            "title": "feof",
            "path": "en.cppreference.com/w/c/io/feof.html",
            "wgPageName": "c/io/feof",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "int feof(FILE* stream);"
        },
        {
            "title": "ferror",
            "path": "en.cppreference.com/w/c/io/ferror.html",
            "wgPageName": "c/io/ferror",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "int ferror(FILE* stream);"
        },
        {
            "title": "fflush",
            "path": "en.cppreference.com/w/c/io/fflush.html",
            "wgPageName": "c/io/fflush",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "int fflush(FILE* stream);"
        },
        {
            "title": "fgetc, getc",
            "path": "en.cppreference.com/w/c/io/fgetc.html",
            "wgPageName": "c/io/fgetc",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "int fgetc(FILE* stream);",
            "other_declarations": 1
        },
        {
            "title": "fgetpos",
            "path": "en.cppreference.com/w/c/io/fgetpos.html",
            "wgPageName": "c/io/fgetpos",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "int fgetpos(FILE* stream, fpos_t* pos);",
            "other_declarations": 1
        },
        {
            "title": "fgets",
            "path": "en.cppreference.com/w/c/io/fgets.html",
            "wgPageName": "c/io/fgets",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "char* fgets(char* str, int count, FILE* stream);",
            "other_declarations": 1
        },
        {
            "title": "fgetwc, getwc",
            "path": "en.cppreference.com/w/c/io/fgetwc.html",
            "wgPageName": "c/io/fgetwc",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "wint_t fgetwc(FILE* stream);",
            "other_declarations": 1
        },
        {
            "title": "fgetws",
            "path": "en.cppreference.com/w/c/io/fgetws.html",
            "wgPageName": "c/io/fgetws",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "wchar_t*\nfgetws(wchar_t* str, int count, FILE* stream);",
            "other_declarations": 1
        },
        {
            "title": "FILE",
            "path": "en.cppreference.com/w/c/io/FILE.html",
            "wgPageName": "c/io/FILE",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "typedef /* unspecified */ FILE;"
        },
        {
            "title": "fopen, fopen_s",
            "path": "en.cppreference.com/w/c/io/fopen.html",
            "wgPageName": "c/io/fopen",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "FILE* fopen(\n    const char* filename,\n    const char* mode);",
            "other_declarations": 2
        },
        {
            "title": "fpos_t",
            "path": "en.cppreference.com/w/c/io/fpos_t.html",
            "wgPageName": "c/io/fpos_t",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "typedef /* implementation-defined */ fpos_t;"
        },
        {
            "title": "printf, fprintf, sprintf, snprintf, printf_s, fprintf_s, sprintf_s, snprintf_s",
            "path": "en.cppreference.com/w/c/io/fprintf.html",
            "wgPageName": "c/io/fprintf",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "int printf(const char* format, ...);",
            "other_declarations": 10
        },
        {
            "title": "fputc, putc",
            "path": "en.cppreference.com/w/c/io/fputc.html",
            "wgPageName": "c/io/fputc",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "int fputc(int ch, FILE* stream);",
            "other_declarations": 1
        },
        {
            "title": "fputs",
            "path": "en.cppreference.com/w/c/io/fputs.html",
            "wgPageName": "c/io/fputs",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "int fputs(const char* str, FILE* stream);",
            "other_declarations": 1
        },
        {
            "title": "fputwc, putwc",
            "path": "en.cppreference.com/w/c/io/fputwc.html",
            "wgPageName": "c/io/fputwc",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "wint_t fputwc(wchar_t ch, FILE* stream);",
            "other_declarations": 1
        },
        {
            "title": "fputws",
            "path": "en.cppreference.com/w/c/io/fputws.html",
            "wgPageName": "c/io/fputws",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "int fputws(const wchar_t* str, FILE* stream);",
            "other_declarations": 1
        },
        {
            "title": "fread",
            "path": "en.cppreference.com/w/c/io/fread.html",
            "wgPageName": "c/io/fread",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "size_t fread(\n    void* buffer,\n    size_t size,\n    size_t count,\n    FILE* stream);",
            "other_declarations": 1
        },
        {
            "title": "freopen, freopen_s",
            "path": "en.cppreference.com/w/c/io/freopen.html",
            "wgPageName": "c/io/freopen",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "FILE* freopen(\n    const char* filename,\n    const char* mode,\n    FILE* stream);",
            "other_declarations": 2
        },
        {
            "title": "scanf, fscanf, sscanf, scanf_s, fscanf_s, sscanf_s",
            "path": "en.cppreference.com/w/c/io/fscanf.html",
            "wgPageName": "c/io/fscanf",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "int scanf(const char* format, ...);",
            "other_declarations": 8
        },
        {
            "title": "fseek",
            "path": "en.cppreference.com/w/c/io/fseek.html",
            "wgPageName": "c/io/fseek",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "int fseek(\n    FILE* stream,\n    long offset,\n    int origin);",
            "other_declarations": 1
        },
        {
            "title": "fsetpos",
            "path": "en.cppreference.com/w/c/io/fsetpos.html",
            "wgPageName": "c/io/fsetpos",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "int fsetpos(FILE* stream, const fpos_t* pos);"
        },
        {
            "title": "ftell",
            "path": "en.cppreference.com/w/c/io/ftell.html",
            "wgPageName": "c/io/ftell",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "long ftell(FILE* stream);"
        },
        {
            "title": "fwide",
            "path": "en.cppreference.com/w/c/io/fwide.html",
            "wgPageName": "c/io/fwide",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "int fwide(FILE* stream, int mode);"
        },
        {
            "title": "wprintf, fwprintf, swprintf, wprintf_s, fwprintf_s, swprintf_s, snwprintf_s",
            "path": "en.cppreference.com/w/c/io/fwprintf.html",
            "wgPageName": "c/io/fwprintf",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "int wprintf(const wchar_t* format, ...);",
            "other_declarations": 9
        },
        {
            "title": "fwrite",
            "path": "en.cppreference.com/w/c/io/fwrite.html",
            "wgPageName": "c/io/fwrite",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "size_t fwrite(\n    const void* buffer,\n    size_t size,\n    size_t count,\n    FILE* stream);",
            "other_declarations": 1
        },
        {
            "title": "wscanf, fwscanf, swscanf, wscanf_s, fwscanf_s, swscanf_s",
            "path": "en.cppreference.com/w/c/io/fwscanf.html",
            "wgPageName": "c/io/fwscanf",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "int wscanf(const wchar_t* format, ...);",
            "other_declarations": 8
        },
        {
            "title": "getchar",
            "path": "en.cppreference.com/w/c/io/getchar.html",
            "wgPageName": "c/io/getchar",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "int getchar(void);"
        },
        {
            "title": "gets, gets_s",
            "path": "en.cppreference.com/w/c/io/gets.html",
            "wgPageName": "c/io/gets",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "char* gets(char* str);",
            "other_declarations": 1
        },
        {
            "title": "getwchar",
            "path": "en.cppreference.com/w/c/io/getwchar.html",
            "wgPageName": "c/io/getwchar",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "wint_t getwchar(void);"
        },
        {
            "title": "perror",
            "path": "en.cppreference.com/w/c/io/perror.html",
            "wgPageName": "c/io/perror",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "void perror(const char* s);"
        },
        {
            "title": "putchar",
            "path": "en.cppreference.com/w/c/io/putchar.html",
            "wgPageName": "c/io/putchar",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "int putchar(int ch);"
        },
        {
            "title": "puts",
            "path": "en.cppreference.com/w/c/io/puts.html",
            "wgPageName": "c/io/puts",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "int puts(const char* str);"
        },
        {
            "title": "putwchar",
            "path": "en.cppreference.com/w/c/io/putwchar.html",
            "wgPageName": "c/io/putwchar",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "wint_t putwchar(wchar_t ch);"
        },
        {
            "title": "remove",
            "path": "en.cppreference.com/w/c/io/remove.html",
            "wgPageName": "c/io/remove",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "int remove(const char* fname);"
        },
        {
            "title": "rename",
            "path": "en.cppreference.com/w/c/io/rename.html",
            "wgPageName": "c/io/rename",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "int rename(\n    const char* old_filename,\n    const char* new_filename);"
        },
        {
            "title": "rewind",
            "path": "en.cppreference.com/w/c/io/rewind.html",
            "wgPageName": "c/io/rewind",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "void rewind(FILE* stream);"
        },
        {
            "title": "setbuf",
            "path": "en.cppreference.com/w/c/io/setbuf.html",
            "wgPageName": "c/io/setbuf",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "void setbuf(FILE* stream, char* buffer);",
            "other_declarations": 2
        },
        {
            "title": "setvbuf",
            "path": "en.cppreference.com/w/c/io/setvbuf.html",
            "wgPageName": "c/io/setvbuf",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "int setvbuf(\n    FILE* stream,\n    char* buffer,\n    int mode,\n    size_t size);",
            "other_declarations": 2
        },
        {
            "title": "stdin, stdout, stderr",
            "path": "en.cppreference.com/w/c/io/std_streams.html",
            "wgPageName": "c/io/std_streams",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "#define stdin /* implementation-defined */",
            "other_declarations": 2
        },
        {
            "title": "tmpfile, tmpfile_s",
            "path": "en.cppreference.com/w/c/io/tmpfile.html",
            "wgPageName": "c/io/tmpfile",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "FILE* tmpfile(void);",
            "other_declarations": 1
        },
        {
            "title": "tmpnam, tmpnam_s",
            "path": "en.cppreference.com/w/c/io/tmpnam.html",
            "wgPageName": "c/io/tmpnam",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "char* tmpnam(char* filename);",
            "other_declarations": 5
        },
        {
            "title": "ungetc",
            "path": "en.cppreference.com/w/c/io/ungetc.html",
            "wgPageName": "c/io/ungetc",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "int ungetc(int ch, FILE* stream);"
        },
        {
            "title": "ungetwc",
            "path": "en.cppreference.com/w/c/io/ungetwc.html",
            "wgPageName": "c/io/ungetwc",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "wint_t ungetwc(wint_t ch, FILE* stream);"
        },
        {
            "title": "vprintf, vfprintf, vsprintf, vsnprintf, vprintf_s, vfprintf_s, vsprintf_s, vsnprintf_s",
            "path": "en.cppreference.com/w/c/io/vfprintf.html",
            "wgPageName": "c/io/vfprintf",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "int vprintf(const char* format, va_list vlist);",
            "other_declarations": 10
        },
        {
            "title": "vscanf, vfscanf, vsscanf, vscanf_s, vfscanf_s, vsscanf_s",
            "path": "en.cppreference.com/w/c/io/vfscanf.html",
            "wgPageName": "c/io/vfscanf",
            "headers": [
                "<stdio.h>"
            ],
            "sample_declaration": "int vscanf(\n    const char* restrict format,\n    va_list vlist);",
            "other_declarations": 5
        },
        {
            "title": "vwprintf, vfwprintf, vswprintf, vwprintf_s, vfwprintf_s, vswprintf_s, vsnwprintf_s",
            "path": "en.cppreference.com/w/c/io/vfwprintf.html",
            "wgPageName": "c/io/vfwprintf",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "int vwprintf(\n    const wchar_t* format,\n    va_list vlist);",
            "other_declarations": 9
        },
        {
            "title": "vwscanf, vfwscanf, vswscanf, vwscanf_s, vfwscanf_s, vswscanf_s",
            "path": "en.cppreference.com/w/c/io/vfwscanf.html",
            "wgPageName": "c/io/vfwscanf",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "int vwscanf(\n    const wchar_t* restrict format,\n    va_list vlist);",
            "other_declarations": 5
        },
        {
            "title": "C keywords",
            "path": "en.cppreference.com/w/c/keyword.html",
            "wgPageName": "c/keyword"
        },
        {
            "title": "C keywords: _Alignas (since C11)",
            "path": "en.cppreference.com/w/c/keyword/_Alignas.html",
            "wgPageName": "c/keyword/_Alignas"
        },
        {
            "title": "C keywords: _Alignof (since C11)",
            "path": "en.cppreference.com/w/c/keyword/_Alignof.html",
            "wgPageName": "c/keyword/_Alignof"
        },
        {
            "title": "C keywords: _Atomic",
            "path": "en.cppreference.com/w/c/keyword/_Atomic.html",
            "wgPageName": "c/keyword/_Atomic"
        },
        {
            "title": "C keywords: _Bool",
            "path": "en.cppreference.com/w/c/keyword/_Bool.html",
            "wgPageName": "c/keyword/_Bool"
        },
        {
            "title": "C keywords: _Complex",
            "path": "en.cppreference.com/w/c/keyword/_Complex.html",
            "wgPageName": "c/keyword/_Complex"
        },
        {
            "title": "C keywords: _Decimal128",
            "path": "en.cppreference.com/w/c/keyword/_Decimal128.html",
            "wgPageName": "c/keyword/_Decimal128"
        },
        {
            "title": "C keywords: _Decimal32",
            "path": "en.cppreference.com/w/c/keyword/_Decimal32.html",
            "wgPageName": "c/keyword/_Decimal32"
        },
        {
            "title": "C keywords: _Decimal64",
            "path": "en.cppreference.com/w/c/keyword/_Decimal64.html",
            "wgPageName": "c/keyword/_Decimal64"
        },
        {
            "title": "C keywords: _Generic",
            "path": "en.cppreference.com/w/c/keyword/_Generic.html",
            "wgPageName": "c/keyword/_Generic"
        },
        {
            "title": "C keywords: _Imaginary",
            "path": "en.cppreference.com/w/c/keyword/_Imaginary.html",
            "wgPageName": "c/keyword/_Imaginary"
        },
        {
            "title": "C keywords: _Noreturn (since C11)",
            "path": "en.cppreference.com/w/c/keyword/_Noreturn.html",
            "wgPageName": "c/keyword/_Noreturn"
        },
        {
            "title": "C keywords: _Static_assert",
            "path": "en.cppreference.com/w/c/keyword/_Static_assert.html",
            "wgPageName": "c/keyword/_Static_assert"
        },
        {
            "title": "C keywords: _Thread_local (since C11)",
            "path": "en.cppreference.com/w/c/keyword/_Thread_local.html",
            "wgPageName": "c/keyword/_Thread_local"
        },
        {
            "title": "C keywords: auto",
            "path": "en.cppreference.com/w/c/keyword/auto.html",
            "wgPageName": "c/keyword/auto"
        },
        {
            "title": "C keywords:  break",
            "path": "en.cppreference.com/w/c/keyword/break.html",
            "wgPageName": "c/keyword/break"
        },
        {
            "title": "C keywords: case",
            "path": "en.cppreference.com/w/c/keyword/case.html",
            "wgPageName": "c/keyword/case"
        },
        {
            "title": "C keywords: char",
            "path": "en.cppreference.com/w/c/keyword/char.html",
            "wgPageName": "c/keyword/char"
        },
        {
            "title": "C keywords: const",
            "path": "en.cppreference.com/w/c/keyword/const.html",
            "wgPageName": "c/keyword/const"
        },
        {
            "title": "C keywords: continue",
            "path": "en.cppreference.com/w/c/keyword/continue.html",
            "wgPageName": "c/keyword/continue"
        },
        {
            "title": "C keywords: default",
            "path": "en.cppreference.com/w/c/keyword/default.html",
            "wgPageName": "c/keyword/default"
        },
        {
            "title": "C keywords: do",
            "path": "en.cppreference.com/w/c/keyword/do.html",
            "wgPageName": "c/keyword/do"
        },
        {
            "title": "C keywords: double",
            "path": "en.cppreference.com/w/c/keyword/double.html",
            "wgPageName": "c/keyword/double"
        },
        {
            "title": "C keywords: else",
            "path": "en.cppreference.com/w/c/keyword/else.html",
            "wgPageName": "c/keyword/else"
        },
        {
            "title": "C keywords: enum",
            "path": "en.cppreference.com/w/c/keyword/enum.html",
            "wgPageName": "c/keyword/enum"
        },
        {
            "title": "C keywords: extern",
            "path": "en.cppreference.com/w/c/keyword/extern.html",
            "wgPageName": "c/keyword/extern"
        },
        {
            "title": "C keywords: float",
            "path": "en.cppreference.com/w/c/keyword/float.html",
            "wgPageName": "c/keyword/float"
        },
        {
            "title": "C keywords: for",
            "path": "en.cppreference.com/w/c/keyword/for.html",
            "wgPageName": "c/keyword/for"
        },
        {
            "title": "C keywords: fortran",
            "path": "en.cppreference.com/w/c/keyword/fortran.html",
            "wgPageName": "c/keyword/fortran"
        },
        {
            "title": "C keywords: goto",
            "path": "en.cppreference.com/w/c/keyword/goto.html",
            "wgPageName": "c/keyword/goto"
        },
        {
            "title": "C keywords: if",
            "path": "en.cppreference.com/w/c/keyword/if.html",
            "wgPageName": "c/keyword/if"
        },
        {
            "title": "C keywords: inline (since C99)",
            "path": "en.cppreference.com/w/c/keyword/inline.html",
            "wgPageName": "c/keyword/inline"
        },
        {
            "title": "C keywords: int",
            "path": "en.cppreference.com/w/c/keyword/int.html",
            "wgPageName": "c/keyword/int"
        },
        {
            "title": "C keywords: long",
            "path": "en.cppreference.com/w/c/keyword/long.html",
            "wgPageName": "c/keyword/long"
        },
        {
            "title": "C keywords: nullptr (since C23)",
            "path": "en.cppreference.com/w/c/keyword/nullptr.html",
            "wgPageName": "c/keyword/nullptr"
        },
        {
            "title": "C keywords: register",
            "path": "en.cppreference.com/w/c/keyword/register.html",
            "wgPageName": "c/keyword/register"
        },
        {
            "title": "C keywords: restrict",
            "path": "en.cppreference.com/w/c/keyword/restrict.html",
            "wgPageName": "c/keyword/restrict"
        },
        {
            "title": "C keywords: return",
            "path": "en.cppreference.com/w/c/keyword/return.html",
            "wgPageName": "c/keyword/return"
        },
        {
            "title": "C keywords: short",
            "path": "en.cppreference.com/w/c/keyword/short.html",
            "wgPageName": "c/keyword/short"
        },
        {
            "title": "C keywords: signed",
            "path": "en.cppreference.com/w/c/keyword/signed.html",
            "wgPageName": "c/keyword/signed"
        },
        {
            "title": "C keywords: sizeof",
            "path": "en.cppreference.com/w/c/keyword/sizeof.html",
            "wgPageName": "c/keyword/sizeof"
        },
        {
            "title": "C keywords: static",
            "path": "en.cppreference.com/w/c/keyword/static.html",
            "wgPageName": "c/keyword/static"
        },
        {
            "title": "C keywords: struct",
            "path": "en.cppreference.com/w/c/keyword/struct.html",
            "wgPageName": "c/keyword/struct"
        },
        {
            "title": "C keywords: switch",
            "path": "en.cppreference.com/w/c/keyword/switch.html",
            "wgPageName": "c/keyword/switch"
        },
        {
            "title": "C keywords: typedef",
            "path": "en.cppreference.com/w/c/keyword/typedef.html",
            "wgPageName": "c/keyword/typedef"
        },
        {
            "title": "C keywords: union",
            "path": "en.cppreference.com/w/c/keyword/union.html",
            "wgPageName": "c/keyword/union"
        },
        {
            "title": "C keywords: unsigned",
            "path": "en.cppreference.com/w/c/keyword/unsigned.html",
            "wgPageName": "c/keyword/unsigned"
        },
        {
            "title": "C keywords: void",
            "path": "en.cppreference.com/w/c/keyword/void.html",
            "wgPageName": "c/keyword/void"
        },
        {
            "title": "C keywords: volatile",
            "path": "en.cppreference.com/w/c/keyword/volatile.html",
            "wgPageName": "c/keyword/volatile"
        },
        {
            "title": "C keywords: while",
            "path": "en.cppreference.com/w/c/keyword/while.html",
            "wgPageName": "c/keyword/while"
        },
        {
            "title": "C language",
            "path": "en.cppreference.com/w/c/language.html",
            "wgPageName": "c/language"
        },
        {
            "title": "_Alignas",
            "path": "en.cppreference.com/w/c/language/_Alignas.html",
            "wgPageName": "c/language/_Alignas"
        },
        {
            "title": "_Alignof operator",
            "path": "en.cppreference.com/w/c/language/_Alignof.html",
            "wgPageName": "c/language/_Alignof"
        },
        {
            "title": "_Noreturn function specifier",
            "path": "en.cppreference.com/w/c/language/_Noreturn.html",
            "wgPageName": "c/language/_Noreturn"
        },
        {
            "title": "Static assertion",
            "path": "en.cppreference.com/w/c/language/_Static_assert.html",
            "wgPageName": "c/language/_Static_assert"
        },
        {
            "title": "Analyzability",
            "path": "en.cppreference.com/w/c/language/analyzability.html",
            "wgPageName": "c/language/analyzability"
        },
        {
            "title": "Arithmetic types",
            "path": "en.cppreference.com/w/c/language/arithmetic_types.html",
            "wgPageName": "c/language/arithmetic_types"
        },
        {
            "title": "Array initialization",
            "path": "en.cppreference.com/w/c/language/array_initialization.html",
            "wgPageName": "c/language/array_initialization"
        },
        {
            "title": "Array declaration",
            "path": "en.cppreference.com/w/c/language/array.html",
            "wgPageName": "c/language/array"
        },
        {
            "title": "c/language/as if",
            "path": "en.cppreference.com/w/c/language/as_if.html",
            "wgPageName": "c/language/as_if"
        },
        {
            "title": "ASCII Chart",
            "path": "en.cppreference.com/w/c/language/ascii.html",
            "wgPageName": "c/language/ascii"
        },
        {
            "title": "Inline assembly",
            "path": "en.cppreference.com/w/c/language/asm.html",
            "wgPageName": "c/language/asm"
        },
        {
            "title": "Atomic types",
            "path": "en.cppreference.com/w/c/language/atomic.html",
            "wgPageName": "c/language/atomic"
        },
        {
            "title": "Attribute specifier sequence(since C23)",
            "path": "en.cppreference.com/w/c/language/attributes.html",
            "wgPageName": "c/language/attributes"
        },
        {
            "title": "C attribute: deprecated (since C23)",
            "path": "en.cppreference.com/w/c/language/attributes/deprecated.html",
            "wgPageName": "c/language/attributes/deprecated"
        },
        {
            "title": "C attribute: fallthrough (since C23)",
            "path": "en.cppreference.com/w/c/language/attributes/fallthrough.html",
            "wgPageName": "c/language/attributes/fallthrough"
        },
        {
            "title": "C attribute: maybe_unused (since C23)",
            "path": "en.cppreference.com/w/c/language/attributes/maybe_unused.html",
            "wgPageName": "c/language/attributes/maybe_unused"
        },
        {
            "title": "C attribute: nodiscard (since C23)",
            "path": "en.cppreference.com/w/c/language/attributes/nodiscard.html",
            "wgPageName": "c/language/attributes/nodiscard"
        },
        {
            "title": "C attribute: noreturn, _Noreturn (since C23)",
            "path": "en.cppreference.com/w/c/language/attributes/noreturn.html",
            "wgPageName": "c/language/attributes/noreturn"
        },
        {
            "title": "Basic concepts",
            "path": "en.cppreference.com/w/c/language/basic_concepts.html",
            "wgPageName": "c/language/basic_concepts"
        },
        {
            "title": "Undefined behavior",
            "path": "en.cppreference.com/w/c/language/behavior.html",
            "wgPageName": "c/language/behavior"
        },
        {
            "title": "Bit fields",
            "path": "en.cppreference.com/w/c/language/bit_field.html",
            "wgPageName": "c/language/bit_field"
        },
        {
            "title": "Predefined Boolean constants (since C23)",
            "path": "en.cppreference.com/w/c/language/bool_constant.html",
            "wgPageName": "c/language/bool_constant"
        },
        {
            "title": "break statement",
            "path": "en.cppreference.com/w/c/language/break.html",
            "wgPageName": "c/language/break"
        },
        {
            "title": "cast operator",
            "path": "en.cppreference.com/w/c/language/cast.html",
            "wgPageName": "c/language/cast"
        },
        {
            "title": "Character constant",
            "path": "en.cppreference.com/w/c/language/character_constant.html",
            "wgPageName": "c/language/character_constant"
        },
        {
            "title": "Character sets and encodings",
            "path": "en.cppreference.com/w/c/language/charset.html",
            "wgPageName": "c/language/charset"
        },
        {
            "title": "Type",
            "path": "en.cppreference.com/w/c/language/compatible_type.html",
            "wgPageName": "c/language/type"
        },
        {
            "title": "Compound literals",
            "path": "en.cppreference.com/w/c/language/compound_literal.html",
            "wgPageName": "c/language/compound_literal"
        },
        {
            "title": "Conformance",
            "path": "en.cppreference.com/w/c/language/conformance.html",
            "wgPageName": "c/language/conformance"
        },
        {
            "title": "const type qualifier",
            "path": "en.cppreference.com/w/c/language/const.html",
            "wgPageName": "c/language/const"
        },
        {
            "title": "Constant expressions",
            "path": "en.cppreference.com/w/c/language/constant_expression.html",
            "wgPageName": "c/language/constant_expression"
        },
        {
            "title": "continue statement",
            "path": "en.cppreference.com/w/c/language/continue.html",
            "wgPageName": "c/language/continue"
        },
        {
            "title": "Implicit conversions",
            "path": "en.cppreference.com/w/c/language/conversion.html",
            "wgPageName": "c/language/conversion"
        },
        {
            "title": "Declarations",
            "path": "en.cppreference.com/w/c/language/declarations.html",
            "wgPageName": "c/language/declarations"
        },
        {
            "title": "do-while loop",
            "path": "en.cppreference.com/w/c/language/do.html",
            "wgPageName": "c/language/do"
        },
        {
            "title": "Enumerations",
            "path": "en.cppreference.com/w/c/language/enum.html",
            "wgPageName": "c/language/enum"
        },
        {
            "title": "Escape sequences",
            "path": "en.cppreference.com/w/c/language/escape.html",
            "wgPageName": "c/language/escape"
        },
        {
            "title": "Order of evaluation",
            "path": "en.cppreference.com/w/c/language/eval_order.html",
            "wgPageName": "c/language/eval_order"
        },
        {
            "title": "Expressions",
            "path": "en.cppreference.com/w/c/language/expressions.html",
            "wgPageName": "c/language/expressions"
        },
        {
            "title": "External and tentative definitions",
            "path": "en.cppreference.com/w/c/language/extern.html",
            "wgPageName": "c/language/extern"
        },
        {
            "title": "File scope",
            "path": "en.cppreference.com/w/c/language/file_scope.html",
            "wgPageName": "c/language/file_scope"
        },
        {
            "title": "Floating constant",
            "path": "en.cppreference.com/w/c/language/floating_constant.html",
            "wgPageName": "c/language/floating_constant"
        },
        {
            "title": "for loop",
            "path": "en.cppreference.com/w/c/language/for.html",
            "wgPageName": "c/language/for"
        },
        {
            "title": "Function declarations",
            "path": "en.cppreference.com/w/c/language/function_declaration.html",
            "wgPageName": "c/language/function_declaration"
        },
        {
            "title": "Function definitions",
            "path": "en.cppreference.com/w/c/language/function_definition.html",
            "wgPageName": "c/language/function_definition"
        },
        {
            "title": "Functions",
            "path": "en.cppreference.com/w/c/language/functions.html",
            "wgPageName": "c/language/functions"
        },
        {
            "title": "Generic selection",
            "path": "en.cppreference.com/w/c/language/generic.html",
            "wgPageName": "c/language/generic"
        },
        {
            "title": "goto statement",
            "path": "en.cppreference.com/w/c/language/goto.html",
            "wgPageName": "c/language/goto"
        },
        {
            "title": "History of C",
            "path": "en.cppreference.com/w/c/language/history.html",
            "wgPageName": "c/language/history"
        },
        {
            "title": "Identifier",
            "path": "en.cppreference.com/w/c/language/identifier.html",
            "wgPageName": "c/language/identifier"
        },
        {
            "title": "if statement",
            "path": "en.cppreference.com/w/c/language/if.html",
            "wgPageName": "c/language/if"
        },
        {
            "title": "Initialization",
            "path": "en.cppreference.com/w/c/language/initialization.html",
            "wgPageName": "c/language/initialization"
        },
        {
            "title": "inline function specifier",
            "path": "en.cppreference.com/w/c/language/inline.html",
            "wgPageName": "c/language/inline"
        },
        {
            "title": "Integer constant",
            "path": "en.cppreference.com/w/c/language/integer_constant.html",
            "wgPageName": "c/language/integer_constant"
        },
        {
            "title": "Lifetime",
            "path": "en.cppreference.com/w/c/language/lifetime.html",
            "wgPageName": "c/language/lifetime"
        },
        {
            "title": "Main function",
            "path": "en.cppreference.com/w/c/language/main_function.html",
            "wgPageName": "c/language/main_function"
        },
        {
            "title": "Memory model",
            "path": "en.cppreference.com/w/c/language/memory_model.html",
            "wgPageName": "c/language/memory_model"
        },
        {
            "title": "Lookup and name spaces",
            "path": "en.cppreference.com/w/c/language/name_space.html",
            "wgPageName": "c/language/name_space"
        },
        {
            "title": "No Diagnostic Required",
            "path": "en.cppreference.com/w/c/language/ndr.html",
            "wgPageName": "c/language/ndr"
        },
        {
            "title": "Predefined null pointer constant (since C23)",
            "path": "en.cppreference.com/w/c/language/nullptr.html",
            "wgPageName": "c/language/nullptr"
        },
        {
            "title": "Objects and alignment",
            "path": "en.cppreference.com/w/c/language/object.html",
            "wgPageName": "c/language/object"
        },
        {
            "title": "Alternative operators and tokens",
            "path": "en.cppreference.com/w/c/language/operator_alternative.html",
            "wgPageName": "c/language/operator_alternative"
        },
        {
            "title": "Arithmetic operators",
            "path": "en.cppreference.com/w/c/language/operator_arithmetic.html",
            "wgPageName": "c/language/operator_arithmetic"
        },
        {
            "title": "Assignment operators",
            "path": "en.cppreference.com/w/c/language/operator_assignment.html",
            "wgPageName": "c/language/operator_assignment"
        },
        {
            "title": "Comparison operators",
            "path": "en.cppreference.com/w/c/language/operator_comparison.html",
            "wgPageName": "c/language/operator_comparison"
        },
        {
            "title": "Increment/decrement operators",
            "path": "en.cppreference.com/w/c/language/operator_incdec.html",
            "wgPageName": "c/language/operator_incdec"
        },
        {
            "title": "Logical operators",
            "path": "en.cppreference.com/w/c/language/operator_logical.html",
            "wgPageName": "c/language/operator_logical"
        },
        {
            "title": "Member access operators",
            "path": "en.cppreference.com/w/c/language/operator_member_access.html",
            "wgPageName": "c/language/operator_member_access"
        },
        {
            "title": "Other operators",
            "path": "en.cppreference.com/w/c/language/operator_other.html",
            "wgPageName": "c/language/operator_other"
        },
        {
            "title": "C Operator Precedence",
            "path": "en.cppreference.com/w/c/language/operator_precedence.html",
            "wgPageName": "c/language/operator_precedence"
        },
        {
            "title": "Pointer declaration",
            "path": "en.cppreference.com/w/c/language/pointer.html",
            "wgPageName": "c/language/pointer"
        },
        {
            "title": "Punctuation",
            "path": "en.cppreference.com/w/c/language/punctuators.html",
            "wgPageName": "c/language/punctuators"
        },
        {
            "title": "restrict type qualifier",
            "path": "en.cppreference.com/w/c/language/restrict.html",
            "wgPageName": "c/language/restrict"
        },
        {
            "title": "return statement",
            "path": "en.cppreference.com/w/c/language/return.html",
            "wgPageName": "c/language/return"
        },
        {
            "title": "Scalar initialization",
            "path": "en.cppreference.com/w/c/language/scalar_initialization.html",
            "wgPageName": "c/language/scalar_initialization"
        },
        {
            "title": "Scope",
            "path": "en.cppreference.com/w/c/language/scope.html",
            "wgPageName": "c/language/scope"
        },
        {
            "title": "sizeof operator",
            "path": "en.cppreference.com/w/c/language/sizeof.html",
            "wgPageName": "c/language/sizeof"
        },
        {
            "title": "Statements",
            "path": "en.cppreference.com/w/c/language/statements.html",
            "wgPageName": "c/language/statements"
        },
        {
            "title": "Static assertion",
            "path": "en.cppreference.com/w/c/language/static_assert.html",
            "wgPageName": "c/language/_Static_assert"
        },
        {
            "title": "Static storage duration",
            "path": "en.cppreference.com/w/c/language/static_storage_duration.html",
            "wgPageName": "c/language/static_storage_duration"
        },
        {
            "title": "Storage-class specifiers",
            "path": "en.cppreference.com/w/c/language/storage_duration.html",
            "wgPageName": "c/language/storage_duration"
        },
        {
            "title": "String literals",
            "path": "en.cppreference.com/w/c/language/string_literal.html",
            "wgPageName": "c/language/string_literal"
        },
        {
            "title": "Struct and union initialization",
            "path": "en.cppreference.com/w/c/language/struct_initialization.html",
            "wgPageName": "c/language/struct_initialization"
        },
        {
            "title": "Struct declaration",
            "path": "en.cppreference.com/w/c/language/struct.html",
            "wgPageName": "c/language/struct"
        },
        {
            "title": "switch statement",
            "path": "en.cppreference.com/w/c/language/switch.html",
            "wgPageName": "c/language/switch"
        },
        {
            "title": "Thread storage duration",
            "path": "en.cppreference.com/w/c/language/thread_storage_duration.html",
            "wgPageName": "c/language/thread_storage_duration"
        },
        {
            "title": "Phases of translation",
            "path": "en.cppreference.com/w/c/language/translation_phases.html",
            "wgPageName": "c/language/translation_phases"
        },
        {
            "title": "Type",
            "path": "en.cppreference.com/w/c/language/type.html",
            "wgPageName": "c/language/type"
        },
        {
            "title": "Typedef declaration",
            "path": "en.cppreference.com/w/c/language/typedef.html",
            "wgPageName": "c/language/typedef"
        },
        {
            "title": "Type",
            "path": "en.cppreference.com/w/c/language/types.html",
            "wgPageName": "c/language/type"
        },
        {
            "title": "Union declaration",
            "path": "en.cppreference.com/w/c/language/union.html",
            "wgPageName": "c/language/union"
        },
        {
            "title": "Value categories",
            "path": "en.cppreference.com/w/c/language/value_category.html",
            "wgPageName": "c/language/value_category"
        },
        {
            "title": "Variadic arguments",
            "path": "en.cppreference.com/w/c/language/variadic.html",
            "wgPageName": "c/language/variadic"
        },
        {
            "title": "volatile type qualifier",
            "path": "en.cppreference.com/w/c/language/volatile.html",
            "wgPageName": "c/language/volatile"
        },
        {
            "title": "while loop",
            "path": "en.cppreference.com/w/c/language/while.html",
            "wgPageName": "c/language/while"
        },
        {
            "title": "Useful resources",
            "path": "en.cppreference.com/w/c/links.html",
            "wgPageName": "c/links"
        },
        {
            "title": "A list of open source C libraries",
            "path": "en.cppreference.com/w/c/links/libs.html",
            "wgPageName": "c/links/libs"
        },
        {
            "title": "Localization support",
            "path": "en.cppreference.com/w/c/locale.html",
            "wgPageName": "c/locale"
        },
        {
            "title": "LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY, LC_NUMERIC, LC_TIME",
            "path": "en.cppreference.com/w/c/locale/LC_categories.html",
            "wgPageName": "c/locale/LC_categories",
            "headers": [
                "<locale.h>"
            ],
            "sample_declaration": "#define LC_ALL /*implementation defined*/",
            "other_declarations": 5
        },
        {
            "title": "lconv",
            "path": "en.cppreference.com/w/c/locale/lconv.html",
            "wgPageName": "c/locale/lconv",
            "headers": [
                "<locale.h>"
            ],
            "sample_declaration": "struct lconv;"
        },
        {
            "title": "localeconv",
            "path": "en.cppreference.com/w/c/locale/localeconv.html",
            "wgPageName": "c/locale/localeconv",
            "headers": [
                "<locale.h>"
            ],
            "sample_declaration": "struct lconv* localeconv(void);"
        },
        {
            "title": "setlocale",
            "path": "en.cppreference.com/w/c/locale/setlocale.html",
            "wgPageName": "c/locale/setlocale",
            "headers": [
                "<locale.h>"
            ],
            "sample_declaration": "char* setlocale(\n    int category,\n    const char* locale);"
        },
        {
            "title": "Dynamic memory management",
            "path": "en.cppreference.com/w/c/memory.html",
            "wgPageName": "c/memory"
        },
        {
            "title": "aligned_alloc",
            "path": "en.cppreference.com/w/c/memory/aligned_alloc.html",
            "wgPageName": "c/memory/aligned_alloc",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "void* aligned_alloc(\n    size_t alignment,\n    size_t size);"
        },
        {
            "title": "calloc",
            "path": "en.cppreference.com/w/c/memory/calloc.html",
            "wgPageName": "c/memory/calloc",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "void* calloc(size_t num, size_t size);"
        },
        {
            "title": "free_aligned_sized",
            "path": "en.cppreference.com/w/c/memory/free_aligned_sized.html",
            "wgPageName": "c/memory/free_aligned_sized",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "void free_aligned_sized(\n    void* ptr,\n    size_t alignment,\n    size_t size);"
        },
        {
            "title": "free_sized",
            "path": "en.cppreference.com/w/c/memory/free_sized.html",
            "wgPageName": "c/memory/free_sized",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "void free_sized(void* ptr, size_t size);"
        },
        {
            "title": "free",
            "path": "en.cppreference.com/w/c/memory/free.html",
            "wgPageName": "c/memory/free",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "void free(void* ptr);"
        },
        {
            "title": "malloc",
            "path": "en.cppreference.com/w/c/memory/malloc.html",
            "wgPageName": "c/memory/malloc",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "void* malloc(size_t size);"
        },
        {
            "title": "realloc",
            "path": "en.cppreference.com/w/c/memory/realloc.html",
            "wgPageName": "c/memory/realloc",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "void* realloc(void* ptr, size_t new_size);"
        },
        {
            "title": "Numerics",
            "path": "en.cppreference.com/w/c/numeric.html",
            "wgPageName": "c/numeric"
        },
        {
            "title": "Complex number arithmetic",
            "path": "en.cppreference.com/w/c/numeric/complex.html",
            "wgPageName": "c/numeric/complex"
        },
        {
            "title": "cabsf, cabs, cabsl",
            "path": "en.cppreference.com/w/c/numeric/complex/cabs.html",
            "wgPageName": "c/numeric/complex/cabs",
            "headers": [
                "<complex.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float cabsf(float complex z);",
            "other_declarations": 3
        },
        {
            "title": "cacosf, cacos, cacosl",
            "path": "en.cppreference.com/w/c/numeric/complex/cacos.html",
            "wgPageName": "c/numeric/complex/cacos",
            "headers": [
                "<complex.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float complex cacosf(float complex z);",
            "other_declarations": 3
        },
        {
            "title": "cacoshf, cacosh, cacoshl",
            "path": "en.cppreference.com/w/c/numeric/complex/cacosh.html",
            "wgPageName": "c/numeric/complex/cacosh",
            "headers": [
                "<complex.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float complex cacoshf(float complex z);",
            "other_declarations": 3
        },
        {
            "title": "cargf, carg, cargl",
            "path": "en.cppreference.com/w/c/numeric/complex/carg.html",
            "wgPageName": "c/numeric/complex/carg",
            "headers": [
                "<complex.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float cargf(float complex z);",
            "other_declarations": 3
        },
        {
            "title": "casinf, casin, casinl",
            "path": "en.cppreference.com/w/c/numeric/complex/casin.html",
            "wgPageName": "c/numeric/complex/casin",
            "headers": [
                "<complex.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float complex casinf(float complex z);",
            "other_declarations": 3
        },
        {
            "title": "casinhf, casinh, casinhl",
            "path": "en.cppreference.com/w/c/numeric/complex/casinh.html",
            "wgPageName": "c/numeric/complex/casinh",
            "headers": [
                "<complex.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float complex casinhf(float complex z);",
            "other_declarations": 3
        },
        {
            "title": "catanf, catan, catanl",
            "path": "en.cppreference.com/w/c/numeric/complex/catan.html",
            "wgPageName": "c/numeric/complex/catan",
            "headers": [
                "<complex.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float complex catanf(float complex z);",
            "other_declarations": 3
        },
        {
            "title": "catanhf, catanh, catanhl",
            "path": "en.cppreference.com/w/c/numeric/complex/catanh.html",
            "wgPageName": "c/numeric/complex/catanh",
            "headers": [
                "<complex.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float complex catanhf(float complex z);",
            "other_declarations": 3
        },
        {
            "title": "ccosf, ccos, ccosl",
            "path": "en.cppreference.com/w/c/numeric/complex/ccos.html",
            "wgPageName": "c/numeric/complex/ccos",
            "headers": [
                "<complex.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float complex ccosf(float complex z);",
            "other_declarations": 3
        },
        {
            "title": "ccoshf, ccosh, ccoshl",
            "path": "en.cppreference.com/w/c/numeric/complex/ccosh.html",
            "wgPageName": "c/numeric/complex/ccosh",
            "headers": [
                "<complex.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float complex ccoshf(float complex z);",
            "other_declarations": 3
        },
        {
            "title": "cexpf, cexp, cexpl",
            "path": "en.cppreference.com/w/c/numeric/complex/cexp.html",
            "wgPageName": "c/numeric/complex/cexp",
            "headers": [
                "<complex.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float complex cexpf(float complex z);",
            "other_declarations": 3
        },
        {
            "title": "cimagf, cimag, cimagl",
            "path": "en.cppreference.com/w/c/numeric/complex/cimag.html",
            "wgPageName": "c/numeric/complex/cimag",
            "headers": [
                "<complex.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float cimagf(float complex z);",
            "other_declarations": 3
        },
        {
            "title": "clogf, clog, clogl",
            "path": "en.cppreference.com/w/c/numeric/complex/clog.html",
            "wgPageName": "c/numeric/complex/clog",
            "headers": [
                "<complex.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float complex clogf(float complex z);",
            "other_declarations": 3
        },
        {
            "title": "CMPLXF, CMPLX, CMPLXL",
            "path": "en.cppreference.com/w/c/numeric/complex/CMPLX.html",
            "wgPageName": "c/numeric/complex/CMPLX",
            "headers": [
                "<complex.h>"
            ],
            "sample_declaration": "float complex CMPLXF(float real, float imag);",
            "other_declarations": 2
        },
        {
            "title": "_Complex_I",
            "path": "en.cppreference.com/w/c/numeric/complex/Complex_I.html",
            "wgPageName": "c/numeric/complex/Complex_I",
            "headers": [
                "<complex.h>"
            ],
            "sample_declaration": "#define _Complex_I /* unspecified */"
        },
        {
            "title": "complex",
            "path": "en.cppreference.com/w/c/numeric/complex/complex.html",
            "wgPageName": "c/numeric/complex/complex",
            "headers": [
                "<complex.h>"
            ],
            "sample_declaration": "#define complex _Complex"
        },
        {
            "title": "conjf, conj, conjl",
            "path": "en.cppreference.com/w/c/numeric/complex/conj.html",
            "wgPageName": "c/numeric/complex/conj",
            "headers": [
                "<complex.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float complex conjf(float complex z);",
            "other_declarations": 3
        },
        {
            "title": "cpowf, cpow, cpowl",
            "path": "en.cppreference.com/w/c/numeric/complex/cpow.html",
            "wgPageName": "c/numeric/complex/cpow",
            "headers": [
                "<complex.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float complex\ncpowf(float complex x, float complex y);",
            "other_declarations": 3
        },
        {
            "title": "cprojf, cproj, cprojl",
            "path": "en.cppreference.com/w/c/numeric/complex/cproj.html",
            "wgPageName": "c/numeric/complex/cproj",
            "headers": [
                "<complex.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float complex cprojf(float complex z);",
            "other_declarations": 3
        },
        {
            "title": "crealf, creal, creall",
            "path": "en.cppreference.com/w/c/numeric/complex/creal.html",
            "wgPageName": "c/numeric/complex/creal",
            "headers": [
                "<complex.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float crealf(float complex z);",
            "other_declarations": 3
        },
        {
            "title": "csinf, csin, csinl",
            "path": "en.cppreference.com/w/c/numeric/complex/csin.html",
            "wgPageName": "c/numeric/complex/csin",
            "headers": [
                "<complex.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float complex csinf(float complex z);",
            "other_declarations": 3
        },
        {
            "title": "csinhf, csinh, csinhl",
            "path": "en.cppreference.com/w/c/numeric/complex/csinh.html",
            "wgPageName": "c/numeric/complex/csinh",
            "headers": [
                "<complex.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float complex csinhf(float complex z);",
            "other_declarations": 3
        },
        {
            "title": "csqrtf, csqrt, csqrtl",
            "path": "en.cppreference.com/w/c/numeric/complex/csqrt.html",
            "wgPageName": "c/numeric/complex/csqrt",
            "headers": [
                "<complex.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float complex csqrtf(float complex z);",
            "other_declarations": 3
        },
        {
            "title": "ctanf, ctan, ctanl",
            "path": "en.cppreference.com/w/c/numeric/complex/ctan.html",
            "wgPageName": "c/numeric/complex/ctan",
            "headers": [
                "<complex.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float complex ctanf(float complex z);",
            "other_declarations": 3
        },
        {
            "title": "ctanhf, ctanh, ctanhl",
            "path": "en.cppreference.com/w/c/numeric/complex/ctanh.html",
            "wgPageName": "c/numeric/complex/ctanh",
            "headers": [
                "<complex.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float complex ctanhf(float complex z);",
            "other_declarations": 3
        },
        {
            "title": "I",
            "path": "en.cppreference.com/w/c/numeric/complex/I.html",
            "wgPageName": "c/numeric/complex/I",
            "headers": [
                "<complex.h>"
            ],
            "sample_declaration": "#define I /* unspecified */"
        },
        {
            "title": "_Imaginary_I",
            "path": "en.cppreference.com/w/c/numeric/complex/Imaginary_I.html",
            "wgPageName": "c/numeric/complex/Imaginary_I",
            "headers": [
                "<complex.h>"
            ],
            "sample_declaration": "#define _Imaginary_I /* unspecified */"
        },
        {
            "title": "imaginary",
            "path": "en.cppreference.com/w/c/numeric/complex/imaginary.html",
            "wgPageName": "c/numeric/complex/imaginary",
            "headers": [
                "<complex.h>"
            ],
            "sample_declaration": "#define imaginary _Imaginary"
        },
        {
            "title": "Floating-point environment",
            "path": "en.cppreference.com/w/c/numeric/fenv.html",
            "wgPageName": "c/numeric/fenv"
        },
        {
            "title": "FE_DFL_ENV",
            "path": "en.cppreference.com/w/c/numeric/fenv/FE_DFL_ENV.html",
            "wgPageName": "c/numeric/fenv/FE_DFL_ENV",
            "headers": [
                "<fenv.h>"
            ],
            "sample_declaration": "#define FE_DFL_ENV /*implementation defined*/"
        },
        {
            "title": "FE_DIVBYZERO, FE_INEXACT, FE_INVALID, FE_OVERFLOW, FE_UNDERFLOW, FE_ALL_EXCEPT",
            "path": "en.cppreference.com/w/c/numeric/fenv/FE_exceptions.html",
            "wgPageName": "c/numeric/fenv/FE_exceptions",
            "headers": [
                "<fenv.h>"
            ],
            "sample_declaration": "#define FE_DIVBYZERO /*implementation defined \\\n                        power of 2*/",
            "other_declarations": 5
        },
        {
            "title": "FE_DOWNWARD, FE_TONEAREST, FE_TOWARDZERO, FE_UPWARD",
            "path": "en.cppreference.com/w/c/numeric/fenv/FE_round.html",
            "wgPageName": "c/numeric/fenv/FE_round",
            "headers": [
                "<fenv.h>"
            ],
            "sample_declaration": "#define FE_DOWNWARD /*implementation defined*/",
            "other_declarations": 3
        },
        {
            "title": "feclearexcept",
            "path": "en.cppreference.com/w/c/numeric/fenv/feclearexcept.html",
            "wgPageName": "c/numeric/fenv/feclearexcept",
            "headers": [
                "<fenv.h>"
            ],
            "sample_declaration": "int feclearexcept(int excepts);"
        },
        {
            "title": "fegetenv, fesetenv",
            "path": "en.cppreference.com/w/c/numeric/fenv/feenv.html",
            "wgPageName": "c/numeric/fenv/feenv",
            "headers": [
                "<fenv.h>"
            ],
            "sample_declaration": "int fegetenv(fenv_t* envp);",
            "other_declarations": 1
        },
        {
            "title": "fegetexceptflag, fesetexceptflag",
            "path": "en.cppreference.com/w/c/numeric/fenv/feexceptflag.html",
            "wgPageName": "c/numeric/fenv/feexceptflag",
            "headers": [
                "<fenv.h>"
            ],
            "sample_declaration": "int fegetexceptflag(\n    fexcept_t* flagp,\n    int excepts);",
            "other_declarations": 1
        },
        {
            "title": "feholdexcept",
            "path": "en.cppreference.com/w/c/numeric/fenv/feholdexcept.html",
            "wgPageName": "c/numeric/fenv/feholdexcept",
            "headers": [
                "<fenv.h>"
            ],
            "sample_declaration": "int feholdexcept(fenv_t* envp);"
        },
        {
            "title": "feraiseexcept",
            "path": "en.cppreference.com/w/c/numeric/fenv/feraiseexcept.html",
            "wgPageName": "c/numeric/fenv/feraiseexcept",
            "headers": [
                "<fenv.h>"
            ],
            "sample_declaration": "int feraiseexcept(int excepts);"
        },
        {
            "title": "fegetround, fesetround",
            "path": "en.cppreference.com/w/c/numeric/fenv/feround.html",
            "wgPageName": "c/numeric/fenv/feround",
            "headers": [
                "<fenv.h>"
            ],
            "sample_declaration": "int fesetround(int round);",
            "other_declarations": 1
        },
        {
            "title": "fetestexcept",
            "path": "en.cppreference.com/w/c/numeric/fenv/fetestexcept.html",
            "wgPageName": "c/numeric/fenv/fetestexcept",
            "headers": [
                "<fenv.h>"
            ],
            "sample_declaration": "int fetestexcept(int excepts);"
        },
        {
            "title": "feupdateenv",
            "path": "en.cppreference.com/w/c/numeric/fenv/feupdateenv.html",
            "wgPageName": "c/numeric/fenv/feupdateenv",
            "headers": [
                "<fenv.h>"
            ],
            "sample_declaration": "int feupdateenv(const fenv_t* envp);"
        },
        {
            "title": "Common mathematical functions",
            "path": "en.cppreference.com/w/c/numeric/math.html",
            "wgPageName": "c/numeric/math"
        },
        {
            "title": "abs, labs, llabs, imaxabs",
            "path": "en.cppreference.com/w/c/numeric/math/abs.html",
            "wgPageName": "c/numeric/math/abs",
            "headers": [
                "<stdlib.h>",
                "<inttypes.h>"
            ],
            "sample_declaration": "int abs(int n);",
            "other_declarations": 3
        },
        {
            "title": "acos, acosf, acosl",
            "path": "en.cppreference.com/w/c/numeric/math/acos.html",
            "wgPageName": "c/numeric/math/acos",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float acosf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "acosh, acoshf, acoshl",
            "path": "en.cppreference.com/w/c/numeric/math/acosh.html",
            "wgPageName": "c/numeric/math/acosh",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float acoshf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "asin, asinf, asinl",
            "path": "en.cppreference.com/w/c/numeric/math/asin.html",
            "wgPageName": "c/numeric/math/asin",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float asinf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "asinh, asinhf, asinhl",
            "path": "en.cppreference.com/w/c/numeric/math/asinh.html",
            "wgPageName": "c/numeric/math/asinh",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float asinhf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "atan, atanf, atanl",
            "path": "en.cppreference.com/w/c/numeric/math/atan.html",
            "wgPageName": "c/numeric/math/atan",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float atanf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "atan2, atan2f, atan2l",
            "path": "en.cppreference.com/w/c/numeric/math/atan2.html",
            "wgPageName": "c/numeric/math/atan2",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float atan2f(float y, float x);",
            "other_declarations": 3
        },
        {
            "title": "atanh, atanhf, atanhl",
            "path": "en.cppreference.com/w/c/numeric/math/atanh.html",
            "wgPageName": "c/numeric/math/atanh",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float atanhf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "cbrt, cbrtf, cbrtl",
            "path": "en.cppreference.com/w/c/numeric/math/cbrt.html",
            "wgPageName": "c/numeric/math/cbrt",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float cbrtf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "ceil, ceilf, ceill",
            "path": "en.cppreference.com/w/c/numeric/math/ceil.html",
            "wgPageName": "c/numeric/math/ceil",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float ceilf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "copysign, copysignf, copysignl",
            "path": "en.cppreference.com/w/c/numeric/math/copysign.html",
            "wgPageName": "c/numeric/math/copysign",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float copysignf(float x, float y);",
            "other_declarations": 3
        },
        {
            "title": "cos, cosf, cosl",
            "path": "en.cppreference.com/w/c/numeric/math/cos.html",
            "wgPageName": "c/numeric/math/cos",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float cosf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "cosh, coshf, coshl",
            "path": "en.cppreference.com/w/c/numeric/math/cosh.html",
            "wgPageName": "c/numeric/math/cosh",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float coshf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "div, ldiv, lldiv, imaxdiv",
            "path": "en.cppreference.com/w/c/numeric/math/div.html",
            "wgPageName": "c/numeric/math/div",
            "headers": [
                "<stdlib.h>",
                "<inttypes.h>"
            ],
            "sample_declaration": "div_t div(int x, int y);",
            "other_declarations": 3
        },
        {
            "title": "erf, erff, erfl",
            "path": "en.cppreference.com/w/c/numeric/math/erf.html",
            "wgPageName": "c/numeric/math/erf",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float erff(float arg);",
            "other_declarations": 3
        },
        {
            "title": "erfc, erfcf, erfcl",
            "path": "en.cppreference.com/w/c/numeric/math/erfc.html",
            "wgPageName": "c/numeric/math/erfc",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float erfcf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "exp, expf, expl",
            "path": "en.cppreference.com/w/c/numeric/math/exp.html",
            "wgPageName": "c/numeric/math/exp",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float expf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "exp2, exp2f, exp2l",
            "path": "en.cppreference.com/w/c/numeric/math/exp2.html",
            "wgPageName": "c/numeric/math/exp2",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float exp2f(float n);",
            "other_declarations": 3
        },
        {
            "title": "expm1, expm1f, expm1l",
            "path": "en.cppreference.com/w/c/numeric/math/expm1.html",
            "wgPageName": "c/numeric/math/expm1",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float expm1f(float arg);",
            "other_declarations": 3
        },
        {
            "title": "fabs, fabsf, fabsl, fabsd32, fabsd64, fabsd128",
            "path": "en.cppreference.com/w/c/numeric/math/fabs.html",
            "wgPageName": "c/numeric/math/fabs",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float fabsf(float arg);",
            "other_declarations": 6
        },
        {
            "title": "fdim, fdimf, fdiml",
            "path": "en.cppreference.com/w/c/numeric/math/fdim.html",
            "wgPageName": "c/numeric/math/fdim",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float fdimf(float x, float y);",
            "other_declarations": 3
        },
        {
            "title": "float_t, double_t",
            "path": "en.cppreference.com/w/c/numeric/math/float_t.html",
            "wgPageName": "c/numeric/math/float_t",
            "headers": [
                "<math.h>"
            ],
            "sample_declaration": "typedef /*implementation defined*/ float_t",
            "other_declarations": 1
        },
        {
            "title": "floor, floorf, floorl",
            "path": "en.cppreference.com/w/c/numeric/math/floor.html",
            "wgPageName": "c/numeric/math/floor",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float floorf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "fma, fmaf, fmal",
            "path": "en.cppreference.com/w/c/numeric/math/fma.html",
            "wgPageName": "c/numeric/math/fma",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float fmaf(float x, float y, float z);",
            "other_declarations": 6
        },
        {
            "title": "fmax, fmaxf, fmaxl",
            "path": "en.cppreference.com/w/c/numeric/math/fmax.html",
            "wgPageName": "c/numeric/math/fmax",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float fmaxf(float x, float y);",
            "other_declarations": 3
        },
        {
            "title": "fmin, fminf, fminl",
            "path": "en.cppreference.com/w/c/numeric/math/fmin.html",
            "wgPageName": "c/numeric/math/fmin",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float fminf(float x, float y);",
            "other_declarations": 3
        },
        {
            "title": "fmod, fmodf, fmodl",
            "path": "en.cppreference.com/w/c/numeric/math/fmod.html",
            "wgPageName": "c/numeric/math/fmod",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float fmodf(float x, float y);",
            "other_declarations": 3
        },
        {
            "title": "FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN",
            "path": "en.cppreference.com/w/c/numeric/math/FP_categories.html",
            "wgPageName": "c/numeric/math/FP_categories",
            "headers": [
                "<math.h>"
            ],
            "sample_declaration": "#define FP_NORMAL /*implementation defined*/",
            "other_declarations": 4
        },
        {
            "title": "fpclassify",
            "path": "en.cppreference.com/w/c/numeric/math/fpclassify.html",
            "wgPageName": "c/numeric/math/fpclassify",
            "headers": [
                "<math.h>"
            ],
            "sample_declaration": "#define fpclassify( \\\n    arg) /* implementation defined */"
        },
        {
            "title": "frexp, frexpf, frexpl",
            "path": "en.cppreference.com/w/c/numeric/math/frexp.html",
            "wgPageName": "c/numeric/math/frexp",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float frexpf(float arg, int* exp);",
            "other_declarations": 3
        },
        {
            "title": "HUGE_VALF, HUGE_VAL, HUGE_VALL",
            "path": "en.cppreference.com/w/c/numeric/math/HUGE_VAL.html",
            "wgPageName": "c/numeric/math/HUGE_VAL",
            "headers": [
                "<math.h>"
            ],
            "sample_declaration": "#define HUGE_VALF /*implementation defined*/",
            "other_declarations": 2
        },
        {
            "title": "hypot, hypotf, hypotl",
            "path": "en.cppreference.com/w/c/numeric/math/hypot.html",
            "wgPageName": "c/numeric/math/hypot",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float hypotf(float x, float y);",
            "other_declarations": 3
        },
        {
            "title": "ilogb, ilogbf, ilogbl",
            "path": "en.cppreference.com/w/c/numeric/math/ilogb.html",
            "wgPageName": "c/numeric/math/ilogb",
            "headers": [
                "<math.h>",
                "<tgmath.h>",
                "<math.h>"
            ],
            "sample_declaration": "int ilogbf(float arg);",
            "other_declarations": 5
        },
        {
            "title": "INFINITY",
            "path": "en.cppreference.com/w/c/numeric/math/INFINITY.html",
            "wgPageName": "c/numeric/math/INFINITY",
            "headers": [
                "<math.h>"
            ],
            "sample_declaration": "#define INFINITY /*implementation defined*/"
        },
        {
            "title": "isfinite",
            "path": "en.cppreference.com/w/c/numeric/math/isfinite.html",
            "wgPageName": "c/numeric/math/isfinite",
            "headers": [
                "<math.h>"
            ],
            "sample_declaration": "#define isfinite( \\\n    arg) /* implementation defined */"
        },
        {
            "title": "isgreater",
            "path": "en.cppreference.com/w/c/numeric/math/isgreater.html",
            "wgPageName": "c/numeric/math/isgreater",
            "headers": [
                "<math.h>"
            ],
            "sample_declaration": "#define isgreater( \\\n    x, y) /* implementation defined */"
        },
        {
            "title": "isgreaterequal",
            "path": "en.cppreference.com/w/c/numeric/math/isgreaterequal.html",
            "wgPageName": "c/numeric/math/isgreaterequal",
            "headers": [
                "<math.h>"
            ],
            "sample_declaration": "#define isgreaterequal( \\\n    x, y) /* implementation defined */"
        },
        {
            "title": "isinf",
            "path": "en.cppreference.com/w/c/numeric/math/isinf.html",
            "wgPageName": "c/numeric/math/isinf",
            "headers": [
                "<math.h>"
            ],
            "sample_declaration": "#define isinf(arg) /* implementation defined \\\n                    */"
        },
        {
            "title": "isless",
            "path": "en.cppreference.com/w/c/numeric/math/isless.html",
            "wgPageName": "c/numeric/math/isless",
            "headers": [
                "<math.h>"
            ],
            "sample_declaration": "#define isless( \\\n    x, y) /* implementation defined */"
        },
        {
            "title": "islessequal",
            "path": "en.cppreference.com/w/c/numeric/math/islessequal.html",
            "wgPageName": "c/numeric/math/islessequal",
            "headers": [
                "<math.h>"
            ],
            "sample_declaration": "#define islessequal( \\\n    x, y) /* implementation defined */"
        },
        {
            "title": "islessgreater",
            "path": "en.cppreference.com/w/c/numeric/math/islessgreater.html",
            "wgPageName": "c/numeric/math/islessgreater",
            "headers": [
                "<math.h>"
            ],
            "sample_declaration": "#define islessgreater( \\\n    x, y) /* implementation defined */"
        },
        {
            "title": "isnan",
            "path": "en.cppreference.com/w/c/numeric/math/isnan.html",
            "wgPageName": "c/numeric/math/isnan",
            "headers": [
                "<math.h>"
            ],
            "sample_declaration": "#define isnan(arg) /* implementation defined \\\n                    */"
        },
        {
            "title": "isnormal",
            "path": "en.cppreference.com/w/c/numeric/math/isnormal.html",
            "wgPageName": "c/numeric/math/isnormal",
            "headers": [
                "<math.h>"
            ],
            "sample_declaration": "#define isnormal( \\\n    arg) /* implementation defined */"
        },
        {
            "title": "isunordered",
            "path": "en.cppreference.com/w/c/numeric/math/isunordered.html",
            "wgPageName": "c/numeric/math/isunordered",
            "headers": [
                "<math.h>"
            ],
            "sample_declaration": "#define isunordered( \\\n    x, y) /* implementation defined */"
        },
        {
            "title": "ldexp, ldexpf, ldexpl",
            "path": "en.cppreference.com/w/c/numeric/math/ldexp.html",
            "wgPageName": "c/numeric/math/ldexp",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float ldexpf(float arg, int exp);",
            "other_declarations": 3
        },
        {
            "title": "lgamma, lgammaf, lgammal",
            "path": "en.cppreference.com/w/c/numeric/math/lgamma.html",
            "wgPageName": "c/numeric/math/lgamma",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float lgammaf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "log, logf, logl",
            "path": "en.cppreference.com/w/c/numeric/math/log.html",
            "wgPageName": "c/numeric/math/log",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float logf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "log10, log10f, log10l",
            "path": "en.cppreference.com/w/c/numeric/math/log10.html",
            "wgPageName": "c/numeric/math/log10",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float log10f(float arg);",
            "other_declarations": 3
        },
        {
            "title": "log1p, log1pf, log1pl",
            "path": "en.cppreference.com/w/c/numeric/math/log1p.html",
            "wgPageName": "c/numeric/math/log1p",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float log1pf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "log2, log2f, log2l",
            "path": "en.cppreference.com/w/c/numeric/math/log2.html",
            "wgPageName": "c/numeric/math/log2",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float log2f(float arg);",
            "other_declarations": 3
        },
        {
            "title": "logb, logbf, logbl",
            "path": "en.cppreference.com/w/c/numeric/math/logb.html",
            "wgPageName": "c/numeric/math/logb",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float logbf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "MATH_ERRNO, MATH_ERREXCEPT, math_errhandling",
            "path": "en.cppreference.com/w/c/numeric/math/math_errhandling.html",
            "wgPageName": "c/numeric/math/math_errhandling",
            "headers": [
                "<math.h>"
            ],
            "sample_declaration": "#define MATH_ERRNO 1",
            "other_declarations": 2
        },
        {
            "title": "modf, modff, modfl",
            "path": "en.cppreference.com/w/c/numeric/math/modf.html",
            "wgPageName": "c/numeric/math/modf",
            "headers": [
                "<math.h>"
            ],
            "sample_declaration": "float modff(float arg, float* iptr);",
            "other_declarations": 2
        },
        {
            "title": "nan, nanf, nanl, nand32, nand64, nand128",
            "path": "en.cppreference.com/w/c/numeric/math/nan.html",
            "wgPageName": "c/numeric/math/nan",
            "headers": [
                "<math.h>"
            ],
            "sample_declaration": "float nanf(const char* arg);",
            "other_declarations": 5
        },
        {
            "title": "nearbyint, nearbyintf, nearbyintl",
            "path": "en.cppreference.com/w/c/numeric/math/nearbyint.html",
            "wgPageName": "c/numeric/math/nearbyint",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float nearbyintf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "nextafter, nextafterf, nextafterl, nexttoward, nexttowardf, nexttowardl",
            "path": "en.cppreference.com/w/c/numeric/math/nextafter.html",
            "wgPageName": "c/numeric/math/nextafter",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float nextafterf(float from, float to);",
            "other_declarations": 7
        },
        {
            "title": "nextafter, nextafterf, nextafterl, nexttoward, nexttowardf, nexttowardl",
            "path": "en.cppreference.com/w/c/numeric/math/nexttoward.html",
            "wgPageName": "c/numeric/math/nextafter",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float nextafterf(float from, float to);",
            "other_declarations": 7
        },
        {
            "title": "pow, powf, powl",
            "path": "en.cppreference.com/w/c/numeric/math/pow.html",
            "wgPageName": "c/numeric/math/pow",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float powf(float base, float exponent);",
            "other_declarations": 3
        },
        {
            "title": "remainder, remainderf, remainderl",
            "path": "en.cppreference.com/w/c/numeric/math/remainder.html",
            "wgPageName": "c/numeric/math/remainder",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float remainderf(float x, float y);",
            "other_declarations": 3
        },
        {
            "title": "remquo, remquof, remquol",
            "path": "en.cppreference.com/w/c/numeric/math/remquo.html",
            "wgPageName": "c/numeric/math/remquo",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float remquof(float x, float y, int* quo);",
            "other_declarations": 3
        },
        {
            "title": "rint, rintf, rintl, lrint, lrintf, lrintl, llrint, llrintf, llrintl",
            "path": "en.cppreference.com/w/c/numeric/math/rint.html",
            "wgPageName": "c/numeric/math/rint",
            "headers": [
                "<math.h>",
                "<tgmath.h>",
                "<math.h>",
                "<tgmath.h>",
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float rintf(float arg);",
            "other_declarations": 11
        },
        {
            "title": "round, roundf, roundl, lround, lroundf, lroundl, llround, llroundf, llroundl",
            "path": "en.cppreference.com/w/c/numeric/math/round.html",
            "wgPageName": "c/numeric/math/round",
            "headers": [
                "<math.h>",
                "<tgmath.h>",
                "<math.h>",
                "<tgmath.h>",
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float roundf(float arg);",
            "other_declarations": 11
        },
        {
            "title": "roundeven, roundevenf, roundevenl",
            "path": "en.cppreference.com/w/c/numeric/math/roundeven.html",
            "wgPageName": "c/numeric/math/roundeven",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float roundevenf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "scalbn, scalbnf, scalbnl, scalbln, scalblnf, scalblnl",
            "path": "en.cppreference.com/w/c/numeric/math/scalbn.html",
            "wgPageName": "c/numeric/math/scalbn",
            "headers": [
                "<math.h>",
                "<tgmath.h>",
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float scalbnf(float arg, int exp);",
            "other_declarations": 7
        },
        {
            "title": "signbit",
            "path": "en.cppreference.com/w/c/numeric/math/signbit.html",
            "wgPageName": "c/numeric/math/signbit",
            "headers": [
                "<math.h>"
            ],
            "sample_declaration": "#define signbit( \\\n    arg) /* implementation defined */"
        },
        {
            "title": "sin, sinf, sinl",
            "path": "en.cppreference.com/w/c/numeric/math/sin.html",
            "wgPageName": "c/numeric/math/sin",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float sinf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "sinh, sinhf, sinhl",
            "path": "en.cppreference.com/w/c/numeric/math/sinh.html",
            "wgPageName": "c/numeric/math/sinh",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float sinhf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "sqrt, sqrtf, sqrtl",
            "path": "en.cppreference.com/w/c/numeric/math/sqrt.html",
            "wgPageName": "c/numeric/math/sqrt",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float sqrtf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "tan, tanf, tanl",
            "path": "en.cppreference.com/w/c/numeric/math/tan.html",
            "wgPageName": "c/numeric/math/tan",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float tanf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "tanh, tanhf, tanhl",
            "path": "en.cppreference.com/w/c/numeric/math/tanh.html",
            "wgPageName": "c/numeric/math/tanh",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float tanhf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "tgamma, tgammaf, tgammal",
            "path": "en.cppreference.com/w/c/numeric/math/tgamma.html",
            "wgPageName": "c/numeric/math/tgamma",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float tgammaf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "trunc, truncf, truncl",
            "path": "en.cppreference.com/w/c/numeric/math/trunc.html",
            "wgPageName": "c/numeric/math/trunc",
            "headers": [
                "<math.h>",
                "<tgmath.h>"
            ],
            "sample_declaration": "float truncf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "Pseudo-random number generation",
            "path": "en.cppreference.com/w/c/numeric/random.html",
            "wgPageName": "c/numeric/random"
        },
        {
            "title": "RAND_MAX",
            "path": "en.cppreference.com/w/c/numeric/random/RAND_MAX.html",
            "wgPageName": "c/numeric/random/RAND_MAX",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "#define RAND_MAX /*implementation defined*/"
        },
        {
            "title": "rand",
            "path": "en.cppreference.com/w/c/numeric/random/rand.html",
            "wgPageName": "c/numeric/random/rand",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "int rand();"
        },
        {
            "title": "srand",
            "path": "en.cppreference.com/w/c/numeric/random/srand.html",
            "wgPageName": "c/numeric/random/srand",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "void srand(unsigned seed);"
        },
        {
            "title": "Type-generic math",
            "path": "en.cppreference.com/w/c/numeric/tgmath.html",
            "wgPageName": "c/numeric/tgmath"
        },
        {
            "title": "Preprocessor",
            "path": "en.cppreference.com/w/c/preprocessor.html",
            "wgPageName": "c/preprocessor"
        },
        {
            "title": "Conditional inclusion",
            "path": "en.cppreference.com/w/c/preprocessor/conditional.html",
            "wgPageName": "c/preprocessor/conditional"
        },
        {
            "title": "Diagnostic directives",
            "path": "en.cppreference.com/w/c/preprocessor/error.html",
            "wgPageName": "c/preprocessor/error"
        },
        {
            "title": "Implementation defined behavior control",
            "path": "en.cppreference.com/w/c/preprocessor/impl.html",
            "wgPageName": "c/preprocessor/impl"
        },
        {
            "title": "Source file inclusion",
            "path": "en.cppreference.com/w/c/preprocessor/include.html",
            "wgPageName": "c/preprocessor/include"
        },
        {
            "title": "Filename and line information",
            "path": "en.cppreference.com/w/c/preprocessor/line.html",
            "wgPageName": "c/preprocessor/line"
        },
        {
            "title": "Replacing text macros",
            "path": "en.cppreference.com/w/c/preprocessor/replace.html",
            "wgPageName": "c/preprocessor/replace"
        },
        {
            "title": "Program support utilities",
            "path": "en.cppreference.com/w/c/program.html",
            "wgPageName": "c/program"
        },
        {
            "title": "_Exit",
            "path": "en.cppreference.com/w/c/program/_Exit.html",
            "wgPageName": "c/program/_Exit",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "void _Exit(int exit_code);",
            "other_declarations": 1
        },
        {
            "title": "abort",
            "path": "en.cppreference.com/w/c/program/abort.html",
            "wgPageName": "c/program/abort",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "void abort(void);",
            "other_declarations": 1
        },
        {
            "title": "at_quick_exit",
            "path": "en.cppreference.com/w/c/program/at_quick_exit.html",
            "wgPageName": "c/program/at_quick_exit",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "int at_quick_exit(void (*func)(void));"
        },
        {
            "title": "atexit",
            "path": "en.cppreference.com/w/c/program/atexit.html",
            "wgPageName": "c/program/atexit",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "int atexit(void (*func)(void));"
        },
        {
            "title": "EXIT_SUCCESS, EXIT_FAILURE",
            "path": "en.cppreference.com/w/c/program/EXIT_status.html",
            "wgPageName": "c/program/EXIT_status",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "#define EXIT_SUCCESS /*implementation \\\n                        defined*/",
            "other_declarations": 1
        },
        {
            "title": "exit",
            "path": "en.cppreference.com/w/c/program/exit.html",
            "wgPageName": "c/program/exit",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "void exit(int exit_code);",
            "other_declarations": 1
        },
        {
            "title": "getenv, getenv_s",
            "path": "en.cppreference.com/w/c/program/getenv.html",
            "wgPageName": "c/program/getenv",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "char* getenv(const char* name);",
            "other_declarations": 1
        },
        {
            "title": "jmp_buf",
            "path": "en.cppreference.com/w/c/program/jmp_buf.html",
            "wgPageName": "c/program/jmp_buf",
            "headers": [
                "<setjmp.h>"
            ],
            "sample_declaration": "typedef /* unspecified */ jmp_buf;"
        },
        {
            "title": "longjmp",
            "path": "en.cppreference.com/w/c/program/longjmp.html",
            "wgPageName": "c/program/longjmp",
            "headers": [
                "<setjmp.h>"
            ],
            "sample_declaration": "void longjmp(jmp_buf env, int status);",
            "other_declarations": 1
        },
        {
            "title": "quick_exit",
            "path": "en.cppreference.com/w/c/program/quick_exit.html",
            "wgPageName": "c/program/quick_exit",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "_Noreturn void quick_exit(int exit_code);"
        },
        {
            "title": "raise",
            "path": "en.cppreference.com/w/c/program/raise.html",
            "wgPageName": "c/program/raise",
            "headers": [
                "<signal.h>"
            ],
            "sample_declaration": "int raise(int sig);"
        },
        {
            "title": "setjmp",
            "path": "en.cppreference.com/w/c/program/setjmp.html",
            "wgPageName": "c/program/setjmp",
            "headers": [
                "<setjmp.h>"
            ],
            "sample_declaration": "#define setjmp(env) /* implementation-defined \\\n                     */"
        },
        {
            "title": "sig_atomic_t",
            "path": "en.cppreference.com/w/c/program/sig_atomic_t.html",
            "wgPageName": "c/program/sig_atomic_t",
            "headers": [
                "<signal.h>"
            ],
            "sample_declaration": "typedef /* unspecified */ sig_atomic_t;"
        },
        {
            "title": "SIG_ERR",
            "path": "en.cppreference.com/w/c/program/SIG_ERR.html",
            "wgPageName": "c/program/SIG_ERR",
            "headers": [
                "<signal.h>"
            ],
            "sample_declaration": "#define SIG_ERR /* implementation defined */"
        },
        {
            "title": "SIG_DFL, SIG_IGN",
            "path": "en.cppreference.com/w/c/program/SIG_strategies.html",
            "wgPageName": "c/program/SIG_strategies",
            "headers": [
                "<signal.h>"
            ],
            "sample_declaration": "#define SIG_DFL /*implementation defined*/",
            "other_declarations": 1
        },
        {
            "title": "SIGTERM, SIGSEGV, SIGINT, SIGILL, SIGABRT, SIGFPE",
            "path": "en.cppreference.com/w/c/program/SIG_types.html",
            "wgPageName": "c/program/SIG_types",
            "headers": [
                "<signal.h>"
            ],
            "sample_declaration": "#define SIGTERM /*implementation defined*/",
            "other_declarations": 5
        },
        {
            "title": "signal",
            "path": "en.cppreference.com/w/c/program/signal.html",
            "wgPageName": "c/program/signal",
            "headers": [
                "<signal.h>"
            ],
            "sample_declaration": "void (*signal(int sig, void (*handler)(int)))(\n    int);"
        },
        {
            "title": "system",
            "path": "en.cppreference.com/w/c/program/system.html",
            "wgPageName": "c/program/system",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "int system(const char* command);"
        },
        {
            "title": "unreachable",
            "path": "en.cppreference.com/w/c/program/unreachable.html",
            "wgPageName": "c/program/unreachable",
            "headers": [
                "<stddef.h>"
            ],
            "sample_declaration": "#define unreachable() /* see below */"
        },
        {
            "title": "Strings library",
            "path": "en.cppreference.com/w/c/string.html",
            "wgPageName": "c/string"
        },
        {
            "title": "Null-terminated byte strings",
            "path": "en.cppreference.com/w/c/string/byte.html",
            "wgPageName": "c/string/byte"
        },
        {
            "title": "atof",
            "path": "en.cppreference.com/w/c/string/byte/atof.html",
            "wgPageName": "c/string/byte/atof",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "double atof(const char* str);"
        },
        {
            "title": "atoi, atol, atoll",
            "path": "en.cppreference.com/w/c/string/byte/atoi.html",
            "wgPageName": "c/string/byte/atoi",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "int atoi(const char* str);",
            "other_declarations": 2
        },
        {
            "title": "isalnum",
            "path": "en.cppreference.com/w/c/string/byte/isalnum.html",
            "wgPageName": "c/string/byte/isalnum",
            "headers": [
                "<ctype.h>"
            ],
            "sample_declaration": "int isalnum(int ch);"
        },
        {
            "title": "isalpha",
            "path": "en.cppreference.com/w/c/string/byte/isalpha.html",
            "wgPageName": "c/string/byte/isalpha",
            "headers": [
                "<ctype.h>"
            ],
            "sample_declaration": "int isalpha(int ch);"
        },
        {
            "title": "isblank",
            "path": "en.cppreference.com/w/c/string/byte/isblank.html",
            "wgPageName": "c/string/byte/isblank",
            "headers": [
                "<ctype.h>"
            ],
            "sample_declaration": "int isblank(int ch);"
        },
        {
            "title": "iscntrl",
            "path": "en.cppreference.com/w/c/string/byte/iscntrl.html",
            "wgPageName": "c/string/byte/iscntrl",
            "headers": [
                "<ctype.h>"
            ],
            "sample_declaration": "int iscntrl(int ch);"
        },
        {
            "title": "isdigit",
            "path": "en.cppreference.com/w/c/string/byte/isdigit.html",
            "wgPageName": "c/string/byte/isdigit",
            "headers": [
                "<ctype.h>"
            ],
            "sample_declaration": "int isdigit(int ch);"
        },
        {
            "title": "isgraph",
            "path": "en.cppreference.com/w/c/string/byte/isgraph.html",
            "wgPageName": "c/string/byte/isgraph",
            "headers": [
                "<ctype.h>"
            ],
            "sample_declaration": "int isgraph(int ch);"
        },
        {
            "title": "islower",
            "path": "en.cppreference.com/w/c/string/byte/islower.html",
            "wgPageName": "c/string/byte/islower",
            "headers": [
                "<ctype.h>"
            ],
            "sample_declaration": "int islower(int ch);"
        },
        {
            "title": "isprint",
            "path": "en.cppreference.com/w/c/string/byte/isprint.html",
            "wgPageName": "c/string/byte/isprint",
            "headers": [
                "<ctype.h>"
            ],
            "sample_declaration": "int isprint(int ch);"
        },
        {
            "title": "ispunct",
            "path": "en.cppreference.com/w/c/string/byte/ispunct.html",
            "wgPageName": "c/string/byte/ispunct",
            "headers": [
                "<ctype.h>"
            ],
            "sample_declaration": "int ispunct(int ch);"
        },
        {
            "title": "isspace",
            "path": "en.cppreference.com/w/c/string/byte/isspace.html",
            "wgPageName": "c/string/byte/isspace",
            "headers": [
                "<ctype.h>"
            ],
            "sample_declaration": "int isspace(int ch);"
        },
        {
            "title": "isupper",
            "path": "en.cppreference.com/w/c/string/byte/isupper.html",
            "wgPageName": "c/string/byte/isupper",
            "headers": [
                "<ctype.h>"
            ],
            "sample_declaration": "int isupper(int ch);"
        },
        {
            "title": "isxdigit",
            "path": "en.cppreference.com/w/c/string/byte/isxdigit.html",
            "wgPageName": "c/string/byte/isxdigit",
            "headers": [
                "<ctype.h>"
            ],
            "sample_declaration": "int isxdigit(int ch);"
        },
        {
            "title": "memccpy",
            "path": "en.cppreference.com/w/c/string/byte/memccpy.html",
            "wgPageName": "c/string/byte/memccpy",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "void* memccpy(\n    void* restrict dest,\n    const void* restrict src,\n    int c,\n    size_t count);"
        },
        {
            "title": "memchr",
            "path": "en.cppreference.com/w/c/string/byte/memchr.html",
            "wgPageName": "c/string/byte/memchr",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "void* memchr(\n    const void* ptr,\n    int ch,\n    size_t count);"
        },
        {
            "title": "memcmp",
            "path": "en.cppreference.com/w/c/string/byte/memcmp.html",
            "wgPageName": "c/string/byte/memcmp",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "int memcmp(\n    const void* lhs,\n    const void* rhs,\n    size_t count);"
        },
        {
            "title": "memcpy, memcpy_s",
            "path": "en.cppreference.com/w/c/string/byte/memcpy.html",
            "wgPageName": "c/string/byte/memcpy",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "void* memcpy(\n    void* dest,\n    const void* src,\n    size_t count);",
            "other_declarations": 2
        },
        {
            "title": "memmove, memmove_s",
            "path": "en.cppreference.com/w/c/string/byte/memmove.html",
            "wgPageName": "c/string/byte/memmove",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "void* memmove(\n    void* dest,\n    const void* src,\n    size_t count);",
            "other_declarations": 1
        },
        {
            "title": "memset, memset_s",
            "path": "en.cppreference.com/w/c/string/byte/memset.html",
            "wgPageName": "c/string/byte/memset",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "void* memset(void* dest, int ch, size_t count);",
            "other_declarations": 2
        },
        {
            "title": "strcat, strcat_s",
            "path": "en.cppreference.com/w/c/string/byte/strcat.html",
            "wgPageName": "c/string/byte/strcat",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "char* strcat(char* dest, const char* src);",
            "other_declarations": 2
        },
        {
            "title": "strchr",
            "path": "en.cppreference.com/w/c/string/byte/strchr.html",
            "wgPageName": "c/string/byte/strchr",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "char* strchr(const char* str, int ch);"
        },
        {
            "title": "strcmp",
            "path": "en.cppreference.com/w/c/string/byte/strcmp.html",
            "wgPageName": "c/string/byte/strcmp",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "int strcmp(const char* lhs, const char* rhs);"
        },
        {
            "title": "strcoll",
            "path": "en.cppreference.com/w/c/string/byte/strcoll.html",
            "wgPageName": "c/string/byte/strcoll",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "int strcoll(const char* lhs, const char* rhs);"
        },
        {
            "title": "strcpy, strcpy_s",
            "path": "en.cppreference.com/w/c/string/byte/strcpy.html",
            "wgPageName": "c/string/byte/strcpy",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "char* strcpy(char* dest, const char* src);",
            "other_declarations": 2
        },
        {
            "title": "strcspn",
            "path": "en.cppreference.com/w/c/string/byte/strcspn.html",
            "wgPageName": "c/string/byte/strcspn",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "size_t strcspn(\n    const char* dest,\n    const char* src);"
        },
        {
            "title": "strdup",
            "path": "en.cppreference.com/w/c/string/byte/strdup.html",
            "wgPageName": "c/string/byte/strdup",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "char* strdup(const char* src);"
        },
        {
            "title": "strerror, strerror_s, strerrorlen_s",
            "path": "en.cppreference.com/w/c/string/byte/strerror.html",
            "wgPageName": "c/string/byte/strerror",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "char* strerror(int errnum);",
            "other_declarations": 2
        },
        {
            "title": "strlen, strnlen_s",
            "path": "en.cppreference.com/w/c/string/byte/strlen.html",
            "wgPageName": "c/string/byte/strlen",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "size_t strlen(const char* str);",
            "other_declarations": 1
        },
        {
            "title": "strncat, strncat_s",
            "path": "en.cppreference.com/w/c/string/byte/strncat.html",
            "wgPageName": "c/string/byte/strncat",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "char* strncat(\n    char* dest,\n    const char* src,\n    size_t count);",
            "other_declarations": 2
        },
        {
            "title": "strncmp",
            "path": "en.cppreference.com/w/c/string/byte/strncmp.html",
            "wgPageName": "c/string/byte/strncmp",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "int strncmp(\n    const char* lhs,\n    const char* rhs,\n    size_t count);"
        },
        {
            "title": "strncpy, strncpy_s",
            "path": "en.cppreference.com/w/c/string/byte/strncpy.html",
            "wgPageName": "c/string/byte/strncpy",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "char* strncpy(\n    char* dest,\n    const char* src,\n    size_t count);",
            "other_declarations": 2
        },
        {
            "title": "strndup",
            "path": "en.cppreference.com/w/c/string/byte/strndup.html",
            "wgPageName": "c/string/byte/strndup",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "char* strndup(const char* src, size_t size);"
        },
        {
            "title": "strpbrk",
            "path": "en.cppreference.com/w/c/string/byte/strpbrk.html",
            "wgPageName": "c/string/byte/strpbrk",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "char* strpbrk(\n    const char* dest,\n    const char* breakset);"
        },
        {
            "title": "strrchr",
            "path": "en.cppreference.com/w/c/string/byte/strrchr.html",
            "wgPageName": "c/string/byte/strrchr",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "char* strrchr(const char* str, int ch);"
        },
        {
            "title": "strspn",
            "path": "en.cppreference.com/w/c/string/byte/strspn.html",
            "wgPageName": "c/string/byte/strspn",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "size_t strspn(\n    const char* dest,\n    const char* src);"
        },
        {
            "title": "strstr",
            "path": "en.cppreference.com/w/c/string/byte/strstr.html",
            "wgPageName": "c/string/byte/strstr",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "char* strstr(\n    const char* str,\n    const char* substr);"
        },
        {
            "title": "strtof, strtod, strtold",
            "path": "en.cppreference.com/w/c/string/byte/strtof.html",
            "wgPageName": "c/string/byte/strtof",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "float strtof(\n    const char* restrict str,\n    char** restrict str_end);",
            "other_declarations": 3
        },
        {
            "title": "strtoimax, strtoumax",
            "path": "en.cppreference.com/w/c/string/byte/strtoimax.html",
            "wgPageName": "c/string/byte/strtoimax",
            "headers": [
                "<inttypes.h>"
            ],
            "sample_declaration": "intmax_t strtoimax(\n    const char* restrict nptr,\n    char** restrict endptr,\n    int base);",
            "other_declarations": 1
        },
        {
            "title": "strtok, strtok_s",
            "path": "en.cppreference.com/w/c/string/byte/strtok.html",
            "wgPageName": "c/string/byte/strtok",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "char* strtok(char* str, const char* delim);",
            "other_declarations": 2
        },
        {
            "title": "strtol, strtoll",
            "path": "en.cppreference.com/w/c/string/byte/strtol.html",
            "wgPageName": "c/string/byte/strtol",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "long strtol(\n    const char* str,\n    char** str_end,\n    int base);",
            "other_declarations": 2
        },
        {
            "title": "strtoul, strtoull",
            "path": "en.cppreference.com/w/c/string/byte/strtoul.html",
            "wgPageName": "c/string/byte/strtoul",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "unsigned long strtoul(\n    const char* str,\n    char** str_end,\n    int base);",
            "other_declarations": 2
        },
        {
            "title": "strxfrm",
            "path": "en.cppreference.com/w/c/string/byte/strxfrm.html",
            "wgPageName": "c/string/byte/strxfrm",
            "headers": [
                "<string.h>"
            ],
            "sample_declaration": "size_t strxfrm(\n    char* dest,\n    const char* src,\n    size_t count);",
            "other_declarations": 1
        },
        {
            "title": "tolower",
            "path": "en.cppreference.com/w/c/string/byte/tolower.html",
            "wgPageName": "c/string/byte/tolower",
            "headers": [
                "<ctype.h>"
            ],
            "sample_declaration": "int tolower(int ch);"
        },
        {
            "title": "toupper",
            "path": "en.cppreference.com/w/c/string/byte/toupper.html",
            "wgPageName": "c/string/byte/toupper",
            "headers": [
                "<ctype.h>"
            ],
            "sample_declaration": "int toupper(int ch);"
        },
        {
            "title": "Null-terminated multibyte strings",
            "path": "en.cppreference.com/w/c/string/multibyte.html",
            "wgPageName": "c/string/multibyte"
        },
        {
            "title": "btowc",
            "path": "en.cppreference.com/w/c/string/multibyte/btowc.html",
            "wgPageName": "c/string/multibyte/btowc",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "wint_t btowc(int c);"
        },
        {
            "title": "c16rtomb",
            "path": "en.cppreference.com/w/c/string/multibyte/c16rtomb.html",
            "wgPageName": "c/string/multibyte/c16rtomb",
            "headers": [
                "<uchar.h>"
            ],
            "sample_declaration": "size_t c16rtomb(\n    char* restrict s,\n    char16_t c16,\n    mbstate_t* restrict ps);"
        },
        {
            "title": "c32rtomb",
            "path": "en.cppreference.com/w/c/string/multibyte/c32rtomb.html",
            "wgPageName": "c/string/multibyte/c32rtomb",
            "headers": [
                "<uchar.h>"
            ],
            "sample_declaration": "size_t c32rtomb(\n    char* restrict s,\n    char32_t c32,\n    mbstate_t* restrict ps);"
        },
        {
            "title": "c8rtomb",
            "path": "en.cppreference.com/w/c/string/multibyte/c8rtomb.html",
            "wgPageName": "c/string/multibyte/c8rtomb",
            "headers": [
                "<uchar.h>"
            ],
            "sample_declaration": "size_t\nc8rtomb(char* s, char8_t c8, mbstate_t* ps);"
        },
        {
            "title": "char16_t",
            "path": "en.cppreference.com/w/c/string/multibyte/char16_t.html",
            "wgPageName": "c/string/multibyte/char16_t",
            "headers": [
                "<uchar.h>",
                "<stdint.h>"
            ],
            "sample_declaration": "typedef uint_least16_t char16_t;",
            "other_declarations": 1
        },
        {
            "title": "char32_t",
            "path": "en.cppreference.com/w/c/string/multibyte/char32_t.html",
            "wgPageName": "c/string/multibyte/char32_t",
            "headers": [
                "<uchar.h>",
                "<stdint.h>"
            ],
            "sample_declaration": "typedef uint_least32_t char32_t;",
            "other_declarations": 1
        },
        {
            "title": "mblen",
            "path": "en.cppreference.com/w/c/string/multibyte/mblen.html",
            "wgPageName": "c/string/multibyte/mblen",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "int mblen(const char* s, size_t n);"
        },
        {
            "title": "mbrlen",
            "path": "en.cppreference.com/w/c/string/multibyte/mbrlen.html",
            "wgPageName": "c/string/multibyte/mbrlen",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "size_t\nmbrlen(const char* s, size_t n, mbstate_t* ps);",
            "other_declarations": 1
        },
        {
            "title": "mbrtoc16",
            "path": "en.cppreference.com/w/c/string/multibyte/mbrtoc16.html",
            "wgPageName": "c/string/multibyte/mbrtoc16",
            "headers": [
                "<uchar.h>"
            ],
            "sample_declaration": "size_t mbrtoc16(\n    char16_t* restrict pc16,\n    const char* restrict s,\n    size_t n,\n    mbstate_t* restrict ps);"
        },
        {
            "title": "mbrtoc32",
            "path": "en.cppreference.com/w/c/string/multibyte/mbrtoc32.html",
            "wgPageName": "c/string/multibyte/mbrtoc32",
            "headers": [
                "<uchar.h>"
            ],
            "sample_declaration": "size_t mbrtoc32(\n    char32_t restrict* pc32,\n    const char* restrict s,\n    size_t n,\n    mbstate_t* restrict ps);"
        },
        {
            "title": "mbrtoc8",
            "path": "en.cppreference.com/w/c/string/multibyte/mbrtoc8.html",
            "wgPageName": "c/string/multibyte/mbrtoc8",
            "headers": [
                "<uchar.h>"
            ],
            "sample_declaration": "size_t mbrtoc8(\n    char8_t* pc8,\n    const char* s,\n    size_t n,\n    mbstate_t* ps);"
        },
        {
            "title": "mbrtowc",
            "path": "en.cppreference.com/w/c/string/multibyte/mbrtowc.html",
            "wgPageName": "c/string/multibyte/mbrtowc",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "size_t mbrtowc(\n    wchar_t* pwc,\n    const char* s,\n    size_t n,\n    mbstate_t* ps);",
            "other_declarations": 1
        },
        {
            "title": "mbsinit",
            "path": "en.cppreference.com/w/c/string/multibyte/mbsinit.html",
            "wgPageName": "c/string/multibyte/mbsinit",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "int mbsinit(const mbstate_t* ps);"
        },
        {
            "title": "mbsrtowcs, mbsrtowcs_s",
            "path": "en.cppreference.com/w/c/string/multibyte/mbsrtowcs.html",
            "wgPageName": "c/string/multibyte/mbsrtowcs",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "size_t mbsrtowcs(\n    wchar_t* dst,\n    const char** src,\n    size_t len,\n    mbstate_t* ps);",
            "other_declarations": 2
        },
        {
            "title": "mbstate_t",
            "path": "en.cppreference.com/w/c/string/multibyte/mbstate_t.html",
            "wgPageName": "c/string/multibyte/mbstate_t",
            "headers": [
                "<uchar.h>",
                "<wchar.h>"
            ],
            "sample_declaration": "struct mbstate_t;"
        },
        {
            "title": "mbstowcs, mbstowcs_s",
            "path": "en.cppreference.com/w/c/string/multibyte/mbstowcs.html",
            "wgPageName": "c/string/multibyte/mbstowcs",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "size_t mbstowcs(\n    wchar_t* dst,\n    const char* src,\n    size_t len)",
            "other_declarations": 2
        },
        {
            "title": "mbtowc",
            "path": "en.cppreference.com/w/c/string/multibyte/mbtowc.html",
            "wgPageName": "c/string/multibyte/mbtowc",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "int mbtowc(\n    wchar_t* pwc,\n    const char* s,\n    size_t n)",
            "other_declarations": 1
        },
        {
            "title": "wcrtomb, wcrtomb_s",
            "path": "en.cppreference.com/w/c/string/multibyte/wcrtomb.html",
            "wgPageName": "c/string/multibyte/wcrtomb",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "size_t\nwcrtomb(char* s, wchar_t wc, mbstate_t* ps);",
            "other_declarations": 2
        },
        {
            "title": "wcsrtombs, wcsrtombs_s",
            "path": "en.cppreference.com/w/c/string/multibyte/wcsrtombs.html",
            "wgPageName": "c/string/multibyte/wcsrtombs",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "size_t wcsrtombs(\n    char* dst,\n    const wchar_t** src,\n    size_t len,\n    mbstate_t* ps);",
            "other_declarations": 2
        },
        {
            "title": "wcstombs, wcstombs_s",
            "path": "en.cppreference.com/w/c/string/multibyte/wcstombs.html",
            "wgPageName": "c/string/multibyte/wcstombs",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "size_t wcstombs(\n    char* dst,\n    const wchar_t* src,\n    size_t len);",
            "other_declarations": 2
        },
        {
            "title": "wctob",
            "path": "en.cppreference.com/w/c/string/multibyte/wctob.html",
            "wgPageName": "c/string/multibyte/wctob",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "int wctob(wint_t c);"
        },
        {
            "title": "wctomb, wctomb_s",
            "path": "en.cppreference.com/w/c/string/multibyte/wctomb.html",
            "wgPageName": "c/string/multibyte/wctomb",
            "headers": [
                "<stdlib.h>"
            ],
            "sample_declaration": "int wctomb(char* s, wchar_t wc);",
            "other_declarations": 1
        },
        {
            "title": "Null-terminated wide strings",
            "path": "en.cppreference.com/w/c/string/wide.html",
            "wgPageName": "c/string/wide"
        },
        {
            "title": "iswalnum",
            "path": "en.cppreference.com/w/c/string/wide/iswalnum.html",
            "wgPageName": "c/string/wide/iswalnum",
            "headers": [
                "<wctype.h>"
            ],
            "sample_declaration": "int iswalnum(wint_t ch);"
        },
        {
            "title": "iswalpha",
            "path": "en.cppreference.com/w/c/string/wide/iswalpha.html",
            "wgPageName": "c/string/wide/iswalpha",
            "headers": [
                "<wctype.h>"
            ],
            "sample_declaration": "int iswalpha(wint_t ch);"
        },
        {
            "title": "iswblank",
            "path": "en.cppreference.com/w/c/string/wide/iswblank.html",
            "wgPageName": "c/string/wide/iswblank",
            "headers": [
                "<wctype.h>"
            ],
            "sample_declaration": "int iswblank(wint_t ch);"
        },
        {
            "title": "iswcntrl",
            "path": "en.cppreference.com/w/c/string/wide/iswcntrl.html",
            "wgPageName": "c/string/wide/iswcntrl",
            "headers": [
                "<wctype.h>"
            ],
            "sample_declaration": "int iswcntrl(wint_t ch);"
        },
        {
            "title": "iswctype",
            "path": "en.cppreference.com/w/c/string/wide/iswctype.html",
            "wgPageName": "c/string/wide/iswctype",
            "headers": [
                "<wctype.h>"
            ],
            "sample_declaration": "int iswctype(wint_t wc, wctype_t desc);"
        },
        {
            "title": "iswdigit",
            "path": "en.cppreference.com/w/c/string/wide/iswdigit.html",
            "wgPageName": "c/string/wide/iswdigit",
            "headers": [
                "<wctype.h>"
            ],
            "sample_declaration": "int iswdigit(wint_t ch);"
        },
        {
            "title": "iswgraph",
            "path": "en.cppreference.com/w/c/string/wide/iswgraph.html",
            "wgPageName": "c/string/wide/iswgraph",
            "headers": [
                "<wctype.h>"
            ],
            "sample_declaration": "int iswgraph(wint_t ch);"
        },
        {
            "title": "iswlower",
            "path": "en.cppreference.com/w/c/string/wide/iswlower.html",
            "wgPageName": "c/string/wide/iswlower",
            "headers": [
                "<wctype.h>"
            ],
            "sample_declaration": "int iswlower(wint_t ch);"
        },
        {
            "title": "iswprint",
            "path": "en.cppreference.com/w/c/string/wide/iswprint.html",
            "wgPageName": "c/string/wide/iswprint",
            "headers": [
                "<wctype.h>"
            ],
            "sample_declaration": "int iswprint(wint_t ch);"
        },
        {
            "title": "iswpunct",
            "path": "en.cppreference.com/w/c/string/wide/iswpunct.html",
            "wgPageName": "c/string/wide/iswpunct",
            "headers": [
                "<wctype.h>"
            ],
            "sample_declaration": "int iswpunct(wint_t ch);"
        },
        {
            "title": "iswspace",
            "path": "en.cppreference.com/w/c/string/wide/iswspace.html",
            "wgPageName": "c/string/wide/iswspace",
            "headers": [
                "<wctype.h>"
            ],
            "sample_declaration": "int iswspace(wint_t ch);"
        },
        {
            "title": "iswupper",
            "path": "en.cppreference.com/w/c/string/wide/iswupper.html",
            "wgPageName": "c/string/wide/iswupper",
            "headers": [
                "<wctype.h>"
            ],
            "sample_declaration": "int iswupper(wint_t ch);"
        },
        {
            "title": "iswxdigit",
            "path": "en.cppreference.com/w/c/string/wide/iswxdigit.html",
            "wgPageName": "c/string/wide/iswxdigit",
            "headers": [
                "<wctype.h>"
            ],
            "sample_declaration": "int iswxdigit(wint_t ch);"
        },
        {
            "title": "towctrans",
            "path": "en.cppreference.com/w/c/string/wide/towctrans.html",
            "wgPageName": "c/string/wide/towctrans",
            "headers": [
                "<wctype.h>"
            ],
            "sample_declaration": "wint_t towctrans(wint_t wc, wctrans_t desc);"
        },
        {
            "title": "towlower",
            "path": "en.cppreference.com/w/c/string/wide/towlower.html",
            "wgPageName": "c/string/wide/towlower",
            "headers": [
                "<wctype.h>"
            ],
            "sample_declaration": "wint_t towlower(wint_t wc);"
        },
        {
            "title": "towupper",
            "path": "en.cppreference.com/w/c/string/wide/towupper.html",
            "wgPageName": "c/string/wide/towupper",
            "headers": [
                "<wctype.h>"
            ],
            "sample_declaration": "wint_t towupper(wint_t wc);"
        },
        {
            "title": "wcscat, wcscat_s",
            "path": "en.cppreference.com/w/c/string/wide/wcscat.html",
            "wgPageName": "c/string/wide/wcscat",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "wchar_t* wcscat(\n    wchar_t* dest,\n    const wchar_t* src);",
            "other_declarations": 2
        },
        {
            "title": "wcschr",
            "path": "en.cppreference.com/w/c/string/wide/wcschr.html",
            "wgPageName": "c/string/wide/wcschr",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "wchar_t* wcschr(const wchar_t* str, wchar_t ch);"
        },
        {
            "title": "wcscmp",
            "path": "en.cppreference.com/w/c/string/wide/wcscmp.html",
            "wgPageName": "c/string/wide/wcscmp",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "int wcscmp(\n    const wchar_t* lhs,\n    const wchar_t* rhs);"
        },
        {
            "title": "wcscoll",
            "path": "en.cppreference.com/w/c/string/wide/wcscoll.html",
            "wgPageName": "c/string/wide/wcscoll",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "int wcscoll(\n    const wchar_t* lhs,\n    const wchar_t* rhs);"
        },
        {
            "title": "wcscpy, wcscpy_s",
            "path": "en.cppreference.com/w/c/string/wide/wcscpy.html",
            "wgPageName": "c/string/wide/wcscpy",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "wchar_t* wcscpy(\n    wchar_t* dest,\n    const wchar_t* src);",
            "other_declarations": 2
        },
        {
            "title": "wcscspn",
            "path": "en.cppreference.com/w/c/string/wide/wcscspn.html",
            "wgPageName": "c/string/wide/wcscspn",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "size_t wcscspn(\n    const wchar_t* dest,\n    const wchar_t* src);"
        },
        {
            "title": "wcslen, wcsnlen_s",
            "path": "en.cppreference.com/w/c/string/wide/wcslen.html",
            "wgPageName": "c/string/wide/wcslen",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "size_t wcslen(const wchar_t* str);",
            "other_declarations": 1
        },
        {
            "title": "wcsncat, wcsncat_s",
            "path": "en.cppreference.com/w/c/string/wide/wcsncat.html",
            "wgPageName": "c/string/wide/wcsncat",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "wchar_t* wcsncat(\n    wchar_t* dest,\n    const wchar_t* src,\n    size_t count);",
            "other_declarations": 2
        },
        {
            "title": "wcsncmp",
            "path": "en.cppreference.com/w/c/string/wide/wcsncmp.html",
            "wgPageName": "c/string/wide/wcsncmp",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "int wcsncmp(\n    const wchar_t* lhs,\n    const wchar_t* rhs,\n    size_t count);"
        },
        {
            "title": "wcsncpy, wcsncpy_s",
            "path": "en.cppreference.com/w/c/string/wide/wcsncpy.html",
            "wgPageName": "c/string/wide/wcsncpy",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "wchar_t* wcsncpy(\n    wchar_t* dest,\n    const wchar_t* src,\n    size_t count);",
            "other_declarations": 2
        },
        {
            "title": "wcspbrk",
            "path": "en.cppreference.com/w/c/string/wide/wcspbrk.html",
            "wgPageName": "c/string/wide/wcspbrk",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "wchar_t* wcspbrk(\n    const wchar_t* dest,\n    const wchar_t* str);"
        },
        {
            "title": "wcsrchr",
            "path": "en.cppreference.com/w/c/string/wide/wcsrchr.html",
            "wgPageName": "c/string/wide/wcsrchr",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "wchar_t* wcsrchr(\n    const wchar_t* str,\n    wchar_t ch);"
        },
        {
            "title": "wcsspn",
            "path": "en.cppreference.com/w/c/string/wide/wcsspn.html",
            "wgPageName": "c/string/wide/wcsspn",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "size_t wcsspn(\n    const wchar_t* dest,\n    const wchar_t* src);"
        },
        {
            "title": "wcsstr",
            "path": "en.cppreference.com/w/c/string/wide/wcsstr.html",
            "wgPageName": "c/string/wide/wcsstr",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "wchar_t* wcsstr(\n    const wchar_t* dest,\n    const wchar_t* src);"
        },
        {
            "title": "wcstof, wcstod, wcstold",
            "path": "en.cppreference.com/w/c/string/wide/wcstof.html",
            "wgPageName": "c/string/wide/wcstof",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "float wcstof(\n    const wchar_t* restrict str,\n    wchar_t** restrict str_end);",
            "other_declarations": 3
        },
        {
            "title": "wcstoimax, wcstoumax",
            "path": "en.cppreference.com/w/c/string/wide/wcstoimax.html",
            "wgPageName": "c/string/wide/wcstoimax",
            "headers": [
                "<inttypes.h>"
            ],
            "sample_declaration": "intmax_t wcstoimax(\n    const wchar_t* restrict nptr,\n    wchar_t** restrict endptr,\n    int base);",
            "other_declarations": 1
        },
        {
            "title": "wcstok, wcstok_s",
            "path": "en.cppreference.com/w/c/string/wide/wcstok.html",
            "wgPageName": "c/string/wide/wcstok",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "wchar_t* wcstok(\n    wchar_t* str,\n    const wchar_t* delim,\n    wchar_t** ptr);",
            "other_declarations": 2
        },
        {
            "title": "wcstol, wcstoll",
            "path": "en.cppreference.com/w/c/string/wide/wcstol.html",
            "wgPageName": "c/string/wide/wcstol",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "long wcstol(\n    const wchar_t* str,\n    wchar_t** str_end,\n    int base);",
            "other_declarations": 2
        },
        {
            "title": "wcstoul, wcstoull",
            "path": "en.cppreference.com/w/c/string/wide/wcstoul.html",
            "wgPageName": "c/string/wide/wcstoul",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "unsigned long wcstoul(\n    const wchar_t* str,\n    wchar_t** str_end,\n    int base);",
            "other_declarations": 2
        },
        {
            "title": "wcsxfrm",
            "path": "en.cppreference.com/w/c/string/wide/wcsxfrm.html",
            "wgPageName": "c/string/wide/wcsxfrm",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "size_t wcsxfrm(\n    wchar_t* dest,\n    const wchar_t* src,\n    size_t count);",
            "other_declarations": 1
        },
        {
            "title": "wctrans",
            "path": "en.cppreference.com/w/c/string/wide/wctrans.html",
            "wgPageName": "c/string/wide/wctrans",
            "headers": [
                "<wctype.h>"
            ],
            "sample_declaration": "wctrans_t wctrans(const char* str);"
        },
        {
            "title": "wctype",
            "path": "en.cppreference.com/w/c/string/wide/wctype.html",
            "wgPageName": "c/string/wide/wctype",
            "headers": [
                "<wctype.h>"
            ],
            "sample_declaration": "wctype_t wctype(const char* str);"
        },
        {
            "title": "wmemchr",
            "path": "en.cppreference.com/w/c/string/wide/wmemchr.html",
            "wgPageName": "c/string/wide/wmemchr",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "wchar_t* wmemchr(\n    const wchar_t* ptr,\n    wchar_t ch,\n    size_t count);"
        },
        {
            "title": "wmemcmp",
            "path": "en.cppreference.com/w/c/string/wide/wmemcmp.html",
            "wgPageName": "c/string/wide/wmemcmp",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "int wmemcmp(\n    const wchar_t* lhs,\n    const wchar_t* rhs,\n    size_t count);"
        },
        {
            "title": "wmemcpy, wmemcpy_s",
            "path": "en.cppreference.com/w/c/string/wide/wmemcpy.html",
            "wgPageName": "c/string/wide/wmemcpy",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "wchar_t* wmemcpy(\n    wchar_t* dest,\n    const wchar_t* src,\n    size_t count);",
            "other_declarations": 2
        },
        {
            "title": "wmemmove, wmemmove_s",
            "path": "en.cppreference.com/w/c/string/wide/wmemmove.html",
            "wgPageName": "c/string/wide/wmemmove",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "wchar_t* wmemmove(\n    wchar_t* dest,\n    const wchar_t* src,\n    size_t count);",
            "other_declarations": 1
        },
        {
            "title": "wmemset",
            "path": "en.cppreference.com/w/c/string/wide/wmemset.html",
            "wgPageName": "c/string/wide/wmemset",
            "headers": [
                "<wchar.h>"
            ],
            "sample_declaration": "wchar_t* wmemset(\n    wchar_t* dest,\n    wchar_t ch,\n    size_t count);"
        },
        {
            "title": "Macro Symbol Index",
            "path": "en.cppreference.com/w/c/symbol_index/macro.html",
            "wgPageName": "c/symbol_index/macro"
        },
        {
            "title": "Concurrency support library",
            "path": "en.cppreference.com/w/c/thread.html",
            "wgPageName": "c/thread"
        },
        {
            "title": "call_once, once_flag, ONCE_FLAG_INIT",
            "path": "en.cppreference.com/w/c/thread/call_once.html",
            "wgPageName": "c/thread/call_once",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "void call_once(\n    once_flag* flag,\n    void (*func)(void));",
            "other_declarations": 2
        },
        {
            "title": "cnd_broadcast",
            "path": "en.cppreference.com/w/c/thread/cnd_broadcast.html",
            "wgPageName": "c/thread/cnd_broadcast",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "int cnd_broadcast(cnd_t* cond);"
        },
        {
            "title": "cnd_destroy",
            "path": "en.cppreference.com/w/c/thread/cnd_destroy.html",
            "wgPageName": "c/thread/cnd_destroy",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "void cnd_destroy(cnd_t* cond);"
        },
        {
            "title": "cnd_init",
            "path": "en.cppreference.com/w/c/thread/cnd_init.html",
            "wgPageName": "c/thread/cnd_init",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "int cnd_init(cnd_t* cond);"
        },
        {
            "title": "cnd_signal",
            "path": "en.cppreference.com/w/c/thread/cnd_signal.html",
            "wgPageName": "c/thread/cnd_signal",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "int cnd_signal(cnd_t* cond);"
        },
        {
            "title": "cnd_timedwait",
            "path": "en.cppreference.com/w/c/thread/cnd_timedwait.html",
            "wgPageName": "c/thread/cnd_timedwait",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "int cnd_timedwait(\n    cnd_t* restrict cond,\n    mtx_t* restrict mutex,\n    const struct timespec* restrict time_point);"
        },
        {
            "title": "cnd_wait",
            "path": "en.cppreference.com/w/c/thread/cnd_wait.html",
            "wgPageName": "c/thread/cnd_wait",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "int cnd_wait(cnd_t* cond, mtx_t* mutex);"
        },
        {
            "title": "mtx_destroy",
            "path": "en.cppreference.com/w/c/thread/mtx_destroy.html",
            "wgPageName": "c/thread/mtx_destroy",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "void mtx_destroy(mtx_t* mutex);"
        },
        {
            "title": "mtx_init",
            "path": "en.cppreference.com/w/c/thread/mtx_init.html",
            "wgPageName": "c/thread/mtx_init",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "int mtx_init(mtx_t* mutex, int type);"
        },
        {
            "title": "mtx_lock",
            "path": "en.cppreference.com/w/c/thread/mtx_lock.html",
            "wgPageName": "c/thread/mtx_lock",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "int mtx_lock(mtx_t* mutex);"
        },
        {
            "title": "mtx_timedlock",
            "path": "en.cppreference.com/w/c/thread/mtx_timedlock.html",
            "wgPageName": "c/thread/mtx_timedlock",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "int mtx_timedlock(\n    mtx_t* restrict mutex,\n    const struct timespec* restrict time_point);"
        },
        {
            "title": "mtx_trylock",
            "path": "en.cppreference.com/w/c/thread/mtx_trylock.html",
            "wgPageName": "c/thread/mtx_trylock",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "int mtx_trylock(mtx_t* mutex);"
        },
        {
            "title": "mtx_plain, mtx_recursive, mtx_timed",
            "path": "en.cppreference.com/w/c/thread/mtx_types.html",
            "wgPageName": "c/thread/mtx_types",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "enum {\n  mtx_plain = /* unspecified */,\n  mtx_recursive = /* unspecified */,\n  mtx_timed = /* unspecified */\n};"
        },
        {
            "title": "mtx_unlock",
            "path": "en.cppreference.com/w/c/thread/mtx_unlock.html",
            "wgPageName": "c/thread/mtx_unlock",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "int mtx_unlock(mtx_t* mutex);"
        },
        {
            "title": "call_once, once_flag, ONCE_FLAG_INIT",
            "path": "en.cppreference.com/w/c/thread/ONCE_FLAG_INIT.html",
            "wgPageName": "c/thread/call_once",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "void call_once(\n    once_flag* flag,\n    void (*func)(void));",
            "other_declarations": 2
        },
        {
            "title": "thrd_create",
            "path": "en.cppreference.com/w/c/thread/thrd_create.html",
            "wgPageName": "c/thread/thrd_create",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "int thrd_create(\n    thrd_t* thr,\n    thrd_start_t func,\n    void* arg);"
        },
        {
            "title": "thrd_current",
            "path": "en.cppreference.com/w/c/thread/thrd_current.html",
            "wgPageName": "c/thread/thrd_current",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "thrd_t thrd_current(void);"
        },
        {
            "title": "thrd_detach",
            "path": "en.cppreference.com/w/c/thread/thrd_detach.html",
            "wgPageName": "c/thread/thrd_detach",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "int thrd_detach(thrd_t thr);"
        },
        {
            "title": "thrd_equal",
            "path": "en.cppreference.com/w/c/thread/thrd_equal.html",
            "wgPageName": "c/thread/thrd_equal",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "int thrd_equal(thrd_t lhs, thrd_t rhs);"
        },
        {
            "title": "thrd_success, thrd_timedout, thrd_busy, thrd_nomem, thrd_error",
            "path": "en.cppreference.com/w/c/thread/thrd_errors.html",
            "wgPageName": "c/thread/thrd_errors",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "enum {\n  thrd_success = /* unspecified */,\n  thrd_nomem = /* unspecified */,\n  thrd_timedout = /* unspecified */,\n  thrd_busy = /* unspecified */,\n  thrd_error = /* unspecified */\n};"
        },
        {
            "title": "thrd_exit",
            "path": "en.cppreference.com/w/c/thread/thrd_exit.html",
            "wgPageName": "c/thread/thrd_exit",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "_Noreturn void thrd_exit(int res);"
        },
        {
            "title": "thrd_join",
            "path": "en.cppreference.com/w/c/thread/thrd_join.html",
            "wgPageName": "c/thread/thrd_join",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "int thrd_join(thrd_t thr, int* res);"
        },
        {
            "title": "thrd_sleep",
            "path": "en.cppreference.com/w/c/thread/thrd_sleep.html",
            "wgPageName": "c/thread/thrd_sleep",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "int thrd_sleep(\n    const struct timespec* duration,\n    struct timespec* remaining);"
        },
        {
            "title": "thrd_yield",
            "path": "en.cppreference.com/w/c/thread/thrd_yield.html",
            "wgPageName": "c/thread/thrd_yield",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "void thrd_yield(void);"
        },
        {
            "title": "thread_local",
            "path": "en.cppreference.com/w/c/thread/thread_local.html",
            "wgPageName": "c/thread/thread_local",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "#define thread_local _Thread_local"
        },
        {
            "title": "tss_create",
            "path": "en.cppreference.com/w/c/thread/tss_create.html",
            "wgPageName": "c/thread/tss_create",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "int tss_create(\n    tss_t* tss_key,\n    tss_dtor_t destructor);"
        },
        {
            "title": "tss_delete",
            "path": "en.cppreference.com/w/c/thread/tss_delete.html",
            "wgPageName": "c/thread/tss_delete",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "void tss_delete(tss_t tss_id);"
        },
        {
            "title": "TSS_DTOR_ITERATIONS",
            "path": "en.cppreference.com/w/c/thread/TSS_DTOR_ITERATIONS.html",
            "wgPageName": "c/thread/TSS_DTOR_ITERATIONS",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "#define TSS_DTOR_ITERATIONS /* unspecified */"
        },
        {
            "title": "tss_get",
            "path": "en.cppreference.com/w/c/thread/tss_get.html",
            "wgPageName": "c/thread/tss_get",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "void* tss_get(tss_t tss_key);"
        },
        {
            "title": "tss_set",
            "path": "en.cppreference.com/w/c/thread/tss_set.html",
            "wgPageName": "c/thread/tss_set",
            "headers": [
                "<threads.h>"
            ],
            "sample_declaration": "int tss_set(tss_t tss_id, void* val);"
        },
        {
            "title": "Type support",
            "path": "en.cppreference.com/w/c/types.html",
            "wgPageName": "c/types"
        },
        {
            "title": "Fixed width integer types (since C99)",
            "path": "en.cppreference.com/w/c/types/integer.html",
            "wgPageName": "c/types/integer"
        },
        {
            "title": "Numeric limits",
            "path": "en.cppreference.com/w/c/types/limits.html",
            "wgPageName": "c/types/limits"
        },
        {
            "title": "FLT_EVAL_METHOD",
            "path": "en.cppreference.com/w/c/types/limits/FLT_EVAL_METHOD.html",
            "wgPageName": "c/types/limits/FLT_EVAL_METHOD",
            "headers": [
                "<float.h>"
            ],
            "sample_declaration": "#define FLT_EVAL_METHOD /* implementation \\\n                           defined */"
        },
        {
            "title": "FLT_ROUNDS",
            "path": "en.cppreference.com/w/c/types/limits/FLT_ROUNDS.html",
            "wgPageName": "c/types/limits/FLT_ROUNDS",
            "headers": [
                "<float.h>"
            ],
            "sample_declaration": "#define FLT_ROUNDS /* implementation defined \\\n                    */"
        },
        {
            "title": "max_align_t",
            "path": "en.cppreference.com/w/c/types/max_align_t.html",
            "wgPageName": "c/types/max_align_t",
            "headers": [
                "<stddef.h>"
            ],
            "sample_declaration": "typedef /*implementation-defined*/ max_align_t;"
        },
        {
            "title": "NULL",
            "path": "en.cppreference.com/w/c/types/NULL.html",
            "wgPageName": "c/types/NULL",
            "headers": [
                "<stddef.h>",
                "<string.h>",
                "<wchar.h>",
                "<time.h>",
                "<locale.h>",
                "<stdio.h>",
                "<stdlib.h>"
            ],
            "sample_declaration": "#define NULL /*implementation-defined*/"
        },
        {
            "title": "nullptr_t",
            "path": "en.cppreference.com/w/c/types/nullptr_t.html",
            "wgPageName": "c/types/nullptr_t",
            "headers": [
                "<stddef.h>"
            ],
            "sample_declaration": "typedef typeof(nullptr) nullptr_t;"
        },
        {
            "title": "offsetof",
            "path": "en.cppreference.com/w/c/types/offsetof.html",
            "wgPageName": "c/types/offsetof",
            "headers": [
                "<stddef.h>"
            ],
            "sample_declaration": "#define offsetof( \\\n    type, member) /*implementation-defined*/"
        },
        {
            "title": "ptrdiff_t",
            "path": "en.cppreference.com/w/c/types/ptrdiff_t.html",
            "wgPageName": "c/types/ptrdiff_t",
            "headers": [
                "<stddef.h>"
            ],
            "sample_declaration": "typedef /*implementation-defined*/ ptrdiff_t;"
        },
        {
            "title": "size_t",
            "path": "en.cppreference.com/w/c/types/size_t.html",
            "wgPageName": "c/types/size_t",
            "headers": [
                "<stddef.h>",
                "<stdio.h>",
                "<stdlib.h>",
                "<string.h>",
                "<time.h>",
                "<uchar.h>",
                "<wchar.h>"
            ],
            "sample_declaration": "typedef /*implementation-defined*/ size_t;"
        },
        {
            "title": "Utility library",
            "path": "en.cppreference.com/w/c/utility.html",
            "wgPageName": "c/utility"
        },
        {
            "title": "Variadic functions",
            "path": "en.cppreference.com/w/c/variadic.html",
            "wgPageName": "c/variadic"
        },
        {
            "title": "va_arg",
            "path": "en.cppreference.com/w/c/variadic/va_arg.html",
            "wgPageName": "c/variadic/va_arg",
            "headers": [
                "<stdarg.h>"
            ],
            "sample_declaration": "T va_arg(va_list ap, T);"
        },
        {
            "title": "va_copy",
            "path": "en.cppreference.com/w/c/variadic/va_copy.html",
            "wgPageName": "c/variadic/va_copy",
            "headers": [
                "<stdarg.h>"
            ],
            "sample_declaration": "void va_copy(va_list dest, va_list src);"
        },
        {
            "title": "va_end",
            "path": "en.cppreference.com/w/c/variadic/va_end.html",
            "wgPageName": "c/variadic/va_end",
            "headers": [
                "<stdarg.h>"
            ],
            "sample_declaration": "void va_end(va_list ap);"
        },
        {
            "title": "va_list",
            "path": "en.cppreference.com/w/c/variadic/va_list.html",
            "wgPageName": "c/variadic/va_list",
            "headers": [
                "<stdarg.h>"
            ],
            "sample_declaration": "/* unspecified */ va_list;"
        },
        {
            "title": "va_start",
            "path": "en.cppreference.com/w/c/variadic/va_start.html",
            "wgPageName": "c/variadic/va_start",
            "headers": [
                "<stdarg.h>"
            ],
            "sample_declaration": "void va_start(va_list ap, parmN);",
            "other_declarations": 1
        }
    ],
    "cpp": [
        {
            "title": "C++11",
            "path": "en.cppreference.com/w/cpp/11.html",
            "wgPageName": "cpp/11"
        },
        {
            "title": "C++14",
            "path": "en.cppreference.com/w/cpp/14.html",
            "wgPageName": "cpp/14"
        },
        {
            "title": "C++17",
            "path": "en.cppreference.com/w/cpp/17.html",
            "wgPageName": "cpp/17"
        },
        {
            "title": "C++20",
            "path": "en.cppreference.com/w/cpp/20.html",
            "wgPageName": "cpp/20"
        },
        {
            "title": "C++23",
            "path": "en.cppreference.com/w/cpp/23.html",
            "wgPageName": "cpp/23"
        },
        {
            "title": "Algorithms library",
            "path": "en.cppreference.com/w/cpp/algorithm.html",
            "wgPageName": "cpp/algorithm"
        },
        {
            "title": "std::accumulate",
            "path": "en.cppreference.com/w/cpp/algorithm/accumulate.html",
            "wgPageName": "cpp/algorithm/accumulate",
            "headers": [
                "<numeric>"
            ],
            "sample_declaration": "template<class InputIt, class T>\nT accumulate(\n    InputIt first,\n    InputIt last,\n    T init);",
            "other_declarations": 3
        },
        {
            "title": "std::adjacent_difference",
            "path": "en.cppreference.com/w/cpp/algorithm/adjacent_difference.html",
            "wgPageName": "cpp/algorithm/adjacent_difference",
            "headers": [
                "<numeric>"
            ],
            "sample_declaration": "template<class InputIt, class OutputIt>\nOutputIt adjacent_difference(\n    InputIt first,\n    InputIt last,\n    OutputIt d_first);",
            "other_declarations": 5
        },
        {
            "title": "std::adjacent_find",
            "path": "en.cppreference.com/w/cpp/algorithm/adjacent_find.html",
            "wgPageName": "cpp/algorithm/adjacent_find",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt>\nForwardIt adjacent_find(\n    ForwardIt first,\n    ForwardIt last);",
            "other_declarations": 5
        },
        {
            "title": "std::all_of, std::any_of, std::none_of",
            "path": "en.cppreference.com/w/cpp/algorithm/all_any_none_of.html",
            "wgPageName": "cpp/algorithm/all_any_none_of",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class InputIt, class UnaryPredicate>\nbool all_of(\n    InputIt first,\n    InputIt last,\n    UnaryPredicate p);",
            "other_declarations": 8
        },
        {
            "title": "std::binary_search",
            "path": "en.cppreference.com/w/cpp/algorithm/binary_search.html",
            "wgPageName": "cpp/algorithm/binary_search",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt, class T>\nbool binary_search(\n    ForwardIt first,\n    ForwardIt last,\n    const T& value);",
            "other_declarations": 3
        },
        {
            "title": "std::bsearch",
            "path": "en.cppreference.com/w/cpp/algorithm/bsearch.html",
            "wgPageName": "cpp/algorithm/bsearch",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "void* bsearch(\n    const void* key,\n    const void* ptr,\n    std::size_t count,\n    std::size_t size,\n    /*compare-pred*/ *comp);\nvoid* bsearch(\n    const void* key,\n    const void* ptr,\n    std::size_t count,\n    std::size_t size,\n    /*c-compare-pred*/ *comp);",
            "other_declarations": 1
        },
        {
            "title": "std::clamp",
            "path": "en.cppreference.com/w/cpp/algorithm/clamp.html",
            "wgPageName": "cpp/algorithm/clamp",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class T>\nconstexpr const T&\nclamp(const T& v, const T& lo, const T& hi);",
            "other_declarations": 1
        },
        {
            "title": "std::copy_backward",
            "path": "en.cppreference.com/w/cpp/algorithm/copy_backward.html",
            "wgPageName": "cpp/algorithm/copy_backward",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class BidirIt1, class BidirIt2>\nBidirIt2 copy_backward(\n    BidirIt1 first,\n    BidirIt1 last,\n    BidirIt2 d_last);",
            "other_declarations": 1
        },
        {
            "title": "std::copy_n",
            "path": "en.cppreference.com/w/cpp/algorithm/copy_n.html",
            "wgPageName": "cpp/algorithm/copy_n",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    class InputIt,\n    class Size,\n    class OutputIt>\nOutputIt copy_n(\n    InputIt first,\n    Size count,\n    OutputIt result);",
            "other_declarations": 2
        },
        {
            "title": "std::copy, std::copy_if",
            "path": "en.cppreference.com/w/cpp/algorithm/copy.html",
            "wgPageName": "cpp/algorithm/copy",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class InputIt, class OutputIt>\nOutputIt copy(\n    InputIt first,\n    InputIt last,\n    OutputIt d_first);",
            "other_declarations": 5
        },
        {
            "title": "std::count, std::count_if",
            "path": "en.cppreference.com/w/cpp/algorithm/count_if.html",
            "wgPageName": "cpp/algorithm/count",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class InputIt, class T>\ntypename iterator_traits<\n    InputIt>::difference_type\ncount(\n    InputIt first,\n    InputIt last,\n    const T& value);",
            "other_declarations": 5
        },
        {
            "title": "std::count, std::count_if",
            "path": "en.cppreference.com/w/cpp/algorithm/count.html",
            "wgPageName": "cpp/algorithm/count",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class InputIt, class T>\ntypename iterator_traits<\n    InputIt>::difference_type\ncount(\n    InputIt first,\n    InputIt last,\n    const T& value);",
            "other_declarations": 5
        },
        {
            "title": "std::equal_range",
            "path": "en.cppreference.com/w/cpp/algorithm/equal_range.html",
            "wgPageName": "cpp/algorithm/equal_range",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt, class T>\nstd::pair<ForwardIt, ForwardIt> equal_range(\n    ForwardIt first,\n    ForwardIt last,\n    const T& value);",
            "other_declarations": 3
        },
        {
            "title": "std::equal",
            "path": "en.cppreference.com/w/cpp/algorithm/equal.html",
            "wgPageName": "cpp/algorithm/equal",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class InputIt1, class InputIt2>\nbool equal(\n    InputIt1 first1,\n    InputIt1 last1,\n    InputIt2 first2);",
            "other_declarations": 11
        },
        {
            "title": "std::exclusive_scan",
            "path": "en.cppreference.com/w/cpp/algorithm/exclusive_scan.html",
            "wgPageName": "cpp/algorithm/exclusive_scan",
            "headers": [
                "<numeric>"
            ],
            "sample_declaration": "template<class InputIt, class OutputIt, class T>\nOutputIt exclusive_scan(\n    InputIt first,\n    InputIt last,\n    OutputIt d_first,\n    T init);",
            "other_declarations": 5
        },
        {
            "title": "std::execution::sequenced_policy, std::execution::parallel_policy, std::execution::parallel_unsequenced_policy, std::execution::unsequenced_policy",
            "path": "en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t.html",
            "wgPageName": "cpp/algorithm/execution_policy_tag_t",
            "headers": [
                "<execution>"
            ],
            "sample_declaration": "class sequenced_policy { /* unspecified */\n};",
            "other_declarations": 3
        },
        {
            "title": "std::execution::seq, std::execution::par, std::execution::par_unseq, std::execution::unseq",
            "path": "en.cppreference.com/w/cpp/algorithm/execution_policy_tag.html",
            "wgPageName": "cpp/algorithm/execution_policy_tag",
            "headers": [
                "<execution>"
            ],
            "sample_declaration": "inline constexpr std::execution::\n    sequenced_policy seq{/* unspecified */};",
            "other_declarations": 3
        },
        {
            "title": "std::fill_n",
            "path": "en.cppreference.com/w/cpp/algorithm/fill_n.html",
            "wgPageName": "cpp/algorithm/fill_n",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class OutputIt, class Size, class T>\nvoid fill_n(\n    OutputIt first,\n    Size count,\n    const T& value);",
            "other_declarations": 3
        },
        {
            "title": "std::fill",
            "path": "en.cppreference.com/w/cpp/algorithm/fill.html",
            "wgPageName": "cpp/algorithm/fill",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt, class T>\nvoid fill(\n    ForwardIt first,\n    ForwardIt last,\n    const T& value);",
            "other_declarations": 2
        },
        {
            "title": "std::find_end",
            "path": "en.cppreference.com/w/cpp/algorithm/find_end.html",
            "wgPageName": "cpp/algorithm/find_end",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt1, class ForwardIt2>\nForwardIt1 find_end(\n    ForwardIt1 first,\n    ForwardIt1 last,\n    ForwardIt2 s_first,\n    ForwardIt2 s_last);",
            "other_declarations": 5
        },
        {
            "title": "std::find_first_of",
            "path": "en.cppreference.com/w/cpp/algorithm/find_first_of.html",
            "wgPageName": "cpp/algorithm/find_first_of",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt1, class ForwardIt2>\nForwardIt1 find_first_of(\n    ForwardIt1 first,\n    ForwardIt1 last,\n    ForwardIt2 s_first,\n    ForwardIt2 s_last);",
            "other_declarations": 7
        },
        {
            "title": "std::find, std::find_if, std::find_if_not",
            "path": "en.cppreference.com/w/cpp/algorithm/find_if_not.html",
            "wgPageName": "cpp/algorithm/find",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class InputIt, class T>\nInputIt find(\n    InputIt first,\n    InputIt last,\n    const T& value);",
            "other_declarations": 8
        },
        {
            "title": "std::find, std::find_if, std::find_if_not",
            "path": "en.cppreference.com/w/cpp/algorithm/find_if.html",
            "wgPageName": "cpp/algorithm/find",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class InputIt, class T>\nInputIt find(\n    InputIt first,\n    InputIt last,\n    const T& value);",
            "other_declarations": 8
        },
        {
            "title": "std::find, std::find_if, std::find_if_not",
            "path": "en.cppreference.com/w/cpp/algorithm/find.html",
            "wgPageName": "cpp/algorithm/find",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class InputIt, class T>\nInputIt find(\n    InputIt first,\n    InputIt last,\n    const T& value);",
            "other_declarations": 8
        },
        {
            "title": "std::for_each_n",
            "path": "en.cppreference.com/w/cpp/algorithm/for_each_n.html",
            "wgPageName": "cpp/algorithm/for_each_n",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    class InputIt,\n    class Size,\n    class UnaryFunction>\nInputIt for_each_n(\n    InputIt first,\n    Size n,\n    UnaryFunction f);",
            "other_declarations": 2
        },
        {
            "title": "std::for_each",
            "path": "en.cppreference.com/w/cpp/algorithm/for_each.html",
            "wgPageName": "cpp/algorithm/for_each",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class InputIt, class UnaryFunction>\nUnaryFunction for_each(\n    InputIt first,\n    InputIt last,\n    UnaryFunction f);",
            "other_declarations": 2
        },
        {
            "title": "std::generate_n",
            "path": "en.cppreference.com/w/cpp/algorithm/generate_n.html",
            "wgPageName": "cpp/algorithm/generate_n",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    class OutputIt,\n    class Size,\n    class Generator>\nvoid generate_n(\n    OutputIt first,\n    Size count,\n    Generator g);",
            "other_declarations": 3
        },
        {
            "title": "std::generate",
            "path": "en.cppreference.com/w/cpp/algorithm/generate.html",
            "wgPageName": "cpp/algorithm/generate",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt, class Generator>\nvoid generate(\n    ForwardIt first,\n    ForwardIt last,\n    Generator g);",
            "other_declarations": 2
        },
        {
            "title": "std::includes",
            "path": "en.cppreference.com/w/cpp/algorithm/includes.html",
            "wgPageName": "cpp/algorithm/includes",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class InputIt1, class InputIt2>\nbool includes(\n    InputIt1 first1,\n    InputIt1 last1,\n    InputIt2 first2,\n    InputIt2 last2);",
            "other_declarations": 5
        },
        {
            "title": "std::inclusive_scan",
            "path": "en.cppreference.com/w/cpp/algorithm/inclusive_scan.html",
            "wgPageName": "cpp/algorithm/inclusive_scan",
            "headers": [
                "<numeric>"
            ],
            "sample_declaration": "template<class InputIt, class OutputIt>\nOutputIt inclusive_scan(\n    InputIt first,\n    InputIt last,\n    OutputIt d_first);",
            "other_declarations": 8
        },
        {
            "title": "std::inner_product",
            "path": "en.cppreference.com/w/cpp/algorithm/inner_product.html",
            "wgPageName": "cpp/algorithm/inner_product",
            "headers": [
                "<numeric>"
            ],
            "sample_declaration": "template<\n    class InputIt1,\n    class InputIt2,\n    class T>\nT inner_product(\n    InputIt1 first1,\n    InputIt1 last1,\n    InputIt2 first2,\n    T init);",
            "other_declarations": 3
        },
        {
            "title": "std::inplace_merge",
            "path": "en.cppreference.com/w/cpp/algorithm/inplace_merge.html",
            "wgPageName": "cpp/algorithm/inplace_merge",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class BidirIt>\nvoid inplace_merge(\n    BidirIt first,\n    BidirIt middle,\n    BidirIt last);",
            "other_declarations": 3
        },
        {
            "title": "std::iota",
            "path": "en.cppreference.com/w/cpp/algorithm/iota.html",
            "wgPageName": "cpp/algorithm/iota",
            "headers": [
                "<numeric>"
            ],
            "sample_declaration": "template<class ForwardIt, class T>\nvoid iota(\n    ForwardIt first,\n    ForwardIt last,\n    T value);",
            "other_declarations": 1
        },
        {
            "title": "std::is_execution_policy",
            "path": "en.cppreference.com/w/cpp/algorithm/is_execution_policy.html",
            "wgPageName": "cpp/algorithm/is_execution_policy",
            "headers": [
                "<execution>"
            ],
            "sample_declaration": "template<class T>\nstruct is_execution_policy;"
        },
        {
            "title": "std::is_heap_until",
            "path": "en.cppreference.com/w/cpp/algorithm/is_heap_until.html",
            "wgPageName": "cpp/algorithm/is_heap_until",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class RandomIt>\nRandomIt is_heap_until(\n    RandomIt first,\n    RandomIt last);",
            "other_declarations": 5
        },
        {
            "title": "std::is_heap",
            "path": "en.cppreference.com/w/cpp/algorithm/is_heap.html",
            "wgPageName": "cpp/algorithm/is_heap",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class RandomIt>\nbool is_heap(RandomIt first, RandomIt last);",
            "other_declarations": 5
        },
        {
            "title": "std::is_partitioned",
            "path": "en.cppreference.com/w/cpp/algorithm/is_partitioned.html",
            "wgPageName": "cpp/algorithm/is_partitioned",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class InputIt, class UnaryPredicate>\nbool is_partitioned(\n    InputIt first,\n    InputIt last,\n    UnaryPredicate p);",
            "other_declarations": 2
        },
        {
            "title": "std::is_permutation",
            "path": "en.cppreference.com/w/cpp/algorithm/is_permutation.html",
            "wgPageName": "cpp/algorithm/is_permutation",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt1, class ForwardIt2>\nbool is_permutation(\n    ForwardIt1 first1,\n    ForwardIt1 last1,\n    ForwardIt2 first2);",
            "other_declarations": 7
        },
        {
            "title": "std::is_sorted_until",
            "path": "en.cppreference.com/w/cpp/algorithm/is_sorted_until.html",
            "wgPageName": "cpp/algorithm/is_sorted_until",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt>\nForwardIt is_sorted_until(\n    ForwardIt first,\n    ForwardIt last);",
            "other_declarations": 5
        },
        {
            "title": "std::is_sorted",
            "path": "en.cppreference.com/w/cpp/algorithm/is_sorted.html",
            "wgPageName": "cpp/algorithm/is_sorted",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt>\nbool is_sorted(ForwardIt first, ForwardIt last);",
            "other_declarations": 5
        },
        {
            "title": "std::iter_swap",
            "path": "en.cppreference.com/w/cpp/algorithm/iter_swap.html",
            "wgPageName": "cpp/algorithm/iter_swap",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt1, class ForwardIt2>\nvoid iter_swap(ForwardIt1 a, ForwardIt2 b);",
            "other_declarations": 1
        },
        {
            "title": "std::lexicographical_compare_three_way",
            "path": "en.cppreference.com/w/cpp/algorithm/lexicographical_compare_three_way.html",
            "wgPageName": "cpp/algorithm/lexicographical_compare_three_way",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    class InputIt1,\n    class InputIt2,\n    class Cmp>\nconstexpr auto\nlexicographical_compare_three_way(\n    InputIt1 first1,\n    InputIt1 last1,\n    InputIt2 first2,\n    InputIt2 last2,\n    Cmp comp);\n->decltype(comp(*first1, *first2));",
            "other_declarations": 1
        },
        {
            "title": "std::lexicographical_compare",
            "path": "en.cppreference.com/w/cpp/algorithm/lexicographical_compare.html",
            "wgPageName": "cpp/algorithm/lexicographical_compare",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class InputIt1, class InputIt2>\nbool lexicographical_compare(\n    InputIt1 first1,\n    InputIt1 last1,\n    InputIt2 first2,\n    InputIt2 last2);",
            "other_declarations": 5
        },
        {
            "title": "std::lower_bound",
            "path": "en.cppreference.com/w/cpp/algorithm/lower_bound.html",
            "wgPageName": "cpp/algorithm/lower_bound",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt, class T>\nForwardIt lower_bound(\n    ForwardIt first,\n    ForwardIt last,\n    const T& value);",
            "other_declarations": 3
        },
        {
            "title": "std::make_heap",
            "path": "en.cppreference.com/w/cpp/algorithm/make_heap.html",
            "wgPageName": "cpp/algorithm/make_heap",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class RandomIt>\nvoid make_heap(RandomIt first, RandomIt last);",
            "other_declarations": 3
        },
        {
            "title": "std::max_element",
            "path": "en.cppreference.com/w/cpp/algorithm/max_element.html",
            "wgPageName": "cpp/algorithm/max_element",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt>\nForwardIt max_element(\n    ForwardIt first,\n    ForwardIt last);",
            "other_declarations": 5
        },
        {
            "title": "std::max",
            "path": "en.cppreference.com/w/cpp/algorithm/max.html",
            "wgPageName": "cpp/algorithm/max",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class T>\nconst T& max(const T& a, const T& b);",
            "other_declarations": 7
        },
        {
            "title": "std::merge",
            "path": "en.cppreference.com/w/cpp/algorithm/merge.html",
            "wgPageName": "cpp/algorithm/merge",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    class InputIt1,\n    class InputIt2,\n    class OutputIt>\nOutputIt merge(\n    InputIt1 first1,\n    InputIt1 last1,\n    InputIt2 first2,\n    InputIt2 last2,\n    OutputIt d_first);",
            "other_declarations": 5
        },
        {
            "title": "std::min_element",
            "path": "en.cppreference.com/w/cpp/algorithm/min_element.html",
            "wgPageName": "cpp/algorithm/min_element",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt>\nForwardIt min_element(\n    ForwardIt first,\n    ForwardIt last);",
            "other_declarations": 5
        },
        {
            "title": "std::min",
            "path": "en.cppreference.com/w/cpp/algorithm/min.html",
            "wgPageName": "cpp/algorithm/min",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class T>\nconst T& min(const T& a, const T& b);",
            "other_declarations": 7
        },
        {
            "title": "std::minmax_element",
            "path": "en.cppreference.com/w/cpp/algorithm/minmax_element.html",
            "wgPageName": "cpp/algorithm/minmax_element",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt>\nstd::pair<ForwardIt, ForwardIt> minmax_element(\n    ForwardIt first,\n    ForwardIt last);",
            "other_declarations": 5
        },
        {
            "title": "std::minmax",
            "path": "en.cppreference.com/w/cpp/algorithm/minmax.html",
            "wgPageName": "cpp/algorithm/minmax",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class T>\nstd::pair<const T&, const T&> minmax(\n    const T& a,\n    const T& b);",
            "other_declarations": 7
        },
        {
            "title": "std::mismatch",
            "path": "en.cppreference.com/w/cpp/algorithm/mismatch.html",
            "wgPageName": "cpp/algorithm/mismatch",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class InputIt1, class InputIt2>\nstd::pair<InputIt1, InputIt2> mismatch(\n    InputIt1 first1,\n    InputIt1 last1,\n    InputIt2 first2);",
            "other_declarations": 11
        },
        {
            "title": "std::move_backward",
            "path": "en.cppreference.com/w/cpp/algorithm/move_backward.html",
            "wgPageName": "cpp/algorithm/move_backward",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class BidirIt1, class BidirIt2>\nBidirIt2 move_backward(\n    BidirIt1 first,\n    BidirIt1 last,\n    BidirIt2 d_last);",
            "other_declarations": 1
        },
        {
            "title": "std::move",
            "path": "en.cppreference.com/w/cpp/algorithm/move.html",
            "wgPageName": "cpp/algorithm/move",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class InputIt, class OutputIt>\nOutputIt move(\n    InputIt first,\n    InputIt last,\n    OutputIt d_first);",
            "other_declarations": 2
        },
        {
            "title": "std::next_permutation",
            "path": "en.cppreference.com/w/cpp/algorithm/next_permutation.html",
            "wgPageName": "cpp/algorithm/next_permutation",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class BidirIt>\nbool next_permutation(\n    BidirIt first,\n    BidirIt last);",
            "other_declarations": 3
        },
        {
            "title": "std::nth_element",
            "path": "en.cppreference.com/w/cpp/algorithm/nth_element.html",
            "wgPageName": "cpp/algorithm/nth_element",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class RandomIt>\nvoid nth_element(\n    RandomIt first,\n    RandomIt nth,\n    RandomIt last);",
            "other_declarations": 5
        },
        {
            "title": "std::partial_sort_copy",
            "path": "en.cppreference.com/w/cpp/algorithm/partial_sort_copy.html",
            "wgPageName": "cpp/algorithm/partial_sort_copy",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class InputIt, class RandomIt>\nRandomIt partial_sort_copy(\n    InputIt first,\n    InputIt last,\n    RandomIt d_first,\n    RandomIt d_last);",
            "other_declarations": 5
        },
        {
            "title": "std::partial_sort",
            "path": "en.cppreference.com/w/cpp/algorithm/partial_sort.html",
            "wgPageName": "cpp/algorithm/partial_sort",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class RandomIt>\nvoid partial_sort(\n    RandomIt first,\n    RandomIt middle,\n    RandomIt last);",
            "other_declarations": 5
        },
        {
            "title": "std::partial_sum",
            "path": "en.cppreference.com/w/cpp/algorithm/partial_sum.html",
            "wgPageName": "cpp/algorithm/partial_sum",
            "headers": [
                "<numeric>"
            ],
            "sample_declaration": "template<class InputIt, class OutputIt>\nOutputIt partial_sum(\n    InputIt first,\n    InputIt last,\n    OutputIt d_first);",
            "other_declarations": 3
        },
        {
            "title": "std::partition_copy",
            "path": "en.cppreference.com/w/cpp/algorithm/partition_copy.html",
            "wgPageName": "cpp/algorithm/partition_copy",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    class InputIt,\n    class OutputIt1,\n    class OutputIt2,\n    class UnaryPredicate>\nstd::pair<OutputIt1, OutputIt2> partition_copy(\n    InputIt first,\n    InputIt last,\n    OutputIt1 d_first_true,\n    OutputIt2 d_first_false,\n    UnaryPredicate p);",
            "other_declarations": 2
        },
        {
            "title": "std::partition_point",
            "path": "en.cppreference.com/w/cpp/algorithm/partition_point.html",
            "wgPageName": "cpp/algorithm/partition_point",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt, class UnaryPredicate>\nForwardIt partition_point(\n    ForwardIt first,\n    ForwardIt last,\n    UnaryPredicate p);",
            "other_declarations": 1
        },
        {
            "title": "std::partition",
            "path": "en.cppreference.com/w/cpp/algorithm/partition.html",
            "wgPageName": "cpp/algorithm/partition",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class BidirIt, class UnaryPredicate>\nBidirIt partition(\n    BidirIt first,\n    BidirIt last,\n    UnaryPredicate p);",
            "other_declarations": 3
        },
        {
            "title": "std::pop_heap",
            "path": "en.cppreference.com/w/cpp/algorithm/pop_heap.html",
            "wgPageName": "cpp/algorithm/pop_heap",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class RandomIt>\nvoid pop_heap(RandomIt first, RandomIt last);",
            "other_declarations": 3
        },
        {
            "title": "std::prev_permutation",
            "path": "en.cppreference.com/w/cpp/algorithm/prev_permutation.html",
            "wgPageName": "cpp/algorithm/prev_permutation",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class BidirIt>\nbool prev_permutation(\n    BidirIt first,\n    BidirIt last);",
            "other_declarations": 3
        },
        {
            "title": "std::push_heap",
            "path": "en.cppreference.com/w/cpp/algorithm/push_heap.html",
            "wgPageName": "cpp/algorithm/push_heap",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class RandomIt>\nvoid push_heap(RandomIt first, RandomIt last);",
            "other_declarations": 3
        },
        {
            "title": "std::qsort",
            "path": "en.cppreference.com/w/cpp/algorithm/qsort.html",
            "wgPageName": "cpp/algorithm/qsort",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "void qsort(\n    void* ptr,\n    std::size_t count,\n    std::size_t size,\n    /*compare-pred*/ *comp);\nvoid qsort(\n    void* ptr,\n    std::size_t count,\n    std::size_t size,\n    /*c-compare-pred*/ *comp);",
            "other_declarations": 1
        },
        {
            "title": "std::random_shuffle, std::shuffle",
            "path": "en.cppreference.com/w/cpp/algorithm/random_shuffle.html",
            "wgPageName": "cpp/algorithm/random_shuffle",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class RandomIt>\nvoid random_shuffle(\n    RandomIt first,\n    RandomIt last);",
            "other_declarations": 3
        },
        {
            "title": "Constrained algorithms (since C++20)",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges.html",
            "wgPageName": "cpp/algorithm/ranges"
        },
        {
            "title": "std::ranges::adjacent_find",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/adjacent_find.html",
            "wgPageName": "cpp/algorithm/ranges/adjacent_find",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::forward_iterator I,\n    std::sentinel_for<I> S,\n    class Proj = std::identity,\n    std::indirect_binary_predicate<\n        std::projected<I, Proj>,\n        std::projected<I, Proj>> Pred =\n        ranges::equal_to>\nconstexpr I adjacent_find(\n    I first,\n    S last,\n    Pred pred = {},\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::all_of, std::ranges::any_of, std::ranges::none_of",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/all_any_none_of.html",
            "wgPageName": "cpp/algorithm/ranges/all_any_none_of",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I,\n    std::sentinel_for<I> S,\n    class Proj = std::identity,\n    std::indirect_unary_predicate<\n        std::projected<I, Proj>> Pred>\nconstexpr bool all_of(\n    I first,\n    S last,\n    Pred pred,\n    Proj proj = {});",
            "other_declarations": 5
        },
        {
            "title": "std::ranges::binary_search",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/binary_search.html",
            "wgPageName": "cpp/algorithm/ranges/binary_search",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::forward_iterator I,\n    std::sentinel_for<I> S,\n    class T,\n    class Proj = std::identity,\n    std::indirect_strict_weak_order<\n        const T*,\n        std::projected<I, Proj>> Comp =\n        ranges::less>\nconstexpr bool binary_search(\n    I first,\n    S last,\n    const T& value,\n    Comp comp = {},\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::clamp",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/clamp.html",
            "wgPageName": "cpp/algorithm/ranges/clamp",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    class T,\n    class Proj = std::identity,\n    std::indirect_strict_weak_order<\n        std::projected<const T*, Proj>> Comp =\n        ranges::less>\nconstexpr const T& clamp(\n    const T& v,\n    const T& lo,\n    const T& hi,\n    Comp comp = {},\n    Proj proj = {});"
        },
        {
            "title": "std::ranges::contains, std::ranges::contains_subrange",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/contains.html",
            "wgPageName": "cpp/algorithm/ranges/contains",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I,\n    std::sentinel_for<I> S,\n    class T,\n    class Proj = std::identity>\nrequires std::indirect_binary_predicate <\n    ranges::equal_to,\n    std::projected<I, Proj>,\nconst T* > constexpr bool contains(\n               I first,\n               S last,\n               const T& value,\n               Proj proj = {});",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::copy_backward, std::ranges::copy_backward_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/copy_backward.html",
            "wgPageName": "cpp/algorithm/ranges/copy_backward",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::bidirectional_iterator I1,\n    std::sentinel_for<I1> S1,\n    std::bidirectional_iterator I2>\nrequires std::indirectly_copyable<I1, I2>\nconstexpr copy_backward_result<I1, I2>\ncopy_backward(I1 first, S1 last, I2 result);",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::copy_n, std::ranges::copy_n_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/copy_n.html",
            "wgPageName": "cpp/algorithm/ranges/copy_n",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I,\n    std::weakly_incrementable O>\nrequires std::indirectly_copyable<I, O>\nconstexpr copy_n_result<I, O> copy_n(\n    I first,\n    std::iter_difference_t<I> n,\n    O result);",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::copy, std::ranges::copy_if, std::ranges::copy_result, std::ranges::copy_if_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/copy.html",
            "wgPageName": "cpp/algorithm/ranges/copy",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I,\n    std::sentinel_for<I> S,\n    std::weakly_incrementable O>\nrequires std::indirectly_copyable<I, O>\nconstexpr copy_result<I, O>\ncopy(I first, S last, O result);",
            "other_declarations": 5
        },
        {
            "title": "std::ranges::count, std::ranges::count_if",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/count.html",
            "wgPageName": "cpp/algorithm/ranges/count",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I,\n    std::sentinel_for<I> S,\n    class T,\n    class Proj = std::identity>\nrequires std::indirect_binary_predicate <\n    ranges::equal_to,\n    std::projected<I, Proj>,\nconst T* >\n    constexpr std::iter_difference_t<I> count(\n        I first,\n        S last,\n        const T& value,\n        Proj proj = {});",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::ends_with",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/ends_with.html",
            "wgPageName": "cpp/algorithm/ranges/ends_with",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I1,\n    std::sentinel_for<I1> S1,\n    std::input_iterator I2,\n    std::sentinel_for<I2> S2,\n    class Pred = ranges::equal_to,\n    class Proj1 = std::identity,\n    class Proj2 = std::identity>\nrequires(\n    std::forward_iterator<I1> ||\n    std::sized_sentinel_for<S1, I1>) &&\n    (std::forward_iterator<I2> ||\n     std::sized_sentinel_for<S2, I2>)&&std::\n        indirectly_comparable<I1, I2, Pred, Proj1, Proj2> constexpr bool ends_with(\n            I1 first1,\n            S1 last1,\n            I2 first2,\n            S2 last2,\n            Pred pred = {},\n            Proj1 proj1 = {},\n            Proj2 proj2 = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::equal_range",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/equal_range.html",
            "wgPageName": "cpp/algorithm/ranges/equal_range",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::forward_iterator I,\n    std::sentinel_for<I> S,\n    class T,\n    class Proj = std::identity,\n    std::indirect_strict_weak_order<\n        const T*,\n        std::projected<I, Proj>> Comp =\n        ranges::less>\nconstexpr ranges::subrange<I> equal_range(\n    I first,\n    S last,\n    const T& value,\n    Comp comp = {},\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::equal",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/equal.html",
            "wgPageName": "cpp/algorithm/ranges/equal",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I1,\n    std::sentinel_for<I1> S1,\n    std::input_iterator I2,\n    std::sentinel_for<I2> S2,\n    class Pred = ranges::equal_to,\n    class Proj1 = std::identity,\n    class Proj2 = std::identity>\nrequires std::indirectly_comparable<\n    I1,\n    I2,\n    Pred,\n    Proj1,\n    Proj2>\nconstexpr bool equal(\n    I1 first1,\n    S1 last1,\n    I2 first2,\n    S2 last2,\n    Pred pred = {},\n    Proj1 proj1 = {},\n    Proj2 proj2 = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::fill_n",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/fill_n.html",
            "wgPageName": "cpp/algorithm/ranges/fill_n",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    class T,\n    std::output_iterator<const T&> O>\nconstexpr O fill_n(\n    O first,\n    std::iter_difference_t<O> n,\n    const T& value);"
        },
        {
            "title": "std::ranges::fill",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/fill.html",
            "wgPageName": "cpp/algorithm/ranges/fill",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    class T,\n    std::output_iterator<const T&> O,\n    std::sentinel_for<O> S>\nconstexpr O\nfill(O first, S last, const T& value);",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::find_end",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/find_end.html",
            "wgPageName": "cpp/algorithm/ranges/find_end",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::forward_iterator I1,\n    std::sentinel_for<I1> S1,\n    std::forward_iterator I2,\n    std::sentinel_for<I2> S2,\n    class Pred = ranges::equal_to,\n    class Proj1 = std::identity,\n    class Proj2 = std::identity>\nrequires std::indirectly_comparable<\n    I1,\n    I2,\n    Pred,\n    Proj1,\n    Proj2>\nconstexpr ranges::subrange<I1> find_end(\n    I1 first1,\n    S1 last1,\n    I2 first2,\n    S2 last2,\n    Pred pred = {},\n    Proj1 proj1 = {},\n    Proj2 proj2 = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::find_first_of",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/find_first_of.html",
            "wgPageName": "cpp/algorithm/ranges/find_first_of",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I1,\n    std::sentinel_for<I1> S1,\n    std::forward_iterator I2,\n    std::sentinel_for<I2> S2,\n    class Pred = ranges::equal_to,\n    class Proj1 = std::identity,\n    class Proj2 = std::identity>\nrequires std::indirectly_comparable<\n    I1,\n    I2,\n    Pred,\n    Proj1,\n    Proj2>\nconstexpr I1 find_first_of(\n    I1 first1,\n    S1 last1,\n    I2 first2,\n    S2 last2,\n    Pred pred = {},\n    Proj1 proj1 = {},\n    Proj2 proj2 = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::find_last, std::ranges::find_last_if, std::ranges::find_last_if_not",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/find_last.html",
            "wgPageName": "cpp/algorithm/ranges/find_last",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::forward_iterator I,\n    std::sentinel_for<I> S,\n    class T,\n    class Proj = std::identity>\nrequires std::indirect_binary_predicate <\n    ranges::equal_to,\n    std::projected<I, Proj>,\nconst T* >\n    constexpr ranges::subrange<I> find_last(\n        I first,\n        S last,\n        const T& value,\n        Proj proj = {});",
            "other_declarations": 5
        },
        {
            "title": "std::ranges::find, std::ranges::find_if, std::ranges::find_if_not",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/find.html",
            "wgPageName": "cpp/algorithm/ranges/find",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I,\n    std::sentinel_for<I> S,\n    class T,\n    class Proj = std::identity>\nrequires std::indirect_binary_predicate <\n    ranges::equal_to,\n    std::projected<I, Proj>,\nconst T* > constexpr I find(\n               I first,\n               S last,\n               const T& value,\n               Proj proj = {});",
            "other_declarations": 5
        },
        {
            "title": "std::ranges::for_each_n, std::ranges::for_each_n_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/for_each_n.html",
            "wgPageName": "cpp/algorithm/ranges/for_each_n",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I,\n    class Proj = identity,\n    std::indirectly_unary_invocable<\n        std::projected<I, Proj>> Fun>\nconstexpr for_each_n_result<I, Fun> for_each_n(\n    I first,\n    std::iter_difference_t<I> n,\n    Fun f,\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::for_each, std::ranges::for_each_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/for_each.html",
            "wgPageName": "cpp/algorithm/ranges/for_each",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I,\n    std::sentinel_for<I> S,\n    class Proj = std::identity,\n    std::indirectly_unary_invocable<\n        std::projected<I, Proj>> Fun>\nconstexpr for_each_result<I, Fun> for_each(\n    I first,\n    S last,\n    Fun f,\n    Proj proj = {});",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::generate_n",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/generate_n.html",
            "wgPageName": "cpp/algorithm/ranges/generate_n",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_or_output_iterator O,\n    std::copy_constructible F>\nrequires std::invocable<F&> &&\n    std::indirectly_writable<\n        O,\n        std::invoke_result_t<F&>>\nconstexpr O generate_n(\n    O first,\n    std::iter_difference_t<O> n,\n    F gen);"
        },
        {
            "title": "std::ranges::generate",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/generate.html",
            "wgPageName": "cpp/algorithm/ranges/generate",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_or_output_iterator O,\n    std::sentinel_for<O> S,\n    std::copy_constructible F>\nrequires std::invocable<F&> &&\n    std::indirectly_writable<\n        O,\n        std::invoke_result_t<F&>>\nconstexpr O generate(O first, S last, F gen);",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::includes",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/includes.html",
            "wgPageName": "cpp/algorithm/ranges/includes",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I1,\n    std::sentinel_for<I1> S1,\n    std::input_iterator I2,\n    std::sentinel_for<I2> S2,\n    class Proj1 = std::identity,\n    class Proj2 = std::identity,\n    std::indirect_strict_weak_order<\n        std::projected<I1, Proj1>,\n        std::projected<I2, Proj2>> Comp =\n        ranges::less>\nconstexpr bool includes(\n    I1 first1,\n    S1 last1,\n    I2 first2,\n    S2 last2,\n    Comp comp = {},\n    Proj1 proj1 = {},\n    Proj2 proj2 = {})",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::inplace_merge",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/inplace_merge.html",
            "wgPageName": "cpp/algorithm/ranges/inplace_merge",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::bidirectional_iterator I,\n    std::sentinel_for<I> S,\n    class Comp = ranges::less,\n    class Proj = std::identity>\nrequires std::sortable<I, Comp, Proj> I\ninplace_merge(\n    I first,\n    I middle,\n    S last,\n    Comp comp = {},\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::iota, std::ranges::iota_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/iota.html",
            "wgPageName": "cpp/algorithm/ranges/iota",
            "headers": [
                "<numeric>"
            ],
            "sample_declaration": "template<\n    std::input_or_output_iterator O,\n    std::sentinel_for<O> S,\n    std::weakly_incrementable T>\nrequires std::indirectly_writable<O, const T&>\nconstexpr iota_result<O, T>\niota(O first, S last, T value);",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::is_heap_until",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/is_heap_until.html",
            "wgPageName": "cpp/algorithm/ranges/is_heap_until",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::random_access_iterator I,\n    std::sentinel_for<I> S,\n    class Proj = std::identity,\n    std::indirect_strict_weak_order<\n        std::projected<I, Proj>> Comp =\n        ranges::less>\nconstexpr I is_heap_until(\n    I first,\n    S last,\n    Comp comp = {},\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::is_heap",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/is_heap.html",
            "wgPageName": "cpp/algorithm/ranges/is_heap",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::random_access_iterator I,\n    std::sentinel_for<I> S,\n    class Proj = std::identity,\n    std::indirect_strict_weak_order<\n        std::projected<I, Proj>> Comp =\n        ranges::less>\nconstexpr bool is_heap(\n    I first,\n    S last,\n    Comp comp = {},\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::is_partitioned",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/is_partitioned.html",
            "wgPageName": "cpp/algorithm/ranges/is_partitioned",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I,\n    std::sentinel_for<I> S,\n    class Proj = std::identity,\n    std::indirect_unary_predicate<\n        std::projected<I, Proj>> Pred>\nconstexpr bool is_partitioned(\n    I first,\n    S last,\n    Pred pred,\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::is_permutation",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/is_permutation.html",
            "wgPageName": "cpp/algorithm/ranges/is_permutation",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::forward_iterator I1,\n    std::sentinel_for<I1> S1,\n    std::forward_iterator I2,\n    std::sentinel_for<I2> S2,\n    class Proj1 = std::identity,\n    class Proj2 = std::identity,\n    std::indirect_equivalence_relation<\n        std::projected<I1, Proj1>,\n        std::projected<I2, Proj2>> Pred =\n        ranges::equal_to>\nconstexpr bool is_permutation(\n    I1 first1,\n    S1 last1,\n    I2 first2,\n    S2 last2,\n    Pred pred = {},\n    Proj1 proj1 = {},\n    Proj2 proj2 = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::is_sorted_until",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/is_sorted_until.html",
            "wgPageName": "cpp/algorithm/ranges/is_sorted_until",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::forward_iterator I,\n    std::sentinel_for<I> S,\n    class Proj = std::identity,\n    std::indirect_strict_weak_order<\n        std::projected<I, Proj>> Comp =\n        ranges::less>\nconstexpr I is_sorted_until(\n    I first,\n    S last,\n    Comp comp = {},\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::is_sorted",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/is_sorted.html",
            "wgPageName": "cpp/algorithm/ranges/is_sorted",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::forward_iterator I,\n    std::sentinel_for<I> S,\n    class Proj = std::identity,\n    std::indirect_strict_weak_order<\n        std::projected<I, Proj>> Comp =\n        ranges::less>\nconstexpr bool is_sorted(\n    I first,\n    S last,\n    Comp comp = {},\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::lexicographical_compare",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/lexicographical_compare.html",
            "wgPageName": "cpp/algorithm/ranges/lexicographical_compare",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I1,\n    std::sentinel_for<I1> S1,\n    std::input_iterator I2,\n    std::sentinel_for<I2> S2,\n    class Proj1 = std::identity,\n    class Proj2 = std::identity,\n    std::indirect_strict_weak_order<\n        std::projected<I1, Proj1>,\n        std::projected<I2, Proj2>> Comp =\n        ranges::less>\nconstexpr bool lexicographical_compare(\n    I1 first1,\n    S1 last1,\n    I2 first2,\n    S2 last2,\n    Comp comp = {},\n    Proj1 proj1 = {},\n    Proj2 proj2 = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::lower_bound",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/lower_bound.html",
            "wgPageName": "cpp/algorithm/ranges/lower_bound",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::forward_iterator I,\n    std::sentinel_for<I> S,\n    class T,\n    class Proj = std::identity,\n    std::indirect_strict_weak_order<\n        const T*,\n        std::projected<I, Proj>> Comp =\n        ranges::less>\nconstexpr I lower_bound(\n    I first,\n    S last,\n    const T& value,\n    Comp comp = {},\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::make_heap",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/make_heap.html",
            "wgPageName": "cpp/algorithm/ranges/make_heap",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::random_access_iterator I,\n    std::sentinel_for<I> S,\n    class Comp = ranges::less,\n    class Proj = std::identity>\nrequires std::sortable<I, Comp, Proj>\nconstexpr I make_heap(\n    I first,\n    S last,\n    Comp comp = {},\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::max_element",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/max_element.html",
            "wgPageName": "cpp/algorithm/ranges/max_element",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::forward_iterator I,\n    std::sentinel_for<I> S,\n    class Proj = std::identity,\n    std::indirect_strict_weak_order<\n        std::projected<I, Proj>> Comp =\n        ranges::less>\nconstexpr I max_element(\n    I first,\n    S last,\n    Comp comp = {},\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::max",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/max.html",
            "wgPageName": "cpp/algorithm/ranges/max",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    class T,\n    class Proj = std::identity,\n    std::indirect_strict_weak_order<\n        std::projected<const T*, Proj>> Comp =\n        ranges::less>\nconstexpr const T& max(\n    const T& a,\n    const T& b,\n    Comp comp = {},\n    Proj proj = {});",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::merge, std::ranges::merge_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/merge.html",
            "wgPageName": "cpp/algorithm/ranges/merge",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I1,\n    std::sentinel_for<I1> S1,\n    std::input_iterator I2,\n    std::sentinel_for<I2> S2,\n    std::weakly_incrementable O,\n    class Comp = ranges::less,\n    class Proj1 = std::identity,\n    class Proj2 = std::identity>\nrequires std::\n    mergeable<I1, I2, O, Comp, Proj1, Proj2>\nconstexpr merge_result<I1, I2, O> merge(\n    I1 first1,\n    S1 last1,\n    I2 first2,\n    S2 last2,\n    O result,\n    Comp comp = {},\n    Proj1 proj1 = {},\n    Proj2 proj2 = {});",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::min_element",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/min_element.html",
            "wgPageName": "cpp/algorithm/ranges/min_element",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::forward_iterator I,\n    std::sentinel_for<I> S,\n    class Proj = std::identity,\n    std::indirect_strict_weak_order<\n        std::projected<I, Proj>> Comp =\n        ranges::less>\nconstexpr I min_element(\n    I first,\n    S last,\n    Comp comp = {},\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::min",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/min.html",
            "wgPageName": "cpp/algorithm/ranges/min",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    class T,\n    class Proj = std::identity,\n    std::indirect_strict_weak_order<\n        std::projected<const T*, Proj>> Comp =\n        ranges::less>\nconstexpr const T& min(\n    const T& a,\n    const T& b,\n    Comp comp = {},\n    Proj proj = {});",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::minmax_element, std::ranges::minmax_element_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/minmax_element.html",
            "wgPageName": "cpp/algorithm/ranges/minmax_element",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::forward_iterator I,\n    std::sentinel_for<I> S,\n    class Proj = std::identity,\n    std::indirect_strict_weak_order<\n        std::projected<I, Proj>> Comp =\n        ranges::less>\nconstexpr minmax_element_result<I>\nminmax_element(\n    I first,\n    S last,\n    Comp comp = {},\n    Proj proj = {});",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::minmax, std::ranges::minmax_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/minmax.html",
            "wgPageName": "cpp/algorithm/ranges/minmax",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    class T,\n    class Proj = std::identity,\n    std::indirect_strict_weak_order<\n        std::projected<const T*, Proj>> Comp =\n        ranges::less>\nconstexpr ranges::minmax_result<const T&>\nminmax(\n    const T& a,\n    const T& b,\n    Comp comp = {},\n    Proj proj = {});",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::mismatch, std::ranges::mismatch_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/mismatch.html",
            "wgPageName": "cpp/algorithm/ranges/mismatch",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I1,\n    std::sentinel_for<I1> S1,\n    std::input_iterator I2,\n    std::sentinel_for<I2> S2,\n    class Pred = ranges::equal_to,\n    class Proj1 = std::identity,\n    class Proj2 = std::identity>\nrequires std::indirectly_comparable<\n    I1,\n    I2,\n    Pred,\n    Proj1,\n    Proj2>\nconstexpr mismatch_result<I1, I2> mismatch(\n    I1 first1,\n    S1 last1,\n    I2 first2,\n    S2 last2,\n    Pred pred = {},\n    Proj1 proj1 = {},\n    Proj2 proj2 = {});",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::move_backward, std::ranges::move_backward_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/move_backward.html",
            "wgPageName": "cpp/algorithm/ranges/move_backward",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::bidirectional_iterator I1,\n    std::sentinel_for<I1> S1,\n    std::bidirectional_iterator I2>\nrequires std::indirectly_movable<I1, I2>\nconstexpr move_backward_result<I1, I2>\nmove_backward(I1 first, S1 last, I2 result);",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::move, std::ranges::move_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/move.html",
            "wgPageName": "cpp/algorithm/ranges/move",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I,\n    std::sentinel_for<I> S,\n    std::weakly_incrementable O>\nrequires std::indirectly_movable<I, O>\nconstexpr move_result<I, O>\nmove(I first, S last, O result);",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::next_permutation, std::ranges::next_permutation_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/next_permutation.html",
            "wgPageName": "cpp/algorithm/ranges/next_permutation",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::bidirectional_iterator I,\n    std::sentinel_for<I> S,\n    class Comp = ranges::less,\n    class Proj = std::identity>\nrequires std::sortable<I, Comp, Proj>\nconstexpr next_permutation_result<I>\nnext_permutation(\n    I first,\n    S last,\n    Comp comp = {},\n    Proj proj = {});",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::nth_element",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/nth_element.html",
            "wgPageName": "cpp/algorithm/ranges/nth_element",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::random_access_iterator I,\n    std::sentinel_for<I> S,\n    class Comp = ranges::less,\n    class Proj = std::identity>\nrequires std::sortable<I, Comp, Proj>\nconstexpr I nth_element(\n    I first,\n    I nth,\n    S last,\n    Comp comp = {},\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::partial_sort_copy, std::ranges::partial_sort_copy_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/partial_sort_copy.html",
            "wgPageName": "cpp/algorithm/ranges/partial_sort_copy",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I1,\n    std::sentinel_for<I1> S1,\n    std::random_access_iterator I2,\n    std::sentinel_for<I2> S2,\n    class Comp = ranges::less,\n    class Proj1 = std::identity,\n    class Proj2 = std::identity>\nrequires std::indirectly_copyable<I1, I2> &&\n    std::sortable<I2, Comp, Proj2> &&\n    std::indirect_strict_weak_order<\n        Comp,\n        std::projected<I1, Proj1>,\n        std::projected<I2, Proj2>>\nconstexpr partial_sort_copy_result<I1, I2>\npartial_sort_copy(\n    I1 first,\n    S1 last,\n    I2 result_first,\n    S2 result_last,\n    Comp comp = {},\n    Proj1 proj1 = {},\n    Proj2 proj2 = {});",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::partial_sort",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/partial_sort.html",
            "wgPageName": "cpp/algorithm/ranges/partial_sort",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::random_access_iterator I,\n    std::sentinel_for<I> S,\n    class Comp = ranges::less,\n    class Proj = std::identity>\nrequires std::sortable<I, Comp, Proj>\nconstexpr I partial_sort(\n    I first,\n    I middle,\n    S last,\n    Comp comp = {},\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::partition_copy, std::ranges::partition_copy_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/partition_copy.html",
            "wgPageName": "cpp/algorithm/ranges/partition_copy",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I,\n    std::sentinel_for<I> S,\n    std::weakly_incrementable O1,\n    std::weakly_incrementable O2,\n    class Proj = std::identity,\n    std::indirect_unary_predicate<\n        std::projected<I, Proj>> Pred>\nrequires std::indirectly_copyable<I, O1> &&\n    std::indirectly_copyable<I, O2>\nconstexpr partition_copy_result<I, O1, O2>\npartition_copy(\n    I first,\n    S last,\n    O1 out_true,\n    O2 out_false,\n    Pred pred,\n    Proj proj = {});",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::partition_point",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/partition_point.html",
            "wgPageName": "cpp/algorithm/ranges/partition_point",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::forward_iterator I,\n    std::sentinel_for<I> S,\n    class Proj = std::identity,\n    std::indirect_unary_predicate<\n        std::projected<I, Proj>> Pred>\nconstexpr I partition_point(\n    I first,\n    S last,\n    Pred pred,\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::partition",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/partition.html",
            "wgPageName": "cpp/algorithm/ranges/partition",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::permutable I,\n    std::sentinel_for<I> S,\n    class Proj = std::identity,\n    std::indirect_unary_predicate<\n        std::projected<I, Proj>> Pred>\nconstexpr ranges::subrange<I> partition(\n    I first,\n    S last,\n    Pred pred,\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::pop_heap",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/pop_heap.html",
            "wgPageName": "cpp/algorithm/ranges/pop_heap",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::random_access_iterator I,\n    std::sentinel_for<I> S,\n    class Comp = ranges::less,\n    class Proj = std::identity>\nrequires std::sortable<I, Comp, Proj>\nconstexpr I pop_heap(\n    I first,\n    S last,\n    Comp comp = {},\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::prev_permutation, std::ranges::prev_permutation_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/prev_permutation.html",
            "wgPageName": "cpp/algorithm/ranges/prev_permutation",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::bidirectional_iterator I,\n    std::sentinel_for<I> S,\n    class Comp = ranges::less,\n    class Proj = std::identity>\nrequires std::sortable<I, Comp, Proj>\nconstexpr prev_permutation_result<I>\nprev_permutation(\n    I first,\n    S last,\n    Comp comp = {},\n    Proj proj = {});",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::push_heap",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/push_heap.html",
            "wgPageName": "cpp/algorithm/ranges/push_heap",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::random_access_iterator I,\n    std::sentinel_for<I> S,\n    class Comp = ranges::less,\n    class Proj = std::identity>\nrequires std::sortable<I, Comp, Proj>\nconstexpr I push_heap(\n    I first,\n    S last,\n    Comp comp = {},\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::remove_copy, std::ranges::remove_copy_if, std::ranges::remove_copy_result, std::ranges::remove_copy_if_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/remove_copy.html",
            "wgPageName": "cpp/algorithm/ranges/remove_copy",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I,\n    std::sentinel_for<I> S,\n    std::weakly_incrementable O,\n    class T,\n    class Proj = std::identity>\nrequires std::indirectly_copyable<I, O> &&\n    std::indirect_binary_predicate <\n    ranges::equal_to,\n    std::projected<I, Proj>,\nconst T* > constexpr remove_copy_result<I, O>\n           remove_copy(\n               I first,\n               S last,\n               O result,\n               const T& value,\n               Proj proj = {});",
            "other_declarations": 5
        },
        {
            "title": "std::ranges::remove, std::ranges::remove_if",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/remove.html",
            "wgPageName": "cpp/algorithm/ranges/remove",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::permutable I,\n    std::sentinel_for<I> S,\n    class T,\n    class Proj = std::identity>\nrequires std::indirect_binary_predicate <\n    ranges::equal_to,\n    std::projected<I, Proj>,\nconst T* > constexpr ranges::subrange<I> remove(\n               I first,\n               S last,\n               const T& value,\n               Proj proj = {});",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::replace_copy, std::ranges::replace_copy_if, std::ranges::replace_copy_result, std::ranges::replace_copy_if_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/replace_copy.html",
            "wgPageName": "cpp/algorithm/ranges/replace_copy",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I,\n    std::sentinel_for<I> S,\n    class T1,\n    class T2,\n    std::output_iterator<const T2&> O,\n    class Proj = std::identity>\nrequires std::indirectly_copyable<I, O> &&\n    std::indirect_binary_predicate <\n    ranges::equal_to,\n    std::projected<I, Proj>,\nconst T1* > constexpr replace_copy_result<I, O>\n            replace_copy(\n                I first,\n                S last,\n                O result,\n                const T1& old_value,\n                const T2& new_value,\n                Proj proj = {});",
            "other_declarations": 5
        },
        {
            "title": "std::ranges::replace, std::ranges::replace_if",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/replace.html",
            "wgPageName": "cpp/algorithm/ranges/replace",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I,\n    std::sentinel_for<I> S,\n    class T1,\n    class T2,\n    class Proj = std::identity>\nrequires std::\n        indirectly_writable<I, const T2&> &&\n    std::indirect_binary_predicate <\n    ranges::equal_to,\n    std::projected<I, Proj>,\nconst T1* > constexpr I replace(\n                I first,\n                S last,\n                const T1& old_value,\n                const T2& new_value,\n                Proj proj = {});",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::in_found_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/return_types/in_found_result.html",
            "wgPageName": "cpp/algorithm/ranges/return_types/in_found_result",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class I>\nstruct in_found_result;"
        },
        {
            "title": "std::ranges::in_fun_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/return_types/in_fun_result.html",
            "wgPageName": "cpp/algorithm/ranges/return_types/in_fun_result",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class I, class F>\nstruct in_fun_result;"
        },
        {
            "title": "std::ranges::in_in_out_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/return_types/in_in_out_result.html",
            "wgPageName": "cpp/algorithm/ranges/return_types/in_in_out_result",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class I1, class I2, class O>\nstruct in_in_out_result;"
        },
        {
            "title": "std::ranges::in_in_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/return_types/in_in_result.html",
            "wgPageName": "cpp/algorithm/ranges/return_types/in_in_result",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class I1, class I2>\nstruct in_in_result;"
        },
        {
            "title": "std::ranges::in_out_out_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/return_types/in_out_out_result.html",
            "wgPageName": "cpp/algorithm/ranges/return_types/in_out_out_result",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class I, class O1, class O2>\nstruct in_out_out_result;"
        },
        {
            "title": "std::ranges::in_out_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/return_types/in_out_result.html",
            "wgPageName": "cpp/algorithm/ranges/return_types/in_out_result",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class I, class O>\nstruct in_out_result;"
        },
        {
            "title": "std::ranges::in_value_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/return_types/in_value_result.html",
            "wgPageName": "cpp/algorithm/ranges/return_types/in_value_result",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class I, class T>\nstruct in_value_result;"
        },
        {
            "title": "std::ranges::min_max_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/return_types/min_max_result.html",
            "wgPageName": "cpp/algorithm/ranges/return_types/min_max_result",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class T>\nstruct min_max_result;"
        },
        {
            "title": "std::ranges::out_value_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/return_types/out_value_result.html",
            "wgPageName": "cpp/algorithm/ranges/return_types/out_value_result",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class O, class T>\nstruct out_value_result;"
        },
        {
            "title": "std::ranges::reverse_copy, std::ranges::reverse_copy_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/reverse_copy.html",
            "wgPageName": "cpp/algorithm/ranges/reverse_copy",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::bidirectional_iterator I,\n    std::sentinel_for<I> S,\n    std::weakly_incrementable O>\nrequires std::indirectly_copyable<I, O>\nconstexpr reverse_copy_result<I, O>\nreverse_copy(I first, S last, O result);",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::reverse",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/reverse.html",
            "wgPageName": "cpp/algorithm/ranges/reverse",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::bidirectional_iterator I,\n    std::sentinel_for<I> S>\nrequires std::permutable<I>\nconstexpr I reverse(I first, S last);",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::rotate_copy, std::ranges::rotate_copy_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/rotate_copy.html",
            "wgPageName": "cpp/algorithm/ranges/rotate_copy",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::forward_iterator I,\n    std::sentinel_for<I> S,\n    std::weakly_incrementable O>\nrequires std::indirectly_copyable<I, O>\nconstexpr rotate_copy_result<I, O> rotate_copy(\n    I first,\n    I middle,\n    S last,\n    O result);",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::rotate",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/rotate.html",
            "wgPageName": "cpp/algorithm/ranges/rotate",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::permutable I,\n    std::sentinel_for<I> S>\nconstexpr ranges::subrange<I>\nrotate(I first, I middle, S last);",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::sample",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/sample.html",
            "wgPageName": "cpp/algorithm/ranges/sample",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I,\n    std::sentinel_for<I> S,\n    std::weakly_incrementable O,\n    class Gen>\nrequires(\n    std::forward_iterator<I> or\n    std::random_access_iterator<O>) &&\n    std::indirectly_copyable<I, O>&& std::\n        uniform_random_bit_generator<\n            std::remove_reference_t<Gen>> O\n    sample(\n        I first,\n        S last,\n        O out,\n        std::iter_difference_t<I> n,\n        Gen&& gen);",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::search_n",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/search_n.html",
            "wgPageName": "cpp/algorithm/ranges/search_n",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::forward_iterator I,\n    std::sentinel_for<I> S,\n    class T,\n    class Pred = ranges::equal_to,\n    class Proj = std::identity>\nrequires std::indirectly_comparable<\n    I,\n    const T*,\n    Pred,\n    Proj>\nconstexpr ranges::subrange<I> search_n(\n    I first,\n    S last,\n    std::iter_difference_t<I> count,\n    const T& value,\n    Pred pred = {},\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::search",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/search.html",
            "wgPageName": "cpp/algorithm/ranges/search",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::forward_iterator I1,\n    std::sentinel_for<I1> S1,\n    std::forward_iterator I2,\n    std::sentinel_for<I2> S2,\n    class Pred = ranges::equal_to,\n    class Proj1 = std::identity,\n    class Proj2 = std::identity>\nrequires std::indirectly_comparable<\n    I1,\n    I2,\n    Pred,\n    Proj1,\n    Proj2>\nconstexpr ranges::subrange<I1> search(\n    I1 first1,\n    S1 last1,\n    I2 first2,\n    S2 last2,\n    Pred pred = {},\n    Proj1 proj1 = {},\n    Proj2 proj2 = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::set_difference, std::ranges::set_difference_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/set_difference.html",
            "wgPageName": "cpp/algorithm/ranges/set_difference",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I1,\n    std::sentinel_for<I1> S1,\n    std::input_iterator I2,\n    std::sentinel_for<I2> S2,\n    std::weakly_incrementable O,\n    class Comp = ranges::less,\n    class Proj1 = std::identity,\n    class Proj2 = std::identity>\nrequires std::\n    mergeable<I1, I2, O, Comp, Proj1, Proj2>\nconstexpr set_difference_result<I1, O>\nset_difference(\n    I1 first1,\n    S1 last1,\n    I2 first2,\n    S2 last2,\n    O result,\n    Comp comp = {},\n    Proj1 proj1 = {},\n    Proj2 proj2 = {});",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::set_intersection, std::ranges::set_intersection_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/set_intersection.html",
            "wgPageName": "cpp/algorithm/ranges/set_intersection",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I1,\n    std::sentinel_for<I1> S1,\n    std::input_iterator I2,\n    std::sentinel_for<I2> S2,\n    std::weakly_incrementable O,\n    class Comp = ranges::less,\n    class Proj1 = std::identity,\n    class Proj2 = std::identity>\nrequires std::\n    mergeable<I1, I2, O, Comp, Proj1, Proj2>\nconstexpr set_intersection_result<I1, I2, O>\nset_intersection(\n    I1 first1,\n    S1 last1,\n    I2 first2,\n    S2 last2,\n    O result,\n    Comp comp = {},\n    Proj1 proj1 = {},\n    Proj2 proj2 = {});",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::set_symmetric_difference, std::ranges::set_symmetric_difference_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/set_symmetric_difference.html",
            "wgPageName": "cpp/algorithm/ranges/set_symmetric_difference",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I1,\n    std::sentinel_for<I1> S1,\n    std::input_iterator I2,\n    std::sentinel_for<I2> S2,\n    std::weakly_incrementable O,\n    class Comp = ranges::less,\n    class Proj1 = std::identity,\n    class Proj2 = std::identity>\nrequires std::\n    mergeable<I1, I2, O, Comp, Proj1, Proj2>\nconstexpr set_symmetric_difference_result<\n    I1,\n    I2,\n    O>\nset_symmetric_difference(\n    I1 first1,\n    S1 last1,\n    I2 first2,\n    S2 last2,\n    O result,\n    Comp comp = {},\n    Proj1 proj1 = {},\n    Proj2 proj2 = {});",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::set_union, std::ranges::set_union_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/set_union.html",
            "wgPageName": "cpp/algorithm/ranges/set_union",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I1,\n    std::sentinel_for<I1> S1,\n    std::input_iterator I2,\n    std::sentinel_for<I2> S2,\n    std::weakly_incrementable O,\n    class Comp = ranges::less,\n    class Proj1 = std::identity,\n    class Proj2 = std::identity>\nrequires std::\n    mergeable<I1, I2, O, Comp, Proj1, Proj2>\nconstexpr set_union_result<I1, I2, O> set_union(\n    I1 first1,\n    S1 last1,\n    I2 first2,\n    S2 last2,\n    O result,\n    Comp comp = {},\n    Proj1 proj1 = {},\n    Proj2 proj2 = {});",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::shift_left, std::ranges::shift_right",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/shift.html",
            "wgPageName": "cpp/algorithm/ranges/shift",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::permutable I,\n    std::sentinel_for<I> S>\nconstexpr ranges::subrange<I> shift_left(\n    I first,\n    S last,\n    std::iter_difference_t<I> n);",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::shuffle",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/shuffle.html",
            "wgPageName": "cpp/algorithm/ranges/shuffle",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::random_access_iterator I,\n    std::sentinel_for<I> S,\n    class Gen>\nrequires std::permutable<I> &&\n    std::uniform_random_bit_generator<\n        std::remove_reference_t<Gen>>\n        I shuffle(I first, S last, Gen&& gen);",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::sort_heap",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/sort_heap.html",
            "wgPageName": "cpp/algorithm/ranges/sort_heap",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::random_access_iterator I,\n    std::sentinel_for<I> S,\n    class Comp = ranges::less,\n    class Proj = std::identity>\nrequires std::sortable<I, Comp, Proj>\nconstexpr I sort_heap(\n    I first,\n    S last,\n    Comp comp = {},\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::sort",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/sort.html",
            "wgPageName": "cpp/algorithm/ranges/sort",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::random_access_iterator I,\n    std::sentinel_for<I> S,\n    class Comp = ranges::less,\n    class Proj = std::identity>\nrequires std::sortable<I, Comp, Proj>\nconstexpr I sort(\n    I first,\n    S last,\n    Comp comp = {},\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::stable_partition",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/stable_partition.html",
            "wgPageName": "cpp/algorithm/ranges/stable_partition",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::bidirectional_iterator I,\n    std::sentinel_for<I> S,\n    class Proj = std::identity,\n    std::indirect_unary_predicate<\n        std::projected<I, Proj>> Pred>\nrequires std::permutable<I> ranges::subrange<I>\nstable_partition(\n    I first,\n    S last,\n    Pred pred,\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::stable_sort",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/stable_sort.html",
            "wgPageName": "cpp/algorithm/ranges/stable_sort",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::random_access_iterator I,\n    std::sentinel_for<I> S,\n    class Comp = ranges::less,\n    class Proj = std::identity>\nrequires std::sortable<I, Comp, Proj> I\nstable_sort(\n    I first,\n    S last,\n    Comp comp = {},\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::starts_with",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/starts_with.html",
            "wgPageName": "cpp/algorithm/ranges/starts_with",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I1,\n    std::sentinel_for<I1> S1,\n    std::input_iterator I2,\n    std::sentinel_for<I2> S2,\n    class Pred = ranges::equal_to,\n    class Proj1 = std::identity,\n    class Proj2 = std::identity>\nrequires std::indirectly_comparable<\n    I1,\n    I2,\n    Pred,\n    Proj1,\n    Proj2>\nconstexpr bool starts_with(\n    I1 first1,\n    S1 last1,\n    I2 first2,\n    S2 last2,\n    Pred pred = {},\n    Proj1 proj1 = {},\n    Proj2 proj2 = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::swap_ranges, std::ranges::swap_ranges_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/swap_ranges.html",
            "wgPageName": "cpp/algorithm/ranges/swap_ranges",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I1,\n    std::sentinel_for<I1> S1,\n    std::input_iterator I2,\n    std::sentinel_for<I2> S2>\nrequires std::indirectly_swappable<I1, I2>\nconstexpr swap_ranges_result<I1, I2>\nswap_ranges(\n    I1 first1,\n    S1 last1,\n    I2 first2,\n    S2 last2);",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::transform, std::ranges::unary_transform_result, std::ranges::binary_transform_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/transform.html",
            "wgPageName": "cpp/algorithm/ranges/transform",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I,\n    std::sentinel_for<I> S,\n    std::weakly_incrementable O,\n    std::copy_constructible F,\n    class Proj = std::identity>\nrequires std::indirectly_writable<\n    O,\n    std::indirect_result_t<\n        F&,\n        std::projected<I, Proj>>>\nconstexpr unary_transform_result<I, O>\ntransform(\n    I first1,\n    S last1,\n    O result,\n    F op,\n    Proj proj = {});",
            "other_declarations": 5
        },
        {
            "title": "std::ranges::unique_copy, std::ranges::unique_copy_result",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/unique_copy.html",
            "wgPageName": "cpp/algorithm/ranges/unique_copy",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I,\n    std::sentinel_for<I> S,\n    std::weakly_incrementable O,\n    class Proj = std::identity,\n    std::indirect_equivalence_relation<\n        std::projected<I, Proj>> C =\n        ranges::equal_to>\nrequires std::indirectly_copyable<I, O> &&(\n    std::forward_iterator<I> ||\n    (std::input_iterator<O> &&\n     std::same_as<\n         std::iter_value_t<I>,\n         std::iter_value_t<O>>) ||\n    std::indirectly_copyable_storable<\n        I,\n        O>)constexpr unique_copy_result<I, O> unique_copy(I first, S last, O result, C comp = {}, Proj proj = {});",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::unique",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/unique.html",
            "wgPageName": "cpp/algorithm/ranges/unique",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::permutable I,\n    std::sentinel_for<I> S,\n    class Proj = std::identity,\n    std::indirect_equivalence_relation<\n        std::projected<I, Proj>> C =\n        ranges::equal_to>\nconstexpr ranges::subrange<I> unique(\n    I first,\n    S last,\n    C comp = {},\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::upper_bound",
            "path": "en.cppreference.com/w/cpp/algorithm/ranges/upper_bound.html",
            "wgPageName": "cpp/algorithm/ranges/upper_bound",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    std::forward_iterator I,\n    std::sentinel_for<I> S,\n    class T,\n    class Proj = std::identity,\n    std::indirect_strict_weak_order<\n        const T*,\n        std::projected<I, Proj>> Comp =\n        ranges::less>\nconstexpr I upper_bound(\n    I first,\n    S last,\n    const T& value,\n    Comp comp = {},\n    Proj proj = {});",
            "other_declarations": 1
        },
        {
            "title": "std::reduce",
            "path": "en.cppreference.com/w/cpp/algorithm/reduce.html",
            "wgPageName": "cpp/algorithm/reduce",
            "headers": [
                "<numeric>"
            ],
            "sample_declaration": "template<class InputIt>\ntypename std::iterator_traits<\n    InputIt>::value_type\nreduce(InputIt first, InputIt last);",
            "other_declarations": 8
        },
        {
            "title": "std::remove_copy, std::remove_copy_if",
            "path": "en.cppreference.com/w/cpp/algorithm/remove_copy.html",
            "wgPageName": "cpp/algorithm/remove_copy",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class InputIt, class OutputIt, class T>\nOutputIt remove_copy(\n    InputIt first,\n    InputIt last,\n    OutputIt d_first,\n    const T& value);",
            "other_declarations": 5
        },
        {
            "title": "std::remove, std::remove_if",
            "path": "en.cppreference.com/w/cpp/algorithm/remove.html",
            "wgPageName": "cpp/algorithm/remove",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt, class T>\nForwardIt remove(\n    ForwardIt first,\n    ForwardIt last,\n    const T& value);",
            "other_declarations": 5
        },
        {
            "title": "std::replace_copy, std::replace_copy_if",
            "path": "en.cppreference.com/w/cpp/algorithm/replace_copy_if.html",
            "wgPageName": "cpp/algorithm/replace_copy",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class InputIt, class OutputIt, class T>\nOutputIt replace_copy(\n    InputIt first,\n    InputIt last,\n    OutputIt d_first,\n    const T& old_value,\n    const T& new_value);",
            "other_declarations": 5
        },
        {
            "title": "std::replace_copy, std::replace_copy_if",
            "path": "en.cppreference.com/w/cpp/algorithm/replace_copy.html",
            "wgPageName": "cpp/algorithm/replace_copy",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class InputIt, class OutputIt, class T>\nOutputIt replace_copy(\n    InputIt first,\n    InputIt last,\n    OutputIt d_first,\n    const T& old_value,\n    const T& new_value);",
            "other_declarations": 5
        },
        {
            "title": "std::replace, std::replace_if",
            "path": "en.cppreference.com/w/cpp/algorithm/replace.html",
            "wgPageName": "cpp/algorithm/replace",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt, class T>\nvoid replace(\n    ForwardIt first,\n    ForwardIt last,\n    const T& old_value,\n    const T& new_value);",
            "other_declarations": 5
        },
        {
            "title": "std::reverse_copy",
            "path": "en.cppreference.com/w/cpp/algorithm/reverse_copy.html",
            "wgPageName": "cpp/algorithm/reverse_copy",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class BidirIt, class OutputIt>\nOutputIt reverse_copy(\n    BidirIt first,\n    BidirIt last,\n    OutputIt d_first);",
            "other_declarations": 2
        },
        {
            "title": "std::reverse",
            "path": "en.cppreference.com/w/cpp/algorithm/reverse.html",
            "wgPageName": "cpp/algorithm/reverse",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class BidirIt>\nvoid reverse(BidirIt first, BidirIt last);",
            "other_declarations": 2
        },
        {
            "title": "std::rotate_copy",
            "path": "en.cppreference.com/w/cpp/algorithm/rotate_copy.html",
            "wgPageName": "cpp/algorithm/rotate_copy",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt, class OutputIt>\nOutputIt rotate_copy(\n    ForwardIt first,\n    ForwardIt n_first,\n    ForwardIt last,\n    OutputIt d_first);",
            "other_declarations": 2
        },
        {
            "title": "std::rotate",
            "path": "en.cppreference.com/w/cpp/algorithm/rotate.html",
            "wgPageName": "cpp/algorithm/rotate",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt>\nvoid rotate(\n    ForwardIt first,\n    ForwardIt n_first,\n    ForwardIt last);",
            "other_declarations": 3
        },
        {
            "title": "std::sample",
            "path": "en.cppreference.com/w/cpp/algorithm/sample.html",
            "wgPageName": "cpp/algorithm/sample",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    class PopulationIterator,\n    class SampleIterator,\n    class Distance,\n    class URBG>\nSampleIterator sample(\n    PopulationIterator first,\n    PopulationIterator last,\n    SampleIterator out,\n    Distance n,\n    URBG&& g);"
        },
        {
            "title": "std::search_n",
            "path": "en.cppreference.com/w/cpp/algorithm/search_n.html",
            "wgPageName": "cpp/algorithm/search_n",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt, class Size, class T>\nForwardIt search_n(\n    ForwardIt first,\n    ForwardIt last,\n    Size count,\n    const T& value);",
            "other_declarations": 5
        },
        {
            "title": "std::search",
            "path": "en.cppreference.com/w/cpp/algorithm/search.html",
            "wgPageName": "cpp/algorithm/search",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt1, class ForwardIt2>\nForwardIt1 search(\n    ForwardIt1 first,\n    ForwardIt1 last,\n    ForwardIt2 s_first,\n    ForwardIt2 s_last);",
            "other_declarations": 7
        },
        {
            "title": "std::set_difference",
            "path": "en.cppreference.com/w/cpp/algorithm/set_difference.html",
            "wgPageName": "cpp/algorithm/set_difference",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    class InputIt1,\n    class InputIt2,\n    class OutputIt>\nOutputIt set_difference(\n    InputIt1 first1,\n    InputIt1 last1,\n    InputIt2 first2,\n    InputIt2 last2,\n    OutputIt d_first);",
            "other_declarations": 5
        },
        {
            "title": "std::set_intersection",
            "path": "en.cppreference.com/w/cpp/algorithm/set_intersection.html",
            "wgPageName": "cpp/algorithm/set_intersection",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    class InputIt1,\n    class InputIt2,\n    class OutputIt>\nOutputIt set_intersection(\n    InputIt1 first1,\n    InputIt1 last1,\n    InputIt2 first2,\n    InputIt2 last2,\n    OutputIt d_first);",
            "other_declarations": 5
        },
        {
            "title": "std::set_symmetric_difference",
            "path": "en.cppreference.com/w/cpp/algorithm/set_symmetric_difference.html",
            "wgPageName": "cpp/algorithm/set_symmetric_difference",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    class InputIt1,\n    class InputIt2,\n    class OutputIt>\nOutputIt set_symmetric_difference(\n    InputIt1 first1,\n    InputIt1 last1,\n    InputIt2 first2,\n    InputIt2 last2,\n    OutputIt d_first);",
            "other_declarations": 5
        },
        {
            "title": "std::set_union",
            "path": "en.cppreference.com/w/cpp/algorithm/set_union.html",
            "wgPageName": "cpp/algorithm/set_union",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    class InputIt1,\n    class InputIt2,\n    class OutputIt>\nOutputIt set_union(\n    InputIt1 first1,\n    InputIt1 last1,\n    InputIt2 first2,\n    InputIt2 last2,\n    OutputIt d_first);",
            "other_declarations": 5
        },
        {
            "title": "std::shift_left, std::shift_right",
            "path": "en.cppreference.com/w/cpp/algorithm/shift.html",
            "wgPageName": "cpp/algorithm/shift",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt>\nconstexpr ForwardIt shift_left(\n    ForwardIt first,\n    ForwardIt last,\n    typename std::iterator_traits<\n        ForwardIt>::difference_type n);",
            "other_declarations": 3
        },
        {
            "title": "std::sort_heap",
            "path": "en.cppreference.com/w/cpp/algorithm/sort_heap.html",
            "wgPageName": "cpp/algorithm/sort_heap",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class RandomIt>\nvoid sort_heap(RandomIt first, RandomIt last);",
            "other_declarations": 3
        },
        {
            "title": "std::sort",
            "path": "en.cppreference.com/w/cpp/algorithm/sort.html",
            "wgPageName": "cpp/algorithm/sort",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class RandomIt>\nvoid sort(RandomIt first, RandomIt last);",
            "other_declarations": 5
        },
        {
            "title": "std::stable_partition",
            "path": "en.cppreference.com/w/cpp/algorithm/stable_partition.html",
            "wgPageName": "cpp/algorithm/stable_partition",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class BidirIt, class UnaryPredicate>\nBidirIt stable_partition(\n    BidirIt first,\n    BidirIt last,\n    UnaryPredicate p);",
            "other_declarations": 1
        },
        {
            "title": "std::stable_sort",
            "path": "en.cppreference.com/w/cpp/algorithm/stable_sort.html",
            "wgPageName": "cpp/algorithm/stable_sort",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class RandomIt>\nvoid stable_sort(RandomIt first, RandomIt last);",
            "other_declarations": 3
        },
        {
            "title": "std::swap_ranges",
            "path": "en.cppreference.com/w/cpp/algorithm/swap_ranges.html",
            "wgPageName": "cpp/algorithm/swap_ranges",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt1, class ForwardIt2>\nForwardIt2 swap_ranges(\n    ForwardIt1 first1,\n    ForwardIt1 last1,\n    ForwardIt2 first2);",
            "other_declarations": 2
        },
        {
            "title": "std::swap",
            "path": "en.cppreference.com/w/cpp/algorithm/swap.html",
            "wgPageName": "cpp/algorithm/swap",
            "headers": [
                "<algorithm>",
                "<utility>",
                "<string_view>"
            ],
            "sample_declaration": "template<class T>\nvoid swap(T& a, T& b);",
            "other_declarations": 4
        },
        {
            "title": "std::transform_exclusive_scan",
            "path": "en.cppreference.com/w/cpp/algorithm/transform_exclusive_scan.html",
            "wgPageName": "cpp/algorithm/transform_exclusive_scan",
            "headers": [
                "<numeric>"
            ],
            "sample_declaration": "template<\n    class InputIt,\n    class OutputIt,\n    class T,\n    class BinaryOperation,\n    class UnaryOperation>\nOutputIt transform_exclusive_scan(\n    InputIt first,\n    InputIt last,\n    OutputIt d_first,\n    T init,\n    BinaryOperation binary_op,\n    UnaryOperation unary_op);",
            "other_declarations": 2
        },
        {
            "title": "std::transform_inclusive_scan",
            "path": "en.cppreference.com/w/cpp/algorithm/transform_inclusive_scan.html",
            "wgPageName": "cpp/algorithm/transform_inclusive_scan",
            "headers": [
                "<numeric>"
            ],
            "sample_declaration": "template<\n    class InputIt,\n    class OutputIt,\n    class BinaryOperation,\n    class UnaryOperation>\nOutputIt transform_inclusive_scan(\n    InputIt first,\n    InputIt last,\n    OutputIt d_first,\n    BinaryOperation binary_op,\n    UnaryOperation unary_op);",
            "other_declarations": 5
        },
        {
            "title": "std::transform_reduce",
            "path": "en.cppreference.com/w/cpp/algorithm/transform_reduce.html",
            "wgPageName": "cpp/algorithm/transform_reduce",
            "headers": [
                "<numeric>"
            ],
            "sample_declaration": "template<\n    class InputIt1,\n    class InputIt2,\n    class T>\nT transform_reduce(\n    InputIt1 first1,\n    InputIt1 last1,\n    InputIt2 first2,\n    T init);",
            "other_declarations": 8
        },
        {
            "title": "std::transform",
            "path": "en.cppreference.com/w/cpp/algorithm/transform.html",
            "wgPageName": "cpp/algorithm/transform",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<\n    class InputIt,\n    class OutputIt,\n    class UnaryOperation>\nOutputIt transform(\n    InputIt first1,\n    InputIt last1,\n    OutputIt d_first,\n    UnaryOperation unary_op);",
            "other_declarations": 5
        },
        {
            "title": "std::unique_copy",
            "path": "en.cppreference.com/w/cpp/algorithm/unique_copy.html",
            "wgPageName": "cpp/algorithm/unique_copy",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class InputIt, class OutputIt>\nOutputIt unique_copy(\n    InputIt first,\n    InputIt last,\n    OutputIt d_first);",
            "other_declarations": 5
        },
        {
            "title": "std::unique",
            "path": "en.cppreference.com/w/cpp/algorithm/unique.html",
            "wgPageName": "cpp/algorithm/unique",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt>\nForwardIt unique(\n    ForwardIt first,\n    ForwardIt last);",
            "other_declarations": 5
        },
        {
            "title": "std::upper_bound",
            "path": "en.cppreference.com/w/cpp/algorithm/upper_bound.html",
            "wgPageName": "cpp/algorithm/upper_bound",
            "headers": [
                "<algorithm>"
            ],
            "sample_declaration": "template<class ForwardIt, class T>\nForwardIt upper_bound(\n    ForwardIt first,\n    ForwardIt last,\n    const T& value);",
            "other_declarations": 3
        },
        {
            "title": "Atomic operations library",
            "path": "en.cppreference.com/w/cpp/atomic.html",
            "wgPageName": "cpp/atomic"
        },
        {
            "title": "std::atomic_compare_exchange_weak, std::atomic_compare_exchange_strong, std::atomic_compare_exchange_weak_explicit, std::atomic_compare_exchange_strong_explicit",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_compare_exchange.html",
            "wgPageName": "cpp/atomic/atomic_compare_exchange",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "template<class T>\nbool atomic_compare_exchange_weak(\n    std::atomic<T>* obj,\n    typename std::atomic<T>::value_type*\n        expected,\n    typename std::atomic<T>::value_type\n        desired) noexcept;",
            "other_declarations": 7
        },
        {
            "title": "std::atomic_exchange, std::atomic_exchange_explicit",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_exchange.html",
            "wgPageName": "cpp/atomic/atomic_exchange",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "template<class T>\nT atomic_exchange(\n    std::atomic<T>* obj,\n    typename std::atomic<T>::value_type\n        desr) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::atomic_fetch_add, std::atomic_fetch_add_explicit",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_fetch_add.html",
            "wgPageName": "cpp/atomic/atomic_fetch_add",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "template<class T>\nT atomic_fetch_add(\n    std::atomic<T>* obj,\n    typename std::atomic<T>::difference_type\n        arg) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::atomic_fetch_and, std::atomic_fetch_and_explicit",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_fetch_and.html",
            "wgPageName": "cpp/atomic/atomic_fetch_and",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "template<class T>\nT atomic_fetch_and(\n    std::atomic<T>* obj,\n    typename std::atomic<T>::value_type\n        arg) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::atomic_fetch_or, std::atomic_fetch_or_explicit",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_fetch_or.html",
            "wgPageName": "cpp/atomic/atomic_fetch_or",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "template<class T>\nT atomic_fetch_or(\n    std::atomic<T>* obj,\n    typename std::atomic<T>::value_type\n        arg) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::atomic_fetch_sub, std::atomic_fetch_sub_explicit",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_fetch_sub.html",
            "wgPageName": "cpp/atomic/atomic_fetch_sub",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "template<class T>\nT atomic_fetch_sub(\n    std::atomic<T>* obj,\n    typename std::atomic<T>::difference_type\n        arg) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::atomic_fetch_xor, std::atomic_fetch_xor_explicit",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_fetch_xor.html",
            "wgPageName": "cpp/atomic/atomic_fetch_xor",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "template<class T>\nT atomic_fetch_xor(\n    std::atomic<T>* obj,\n    typename std::atomic<T>::value_type\n        arg) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::atomic_flag_clear, std::atomic_flag_clear_explicit",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_flag_clear.html",
            "wgPageName": "cpp/atomic/atomic_flag_clear",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "void atomic_flag_clear(\n    volatile std::atomic_flag* p) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "ATOMIC_FLAG_INIT",
            "path": "en.cppreference.com/w/cpp/atomic/ATOMIC_FLAG_INIT.html",
            "wgPageName": "cpp/atomic/ATOMIC_FLAG_INIT",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "#define ATOMIC_FLAG_INIT /* implementation-defined \\\n                          */"
        },
        {
            "title": "std::atomic_flag_notify_all",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_flag_notify_all.html",
            "wgPageName": "cpp/atomic/atomic_flag_notify_all",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "void atomic_flag_notify_all(\n    std::atomic_flag* object) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic_flag_notify_one",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_flag_notify_one.html",
            "wgPageName": "cpp/atomic/atomic_flag_notify_one",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "void atomic_flag_notify_one(\n    std::atomic_flag* object) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic_flag_test_and_set, std::atomic_flag_test_and_set_explicit",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_flag_test_and_set.html",
            "wgPageName": "cpp/atomic/atomic_flag_test_and_set",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "bool atomic_flag_test_and_set(\n    volatile std::atomic_flag* p) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::atomic_flag_test, std::atomic_flag_test_explicit",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_flag_test.html",
            "wgPageName": "cpp/atomic/atomic_flag_test",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "bool atomic_flag_test(\n    const volatile std::atomic_flag*\n        object) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::atomic_flag_wait, std::atomic_flag_wait_explicit",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_flag_wait.html",
            "wgPageName": "cpp/atomic/atomic_flag_wait",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "void atomic_flag_wait(\n    const atomic_flag* object,\n    bool old) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::atomic_flag",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_flag.html",
            "wgPageName": "cpp/atomic/atomic_flag",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "class atomic_flag;"
        },
        {
            "title": "std::atomic_flag::atomic_flag",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_flag/atomic_flag.html",
            "wgPageName": "cpp/atomic/atomic_flag/atomic_flag",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "atomic_flag() noexcept = default;",
            "other_declarations": 2
        },
        {
            "title": "std::atomic_flag::clear",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_flag/clear.html",
            "wgPageName": "cpp/atomic/atomic_flag/clear",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "void clear(\n    std::memory_order order = std::\n        memory_order_seq_cst) volatile noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic_flag::notify_all",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_flag/notify_all.html",
            "wgPageName": "cpp/atomic/atomic_flag/notify_all",
            "sample_declaration": "void notify_all() noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic_flag::notify_one",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_flag/notify_one.html",
            "wgPageName": "cpp/atomic/atomic_flag/notify_one",
            "sample_declaration": "void notify_one() noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic_flag::operator=",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_flag/operator=.html",
            "wgPageName": "cpp/atomic/atomic_flag/operator=",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "atomic_flag& operator=(const atomic_flag&) =\n    delete;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic_flag::test_and_set",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_flag/test_and_set.html",
            "wgPageName": "cpp/atomic/atomic_flag/test_and_set",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "bool test_and_set(\n    std::memory_order order = std::\n        memory_order_seq_cst) volatile noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic_flag::test",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_flag/test.html",
            "wgPageName": "cpp/atomic/atomic_flag/test",
            "sample_declaration": "bool test(\n    std::memory_order order =\n        std::memory_order::seq_cst) const\n    volatile noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic_flag::wait",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_flag/wait.html",
            "wgPageName": "cpp/atomic/atomic_flag/wait",
            "sample_declaration": "void wait(\n    bool old,\n    std::memory_order order =\n        std::memory_order::seq_cst)\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic_init",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_init.html",
            "wgPageName": "cpp/atomic/atomic_init",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "template<class T>\nvoid atomic_init(\n    std::atomic<T>* obj,\n    typename std::atomic<T>::value_type\n        desired) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic_is_lock_free, ATOMIC_xxx_LOCK_FREE",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_is_lock_free.html",
            "wgPageName": "cpp/atomic/atomic_is_lock_free",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "template<class T>\nbool atomic_is_lock_free(\n    const volatile std::atomic<T>*\n        obj) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::atomic_load, std::atomic_load_explicit",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_load.html",
            "wgPageName": "cpp/atomic/atomic_load",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "template<class T>\nT atomic_load(\n    const std::atomic<T>* obj) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::atomic_notify_all",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_notify_all.html",
            "wgPageName": "cpp/atomic/atomic_notify_all",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "template<class T>\nvoid atomic_notify_all(std::atomic<T>* object);",
            "other_declarations": 1
        },
        {
            "title": "std::atomic_notify_one",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_notify_one.html",
            "wgPageName": "cpp/atomic/atomic_notify_one",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "template<class T>\nvoid atomic_notify_one(std::atomic<T>* object);",
            "other_declarations": 1
        },
        {
            "title": "std::atomic_ref",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_ref.html",
            "wgPageName": "cpp/atomic/atomic_ref",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "template<class T>\nstruct atomic_ref;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic_ref<T>::atomic_ref",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_ref/atomic_ref.html",
            "wgPageName": "cpp/atomic/atomic_ref/atomic_ref",
            "sample_declaration": "explicit atomic_ref(T& obj);",
            "other_declarations": 1
        },
        {
            "title": "std::atomic_ref<T>::compare_exchange_weak, std::atomic_ref<T>::compare_exchange_strong",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_ref/compare_exchange.html",
            "wgPageName": "cpp/atomic/atomic_ref/compare_exchange",
            "sample_declaration": "bool compare_exchange_weak(\n    T& expected,\n    T desired,\n    std::memory_order success,\n    std::memory_order failure) const noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::atomic_ref<T>::exchange",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_ref/exchange.html",
            "wgPageName": "cpp/atomic/atomic_ref/exchange",
            "sample_declaration": "T exchange(\n    T desired,\n    std::memory_order order =\n        std::memory_order_seq_cst)\n    const noexcept;"
        },
        {
            "title": "std::atomic_ref<T>::fetch_add",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_ref/fetch_add.html",
            "wgPageName": "cpp/atomic/atomic_ref/fetch_add",
            "sample_declaration": "T fetch_add(\n    T arg,\n    std::memory_order order =\n        std::memory_order_seq_cst)\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic_ref<T>::fetch_and",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_ref/fetch_and.html",
            "wgPageName": "cpp/atomic/atomic_ref/fetch_and",
            "sample_declaration": "T fetch_and(\n    T arg,\n    std::memory_order order =\n        std::memory_order_seq_cst)\n    const noexcept;"
        },
        {
            "title": "std::atomic_ref<T>::fetch_or",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_ref/fetch_or.html",
            "wgPageName": "cpp/atomic/atomic_ref/fetch_or",
            "sample_declaration": "T fetch_or(\n    T arg,\n    std::memory_order order =\n        std::memory_order_seq_cst)\n    const noexcept;"
        },
        {
            "title": "std::atomic_ref<T>::fetch_sub",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_ref/fetch_sub.html",
            "wgPageName": "cpp/atomic/atomic_ref/fetch_sub",
            "sample_declaration": "T fetch_sub(\n    T arg,\n    std::memory_order order =\n        std::memory_order_seq_cst)\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic_ref<T>::fetch_xor",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_ref/fetch_xor.html",
            "wgPageName": "cpp/atomic/atomic_ref/fetch_xor",
            "sample_declaration": "T fetch_xor(\n    T arg,\n    std::memory_order order =\n        std::memory_order_seq_cst)\n    const noexcept;"
        },
        {
            "title": "std::atomic_ref<T>::is_always_lock_free",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_ref/is_always_lock_free.html",
            "wgPageName": "cpp/atomic/atomic_ref/is_always_lock_free",
            "sample_declaration": "static constexpr bool is_always_lock_free =\n    /*implementation-defined*/;"
        },
        {
            "title": "std::atomic_ref<T>::is_lock_free",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_ref/is_lock_free.html",
            "wgPageName": "cpp/atomic/atomic_ref/is_lock_free",
            "sample_declaration": "bool is_lock_free() const noexcept;"
        },
        {
            "title": "std::atomic_ref<T>::load",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_ref/load.html",
            "wgPageName": "cpp/atomic/atomic_ref/load",
            "sample_declaration": "T load(\n    std::memory_order order =\n        std::memory_order_seq_cst)\n    const noexcept;"
        },
        {
            "title": "std::atomic_ref<T>::notify_all",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_ref/notify_all.html",
            "wgPageName": "cpp/atomic/atomic_ref/notify_all",
            "sample_declaration": "void notify_all() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic_ref<T>::notify_one",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_ref/notify_one.html",
            "wgPageName": "cpp/atomic/atomic_ref/notify_one",
            "sample_declaration": "void notify_one() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic_ref<T>::operator++,++(int),--,--(int)",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_ref/operator_arith.html",
            "wgPageName": "cpp/atomic/atomic_ref/operator_arith",
            "sample_declaration": "value_type operator++() const noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::atomic_ref<T>::operator+=,-=,&=,|=,^=",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_ref/operator_arith2.html",
            "wgPageName": "cpp/atomic/atomic_ref/operator_arith2",
            "sample_declaration": "T operator+=(T arg) const noexcept;",
            "other_declarations": 6
        },
        {
            "title": "std::atomic_ref<T>::operator T",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_ref/operator_T.html",
            "wgPageName": "cpp/atomic/atomic_ref/operator_T",
            "sample_declaration": "operator T() const noexcept;"
        },
        {
            "title": "std::atomic_ref<T>::operator=",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_ref/operator=.html",
            "wgPageName": "cpp/atomic/atomic_ref/operator=",
            "sample_declaration": "T operator=(T desired) const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic_ref<T>::required_alignment",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_ref/required_alignment.html",
            "wgPageName": "cpp/atomic/atomic_ref/required_alignment",
            "sample_declaration": "static constexpr std::size_t\n    required_alignment =\n    /*implementation-defined*/;"
        },
        {
            "title": "std::atomic_ref<T>::store",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_ref/store.html",
            "wgPageName": "cpp/atomic/atomic_ref/store",
            "sample_declaration": "void store(\n    T desired,\n    std::memory_order order =\n        std::memory_order_seq_cst)\n    const noexcept;"
        },
        {
            "title": "std::atomic_ref<T>::wait",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_ref/wait.html",
            "wgPageName": "cpp/atomic/atomic_ref/wait",
            "sample_declaration": "void wait(\n    T old,\n    std::memory_order order =\n        std::memory_order::seq_cst)\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic_signal_fence",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_signal_fence.html",
            "wgPageName": "cpp/atomic/atomic_signal_fence",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "extern \"C\" void atomic_signal_fence(\n    std::memory_order order) noexcept;"
        },
        {
            "title": "std::atomic_store, std::atomic_store_explicit",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_store.html",
            "wgPageName": "cpp/atomic/atomic_store",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "template<class T>\nvoid atomic_store(\n    std::atomic<T>* obj,\n    typename std::atomic<T>::value_type\n        desr) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::atomic_thread_fence",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_thread_fence.html",
            "wgPageName": "cpp/atomic/atomic_thread_fence",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "extern \"C\" void atomic_thread_fence(\n    std::memory_order order) noexcept;"
        },
        {
            "title": "ATOMIC_VAR_INIT",
            "path": "en.cppreference.com/w/cpp/atomic/ATOMIC_VAR_INIT.html",
            "wgPageName": "cpp/atomic/ATOMIC_VAR_INIT",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "#define ATOMIC_VAR_INIT( \\\n    value) /* implementation-defined */"
        },
        {
            "title": "std::atomic_wait, std::atomic_wait_explicit",
            "path": "en.cppreference.com/w/cpp/atomic/atomic_wait.html",
            "wgPageName": "cpp/atomic/atomic_wait",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "template<class T>\nvoid atomic_wait(\n    const std::atomic<T>* object,\n    typename std::atomic<T>::value_type old);",
            "other_declarations": 3
        },
        {
            "title": "std::atomic",
            "path": "en.cppreference.com/w/cpp/atomic/atomic.html",
            "wgPageName": "cpp/atomic/atomic",
            "headers": [
                "<atomic>",
                "<memory>",
                "<stdatomic.h>"
            ],
            "sample_declaration": "template<class T>\nstruct atomic;",
            "other_declarations": 4
        },
        {
            "title": "std::atomic<T>::atomic",
            "path": "en.cppreference.com/w/cpp/atomic/atomic/atomic.html",
            "wgPageName": "cpp/atomic/atomic/atomic",
            "sample_declaration": "atomic() noexcept = default;",
            "other_declarations": 3
        },
        {
            "title": "std::atomic<T>::compare_exchange_weak, std::atomic<T>::compare_exchange_strong",
            "path": "en.cppreference.com/w/cpp/atomic/atomic/compare_exchange.html",
            "wgPageName": "cpp/atomic/atomic/compare_exchange",
            "sample_declaration": "bool compare_exchange_weak(\n    T& expected,\n    T desired,\n    std::memory_order success,\n    std::memory_order failure) noexcept;",
            "other_declarations": 7
        },
        {
            "title": "std::atomic<T>::exchange",
            "path": "en.cppreference.com/w/cpp/atomic/atomic/exchange.html",
            "wgPageName": "cpp/atomic/atomic/exchange",
            "sample_declaration": "T exchange(\n    T desired,\n    std::memory_order order =\n        std::memory_order_seq_cst) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic<T>::fetch_add",
            "path": "en.cppreference.com/w/cpp/atomic/atomic/fetch_add.html",
            "wgPageName": "cpp/atomic/atomic/fetch_add",
            "sample_declaration": "T fetch_add(\n    T arg,\n    std::memory_order order =\n        std::memory_order_seq_cst) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::atomic<T>::fetch_and",
            "path": "en.cppreference.com/w/cpp/atomic/atomic/fetch_and.html",
            "wgPageName": "cpp/atomic/atomic/fetch_and",
            "sample_declaration": "T fetch_and(\n    T arg,\n    std::memory_order order =\n        std::memory_order_seq_cst) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic<T>::fetch_or",
            "path": "en.cppreference.com/w/cpp/atomic/atomic/fetch_or.html",
            "wgPageName": "cpp/atomic/atomic/fetch_or",
            "sample_declaration": "T fetch_or(\n    T arg,\n    std::memory_order order =\n        std::memory_order_seq_cst) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic<T>::fetch_sub",
            "path": "en.cppreference.com/w/cpp/atomic/atomic/fetch_sub.html",
            "wgPageName": "cpp/atomic/atomic/fetch_sub",
            "sample_declaration": "T fetch_sub(\n    T arg,\n    std::memory_order order =\n        std::memory_order_seq_cst) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::atomic<T>::fetch_xor",
            "path": "en.cppreference.com/w/cpp/atomic/atomic/fetch_xor.html",
            "wgPageName": "cpp/atomic/atomic/fetch_xor",
            "sample_declaration": "T fetch_xor(\n    T arg,\n    std::memory_order order =\n        std::memory_order_seq_cst) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic<T>::is_always_lock_free",
            "path": "en.cppreference.com/w/cpp/atomic/atomic/is_always_lock_free.html",
            "wgPageName": "cpp/atomic/atomic/is_always_lock_free",
            "sample_declaration": "static constexpr bool is_always_lock_free =\n    /*implementation-defined*/;"
        },
        {
            "title": "std::atomic<T>::is_lock_free",
            "path": "en.cppreference.com/w/cpp/atomic/atomic/is_lock_free.html",
            "wgPageName": "cpp/atomic/atomic/is_lock_free",
            "sample_declaration": "bool is_lock_free() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic<T>::load",
            "path": "en.cppreference.com/w/cpp/atomic/atomic/load.html",
            "wgPageName": "cpp/atomic/atomic/load",
            "sample_declaration": "T load(\n    std::memory_order order =\n        std::memory_order_seq_cst)\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic<T>::notify_all",
            "path": "en.cppreference.com/w/cpp/atomic/atomic/notify_all.html",
            "wgPageName": "cpp/atomic/atomic/notify_all",
            "sample_declaration": "void notify_all() noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic<T>::notify_one",
            "path": "en.cppreference.com/w/cpp/atomic/atomic/notify_one.html",
            "wgPageName": "cpp/atomic/atomic/notify_one",
            "sample_declaration": "void notify_one() noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic<T>::operator++,++(int),--,--(int)",
            "path": "en.cppreference.com/w/cpp/atomic/atomic/operator_arith.html",
            "wgPageName": "cpp/atomic/atomic/operator_arith",
            "sample_declaration": "T operator++() noexcept;\nT operator++() volatile noexcept;",
            "other_declarations": 7
        },
        {
            "title": "std::atomic<T>::operator+=,-=,&=,|=,^=",
            "path": "en.cppreference.com/w/cpp/atomic/atomic/operator_arith2.html",
            "wgPageName": "cpp/atomic/atomic/operator_arith2",
            "sample_declaration": "T operator+=(T arg) noexcept;",
            "other_declarations": 13
        },
        {
            "title": "std::atomic<T>::operator T",
            "path": "en.cppreference.com/w/cpp/atomic/atomic/operator_T.html",
            "wgPageName": "cpp/atomic/atomic/operator_T",
            "sample_declaration": "operator T() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic<T>::operator=",
            "path": "en.cppreference.com/w/cpp/atomic/atomic/operator=.html",
            "wgPageName": "cpp/atomic/atomic/operator=",
            "sample_declaration": "T operator=(T desired) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::atomic<T>::store",
            "path": "en.cppreference.com/w/cpp/atomic/atomic/store.html",
            "wgPageName": "cpp/atomic/atomic/store",
            "sample_declaration": "void store(\n    T desired,\n    std::memory_order order =\n        std::memory_order_seq_cst) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atomic<T>::wait",
            "path": "en.cppreference.com/w/cpp/atomic/atomic/wait.html",
            "wgPageName": "cpp/atomic/atomic/wait",
            "sample_declaration": "void wait(\n    T old,\n    std::memory_order order =\n        std::memory_order::seq_cst)\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::kill_dependency",
            "path": "en.cppreference.com/w/cpp/atomic/kill_dependency.html",
            "wgPageName": "cpp/atomic/kill_dependency",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "template<class T>\nT kill_dependency(T y) noexcept;"
        },
        {
            "title": "std::memory_order",
            "path": "en.cppreference.com/w/cpp/atomic/memory_order.html",
            "wgPageName": "cpp/atomic/memory_order",
            "headers": [
                "<atomic>"
            ],
            "sample_declaration": "typedef enum memory_order {\n  memory_order_relaxed,\n  memory_order_consume,\n  memory_order_acquire,\n  memory_order_release,\n  memory_order_acq_rel,\n  memory_order_seq_cst\n} memory_order;",
            "other_declarations": 1
        },
        {
            "title": "Date and time utilities",
            "path": "en.cppreference.com/w/cpp/chrono.html",
            "wgPageName": "cpp/chrono"
        },
        {
            "title": "std::chrono::ambiguous_local_time",
            "path": "en.cppreference.com/w/cpp/chrono/ambiguous_local_time.html",
            "wgPageName": "cpp/chrono/ambiguous_local_time",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class ambiguous_local_time;"
        },
        {
            "title": "C Date and time utilities",
            "path": "en.cppreference.com/w/cpp/chrono/c.html",
            "wgPageName": "cpp/chrono/c"
        },
        {
            "title": "std::asctime",
            "path": "en.cppreference.com/w/cpp/chrono/c/asctime.html",
            "wgPageName": "cpp/chrono/c/asctime",
            "headers": [
                "<ctime>"
            ],
            "sample_declaration": "char* asctime(const std::tm* time_ptr);"
        },
        {
            "title": "std::clock_t",
            "path": "en.cppreference.com/w/cpp/chrono/c/clock_t.html",
            "wgPageName": "cpp/chrono/c/clock_t",
            "headers": [
                "<ctime>"
            ],
            "sample_declaration": "typedef /* unspecified */ clock_t;"
        },
        {
            "title": "std::clock",
            "path": "en.cppreference.com/w/cpp/chrono/c/clock.html",
            "wgPageName": "cpp/chrono/c/clock",
            "headers": [
                "<ctime>"
            ],
            "sample_declaration": "std::clock_t clock();"
        },
        {
            "title": "CLOCKS_PER_SEC",
            "path": "en.cppreference.com/w/cpp/chrono/c/CLOCKS_PER_SEC.html",
            "wgPageName": "cpp/chrono/c/CLOCKS_PER_SEC",
            "headers": [
                "<ctime>"
            ],
            "sample_declaration": "#define CLOCKS_PER_SEC /*implementation \\\n                          defined*/"
        },
        {
            "title": "std::ctime",
            "path": "en.cppreference.com/w/cpp/chrono/c/ctime.html",
            "wgPageName": "cpp/chrono/c/ctime",
            "headers": [
                "<ctime>"
            ],
            "sample_declaration": "char* ctime(const std::time_t* time);"
        },
        {
            "title": "std::difftime",
            "path": "en.cppreference.com/w/cpp/chrono/c/difftime.html",
            "wgPageName": "cpp/chrono/c/difftime",
            "headers": [
                "<ctime>"
            ],
            "sample_declaration": "double difftime(\n    std::time_t time_end,\n    std::time_t time_beg);"
        },
        {
            "title": "std::gmtime",
            "path": "en.cppreference.com/w/cpp/chrono/c/gmtime.html",
            "wgPageName": "cpp/chrono/c/gmtime",
            "headers": [
                "<ctime>"
            ],
            "sample_declaration": "std::tm* gmtime(const std::time_t* time);"
        },
        {
            "title": "std::localtime",
            "path": "en.cppreference.com/w/cpp/chrono/c/localtime.html",
            "wgPageName": "cpp/chrono/c/localtime",
            "headers": [
                "<ctime>"
            ],
            "sample_declaration": "std::tm* localtime(const std::time_t* time);"
        },
        {
            "title": "std::mktime",
            "path": "en.cppreference.com/w/cpp/chrono/c/mktime.html",
            "wgPageName": "cpp/chrono/c/mktime",
            "headers": [
                "<ctime>"
            ],
            "sample_declaration": "std::time_t mktime(std::tm* time);"
        },
        {
            "title": "std::strftime",
            "path": "en.cppreference.com/w/cpp/chrono/c/strftime.html",
            "wgPageName": "cpp/chrono/c/strftime",
            "headers": [
                "<ctime>"
            ],
            "sample_declaration": "std::size_t strftime(\n    char* str,\n    std::size_t count,\n    const char* format,\n    const std::tm* time);"
        },
        {
            "title": "std::time_t",
            "path": "en.cppreference.com/w/cpp/chrono/c/time_t.html",
            "wgPageName": "cpp/chrono/c/time_t",
            "headers": [
                "<ctime>"
            ],
            "sample_declaration": "typedef /* unspecified */ time_t;"
        },
        {
            "title": "std::time",
            "path": "en.cppreference.com/w/cpp/chrono/c/time.html",
            "wgPageName": "cpp/chrono/c/time",
            "headers": [
                "<ctime>"
            ],
            "sample_declaration": "std::time_t time(std::time_t* arg);"
        },
        {
            "title": "std::timespec_get",
            "path": "en.cppreference.com/w/cpp/chrono/c/timespec_get.html",
            "wgPageName": "cpp/chrono/c/timespec_get",
            "headers": [
                "<ctime>"
            ],
            "sample_declaration": "int timespec_get(std::timespec* ts, int base);",
            "other_declarations": 1
        },
        {
            "title": "std::timespec",
            "path": "en.cppreference.com/w/cpp/chrono/c/timespec.html",
            "wgPageName": "cpp/chrono/c/timespec",
            "headers": [
                "<ctime>"
            ],
            "sample_declaration": "struct timespec;"
        },
        {
            "title": "std::tm",
            "path": "en.cppreference.com/w/cpp/chrono/c/tm.html",
            "wgPageName": "cpp/chrono/c/tm",
            "headers": [
                "<ctime>"
            ],
            "sample_declaration": "struct tm;"
        },
        {
            "title": "std::wcsftime",
            "path": "en.cppreference.com/w/cpp/chrono/c/wcsftime.html",
            "wgPageName": "cpp/chrono/c/wcsftime",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "std::size_t wcsftime(\n    wchar_t* str,\n    std::size_t count,\n    const wchar_t* format,\n    const std::tm* time);"
        },
        {
            "title": "std::chrono::choose",
            "path": "en.cppreference.com/w/cpp/chrono/choose.html",
            "wgPageName": "cpp/chrono/choose",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "enum class choose { earliest, latest };"
        },
        {
            "title": "std::chrono::clock_cast",
            "path": "en.cppreference.com/w/cpp/chrono/clock_cast.html",
            "wgPageName": "cpp/chrono/clock_cast",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class Dest,\n    class Source,\n    class Duration>\nauto clock_cast(const std::chrono::time_point<\n                Source,\n                Duration>& t);"
        },
        {
            "title": "std::chrono::clock_time_conversion",
            "path": "en.cppreference.com/w/cpp/chrono/clock_time_conversion.html",
            "wgPageName": "cpp/chrono/clock_time_conversion",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class Dest, class Source>\nstruct clock_time_conversion {};"
        },
        {
            "title": "std::chrono::current_zone",
            "path": "en.cppreference.com/w/cpp/chrono/current_zone.html",
            "wgPageName": "cpp/chrono/current_zone",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "const std::chrono::time_zone* current_zone();"
        },
        {
            "title": "std::chrono::day",
            "path": "en.cppreference.com/w/cpp/chrono/day.html",
            "wgPageName": "cpp/chrono/day",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class day;"
        },
        {
            "title": "std::chrono::day::day",
            "path": "en.cppreference.com/w/cpp/chrono/day/day.html",
            "wgPageName": "cpp/chrono/day/day",
            "sample_declaration": "day() = default;",
            "other_declarations": 1
        },
        {
            "title": "std::formatter<std::chrono::day>",
            "path": "en.cppreference.com/w/cpp/chrono/day/formatter.html",
            "wgPageName": "cpp/chrono/day/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT>\nstruct formatter<std::chrono::day, CharT>;"
        },
        {
            "title": "std::chrono::from_stream (std::chrono::day)",
            "path": "en.cppreference.com/w/cpp/chrono/day/from_stream.html",
            "wgPageName": "cpp/chrono/day/from_stream",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Alloc = std::allocator<CharT> >\nstd::basic_istream<CharT, Traits>& from_stream(\n    std::basic_istream<CharT, Traits>& is,\n    const CharT* fmt,\n    std::chrono::day& d,\n    std::basic_string<CharT, Traits, Alloc>*\n        abbrev = nullptr,\n    std::chrono::minutes* offset = nullptr);"
        },
        {
            "title": "std::chrono::day::ok",
            "path": "en.cppreference.com/w/cpp/chrono/day/ok.html",
            "wgPageName": "cpp/chrono/day/ok",
            "sample_declaration": "constexpr bool ok() const noexcept;"
        },
        {
            "title": "std::chrono::operator+, std::chrono::operator- (std::chrono::day)",
            "path": "en.cppreference.com/w/cpp/chrono/day/operator_arith_2.html",
            "wgPageName": "cpp/chrono/day/operator_arith_2",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr std::chrono::day operator+(\n    const std::chrono::day& d,\n    const std::chrono::days& ds) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::chrono::day::operator+=, std::chrono::day::operator-=",
            "path": "en.cppreference.com/w/cpp/chrono/day/operator_arith.html",
            "wgPageName": "cpp/chrono/day/operator_arith",
            "sample_declaration": "constexpr std::chrono::day& operator+=(\n    const std::chrono::days& d) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::operator==,<=>(std::chrono::day)",
            "path": "en.cppreference.com/w/cpp/chrono/day/operator_cmp.html",
            "wgPageName": "cpp/chrono/day/operator_cmp",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr bool operator==(\n    const std::chrono::day& x,\n    const std::chrono::day& y) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::day::operator++, std::chrono::day::operator--",
            "path": "en.cppreference.com/w/cpp/chrono/day/operator_inc_dec.html",
            "wgPageName": "cpp/chrono/day/operator_inc_dec",
            "sample_declaration": "constexpr std::chrono::day&\noperator++() noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::chrono::operator<<(std::chrono::day)",
            "path": "en.cppreference.com/w/cpp/chrono/day/operator_ltlt.html",
            "wgPageName": "cpp/chrono/day/operator_ltlt",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::day& d);"
        },
        {
            "title": "std::chrono::day::operator unsigned",
            "path": "en.cppreference.com/w/cpp/chrono/day/operator_unsigned.html",
            "wgPageName": "cpp/chrono/day/operator_unsigned",
            "sample_declaration": "explicit constexpr operator unsigned()\n    const noexcept;"
        },
        {
            "title": "std::chrono::duration_values",
            "path": "en.cppreference.com/w/cpp/chrono/duration_values.html",
            "wgPageName": "cpp/chrono/duration_values",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class Rep>\nstruct duration_values;"
        },
        {
            "title": "std::chrono::duration_values<Rep>::max",
            "path": "en.cppreference.com/w/cpp/chrono/duration_values/max.html",
            "wgPageName": "cpp/chrono/duration_values/max",
            "sample_declaration": "static constexpr Rep max();",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::duration_values<Rep>::min",
            "path": "en.cppreference.com/w/cpp/chrono/duration_values/min.html",
            "wgPageName": "cpp/chrono/duration_values/min",
            "sample_declaration": "static constexpr Rep min();",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::duration_values<Rep>::zero",
            "path": "en.cppreference.com/w/cpp/chrono/duration_values/zero.html",
            "wgPageName": "cpp/chrono/duration_values/zero",
            "sample_declaration": "static constexpr Rep zero();",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::duration",
            "path": "en.cppreference.com/w/cpp/chrono/duration.html",
            "wgPageName": "cpp/chrono/duration",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class Rep,\n    class Period = std::ratio<1> >\nclass duration;"
        },
        {
            "title": "std::chrono::abs(std::chrono::duration)",
            "path": "en.cppreference.com/w/cpp/chrono/duration/abs.html",
            "wgPageName": "cpp/chrono/duration/abs",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class Rep, class Period>\nconstexpr std::chrono::duration<Rep, Period>\nabs(std::chrono::duration<Rep, Period> d);"
        },
        {
            "title": "std::chrono::ceil(std::chrono::duration)",
            "path": "en.cppreference.com/w/cpp/chrono/duration/ceil.html",
            "wgPageName": "cpp/chrono/duration/ceil",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class ToDuration,\n    class Rep,\n    class Period>\nconstexpr ToDuration ceil(\n    const std::chrono::duration<Rep, Period>&\n        d);"
        },
        {
            "title": "std::common_type(std::chrono::duration)",
            "path": "en.cppreference.com/w/cpp/chrono/duration/common_type.html",
            "wgPageName": "cpp/chrono/duration/common_type",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class Rep1,\n    class Period1,\n    class Rep2,\n    class Period2>\nstruct common_type<\n    std::chrono::duration<Rep1, Period1>,\n    std::chrono::duration<Rep2, Period2>> {\n  typedef std::chrono::duration<\n      typename std::common_type<Rep1, Rep2>::\n          type,\n      /*see note*/>\n      type;\n};"
        },
        {
            "title": "std::chrono::duration<Rep,Period>::count",
            "path": "en.cppreference.com/w/cpp/chrono/duration/count.html",
            "wgPageName": "cpp/chrono/duration/count",
            "sample_declaration": "constexpr rep count() const;"
        },
        {
            "title": "std::chrono::duration_cast",
            "path": "en.cppreference.com/w/cpp/chrono/duration/duration_cast.html",
            "wgPageName": "cpp/chrono/duration/duration_cast",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class ToDuration,\n    class Rep,\n    class Period>\nconstexpr ToDuration duration_cast(\n    const std::chrono::duration<Rep, Period>&\n        d);"
        },
        {
            "title": "std::chrono::duration<Rep,Period>::duration",
            "path": "en.cppreference.com/w/cpp/chrono/duration/duration.html",
            "wgPageName": "cpp/chrono/duration/duration",
            "sample_declaration": "constexpr duration() = default;",
            "other_declarations": 3
        },
        {
            "title": "std::chrono::floor(std::chrono::duration)",
            "path": "en.cppreference.com/w/cpp/chrono/duration/floor.html",
            "wgPageName": "cpp/chrono/duration/floor",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class ToDuration,\n    class Rep,\n    class Period>\nconstexpr ToDuration floor(\n    const std::chrono::duration<Rep, Period>&\n        d);"
        },
        {
            "title": "std::formatter<std::chrono::duration>",
            "path": "en.cppreference.com/w/cpp/chrono/duration/formatter.html",
            "wgPageName": "cpp/chrono/duration/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class Rep, class Period, class CharT>\nstruct formatter<\n    std::chrono::duration<Rep, Period>,\n    CharT>;"
        },
        {
            "title": "std::chrono::from_stream (std::chrono::duration)",
            "path": "en.cppreference.com/w/cpp/chrono/duration/from_stream.html",
            "wgPageName": "cpp/chrono/duration/from_stream",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Rep,\n    class Period,\n    class Alloc = std::allocator<CharT> >\nstd::basic_istream<CharT, Traits>& from_stream(\n    std::basic_istream<CharT, Traits>& is,\n    const CharT* fmt,\n    std::chrono::duration<Rep, Period>& d,\n    std::basic_string<CharT, Traits, Alloc>*\n        abbrev = nullptr,\n    std::chrono::minutes* offset = nullptr);"
        },
        {
            "title": "std::chrono::duration<Rep,Period>::max",
            "path": "en.cppreference.com/w/cpp/chrono/duration/max.html",
            "wgPageName": "cpp/chrono/duration/max",
            "sample_declaration": "static constexpr duration max();",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::duration<Rep,Period>::min",
            "path": "en.cppreference.com/w/cpp/chrono/duration/min.html",
            "wgPageName": "cpp/chrono/duration/min",
            "sample_declaration": "static constexpr duration min();",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::duration<Rep,Period>::operator+(unary), std::chrono::duration<Rep,Period>::operator-(unary)",
            "path": "en.cppreference.com/w/cpp/chrono/duration/operator_arith.html",
            "wgPageName": "cpp/chrono/duration/operator_arith",
            "sample_declaration": "constexpr duration operator+() const;",
            "other_declarations": 3
        },
        {
            "title": "std::chrono::duration<Rep,Period>::operator++, std::chrono::duration<Rep,Period>::operator--",
            "path": "en.cppreference.com/w/cpp/chrono/duration/operator_arith2.html",
            "wgPageName": "cpp/chrono/duration/operator_arith2",
            "sample_declaration": "duration& operator++();",
            "other_declarations": 7
        },
        {
            "title": "std::chrono::duration<Rep,Period>::operator+=, -=, *=, /=, %=",
            "path": "en.cppreference.com/w/cpp/chrono/duration/operator_arith3.html",
            "wgPageName": "cpp/chrono/duration/operator_arith3",
            "sample_declaration": "duration& operator+=(const duration& d);",
            "other_declarations": 11
        },
        {
            "title": "operator+,-,*,/,%(std::chrono::duration)",
            "path": "en.cppreference.com/w/cpp/chrono/duration/operator_arith4.html",
            "wgPageName": "cpp/chrono/duration/operator_arith4",
            "sample_declaration": "template<\n    class Rep1,\n    class Period1,\n    class Rep2,\n    class Period2>\ntypename std::common_type<\n    duration<Rep1, Period1>,\n    duration<Rep2, Period2>>::type constexpr\noperator+(\n    const duration<Rep1, Period1>& lhs,\n    const duration<Rep2, Period2>& rhs);",
            "other_declarations": 7
        },
        {
            "title": "operator==,!=,<,<=,>,>=,<=>(std::chrono::duration)",
            "path": "en.cppreference.com/w/cpp/chrono/duration/operator_cmp.html",
            "wgPageName": "cpp/chrono/duration/operator_cmp",
            "sample_declaration": "template<\n    class Rep1,\n    class Period1,\n    class Rep2,\n    class Period2>\nconstexpr bool operator==(\n    const std::chrono::duration<Rep1, Period1>&\n        lhs,\n    const std::chrono::duration<Rep2, Period2>&\n        rhs);",
            "other_declarations": 6
        },
        {
            "title": "std::chrono::operator<< (std::chrono::duration)",
            "path": "en.cppreference.com/w/cpp/chrono/duration/operator_ltlt.html",
            "wgPageName": "cpp/chrono/duration/operator_ltlt",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Rep,\n    class Period>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::duration<Rep, Period>&\n        d);"
        },
        {
            "title": "std::chrono::duration<Rep,Period>::operator=",
            "path": "en.cppreference.com/w/cpp/chrono/duration/operator=.html",
            "wgPageName": "cpp/chrono/duration/operator=",
            "sample_declaration": "duration& operator=(const duration& other) =\n    default;"
        },
        {
            "title": "std::chrono::round(std::chrono::duration)",
            "path": "en.cppreference.com/w/cpp/chrono/duration/round.html",
            "wgPageName": "cpp/chrono/duration/round",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class ToDuration,\n    class Rep,\n    class Period>\nconstexpr ToDuration round(\n    const std::chrono::duration<Rep, Period>&\n        d);"
        },
        {
            "title": "std::chrono::duration<Rep,Period>::zero",
            "path": "en.cppreference.com/w/cpp/chrono/duration/zero.html",
            "wgPageName": "cpp/chrono/duration/zero",
            "sample_declaration": "static constexpr duration zero();",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::file_clock",
            "path": "en.cppreference.com/w/cpp/chrono/file_clock.html",
            "wgPageName": "cpp/chrono/file_clock",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "using file_clock = /* see below */;"
        },
        {
            "title": "std::formatter<std::chrono::file_time>",
            "path": "en.cppreference.com/w/cpp/chrono/file_clock/formatter.html",
            "wgPageName": "cpp/chrono/file_clock/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class Duration, class CharT>\nstruct formatter<\n    std::chrono::file_time<Duration>,\n    CharT>;"
        },
        {
            "title": "std::chrono::from_stream (std::chrono::file_time)",
            "path": "en.cppreference.com/w/cpp/chrono/file_clock/from_stream.html",
            "wgPageName": "cpp/chrono/file_clock/from_stream",
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Duration,\n    class Alloc = std::allocator<CharT> >\nstd::basic_istream<CharT, Traits>& from_stream(\n    std::basic_istream<CharT, Traits>& is,\n    const CharT* fmt,\n    std::chrono::file_time<Duration>& tp,\n    std::basic_string<CharT, Traits, Alloc>*\n        abbrev = nullptr,\n    std::chrono::minutes* offset = nullptr);"
        },
        {
            "title": "std::chrono::file_clock::now",
            "path": "en.cppreference.com/w/cpp/chrono/file_clock/now.html",
            "wgPageName": "cpp/chrono/file_clock/now",
            "sample_declaration": "static std::chrono::time_point<\n    std::chrono::file_clock>\nnow() noexcept;"
        },
        {
            "title": "std::chrono::operator<<(std::chrono::file_time)",
            "path": "en.cppreference.com/w/cpp/chrono/file_clock/operator_ltlt.html",
            "wgPageName": "cpp/chrono/file_clock/operator_ltlt",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Duration>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::file_time<Duration>& tp);"
        },
        {
            "title": "std::chrono::file_clock::to_sys, std::chrono::file_clock::from_sys",
            "path": "en.cppreference.com/w/cpp/chrono/file_clock/to_from_sys.html",
            "wgPageName": "cpp/chrono/file_clock/to_from_sys",
            "sample_declaration": "template<class Duration>\nstatic std::chrono::sys_time</*see below*/>\nto_sys(\n    const std::chrono::file_time<Duration>& t);",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::file_clock::to_utc, std::chrono::file_clock::from_utc",
            "path": "en.cppreference.com/w/cpp/chrono/file_clock/to_from_utc.html",
            "wgPageName": "cpp/chrono/file_clock/to_from_utc",
            "sample_declaration": "template<class Duration>\nstatic std::chrono::utc_time</*see below*/>\nto_utc(\n    const std::chrono::file_time<Duration>& t);",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::gps_clock",
            "path": "en.cppreference.com/w/cpp/chrono/gps_clock.html",
            "wgPageName": "cpp/chrono/gps_clock",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class gps_clock;"
        },
        {
            "title": "std::formatter<std::chrono::gps_time>",
            "path": "en.cppreference.com/w/cpp/chrono/gps_clock/formatter.html",
            "wgPageName": "cpp/chrono/gps_clock/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class Duration, class CharT>\nstruct formatter<\n    std::chrono::gps_time<Duration>,\n    CharT>;"
        },
        {
            "title": "std::chrono::from_stream (std::chrono::gps_time)",
            "path": "en.cppreference.com/w/cpp/chrono/gps_clock/from_stream.html",
            "wgPageName": "cpp/chrono/gps_clock/from_stream",
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Duration,\n    class Alloc = std::allocator<CharT> >\nstd::basic_istream<CharT, Traits>& from_stream(\n    std::basic_istream<CharT, Traits>& is,\n    const CharT* fmt,\n    std::chrono::gps_time<Duration>& tp,\n    std::basic_string<CharT, Traits, Alloc>*\n        abbrev = nullptr,\n    std::chrono::minutes* offset = nullptr);"
        },
        {
            "title": "std::chrono::gps_clock::from_utc",
            "path": "en.cppreference.com/w/cpp/chrono/gps_clock/from_utc.html",
            "wgPageName": "cpp/chrono/gps_clock/from_utc",
            "sample_declaration": "template<class Duration>\nstatic std::chrono::gps_time<std::common_type_t<\n    Duration,\n    std::chrono::seconds>>\nfrom_utc(const std::chrono::utc_time<\n         Duration>&) noexcept;"
        },
        {
            "title": "std::chrono::gps_clock::now",
            "path": "en.cppreference.com/w/cpp/chrono/gps_clock/now.html",
            "wgPageName": "cpp/chrono/gps_clock/now",
            "sample_declaration": "static std::chrono::time_point<\n    std::chrono::gps_clock>\nnow();"
        },
        {
            "title": "std::chrono::operator<<(std::chrono::gps_time)",
            "path": "en.cppreference.com/w/cpp/chrono/gps_clock/operator_ltlt.html",
            "wgPageName": "cpp/chrono/gps_clock/operator_ltlt",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Duration>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::gps_time<Duration>& tp);"
        },
        {
            "title": "std::chrono::gps_clock::to_utc",
            "path": "en.cppreference.com/w/cpp/chrono/gps_clock/to_utc.html",
            "wgPageName": "cpp/chrono/gps_clock/to_utc",
            "sample_declaration": "template<class Duration>\nstatic std::chrono::utc_time<std::common_type_t<\n    Duration,\n    std::chrono::seconds>>\nto_utc(const std::chrono::gps_time<Duration>&\n           t) noexcept;"
        },
        {
            "title": "std::chrono::hh_mm_ss",
            "path": "en.cppreference.com/w/cpp/chrono/hh_mm_ss.html",
            "wgPageName": "cpp/chrono/hh_mm_ss",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class Duration>\nclass hh_mm_ss;"
        },
        {
            "title": "std::chrono::hh_mm_ss<Duration>::is_negative, std::chrono::hh_mm_ss<Duration>::hours, std::chrono::hh_mm_ss<Duration>::minutes, std::chrono::hh_mm_ss<Duration>::seconds, std::chrono::hh_mm_ss<Duration>::subseconds",
            "path": "en.cppreference.com/w/cpp/chrono/hh_mm_ss/accessors.html",
            "wgPageName": "cpp/chrono/hh_mm_ss/accessors",
            "sample_declaration": "constexpr bool is_negative() const noexcept;",
            "other_declarations": 4
        },
        {
            "title": "std::chrono::hh_mm_ss<Duration>::operator precision, std::chrono::hh_mm_ss<Duration>::to_duration",
            "path": "en.cppreference.com/w/cpp/chrono/hh_mm_ss/duration.html",
            "wgPageName": "cpp/chrono/hh_mm_ss/duration",
            "sample_declaration": "constexpr explicit operator precision()\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::formatter<std::chrono::hh_mm_ss>",
            "path": "en.cppreference.com/w/cpp/chrono/hh_mm_ss/formatter.html",
            "wgPageName": "cpp/chrono/hh_mm_ss/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT>\nstruct formatter<std::chrono::hh_mm_ss, CharT>;"
        },
        {
            "title": "std::chrono::hh_mm_ss<Duration>::hh_mm_ss",
            "path": "en.cppreference.com/w/cpp/chrono/hh_mm_ss/hh_mm_ss.html",
            "wgPageName": "cpp/chrono/hh_mm_ss/hh_mm_ss",
            "sample_declaration": "constexpr hh_mm_ss() noexcept\n    : hh_mm_ss{Duration::zero()} {}",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::operator<<(std::chrono::hh_mm_ss)",
            "path": "en.cppreference.com/w/cpp/chrono/hh_mm_ss/operator_ltlt.html",
            "wgPageName": "cpp/chrono/hh_mm_ss/operator_ltlt",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Duration>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::hh_mm_ss<Duration>& t);"
        },
        {
            "title": "std::chrono::high_resolution_clock",
            "path": "en.cppreference.com/w/cpp/chrono/high_resolution_clock.html",
            "wgPageName": "cpp/chrono/high_resolution_clock",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class high_resolution_clock;"
        },
        {
            "title": "std::chrono::high_resolution_clock::now",
            "path": "en.cppreference.com/w/cpp/chrono/high_resolution_clock/now.html",
            "wgPageName": "cpp/chrono/high_resolution_clock/now",
            "sample_declaration": "static std::chrono::time_point<\n    std::chrono::high_resolution_clock>\nnow() noexcept;"
        },
        {
            "title": "std::chrono::is_am, std::chrono::is_pm, std::chrono::make12, std::chrono::make24",
            "path": "en.cppreference.com/w/cpp/chrono/hour_fun.html",
            "wgPageName": "cpp/chrono/hour_fun",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr bool is_am(\n    const std::chrono::hours& h) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::chrono::is_clock",
            "path": "en.cppreference.com/w/cpp/chrono/is_clock.html",
            "wgPageName": "cpp/chrono/is_clock",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class T>\nstruct is_clock;"
        },
        {
            "title": "std::chrono::last_spec, std::chrono::last",
            "path": "en.cppreference.com/w/cpp/chrono/last_spec.html",
            "wgPageName": "cpp/chrono/last_spec",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "struct last_spec {\n  explicit last_spec() = default;\n};",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::leap_second",
            "path": "en.cppreference.com/w/cpp/chrono/leap_second.html",
            "wgPageName": "cpp/chrono/leap_second",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class leap_second;"
        },
        {
            "title": "std::chrono::leap_second::date",
            "path": "en.cppreference.com/w/cpp/chrono/leap_second/date.html",
            "wgPageName": "cpp/chrono/leap_second/date",
            "sample_declaration": "constexpr std::chrono::sys_seconds date()\n    const noexcept;"
        },
        {
            "title": "std::chrono::operator==,<,<=,>,>=,<=>(std::chrono::leap_second)",
            "path": "en.cppreference.com/w/cpp/chrono/leap_second/operator_cmp.html",
            "wgPageName": "cpp/chrono/leap_second/operator_cmp",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr bool operator==(\n    const std::chrono::leap_second& x,\n    const std::chrono::leap_second& y) noexcept;",
            "other_declarations": 11
        },
        {
            "title": "std::chrono::local_info",
            "path": "en.cppreference.com/w/cpp/chrono/local_info.html",
            "wgPageName": "cpp/chrono/local_info",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "struct local_info;"
        },
        {
            "title": "std::formatter<std::chrono::local_info>",
            "path": "en.cppreference.com/w/cpp/chrono/local_info/formatter.html",
            "wgPageName": "cpp/chrono/local_info/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT>\nstruct formatter<\n    std::chrono::local_info,\n    CharT>;"
        },
        {
            "title": "std::chrono::operator<< (std::chrono::local_info)",
            "path": "en.cppreference.com/w/cpp/chrono/local_info/operator_ltlt.html",
            "wgPageName": "cpp/chrono/local_info/operator_ltlt",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::local_info& r);"
        },
        {
            "title": "std::chrono::local_t",
            "path": "en.cppreference.com/w/cpp/chrono/local_t.html",
            "wgPageName": "cpp/chrono/local_t",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "struct local_t {};"
        },
        {
            "title": "std::formatter<std::chrono::local_time>, std::chrono::local_time_format",
            "path": "en.cppreference.com/w/cpp/chrono/local_t/formatter.html",
            "wgPageName": "cpp/chrono/local_t/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class Duration, class CharT>\nstruct formatter<\n    std::chrono::local_time<Duration>,\n    CharT>;",
            "other_declarations": 3
        },
        {
            "title": "std::chrono::from_stream (std::chrono::local_time)",
            "path": "en.cppreference.com/w/cpp/chrono/local_t/from_stream.html",
            "wgPageName": "cpp/chrono/local_t/from_stream",
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Duration,\n    class Alloc = std::allocator<CharT> >\nstd::basic_istream<CharT, Traits>& from_stream(\n    std::basic_istream<CharT, Traits>& is,\n    const CharT* fmt,\n    std::chrono::local_time<Duration>& tp,\n    std::basic_string<CharT, Traits, Alloc>*\n        abbrev = nullptr,\n    std::chrono::minutes* offset = nullptr);"
        },
        {
            "title": "std::chrono::operator<<(std::chrono::local_time)",
            "path": "en.cppreference.com/w/cpp/chrono/local_t/operator_ltlt.html",
            "wgPageName": "cpp/chrono/local_t/operator_ltlt",
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Duration>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::local_time<Duration>&\n        tp);"
        },
        {
            "title": "std::chrono::locate_zone",
            "path": "en.cppreference.com/w/cpp/chrono/locate_zone.html",
            "wgPageName": "cpp/chrono/locate_zone",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "const std::chrono::time_zone* locate_zone(\n    std::string_view tz_name);"
        },
        {
            "title": "std::chrono::month_day_last",
            "path": "en.cppreference.com/w/cpp/chrono/month_day_last.html",
            "wgPageName": "cpp/chrono/month_day_last",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class month_day_last;"
        },
        {
            "title": "std::formatter<std::chrono::month_day_last>",
            "path": "en.cppreference.com/w/cpp/chrono/month_day_last/formatter.html",
            "wgPageName": "cpp/chrono/month_day_last/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT>\nstruct formatter<\n    std::chrono::month_day_last,\n    CharT>;"
        },
        {
            "title": "std::chrono::month_day_last::month_day_last",
            "path": "en.cppreference.com/w/cpp/chrono/month_day_last/month_day_last.html",
            "wgPageName": "cpp/chrono/month_day_last/month_day_last",
            "sample_declaration": "explicit constexpr month_day_last(\n    const std::chrono::month& m) noexcept;"
        },
        {
            "title": "std::chrono::month_day_last::month",
            "path": "en.cppreference.com/w/cpp/chrono/month_day_last/month.html",
            "wgPageName": "cpp/chrono/month_day_last/month",
            "sample_declaration": "constexpr std::chrono::month month()\n    const noexcept;"
        },
        {
            "title": "std::chrono::month_day_last::ok",
            "path": "en.cppreference.com/w/cpp/chrono/month_day_last/ok.html",
            "wgPageName": "cpp/chrono/month_day_last/ok",
            "sample_declaration": "constexpr bool ok() const noexcept;"
        },
        {
            "title": "std::chrono::operator==,<=>(std::chrono::month_day_last)",
            "path": "en.cppreference.com/w/cpp/chrono/month_day_last/operator_cmp.html",
            "wgPageName": "cpp/chrono/month_day_last/operator_cmp",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr bool operator==(\n    const std::chrono::month_day_last& x,\n    const std::chrono::month_day_last&\n        y) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::operator<<(std::chrono::month_day_last)",
            "path": "en.cppreference.com/w/cpp/chrono/month_day_last/operator_ltlt.html",
            "wgPageName": "cpp/chrono/month_day_last/operator_ltlt",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::month_day_last& mdl);"
        },
        {
            "title": "std::chrono::month_day",
            "path": "en.cppreference.com/w/cpp/chrono/month_day.html",
            "wgPageName": "cpp/chrono/month_day",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class month_day;"
        },
        {
            "title": "std::chrono::month_day::month, std::chrono::month_day::day",
            "path": "en.cppreference.com/w/cpp/chrono/month_day/accessors.html",
            "wgPageName": "cpp/chrono/month_day/accessors",
            "sample_declaration": "constexpr std::chrono::month month()\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::formatter<std::chrono::month_day>",
            "path": "en.cppreference.com/w/cpp/chrono/month_day/formatter.html",
            "wgPageName": "cpp/chrono/month_day/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT>\nstruct formatter<std::chrono::month_day, CharT>;"
        },
        {
            "title": "std::chrono::from_stream (std::chrono::month_day)",
            "path": "en.cppreference.com/w/cpp/chrono/month_day/from_stream.html",
            "wgPageName": "cpp/chrono/month_day/from_stream",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Alloc = std::allocator<CharT> >\nstd::basic_istream<CharT, Traits>& from_stream(\n    std::basic_istream<CharT, Traits>& is,\n    const CharT* fmt,\n    std::chrono::month_day& md,\n    std::basic_string<CharT, Traits, Alloc>*\n        abbrev = nullptr,\n    std::chrono::minutes* offset = nullptr);"
        },
        {
            "title": "std::chrono::month_day::month_day",
            "path": "en.cppreference.com/w/cpp/chrono/month_day/month_day.html",
            "wgPageName": "cpp/chrono/month_day/month_day",
            "sample_declaration": "month_day() = default;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::month_day::ok",
            "path": "en.cppreference.com/w/cpp/chrono/month_day/ok.html",
            "wgPageName": "cpp/chrono/month_day/ok",
            "sample_declaration": "constexpr bool ok() const noexcept;"
        },
        {
            "title": "std::chrono::operator==,<=>(std::chrono::month_day)",
            "path": "en.cppreference.com/w/cpp/chrono/month_day/operator_cmp.html",
            "wgPageName": "cpp/chrono/month_day/operator_cmp",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr bool operator==(\n    const std::chrono::month_day& x,\n    const std::chrono::month_day& y) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::operator<<(std::chrono::month_day)",
            "path": "en.cppreference.com/w/cpp/chrono/month_day/operator_ltlt.html",
            "wgPageName": "cpp/chrono/month_day/operator_ltlt",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::month_day& md);"
        },
        {
            "title": "std::chrono::month_weekday_last",
            "path": "en.cppreference.com/w/cpp/chrono/month_weekday_last.html",
            "wgPageName": "cpp/chrono/month_weekday_last",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class month_weekday_last;"
        },
        {
            "title": "std::chrono::month_weekday_last::month, std::chrono::month_weekday_last::weekday_last",
            "path": "en.cppreference.com/w/cpp/chrono/month_weekday_last/accessors.html",
            "wgPageName": "cpp/chrono/month_weekday_last/accessors",
            "sample_declaration": "constexpr std::chrono::month month()\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::formatter<std::chrono::month_weekday_last>",
            "path": "en.cppreference.com/w/cpp/chrono/month_weekday_last/formatter.html",
            "wgPageName": "cpp/chrono/month_weekday_last/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT>\nstruct formatter<\n    std::chrono::month_weekday_last,\n    CharT>;"
        },
        {
            "title": "std::chrono::month_weekday_last::month_weekday_last",
            "path": "en.cppreference.com/w/cpp/chrono/month_weekday_last/month_weekday_last.html",
            "wgPageName": "cpp/chrono/month_weekday_last/month_weekday_last",
            "sample_declaration": "constexpr month_weekday_last(\n    const std::chrono::month& m,\n    const std::chrono::weekday_last&\n        wdl) noexcept;"
        },
        {
            "title": "std::chrono::month_weekday_last::ok",
            "path": "en.cppreference.com/w/cpp/chrono/month_weekday_last/ok.html",
            "wgPageName": "cpp/chrono/month_weekday_last/ok",
            "sample_declaration": "constexpr bool ok() const noexcept;"
        },
        {
            "title": "std::chrono::operator==(std::chrono::month_weekday_last)",
            "path": "en.cppreference.com/w/cpp/chrono/month_weekday_last/operator_cmp.html",
            "wgPageName": "cpp/chrono/month_weekday_last/operator_cmp",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr bool operator==(\n    const std::chrono::month_weekday_last& x,\n    const std::chrono::month_weekday_last&\n        y) noexcept;"
        },
        {
            "title": "std::chrono::operator<<(std::chrono::month_weekday_last)",
            "path": "en.cppreference.com/w/cpp/chrono/month_weekday_last/operator_ltlt.html",
            "wgPageName": "cpp/chrono/month_weekday_last/operator_ltlt",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::month_weekday_last&\n        mwdl);"
        },
        {
            "title": "std::chrono::month_weekday",
            "path": "en.cppreference.com/w/cpp/chrono/month_weekday.html",
            "wgPageName": "cpp/chrono/month_weekday",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class month_weekday;"
        },
        {
            "title": "std::chrono::month_weekday::month, std::chrono::month_weekday::weekday_indexed",
            "path": "en.cppreference.com/w/cpp/chrono/month_weekday/accessors.html",
            "wgPageName": "cpp/chrono/month_weekday/accessors",
            "sample_declaration": "constexpr std::chrono::month month()\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::formatter<std::chrono::month_weekday>",
            "path": "en.cppreference.com/w/cpp/chrono/month_weekday/formatter.html",
            "wgPageName": "cpp/chrono/month_weekday/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT>\nstruct formatter<\n    std::chrono::month_weekday,\n    CharT>;"
        },
        {
            "title": "std::chrono::month_weekday::month_weekday",
            "path": "en.cppreference.com/w/cpp/chrono/month_weekday/month_weekday.html",
            "wgPageName": "cpp/chrono/month_weekday/month_weekday",
            "sample_declaration": "constexpr month_weekday(\n    const std::chrono::month& m,\n    const std::chrono::weekday_indexed&\n        wdi) noexcept;"
        },
        {
            "title": "std::chrono::month_weekday::ok",
            "path": "en.cppreference.com/w/cpp/chrono/month_weekday/ok.html",
            "wgPageName": "cpp/chrono/month_weekday/ok",
            "sample_declaration": "constexpr bool ok() const noexcept;"
        },
        {
            "title": "std::chrono::operator==(std::chrono::month_weekday)",
            "path": "en.cppreference.com/w/cpp/chrono/month_weekday/operator_cmp.html",
            "wgPageName": "cpp/chrono/month_weekday/operator_cmp",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr bool operator==(\n    const std::chrono::month_weekday& x,\n    const std::chrono::month_weekday&\n        y) noexcept;"
        },
        {
            "title": "std::chrono::operator<<(std::chrono::month_weekday)",
            "path": "en.cppreference.com/w/cpp/chrono/month_weekday/operator_ltlt.html",
            "wgPageName": "cpp/chrono/month_weekday/operator_ltlt",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::month_weekday& mwd);"
        },
        {
            "title": "std::chrono::month",
            "path": "en.cppreference.com/w/cpp/chrono/month.html",
            "wgPageName": "cpp/chrono/month",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class month;",
            "other_declarations": 12
        },
        {
            "title": "std::formatter<std::chrono::month>",
            "path": "en.cppreference.com/w/cpp/chrono/month/formatter.html",
            "wgPageName": "cpp/chrono/month/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT>\nstruct formatter<std::chrono::month, CharT>;"
        },
        {
            "title": "std::chrono::from_stream (std::chrono::month)",
            "path": "en.cppreference.com/w/cpp/chrono/month/from_stream.html",
            "wgPageName": "cpp/chrono/month/from_stream",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Alloc = std::allocator<CharT> >\nstd::basic_istream<CharT, Traits>& from_stream(\n    std::basic_istream<CharT, Traits>& is,\n    const CharT* fmt,\n    std::chrono::month& m,\n    std::basic_string<CharT, Traits, Alloc>*\n        abbrev = nullptr,\n    std::chrono::minutes* offset = nullptr);"
        },
        {
            "title": "std::chrono::month::month",
            "path": "en.cppreference.com/w/cpp/chrono/month/month.html",
            "wgPageName": "cpp/chrono/month/month",
            "sample_declaration": "month() = default;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::month::ok",
            "path": "en.cppreference.com/w/cpp/chrono/month/ok.html",
            "wgPageName": "cpp/chrono/month/ok",
            "sample_declaration": "constexpr bool ok() const noexcept;"
        },
        {
            "title": "std::chrono::operator+, std::chrono::operator- (std::chrono::month)",
            "path": "en.cppreference.com/w/cpp/chrono/month/operator_arith_2.html",
            "wgPageName": "cpp/chrono/month/operator_arith_2",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr std::chrono::month operator+(\n    const std::chrono::month& m,\n    const std::chrono::months& ms) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::chrono::month::operator+=, std::chrono::month::operator-=",
            "path": "en.cppreference.com/w/cpp/chrono/month/operator_arith.html",
            "wgPageName": "cpp/chrono/month/operator_arith",
            "sample_declaration": "constexpr std::chrono::month& operator+=(\n    const std::chrono::months& m) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::operator==,<=>(std::chrono::month)",
            "path": "en.cppreference.com/w/cpp/chrono/month/operator_cmp.html",
            "wgPageName": "cpp/chrono/month/operator_cmp",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr bool operator==(\n    const std::chrono::month& x,\n    const std::chrono::month& y) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::month::operator++, std::chrono::month::operator--",
            "path": "en.cppreference.com/w/cpp/chrono/month/operator_inc_dec.html",
            "wgPageName": "cpp/chrono/month/operator_inc_dec",
            "sample_declaration": "constexpr std::chrono::month&\noperator++() noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::chrono::operator<<(std::chrono::month)",
            "path": "en.cppreference.com/w/cpp/chrono/month/operator_ltlt.html",
            "wgPageName": "cpp/chrono/month/operator_ltlt",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::month& m);"
        },
        {
            "title": "std::chrono::month::operator unsigned",
            "path": "en.cppreference.com/w/cpp/chrono/month/operator_unsigned.html",
            "wgPageName": "cpp/chrono/month/operator_unsigned",
            "sample_declaration": "explicit constexpr operator unsigned()\n    const noexcept;"
        },
        {
            "title": "std::chrono::nonexistent_local_time",
            "path": "en.cppreference.com/w/cpp/chrono/nonexistent_local_time.html",
            "wgPageName": "cpp/chrono/nonexistent_local_time",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class nonexistent_local_time;"
        },
        {
            "title": "std::chrono::operator/ (calendar)",
            "path": "en.cppreference.com/w/cpp/chrono/operator_slash.html",
            "wgPageName": "cpp/chrono/operator_slash",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr auto operator/(\n    const std::chrono::year& y,\n    const std::chrono::month& m) noexcept\n    -> std::chrono::year_month;",
            "other_declarations": 39
        },
        {
            "title": "std::literals::chrono_literals::operator\"\"d",
            "path": "en.cppreference.com/w/cpp/chrono/operator\"\"d.html",
            "wgPageName": "cpp/chrono/operator\\\"\\\"d",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr std::chrono::day operator\"\"d(\n    unsigned long long d) noexcept;"
        },
        {
            "title": "std::literals::chrono_literals::operator\"\"h",
            "path": "en.cppreference.com/w/cpp/chrono/operator\"\"h.html",
            "wgPageName": "cpp/chrono/operator\\\"\\\"h",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr chrono::hours operator\"\" h(\n    unsigned long long hrs);",
            "other_declarations": 1
        },
        {
            "title": "std::literals::chrono_literals::operator\"\"min",
            "path": "en.cppreference.com/w/cpp/chrono/operator\"\"min.html",
            "wgPageName": "cpp/chrono/operator\\\"\\\"min",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr chrono::minutes operator\"\" min(\n    unsigned long long mins);",
            "other_declarations": 1
        },
        {
            "title": "std::literals::chrono_literals::operator\"\"ms",
            "path": "en.cppreference.com/w/cpp/chrono/operator\"\"ms.html",
            "wgPageName": "cpp/chrono/operator\\\"\\\"ms",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr std::chrono::milliseconds\noperator\"\" ms(unsigned long long ms);",
            "other_declarations": 1
        },
        {
            "title": "std::literals::chrono_literals::operator\"\"ns",
            "path": "en.cppreference.com/w/cpp/chrono/operator\"\"ns.html",
            "wgPageName": "cpp/chrono/operator\\\"\\\"ns",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr std::chrono::nanoseconds\noperator\"\" ns(unsigned long long nsec);",
            "other_declarations": 1
        },
        {
            "title": "std::literals::chrono_literals::operator\"\"s",
            "path": "en.cppreference.com/w/cpp/chrono/operator\"\"s.html",
            "wgPageName": "cpp/chrono/operator\\\"\\\"s",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr chrono::seconds operator\"\" s(\n    unsigned long long secs);",
            "other_declarations": 1
        },
        {
            "title": "std::literals::chrono_literals::operator\"\"us",
            "path": "en.cppreference.com/w/cpp/chrono/operator\"\"us.html",
            "wgPageName": "cpp/chrono/operator\\\"\\\"us",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr std::chrono::microseconds\noperator\"\" us(unsigned long long us);",
            "other_declarations": 1
        },
        {
            "title": "std::literals::chrono_literals::operator\"\"y",
            "path": "en.cppreference.com/w/cpp/chrono/operator\"\"y.html",
            "wgPageName": "cpp/chrono/operator\\\"\\\"y",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr std::chrono::year operator\"\"y(\n    unsigned long long y) noexcept;"
        },
        {
            "title": "std::chrono::parse",
            "path": "en.cppreference.com/w/cpp/chrono/parse.html",
            "wgPageName": "cpp/chrono/parse",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT, class Parsable>\n/* unspecified */ parse(\n    const CharT* fmt,\n    Parsable& tp);",
            "other_declarations": 7
        },
        {
            "title": "std::chrono::steady_clock",
            "path": "en.cppreference.com/w/cpp/chrono/steady_clock.html",
            "wgPageName": "cpp/chrono/steady_clock",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class steady_clock;"
        },
        {
            "title": "std::chrono::steady_clock::now",
            "path": "en.cppreference.com/w/cpp/chrono/steady_clock/now.html",
            "wgPageName": "cpp/chrono/steady_clock/now",
            "sample_declaration": "static std::chrono::time_point<\n    std::chrono::steady_clock>\nnow() noexcept;"
        },
        {
            "title": "std::chrono::sys_info",
            "path": "en.cppreference.com/w/cpp/chrono/sys_info.html",
            "wgPageName": "cpp/chrono/sys_info",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "struct sys_info;"
        },
        {
            "title": "std::formatter<std::chrono::sys_info>",
            "path": "en.cppreference.com/w/cpp/chrono/sys_info/formatter.html",
            "wgPageName": "cpp/chrono/sys_info/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT>\nstruct formatter<std::chrono::sys_info, CharT>;"
        },
        {
            "title": "std::chrono::operator<< (std::chrono::sys_info)",
            "path": "en.cppreference.com/w/cpp/chrono/sys_info/operator_ltlt.html",
            "wgPageName": "cpp/chrono/sys_info/operator_ltlt",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::sys_info& r);"
        },
        {
            "title": "std::chrono::system_clock",
            "path": "en.cppreference.com/w/cpp/chrono/system_clock.html",
            "wgPageName": "cpp/chrono/system_clock",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class system_clock;"
        },
        {
            "title": "std::formatter<std::chrono::sys_time>",
            "path": "en.cppreference.com/w/cpp/chrono/system_clock/formatter.html",
            "wgPageName": "cpp/chrono/system_clock/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class Duration, class CharT>\nstruct formatter<\n    std::chrono::sys_time<Duration>,\n    CharT>;"
        },
        {
            "title": "std::chrono::from_stream (std::chrono::sys_time)",
            "path": "en.cppreference.com/w/cpp/chrono/system_clock/from_stream.html",
            "wgPageName": "cpp/chrono/system_clock/from_stream",
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Duration,\n    class Alloc = std::allocator<CharT> >\nstd::basic_istream<CharT, Traits>& from_stream(\n    std::basic_istream<CharT, Traits>& is,\n    const CharT* fmt,\n    std::chrono::sys_time<Duration>& tp,\n    std::basic_string<CharT, Traits, Alloc>*\n        abbrev = nullptr,\n    std::chrono::minutes* offset = nullptr);"
        },
        {
            "title": "std::chrono::system_clock::from_time_t",
            "path": "en.cppreference.com/w/cpp/chrono/system_clock/from_time_t.html",
            "wgPageName": "cpp/chrono/system_clock/from_time_t",
            "sample_declaration": "static std::chrono::system_clock::time_point\nfrom_time_t(std::time_t t) noexcept;"
        },
        {
            "title": "std::chrono::system_clock::now",
            "path": "en.cppreference.com/w/cpp/chrono/system_clock/now.html",
            "wgPageName": "cpp/chrono/system_clock/now",
            "sample_declaration": "static std::chrono::time_point<\n    std::chrono::system_clock>\nnow() noexcept;"
        },
        {
            "title": "std::chrono::operator<<(std::chrono::sys_time)",
            "path": "en.cppreference.com/w/cpp/chrono/system_clock/operator_ltlt.html",
            "wgPageName": "cpp/chrono/system_clock/operator_ltlt",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Duration>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::sys_time<Duration>& tp);",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::system_clock::to_time_t",
            "path": "en.cppreference.com/w/cpp/chrono/system_clock/to_time_t.html",
            "wgPageName": "cpp/chrono/system_clock/to_time_t",
            "sample_declaration": "static std::time_t to_time_t(\n    const time_point& t) noexcept;"
        },
        {
            "title": "std::chrono::tai_clock",
            "path": "en.cppreference.com/w/cpp/chrono/tai_clock.html",
            "wgPageName": "cpp/chrono/tai_clock",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class tai_clock;"
        },
        {
            "title": "std::formatter<std::chrono::tai_time>",
            "path": "en.cppreference.com/w/cpp/chrono/tai_clock/formatter.html",
            "wgPageName": "cpp/chrono/tai_clock/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class Duration, class CharT>\nstruct formatter<\n    std::chrono::tai_time<Duration>,\n    CharT>;"
        },
        {
            "title": "std::chrono::from_stream (std::chrono::tai_time)",
            "path": "en.cppreference.com/w/cpp/chrono/tai_clock/from_stream.html",
            "wgPageName": "cpp/chrono/tai_clock/from_stream",
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Duration,\n    class Alloc = std::allocator<CharT> >\nstd::basic_istream<CharT, Traits>& from_stream(\n    std::basic_istream<CharT, Traits>& is,\n    const CharT* fmt,\n    std::chrono::tai_time<Duration>& tp,\n    std::basic_string<CharT, Traits, Alloc>*\n        abbrev = nullptr,\n    std::chrono::minutes* offset = nullptr);"
        },
        {
            "title": "std::chrono::tai_clock::from_utc",
            "path": "en.cppreference.com/w/cpp/chrono/tai_clock/from_utc.html",
            "wgPageName": "cpp/chrono/tai_clock/from_utc",
            "sample_declaration": "template<class Duration>\nstatic std::chrono::tai_time<std::common_type_t<\n    Duration,\n    std::chrono::seconds>>\nfrom_utc(const std::chrono::utc_time<\n         Duration>&) noexcept;"
        },
        {
            "title": "std::chrono::tai_clock::now",
            "path": "en.cppreference.com/w/cpp/chrono/tai_clock/now.html",
            "wgPageName": "cpp/chrono/tai_clock/now",
            "sample_declaration": "static std::chrono::time_point<\n    std::chrono::tai_clock>\nnow();"
        },
        {
            "title": "std::chrono::operator<<(std::chrono::tai_time)",
            "path": "en.cppreference.com/w/cpp/chrono/tai_clock/operator_ltlt.html",
            "wgPageName": "cpp/chrono/tai_clock/operator_ltlt",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Duration>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::tai_time<Duration>& tp);"
        },
        {
            "title": "std::chrono::tai_clock::to_utc",
            "path": "en.cppreference.com/w/cpp/chrono/tai_clock/to_utc.html",
            "wgPageName": "cpp/chrono/tai_clock/to_utc",
            "sample_declaration": "template<class Duration>\nstatic std::chrono::utc_time<std::common_type_t<\n    Duration,\n    std::chrono::seconds>>\nto_utc(const std::chrono::tai_time<Duration>&\n           t) noexcept;"
        },
        {
            "title": "std::chrono::time_point",
            "path": "en.cppreference.com/w/cpp/chrono/time_point.html",
            "wgPageName": "cpp/chrono/time_point",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class Clock,\n    class Duration = typename Clock::duration>\nclass time_point;"
        },
        {
            "title": "std::chrono::ceil(std::chrono::time_point)",
            "path": "en.cppreference.com/w/cpp/chrono/time_point/ceil.html",
            "wgPageName": "cpp/chrono/time_point/ceil",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class ToDuration,\n    class Clock,\n    class Duration>\nconstexpr std::chrono::\n    time_point<Clock, ToDuration>\n    ceil(const std::chrono::\n             time_point<Clock, Duration>& tp);"
        },
        {
            "title": "std::common_type(std::chrono::time_point)",
            "path": "en.cppreference.com/w/cpp/chrono/time_point/common_type.html",
            "wgPageName": "cpp/chrono/time_point/common_type",
            "sample_declaration": "template<\n    class Clock,\n    class Duration1,\n    class Duration2>\nstruct common_type<\n    std::chrono::time_point<Clock, Duration1>,\n    std::chrono::time_point<Clock, Duration2>> {\n  typedef std::chrono::time_point<\n      Clock,\n      typename std::common_type<\n          Duration1,\n          Duration2>::type>\n      type;\n};"
        },
        {
            "title": "std::chrono::floor(std::chrono::time_point)",
            "path": "en.cppreference.com/w/cpp/chrono/time_point/floor.html",
            "wgPageName": "cpp/chrono/time_point/floor",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class ToDuration,\n    class Clock,\n    class Duration>\nconstexpr std::chrono::\n    time_point<Clock, ToDuration>\n    floor(const std::chrono::\n              time_point<Clock, Duration>& tp);"
        },
        {
            "title": "std::chrono::time_point<Clock,Duration>::max",
            "path": "en.cppreference.com/w/cpp/chrono/time_point/max.html",
            "wgPageName": "cpp/chrono/time_point/max",
            "sample_declaration": "static constexpr time_point max();",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::time_point<Clock,Duration>::min",
            "path": "en.cppreference.com/w/cpp/chrono/time_point/min.html",
            "wgPageName": "cpp/chrono/time_point/min",
            "sample_declaration": "static constexpr time_point min();",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::time_point<Clock,Duration>::operator+=, operator-=",
            "path": "en.cppreference.com/w/cpp/chrono/time_point/operator_arith.html",
            "wgPageName": "cpp/chrono/time_point/operator_arith",
            "sample_declaration": "time_point& operator+=(const duration& d);",
            "other_declarations": 3
        },
        {
            "title": "operator+, operator-(std::chrono::time_point)",
            "path": "en.cppreference.com/w/cpp/chrono/time_point/operator_arith2.html",
            "wgPageName": "cpp/chrono/time_point/operator_arith2",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class C, class D1, class R2, class P2>\ntime_point<\n    C,\n    typename std::\n        common_type<D1, duration<R2, P2>>::type>\noperator+(\n    const time_point<C, D1>& pt,\n    const duration<R2, P2>& d);",
            "other_declarations": 7
        },
        {
            "title": "operator==,!=,<,<=,>,>=,<=>(std::chrono::time_point)",
            "path": "en.cppreference.com/w/cpp/chrono/time_point/operator_cmp.html",
            "wgPageName": "cpp/chrono/time_point/operator_cmp",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class Clock, class Dur1, class Dur2>\nbool operator==(\n    const std::chrono::time_point<Clock, Dur1>&\n        lhs,\n    const std::chrono::time_point<Clock, Dur2>&\n        rhs);",
            "other_declarations": 12
        },
        {
            "title": "std::chrono::time_point<Clock,Duration>::operator++, std::chrono::time_point<Clock,Duration>::operator--",
            "path": "en.cppreference.com/w/cpp/chrono/time_point/operator_inc_dec.html",
            "wgPageName": "cpp/chrono/time_point/operator_inc_dec",
            "sample_declaration": "constexpr time_point& operator++();",
            "other_declarations": 3
        },
        {
            "title": "std::chrono::round(std::chrono::time_point)",
            "path": "en.cppreference.com/w/cpp/chrono/time_point/round.html",
            "wgPageName": "cpp/chrono/time_point/round",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class ToDuration,\n    class Clock,\n    class Duration>\nconstexpr std::chrono::\n    time_point<Clock, ToDuration>\n    round(const std::chrono::\n              time_point<Clock, Duration>& tp);"
        },
        {
            "title": "std::chrono::time_point_cast",
            "path": "en.cppreference.com/w/cpp/chrono/time_point/time_point_cast.html",
            "wgPageName": "cpp/chrono/time_point/time_point_cast",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class ToDuration,\n    class Clock,\n    class Duration>\nstd::chrono::time_point<Clock, ToDuration>\ntime_point_cast(const std::chrono::time_point<\n                Clock,\n                Duration>& t);",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::time_point<Clock,Duration>::time_point",
            "path": "en.cppreference.com/w/cpp/chrono/time_point/time_point.html",
            "wgPageName": "cpp/chrono/time_point/time_point",
            "sample_declaration": "time_point();",
            "other_declarations": 5
        },
        {
            "title": "std::chrono::time_point<Clock,Duration>::time_since_epoch",
            "path": "en.cppreference.com/w/cpp/chrono/time_point/time_since_epoch.html",
            "wgPageName": "cpp/chrono/time_point/time_since_epoch",
            "sample_declaration": "duration time_since_epoch() const;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::time_zone_link",
            "path": "en.cppreference.com/w/cpp/chrono/time_zone_link.html",
            "wgPageName": "cpp/chrono/time_zone_link",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class time_zone_link;"
        },
        {
            "title": "std::chrono::time_zone_link::name, std::chrono::time_zone_link::target",
            "path": "en.cppreference.com/w/cpp/chrono/time_zone_link/accessors.html",
            "wgPageName": "cpp/chrono/time_zone_link/accessors",
            "sample_declaration": "std::string_view name() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::operator==,<=>(std::chrono::time_zone_link)",
            "path": "en.cppreference.com/w/cpp/chrono/time_zone_link/operator_cmp.html",
            "wgPageName": "cpp/chrono/time_zone_link/operator_cmp",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "bool operator==(\n    const std::chrono::time_zone_link& x,\n    const std::chrono::time_zone_link&\n        y) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::time_zone",
            "path": "en.cppreference.com/w/cpp/chrono/time_zone.html",
            "wgPageName": "cpp/chrono/time_zone",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class time_zone;"
        },
        {
            "title": "std::chrono::time_zone::get_info",
            "path": "en.cppreference.com/w/cpp/chrono/time_zone/get_info.html",
            "wgPageName": "cpp/chrono/time_zone/get_info",
            "sample_declaration": "template<class Duration>\nstd::chrono::sys_info get_info(\n    const std::chrono::sys_time<Duration>& tp)\n    const;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::time_zone::name",
            "path": "en.cppreference.com/w/cpp/chrono/time_zone/name.html",
            "wgPageName": "cpp/chrono/time_zone/name",
            "sample_declaration": "std::string_view name() const noexcept;"
        },
        {
            "title": "std::chrono::operator==,<=>(std::chrono::time_zone)",
            "path": "en.cppreference.com/w/cpp/chrono/time_zone/operator_cmp.html",
            "wgPageName": "cpp/chrono/time_zone/operator_cmp",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "bool operator==(\n    const std::chrono::time_zone& x,\n    const std::chrono::time_zone& y) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::time_zone::to_local",
            "path": "en.cppreference.com/w/cpp/chrono/time_zone/to_local.html",
            "wgPageName": "cpp/chrono/time_zone/to_local",
            "sample_declaration": "template<class Duration>\nauto to_local(\n    const std::chrono::sys_time<Duration>& tp)\n    const -> std::chrono::local_time<\n        std::common_type_t<\n            Duration,\n            std::chrono::seconds>>;"
        },
        {
            "title": "std::chrono::time_zone::to_sys",
            "path": "en.cppreference.com/w/cpp/chrono/time_zone/to_sys.html",
            "wgPageName": "cpp/chrono/time_zone/to_sys",
            "sample_declaration": "template<class Duration>\nauto to_sys(\n    const std::chrono::local_time<Duration>& tp)\n    const\n    -> std::chrono::sys_time<std::common_type_t<\n        Duration,\n        std::chrono::seconds>>;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::treat_as_floating_point",
            "path": "en.cppreference.com/w/cpp/chrono/treat_as_floating_point.html",
            "wgPageName": "cpp/chrono/treat_as_floating_point",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class Rep>\nstruct treat_as_floating_point\n    : std::is_floating_point<Rep> {};"
        },
        {
            "title": "std::chrono::get_tzdb_list, std::chrono::get_tzdb, std::chrono::remote_version, std::chrono::reload_tzdb",
            "path": "en.cppreference.com/w/cpp/chrono/tzdb_functions.html",
            "wgPageName": "cpp/chrono/tzdb_functions",
            "sample_declaration": "std::chrono::tzdb_list& get_tzdb_list();",
            "other_declarations": 3
        },
        {
            "title": "std::chrono::tzdb_list",
            "path": "en.cppreference.com/w/cpp/chrono/tzdb_list.html",
            "wgPageName": "cpp/chrono/tzdb_list",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class tzdb_list;"
        },
        {
            "title": "std::chrono::tzdb_list::begin",
            "path": "en.cppreference.com/w/cpp/chrono/tzdb_list/begin.html",
            "wgPageName": "cpp/chrono/tzdb_list/begin",
            "sample_declaration": "const_iterator begin() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::tzdb_list::end, std::chrono::tzdb_list::cend",
            "path": "en.cppreference.com/w/cpp/chrono/tzdb_list/end.html",
            "wgPageName": "cpp/chrono/tzdb_list/end",
            "sample_declaration": "const_iterator end() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::tzdb_list::erase_after",
            "path": "en.cppreference.com/w/cpp/chrono/tzdb_list/erase_after.html",
            "wgPageName": "cpp/chrono/tzdb_list/erase_after",
            "sample_declaration": "const_iterator erase_after(const_iterator p);"
        },
        {
            "title": "std::chrono::tzdb_list::front",
            "path": "en.cppreference.com/w/cpp/chrono/tzdb_list/front.html",
            "wgPageName": "cpp/chrono/tzdb_list/front",
            "sample_declaration": "const std::chrono::tzdb& front() const noexcept;"
        },
        {
            "title": "std::chrono::tzdb",
            "path": "en.cppreference.com/w/cpp/chrono/tzdb.html",
            "wgPageName": "cpp/chrono/tzdb",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "struct tzdb;"
        },
        {
            "title": "std::chrono::tzdb::current_zone",
            "path": "en.cppreference.com/w/cpp/chrono/tzdb/current_zone.html",
            "wgPageName": "cpp/chrono/tzdb/current_zone",
            "sample_declaration": "const std::chrono::time_zone* current_zone()\n    const;"
        },
        {
            "title": "std::chrono::tzdb::locate_zone",
            "path": "en.cppreference.com/w/cpp/chrono/tzdb/locate_zone.html",
            "wgPageName": "cpp/chrono/tzdb/locate_zone",
            "sample_declaration": "const std::chrono::time_zone* locate_zone(\n    std::string_view tz_name) const;"
        },
        {
            "title": "std::chrono::utc_clock",
            "path": "en.cppreference.com/w/cpp/chrono/utc_clock.html",
            "wgPageName": "cpp/chrono/utc_clock",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class utc_clock;"
        },
        {
            "title": "std::formatter<std::chrono::utc_time>",
            "path": "en.cppreference.com/w/cpp/chrono/utc_clock/formatter.html",
            "wgPageName": "cpp/chrono/utc_clock/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class Duration, class CharT>\nstruct formatter<\n    std::chrono::utc_time<Duration>,\n    CharT>;"
        },
        {
            "title": "std::chrono::from_stream (std::chrono::utc_time)",
            "path": "en.cppreference.com/w/cpp/chrono/utc_clock/from_stream.html",
            "wgPageName": "cpp/chrono/utc_clock/from_stream",
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Duration,\n    class Alloc = std::allocator<CharT> >\nstd::basic_istream<CharT, Traits>& from_stream(\n    std::basic_istream<CharT, Traits>& is,\n    const CharT* fmt,\n    std::chrono::utc_time<Duration>& tp,\n    std::basic_string<CharT, Traits, Alloc>*\n        abbrev = nullptr,\n    std::chrono::minutes* offset = nullptr);"
        },
        {
            "title": "std::chrono::utc_clock::from_sys",
            "path": "en.cppreference.com/w/cpp/chrono/utc_clock/from_sys.html",
            "wgPageName": "cpp/chrono/utc_clock/from_sys",
            "sample_declaration": "template<class Duration>\nstatic std::chrono::utc_time<std::common_type_t<\n    Duration,\n    std::chrono::seconds>>\nfrom_sys(\n    const std::chrono::sys_time<Duration>& t);"
        },
        {
            "title": "std::chrono::get_leap_second_info",
            "path": "en.cppreference.com/w/cpp/chrono/utc_clock/get_leap_second_info.html",
            "wgPageName": "cpp/chrono/utc_clock/get_leap_second_info",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class Duration>\nstd::chrono::leap_second_info\nget_leap_second_info(\n    const std::chrono::utc_time<Duration>& ut);"
        },
        {
            "title": "std::chrono::leap_second_info",
            "path": "en.cppreference.com/w/cpp/chrono/utc_clock/leap_second_info.html",
            "wgPageName": "cpp/chrono/utc_clock/leap_second_info",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "struct leap_second_info {\n  bool is_leap_second;\n  std::chrono::seconds elapsed;\n};"
        },
        {
            "title": "std::chrono::utc_clock::now",
            "path": "en.cppreference.com/w/cpp/chrono/utc_clock/now.html",
            "wgPageName": "cpp/chrono/utc_clock/now",
            "sample_declaration": "static std::chrono::time_point<\n    std::chrono::utc_clock>\nnow();"
        },
        {
            "title": "std::chrono::operator<<(std::chrono::utc_time)",
            "path": "en.cppreference.com/w/cpp/chrono/utc_clock/operator_ltlt.html",
            "wgPageName": "cpp/chrono/utc_clock/operator_ltlt",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Duration>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::utc_time<Duration>& tp);"
        },
        {
            "title": "std::chrono::utc_clock::to_sys",
            "path": "en.cppreference.com/w/cpp/chrono/utc_clock/to_sys.html",
            "wgPageName": "cpp/chrono/utc_clock/to_sys",
            "sample_declaration": "template<class Duration>\nstatic std::chrono::sys_time<std::common_type_t<\n    Duration,\n    std::chrono::seconds>>\nto_sys(\n    const std::chrono::utc_time<Duration>& t);"
        },
        {
            "title": "std::chrono::weekday_indexed",
            "path": "en.cppreference.com/w/cpp/chrono/weekday_indexed.html",
            "wgPageName": "cpp/chrono/weekday_indexed",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class weekday_indexed;"
        },
        {
            "title": "std::formatter<std::chrono::weekday_indexed>",
            "path": "en.cppreference.com/w/cpp/chrono/weekday_indexed/formatter.html",
            "wgPageName": "cpp/chrono/weekday_indexed/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT>\nstruct formatter<\n    std::chrono::weekday_indexed,\n    CharT>;"
        },
        {
            "title": "std::chrono::weekday_indexed::index",
            "path": "en.cppreference.com/w/cpp/chrono/weekday_indexed/index.html",
            "wgPageName": "cpp/chrono/weekday_indexed/index",
            "sample_declaration": "constexpr unsigned index() const noexcept;"
        },
        {
            "title": "std::chrono::weekday_indexed::ok",
            "path": "en.cppreference.com/w/cpp/chrono/weekday_indexed/ok.html",
            "wgPageName": "cpp/chrono/weekday_indexed/ok",
            "sample_declaration": "constexpr bool ok() const noexcept;"
        },
        {
            "title": "std::chrono::operator==(std::chrono::weekday_indexed)",
            "path": "en.cppreference.com/w/cpp/chrono/weekday_indexed/operator_cmp.html",
            "wgPageName": "cpp/chrono/weekday_indexed/operator_cmp",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr bool operator==(\n    const std::chrono::weekday_indexed& x,\n    const std::chrono::weekday_indexed&\n        y) noexcept;"
        },
        {
            "title": "std::chrono::operator<<(std::chrono::weekday_indexed)",
            "path": "en.cppreference.com/w/cpp/chrono/weekday_indexed/operator_ltlt.html",
            "wgPageName": "cpp/chrono/weekday_indexed/operator_ltlt",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::weekday_indexed& wdi);"
        },
        {
            "title": "std::chrono::weekday_indexed::weekday_indexed",
            "path": "en.cppreference.com/w/cpp/chrono/weekday_indexed/weekday_indexed.html",
            "wgPageName": "cpp/chrono/weekday_indexed/weekday_indexed",
            "sample_declaration": "weekday_indexed() = default;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::weekday_indexed::weekday",
            "path": "en.cppreference.com/w/cpp/chrono/weekday_indexed/weekday.html",
            "wgPageName": "cpp/chrono/weekday_indexed/weekday",
            "sample_declaration": "constexpr std::chrono::weekday weekday()\n    const noexcept;"
        },
        {
            "title": "std::chrono::weekday_last",
            "path": "en.cppreference.com/w/cpp/chrono/weekday_last.html",
            "wgPageName": "cpp/chrono/weekday_last",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class weekday_last;"
        },
        {
            "title": "std::formatter<std::chrono::weekday_last>",
            "path": "en.cppreference.com/w/cpp/chrono/weekday_last/formatter.html",
            "wgPageName": "cpp/chrono/weekday_last/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT>\nstruct formatter<\n    std::chrono::weekday_last,\n    CharT>;"
        },
        {
            "title": "std::chrono::weekday_last::ok",
            "path": "en.cppreference.com/w/cpp/chrono/weekday_last/ok.html",
            "wgPageName": "cpp/chrono/weekday_last/ok",
            "sample_declaration": "constexpr bool ok() const noexcept;"
        },
        {
            "title": "std::chrono::operator==(std::chrono::weekday_last)",
            "path": "en.cppreference.com/w/cpp/chrono/weekday_last/operator_cmp.html",
            "wgPageName": "cpp/chrono/weekday_last/operator_cmp",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr bool operator==(\n    const std::chrono::weekday_last& x,\n    const std::chrono::weekday_last&\n        y) noexcept;"
        },
        {
            "title": "std::chrono::operator<<(std::chrono::weekday_last)",
            "path": "en.cppreference.com/w/cpp/chrono/weekday_last/operator_ltlt.html",
            "wgPageName": "cpp/chrono/weekday_last/operator_ltlt",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::weekday_last& wdl);"
        },
        {
            "title": "std::chrono::weekday_last::weekday_last",
            "path": "en.cppreference.com/w/cpp/chrono/weekday_last/weekday_last.html",
            "wgPageName": "cpp/chrono/weekday_last/weekday_last",
            "sample_declaration": "explicit constexpr weekday_last(\n    const std::chrono::weekday& wd) noexcept;"
        },
        {
            "title": "std::chrono::weekday_last::weekday",
            "path": "en.cppreference.com/w/cpp/chrono/weekday_last/weekday.html",
            "wgPageName": "cpp/chrono/weekday_last/weekday",
            "sample_declaration": "constexpr std::chrono::weekday weekday()\n    const noexcept;"
        },
        {
            "title": "std::chrono::weekday",
            "path": "en.cppreference.com/w/cpp/chrono/weekday.html",
            "wgPageName": "cpp/chrono/weekday",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class weekday;",
            "other_declarations": 7
        },
        {
            "title": "std::chrono::weekday::c_encoding, std::chrono::weekday::iso_encoding",
            "path": "en.cppreference.com/w/cpp/chrono/weekday/encoding.html",
            "wgPageName": "cpp/chrono/weekday/encoding",
            "sample_declaration": "constexpr unsigned c_encoding() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::formatter<std::chrono::weekday>",
            "path": "en.cppreference.com/w/cpp/chrono/weekday/formatter.html",
            "wgPageName": "cpp/chrono/weekday/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT>\nstruct formatter<std::chrono::weekday, CharT>;"
        },
        {
            "title": "std::chrono::from_stream (std::chrono::weekday)",
            "path": "en.cppreference.com/w/cpp/chrono/weekday/from_stream.html",
            "wgPageName": "cpp/chrono/weekday/from_stream",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Alloc = std::allocator<CharT> >\nstd::basic_istream<CharT, Traits>& from_stream(\n    std::basic_istream<CharT, Traits>& is,\n    const CharT* fmt,\n    std::chrono::weekday& wd,\n    std::basic_string<CharT, Traits, Alloc>*\n        abbrev = nullptr,\n    std::chrono::minutes* offset = nullptr);"
        },
        {
            "title": "std::chrono::weekday::ok",
            "path": "en.cppreference.com/w/cpp/chrono/weekday/ok.html",
            "wgPageName": "cpp/chrono/weekday/ok",
            "sample_declaration": "constexpr bool ok() const noexcept;"
        },
        {
            "title": "std::chrono::operator+, std::chrono::operator- (std::chrono::weekday)",
            "path": "en.cppreference.com/w/cpp/chrono/weekday/operator_arith_2.html",
            "wgPageName": "cpp/chrono/weekday/operator_arith_2",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr std::chrono::weekday operator+(\n    const std::chrono::weekday& wd,\n    const std::chrono::days& d) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::chrono::weekday::operator+=, std::chrono::weekday::operator-=",
            "path": "en.cppreference.com/w/cpp/chrono/weekday/operator_arith.html",
            "wgPageName": "cpp/chrono/weekday/operator_arith",
            "sample_declaration": "constexpr std::chrono::weekday& operator+=(\n    const std::chrono::days& d) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::weekday::operator[]",
            "path": "en.cppreference.com/w/cpp/chrono/weekday/operator_at.html",
            "wgPageName": "cpp/chrono/weekday/operator_at",
            "sample_declaration": "constexpr std::chrono::weekday_indexed\noperator[](unsigned index) const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::operator==(std::chrono::weekday)",
            "path": "en.cppreference.com/w/cpp/chrono/weekday/operator_cmp.html",
            "wgPageName": "cpp/chrono/weekday/operator_cmp",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr bool operator==(\n    const std::chrono::weekday& x,\n    const std::chrono::weekday& y) noexcept;"
        },
        {
            "title": "std::chrono::weekday::operator++, std::chrono::weekday::operator--",
            "path": "en.cppreference.com/w/cpp/chrono/weekday/operator_inc_dec.html",
            "wgPageName": "cpp/chrono/weekday/operator_inc_dec",
            "sample_declaration": "constexpr std::chrono::weekday&\noperator++() noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::chrono::operator<<(std::chrono::weekday)",
            "path": "en.cppreference.com/w/cpp/chrono/weekday/operator_ltlt.html",
            "wgPageName": "cpp/chrono/weekday/operator_ltlt",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::weekday& wd);"
        },
        {
            "title": "std::chrono::weekday::weekday",
            "path": "en.cppreference.com/w/cpp/chrono/weekday/weekday.html",
            "wgPageName": "cpp/chrono/weekday/weekday",
            "sample_declaration": "weekday() = default;",
            "other_declarations": 3
        },
        {
            "title": "std::chrono::year_month_day_last",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_day_last.html",
            "wgPageName": "cpp/chrono/year_month_day_last",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class year_month_day_last;"
        },
        {
            "title": "std::chrono::year_month_day_last::year, std::chrono::year_month_day_last::month, std::chrono::year_month_day_last::day, std::chrono::year_month_day_last::month_day_last",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_day_last/accessors.html",
            "wgPageName": "cpp/chrono/year_month_day_last/accessors",
            "sample_declaration": "constexpr std::chrono::year year()\n    const noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::formatter<std::chrono::year_month_day_last>",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_day_last/formatter.html",
            "wgPageName": "cpp/chrono/year_month_day_last/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT>\nstruct formatter<\n    std::chrono::year_month_day_last,\n    CharT>;"
        },
        {
            "title": "std::chrono::year_month_day_last::ok",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_day_last/ok.html",
            "wgPageName": "cpp/chrono/year_month_day_last/ok",
            "sample_declaration": "constexpr bool ok() const noexcept;"
        },
        {
            "title": "std::chrono::operator+, std::chrono::operator- (std::chrono::year_month_day_last)",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_day_last/operator_arith_2.html",
            "wgPageName": "cpp/chrono/year_month_day_last/operator_arith_2",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr std::chrono::year_month_day_last\noperator+(\n    const std::chrono::year_month_day_last&\n        ymdl,\n    const std::chrono::months& dm) noexcept;",
            "other_declarations": 5
        },
        {
            "title": "std::chrono::year_month_day_last::operator+=, std::chrono::year_month_day_last::operator-=",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_day_last/operator_arith.html",
            "wgPageName": "cpp/chrono/year_month_day_last/operator_arith",
            "sample_declaration": "constexpr std::chrono::year_month_day_last&\noperator+=(const std::chrono::years& dy)\n    const noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::chrono::operator==,<=>(std::chrono::year_month_day_last)",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_day_last/operator_cmp.html",
            "wgPageName": "cpp/chrono/year_month_day_last/operator_cmp",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr bool operator==(\n    const std::chrono::year_month_day_last& x,\n    const std::chrono::year_month_day_last&\n        y) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::year_month_day_last::operator sys_days, std::chrono::year_month_day_last::operator local_days",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_day_last/operator_days.html",
            "wgPageName": "cpp/chrono/year_month_day_last/operator_days",
            "sample_declaration": "constexpr operator std::chrono::sys_days()\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::operator<<(std::chrono::year_month_day_last)",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_day_last/operator_ltlt.html",
            "wgPageName": "cpp/chrono/year_month_day_last/operator_ltlt",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::year_month_day_last&\n        ymdl);"
        },
        {
            "title": "std::chrono::year_month_day_last::year_month_day_last",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_day_last/year_month_day_last.html",
            "wgPageName": "cpp/chrono/year_month_day_last/year_month_day_last",
            "sample_declaration": "constexpr year_month_day_last(\n    const std::chrono::year& y,\n    const std::chrono::month_day_last&\n        mdl) noexcept;"
        },
        {
            "title": "std::chrono::year_month_day",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_day.html",
            "wgPageName": "cpp/chrono/year_month_day",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class year_month_day;"
        },
        {
            "title": "std::chrono::year_month_day::year, std::chrono::year_month_day::month, std::chrono::year_month_day::day",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_day/accessors.html",
            "wgPageName": "cpp/chrono/year_month_day/accessors",
            "sample_declaration": "constexpr std::chrono::year year()\n    const noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::formatter<std::chrono::year_month_day>",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_day/formatter.html",
            "wgPageName": "cpp/chrono/year_month_day/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT>\nstruct formatter<\n    std::chrono::year_month_day,\n    CharT>;"
        },
        {
            "title": "std::chrono::from_stream (std::chrono::year_month_day)",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_day/from_stream.html",
            "wgPageName": "cpp/chrono/year_month_day/from_stream",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Alloc = std::allocator<CharT> >\nstd::basic_istream<CharT, Traits>& from_stream(\n    std::basic_istream<CharT, Traits>& is,\n    const CharT* fmt,\n    std::chrono::year_month_day& ymd,\n    std::basic_string<CharT, Traits, Alloc>*\n        abbrev = nullptr,\n    std::chrono::minutes* offset = nullptr);"
        },
        {
            "title": "std::chrono::year_month_day::ok",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_day/ok.html",
            "wgPageName": "cpp/chrono/year_month_day/ok",
            "sample_declaration": "constexpr bool ok() const noexcept;"
        },
        {
            "title": "std::chrono::operator+, std::chrono::operator- (std::chrono::year_month_day)",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_day/operator_arith_2.html",
            "wgPageName": "cpp/chrono/year_month_day/operator_arith_2",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr std::chrono::year_month_day operator+(\n    const std::chrono::year_month_day& ymd,\n    const std::chrono::months& dm) noexcept;",
            "other_declarations": 5
        },
        {
            "title": "std::chrono::year_month_day::operator+=, std::chrono::year_month_day::operator-=",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_day/operator_arith.html",
            "wgPageName": "cpp/chrono/year_month_day/operator_arith",
            "sample_declaration": "constexpr std::chrono::year_month_day&\noperator+=(const std::chrono::years& dy)\n    const noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::chrono::operator==,<=>(std::chrono::year_month_day)",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_day/operator_cmp.html",
            "wgPageName": "cpp/chrono/year_month_day/operator_cmp",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr bool operator==(\n    const std::chrono::year_month_day& x,\n    const std::chrono::year_month_day&\n        y) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::year_month_day::operator sys_days, std::chrono::year_month_day::operator local_days",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_day/operator_days.html",
            "wgPageName": "cpp/chrono/year_month_day/operator_days",
            "sample_declaration": "constexpr operator std::chrono::sys_days()\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::operator<<(std::chrono::year_month_day)",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_day/operator_ltlt.html",
            "wgPageName": "cpp/chrono/year_month_day/operator_ltlt",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::year_month_day& ymd);"
        },
        {
            "title": "std::chrono::year_month_day::year_month_day",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_day/year_month_day.html",
            "wgPageName": "cpp/chrono/year_month_day/year_month_day",
            "sample_declaration": "year_month_day() = default;",
            "other_declarations": 4
        },
        {
            "title": "std::chrono::year_month_weekday_last",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_weekday_last.html",
            "wgPageName": "cpp/chrono/year_month_weekday_last",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class year_month_weekday_last;"
        },
        {
            "title": "std::chrono::year_month_weekday_last::year, std::chrono::year_month_weekday_last::month, std::chrono::year_month_weekday_last::weekday, std::chrono::year_month_weekday_last::weekday_last",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_weekday_last/accessors.html",
            "wgPageName": "cpp/chrono/year_month_weekday_last/accessors",
            "sample_declaration": "constexpr std::chrono::year year()\n    const noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::formatter<std::chrono::year_month_weekday_last>",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_weekday_last/formatter.html",
            "wgPageName": "cpp/chrono/year_month_weekday_last/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT>\nstruct formatter<\n    std::chrono::year_month_weekday_last,\n    CharT>;"
        },
        {
            "title": "std::chrono::year_month_weekday_last::ok",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_weekday_last/ok.html",
            "wgPageName": "cpp/chrono/year_month_weekday_last/ok",
            "sample_declaration": "constexpr bool ok() const noexcept;"
        },
        {
            "title": "std::chrono::operator+, std::chrono::operator- (std::chrono::year_month_weekday_last)",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_weekday_last/operator_arith_2.html",
            "wgPageName": "cpp/chrono/year_month_weekday_last/operator_arith_2",
            "sample_declaration": "constexpr std::chrono::year_month_weekday_last\noperator+(\n    const std::chrono::year_month_weekday_last&\n        ymwdl,\n    const std::chrono::months& dm) noexcept;",
            "other_declarations": 5
        },
        {
            "title": "std::chrono::year_month_weekday_last::operator+=, std::chrono::year_month_weekday_last::operator-=",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_weekday_last/operator_arith.html",
            "wgPageName": "cpp/chrono/year_month_weekday_last/operator_arith",
            "sample_declaration": "constexpr std::chrono::year_month_weekday_last&\noperator+=(const std::chrono::years& dy)\n    const noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::chrono::operator==(std::chrono::year_month_weekday_last)",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_weekday_last/operator_cmp.html",
            "wgPageName": "cpp/chrono/year_month_weekday_last/operator_cmp",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr bool operator==(\n    const std::chrono::year_month_weekday_last&\n        x,\n    const std::chrono::year_month_weekday_last&\n        y) noexcept;"
        },
        {
            "title": "std::chrono::year_month_weekday_last::operator sys_days, std::chrono::year_month_weekday_last::operator local_days",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_weekday_last/operator_days.html",
            "wgPageName": "cpp/chrono/year_month_weekday_last/operator_days",
            "sample_declaration": "constexpr operator std::chrono::sys_days()\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::operator<<(std::chrono::year_month_weekday_last)",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_weekday_last/operator_ltlt.html",
            "wgPageName": "cpp/chrono/year_month_weekday_last/operator_ltlt",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::year_month_weekday_last&\n        ymwdl);"
        },
        {
            "title": "std::chrono::year_month_weekday_last::year_month_weekday_last",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_weekday_last/year_month_weekday_last.html",
            "wgPageName": "cpp/chrono/year_month_weekday_last/year_month_weekday_last",
            "sample_declaration": "constexpr year_month_weekday_last(\n    const std::chrono::year& y,\n    const std::chrono::month& m,\n    const std::chrono::weekday_last&\n        wdl) noexcept;"
        },
        {
            "title": "std::chrono::year_month_weekday",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_weekday.html",
            "wgPageName": "cpp/chrono/year_month_weekday",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class year_month_weekday;"
        },
        {
            "title": "std::chrono::year_month_weekday::year, std::chrono::year_month_weekday::month, std::chrono::year_month_weekday::weekday, std::chrono::year_month_weekday::index, std::chrono::year_month_weekday::weekday_indexed",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_weekday/accessors.html",
            "wgPageName": "cpp/chrono/year_month_weekday/accessors",
            "sample_declaration": "constexpr std::chrono::year year()\n    const noexcept;",
            "other_declarations": 4
        },
        {
            "title": "std::formatter<std::chrono::year_month_weekday>",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_weekday/formatter.html",
            "wgPageName": "cpp/chrono/year_month_weekday/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT>\nstruct formatter<\n    std::chrono::year_month_weekday,\n    CharT>;"
        },
        {
            "title": "std::chrono::year_month_weekday::ok",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_weekday/ok.html",
            "wgPageName": "cpp/chrono/year_month_weekday/ok",
            "sample_declaration": "constexpr bool ok() const noexcept;"
        },
        {
            "title": "std::chrono::operator+, std::chrono::operator- (std::chrono::year_month_weekday)",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_weekday/operator_arith_2.html",
            "wgPageName": "cpp/chrono/year_month_weekday/operator_arith_2",
            "sample_declaration": "constexpr std::chrono::year_month_weekday\noperator+(\n    const std::chrono::year_month_weekday& ymwd,\n    const std::chrono::months& dm) noexcept;",
            "other_declarations": 5
        },
        {
            "title": "std::chrono::year_month_weekday::operator+=, std::chrono::year_month_weekday::operator-=",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_weekday/operator_arith.html",
            "wgPageName": "cpp/chrono/year_month_weekday/operator_arith",
            "sample_declaration": "constexpr std::chrono::year_month_weekday&\noperator+=(const std::chrono::years& dy)\n    const noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::chrono::operator==(std::chrono::year_month_weekday)",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_weekday/operator_cmp.html",
            "wgPageName": "cpp/chrono/year_month_weekday/operator_cmp",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr bool operator==(\n    const std::chrono::year_month_weekday& x,\n    const std::chrono::year_month_weekday&\n        y) noexcept;"
        },
        {
            "title": "std::chrono::year_month_weekday::operator sys_days, std::chrono::year_month_weekday::operator local_days",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_weekday/operator_days.html",
            "wgPageName": "cpp/chrono/year_month_weekday/operator_days",
            "sample_declaration": "constexpr operator std::chrono::sys_days()\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::operator<<(std::chrono::year_month_weekday)",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_weekday/operator_ltlt.html",
            "wgPageName": "cpp/chrono/year_month_weekday/operator_ltlt",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::year_month_weekday&\n        ymwd);"
        },
        {
            "title": "std::chrono::year_month_weekday::year_month_weekday",
            "path": "en.cppreference.com/w/cpp/chrono/year_month_weekday/year_month_weekday.html",
            "wgPageName": "cpp/chrono/year_month_weekday/year_month_weekday",
            "sample_declaration": "year_month_weekday() = default;",
            "other_declarations": 3
        },
        {
            "title": "std::chrono::year_month",
            "path": "en.cppreference.com/w/cpp/chrono/year_month.html",
            "wgPageName": "cpp/chrono/year_month",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class year_month;"
        },
        {
            "title": "std::chrono::year_month::year, std::chrono::year_month::month",
            "path": "en.cppreference.com/w/cpp/chrono/year_month/accessors.html",
            "wgPageName": "cpp/chrono/year_month/accessors",
            "sample_declaration": "constexpr std::chrono::year year()\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::formatter<std::chrono::year_month>",
            "path": "en.cppreference.com/w/cpp/chrono/year_month/formatter.html",
            "wgPageName": "cpp/chrono/year_month/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT>\nstruct formatter<\n    std::chrono::year_month,\n    CharT>;"
        },
        {
            "title": "std::chrono::from_stream (std::chrono::year_month)",
            "path": "en.cppreference.com/w/cpp/chrono/year_month/from_stream.html",
            "wgPageName": "cpp/chrono/year_month/from_stream",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Alloc = std::allocator<CharT> >\nstd::basic_istream<CharT, Traits>& from_stream(\n    std::basic_istream<CharT, Traits>& is,\n    const CharT* fmt,\n    std::chrono::year_month& ym,\n    std::basic_string<CharT, Traits, Alloc>*\n        abbrev = nullptr,\n    std::chrono::minutes* offset = nullptr);"
        },
        {
            "title": "std::chrono::year_month::ok",
            "path": "en.cppreference.com/w/cpp/chrono/year_month/ok.html",
            "wgPageName": "cpp/chrono/year_month/ok",
            "sample_declaration": "constexpr bool ok() const noexcept;"
        },
        {
            "title": "std::chrono::operator+, std::chrono::operator- (std::chrono::year_month)",
            "path": "en.cppreference.com/w/cpp/chrono/year_month/operator_arith_2.html",
            "wgPageName": "cpp/chrono/year_month/operator_arith_2",
            "sample_declaration": "constexpr std::chrono::year_month operator+(\n    const std::chrono::year_month& ym,\n    const std::chrono::years& dy) noexcept;",
            "other_declarations": 6
        },
        {
            "title": "std::chrono::year_month::operator+=, std::chrono::year_month::operator-=",
            "path": "en.cppreference.com/w/cpp/chrono/year_month/operator_arith.html",
            "wgPageName": "cpp/chrono/year_month/operator_arith",
            "sample_declaration": "constexpr std::chrono::year_month& operator+=(\n    const std::chrono::years& dy)\n    const noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::chrono::operator==,<=>(std::chrono::year_month)",
            "path": "en.cppreference.com/w/cpp/chrono/year_month/operator_cmp.html",
            "wgPageName": "cpp/chrono/year_month/operator_cmp",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr bool operator==(\n    const std::chrono::year_month& x,\n    const std::chrono::year_month& y) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::operator<<(std::chrono::year_month)",
            "path": "en.cppreference.com/w/cpp/chrono/year_month/operator_ltlt.html",
            "wgPageName": "cpp/chrono/year_month/operator_ltlt",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::year_month& ym);"
        },
        {
            "title": "std::chrono::year_month::year_month",
            "path": "en.cppreference.com/w/cpp/chrono/year_month/year_month.html",
            "wgPageName": "cpp/chrono/year_month/year_month",
            "sample_declaration": "year_month() = default;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::year",
            "path": "en.cppreference.com/w/cpp/chrono/year.html",
            "wgPageName": "cpp/chrono/year",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "class year;"
        },
        {
            "title": "std::formatter<std::chrono::year>",
            "path": "en.cppreference.com/w/cpp/chrono/year/formatter.html",
            "wgPageName": "cpp/chrono/year/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT>\nstruct formatter<std::chrono::year, CharT>;"
        },
        {
            "title": "std::chrono::from_stream (std::chrono::year)",
            "path": "en.cppreference.com/w/cpp/chrono/year/from_stream.html",
            "wgPageName": "cpp/chrono/year/from_stream",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Alloc = std::allocator<CharT> >\nstd::basic_istream<CharT, Traits>& from_stream(\n    std::basic_istream<CharT, Traits>& is,\n    const CharT* fmt,\n    std::chrono::year& y,\n    std::basic_string<CharT, Traits, Alloc>*\n        abbrev = nullptr,\n    std::chrono::minutes* offset = nullptr);"
        },
        {
            "title": "std::chrono::year::is_leap",
            "path": "en.cppreference.com/w/cpp/chrono/year/is_leap.html",
            "wgPageName": "cpp/chrono/year/is_leap",
            "sample_declaration": "constexpr bool is_leap() const noexcept;"
        },
        {
            "title": "std::chrono::year::max",
            "path": "en.cppreference.com/w/cpp/chrono/year/max.html",
            "wgPageName": "cpp/chrono/year/max",
            "sample_declaration": "static constexpr year max() noexcept;"
        },
        {
            "title": "std::chrono::year::min",
            "path": "en.cppreference.com/w/cpp/chrono/year/min.html",
            "wgPageName": "cpp/chrono/year/min",
            "sample_declaration": "static constexpr std::chrono::year\nmin() noexcept;"
        },
        {
            "title": "std::chrono::year::ok",
            "path": "en.cppreference.com/w/cpp/chrono/year/ok.html",
            "wgPageName": "cpp/chrono/year/ok",
            "sample_declaration": "constexpr bool ok() const noexcept;"
        },
        {
            "title": "std::chrono::operator+, std::chrono::operator- (std::chrono::year)",
            "path": "en.cppreference.com/w/cpp/chrono/year/operator_arith_2.html",
            "wgPageName": "cpp/chrono/year/operator_arith_2",
            "sample_declaration": "constexpr std::chrono::year operator+(\n    const std::chrono::year& y,\n    const std::chrono::years& ys) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::chrono::year::operator+=, std::chrono::year::operator-=",
            "path": "en.cppreference.com/w/cpp/chrono/year/operator_arith.html",
            "wgPageName": "cpp/chrono/year/operator_arith",
            "sample_declaration": "constexpr std::chrono::year& operator+=(\n    const std::chrono::years& y) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::operator==,<=>(std::chrono::year)",
            "path": "en.cppreference.com/w/cpp/chrono/year/operator_cmp.html",
            "wgPageName": "cpp/chrono/year/operator_cmp",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "constexpr bool operator==(\n    const std::chrono::year& x,\n    const std::chrono::year& y) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::year::operator++, std::chrono::year::operator--",
            "path": "en.cppreference.com/w/cpp/chrono/year/operator_inc_dec.html",
            "wgPageName": "cpp/chrono/year/operator_inc_dec",
            "sample_declaration": "constexpr std::chrono::year&\noperator++() noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::chrono::year::operator int",
            "path": "en.cppreference.com/w/cpp/chrono/year/operator_int.html",
            "wgPageName": "cpp/chrono/year/operator_int",
            "sample_declaration": "explicit constexpr operator int()\n    const noexcept;"
        },
        {
            "title": "std::chrono::operator<<(std::chrono::year)",
            "path": "en.cppreference.com/w/cpp/chrono/year/operator_ltlt.html",
            "wgPageName": "cpp/chrono/year/operator_ltlt",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::year& y);"
        },
        {
            "title": "std::chrono::year::operator+, std::chrono::year::operator-",
            "path": "en.cppreference.com/w/cpp/chrono/year/operator_sign.html",
            "wgPageName": "cpp/chrono/year/operator_sign",
            "sample_declaration": "constexpr std::chrono::year\noperator+() noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::year::year",
            "path": "en.cppreference.com/w/cpp/chrono/year/year.html",
            "wgPageName": "cpp/chrono/year/year",
            "sample_declaration": "year() = default;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::zoned_time",
            "path": "en.cppreference.com/w/cpp/chrono/zoned_time.html",
            "wgPageName": "cpp/chrono/zoned_time",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class Duration,\n    class TimeZonePtr =\n        const std::chrono::time_zone*>\nclass zoned_time;",
            "other_declarations": 1
        },
        {
            "title": "Deduction guides for std::chrono::zoned_time",
            "path": "en.cppreference.com/w/cpp/chrono/zoned_time/deduction_guides.html",
            "wgPageName": "cpp/chrono/zoned_time/deduction_guides",
            "sample_declaration": "zoned_time()->zoned_time<std::chrono::seconds>;",
            "other_declarations": 5
        },
        {
            "title": "std::formatter<std::chrono::zoned_time>",
            "path": "en.cppreference.com/w/cpp/chrono/zoned_time/formatter.html",
            "wgPageName": "cpp/chrono/zoned_time/formatter",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class Duration,\n    class TimeZonePtr,\n    class CharT>\nstruct formatter<\n    std::chrono::\n        zoned_time<Duration, TimeZonePtr>,\n    CharT>\n    : std::formatter<\n          /*local-time-format-t*/<Duration>,\n          CharT>"
        },
        {
            "title": "std::chrono::zoned_time<Duration,TimeZonePtr>::get_info",
            "path": "en.cppreference.com/w/cpp/chrono/zoned_time/get_info.html",
            "wgPageName": "cpp/chrono/zoned_time/get_info",
            "sample_declaration": "std::chrono::sys_info get_info() const;"
        },
        {
            "title": "std::chrono::zoned_time<Duration,TimeZonePtr>::operator local_time<duration>, std::chrono::zoned_time<Duration,TimeZonePtr>::get_local_time",
            "path": "en.cppreference.com/w/cpp/chrono/zoned_time/get_local_time.html",
            "wgPageName": "cpp/chrono/zoned_time/get_local_time",
            "sample_declaration": "std::chrono::local_time<duration>\nget_local_time() const;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::zoned_time<Duration,TimeZonePtr>::operator sys_time<duration>, std::chrono::zoned_time<Duration,TimeZonePtr>::get_sys_time",
            "path": "en.cppreference.com/w/cpp/chrono/zoned_time/get_sys_time.html",
            "wgPageName": "cpp/chrono/zoned_time/get_sys_time",
            "sample_declaration": "operator std::chrono::sys_time<duration>()\n    const;",
            "other_declarations": 1
        },
        {
            "title": "std::chrono::zoned_time<Duration,TimeZonePtr>::get_time_zone",
            "path": "en.cppreference.com/w/cpp/chrono/zoned_time/get_time_zone.html",
            "wgPageName": "cpp/chrono/zoned_time/get_time_zone",
            "sample_declaration": "TimeZonePtr get_time_zone() const;"
        },
        {
            "title": "std::chrono::operator==(std::chrono::zoned_time)",
            "path": "en.cppreference.com/w/cpp/chrono/zoned_time/operator_cmp.html",
            "wgPageName": "cpp/chrono/zoned_time/operator_cmp",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class Duration1,\n    class Duration2,\n    class TimeZonePtr>\nbool operator==(\n    const std::chrono::\n        zoned_time<Duration1, TimeZonePtr>& x,\n    const std::chrono::\n        zoned_time<Duration2, TimeZonePtr>& y);"
        },
        {
            "title": "std::chrono::operator<<(std::chrono::zoned_time)",
            "path": "en.cppreference.com/w/cpp/chrono/zoned_time/operator_ltlt.html",
            "wgPageName": "cpp/chrono/zoned_time/operator_ltlt",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Duration,\n    class TimeZonePtr>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::chrono::\n        zoned_time<Duration, TimeZonePtr>& tp);"
        },
        {
            "title": "std::chrono::zoned_time<Duration,TimeZonePtr>::operator=",
            "path": "en.cppreference.com/w/cpp/chrono/zoned_time/operator=.html",
            "wgPageName": "cpp/chrono/zoned_time/operator=",
            "sample_declaration": "zoned_time& operator=(const zoned_time& other) =\n    default;",
            "other_declarations": 2
        },
        {
            "title": "std::chrono::zoned_time<Duration,TimeZonePtr>::zoned_time",
            "path": "en.cppreference.com/w/cpp/chrono/zoned_time/zoned_time.html",
            "wgPageName": "cpp/chrono/zoned_time/zoned_time",
            "sample_declaration": "zoned_time();",
            "other_declarations": 15
        },
        {
            "title": "std::chrono::zoned_traits",
            "path": "en.cppreference.com/w/cpp/chrono/zoned_traits.html",
            "wgPageName": "cpp/chrono/zoned_traits",
            "headers": [
                "<chrono>"
            ],
            "sample_declaration": "template<class TimeZonePtr>\nstruct zoned_traits {};",
            "other_declarations": 1
        },
        {
            "title": "Comments",
            "path": "en.cppreference.com/w/cpp/comment.html",
            "wgPageName": "cpp/comment"
        },
        {
            "title": "Comments",
            "path": "en.cppreference.com/w/cpp/comments.html",
            "wgPageName": "cpp/comment"
        },
        {
            "title": "C++ compiler support",
            "path": "en.cppreference.com/w/cpp/compiler_support.html",
            "wgPageName": "cpp/compiler_support"
        },
        {
            "title": "Compiler support for C++11",
            "path": "en.cppreference.com/w/cpp/compiler_support/11.html",
            "wgPageName": "cpp/compiler_support/11"
        },
        {
            "title": "Compiler support for C++14",
            "path": "en.cppreference.com/w/cpp/compiler_support/14.html",
            "wgPageName": "cpp/compiler_support/14"
        },
        {
            "title": "Compiler support for C++17",
            "path": "en.cppreference.com/w/cpp/compiler_support/17.html",
            "wgPageName": "cpp/compiler_support/17"
        },
        {
            "title": "Compiler support for C++20",
            "path": "en.cppreference.com/w/cpp/compiler_support/20.html",
            "wgPageName": "cpp/compiler_support/20"
        },
        {
            "title": "Compiler support for C++23",
            "path": "en.cppreference.com/w/cpp/compiler_support/23.html",
            "wgPageName": "cpp/compiler_support/23"
        },
        {
            "title": "Concepts library (since C++20)",
            "path": "en.cppreference.com/w/cpp/concepts.html",
            "wgPageName": "cpp/concepts"
        },
        {
            "title": "std::assignable_from",
            "path": "en.cppreference.com/w/cpp/concepts/assignable_from.html",
            "wgPageName": "cpp/concepts/assignable_from",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class LHS, class RHS>\nconcept assignable_from =\n    std::is_lvalue_reference_v<LHS> &&\n    std::common_reference_with <\n    const std::remove_reference_t<LHS>\n&, const std::remove_reference_t<RHS>& >\n       &&requires(LHS lhs, RHS&& rhs) {\n  {\n    lhs = std::forward<RHS>(rhs)\n    } -> std::same_as<LHS>;\n};"
        },
        {
            "title": "boolean-testable",
            "path": "en.cppreference.com/w/cpp/concepts/boolean-testable.html",
            "wgPageName": "cpp/concepts/boolean-testable",
            "sample_declaration": "template<class B>\nconcept __boolean_testable_impl =  // exposition\n                                   // only\n                                   // std::convertible_to<B,\n                                   // bool>;",
            "other_declarations": 1
        },
        {
            "title": "std::common_reference_with",
            "path": "en.cppreference.com/w/cpp/concepts/common_reference_with.html",
            "wgPageName": "cpp/concepts/common_reference_with",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class T, class U>\nconcept common_reference_with = std::same_as<\n    std::common_reference_t<T, U>,\n    std::common_reference_t<U, T>> &&\n    std::convertible_to<\n        T,\n        std::common_reference_t<T, U>> &&\n    std::convertible_to<\n        U,\n        std::common_reference_t<T, U>>;"
        },
        {
            "title": "std::common_with",
            "path": "en.cppreference.com/w/cpp/concepts/common_with.html",
            "wgPageName": "cpp/concepts/common_with",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class T, class U>\nconcept common_with = std::same_as<\n    std::common_type_t<T, U>,\n    std::common_type_t<U, T>> && requires {\n  static_cast<std::common_type_t<T, U>>(\n      std::declval<T>());\n  static_cast<std::common_type_t<T, U>>(\n      std::declval<U>());\n} && std::common_reference_with<\n    std::add_lvalue_reference_t<const T>,\n    std::add_lvalue_reference_t<const U>> &&\n    std::common_reference_with<\n        std::add_lvalue_reference_t<\n            std::common_type_t<T, U>>,\n        std::common_reference_t<\n            std::add_lvalue_reference_t<\n                const T>,\n            std::add_lvalue_reference_t<\n                const U>>>;"
        },
        {
            "title": "std::constructible_from",
            "path": "en.cppreference.com/w/cpp/concepts/constructible_from.html",
            "wgPageName": "cpp/concepts/constructible_from",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class T, class... Args>\nconcept constructible_from =\n    std::destructible<T> &&\n    std::is_constructible_v<T, Args...>;"
        },
        {
            "title": "std::convertible_to",
            "path": "en.cppreference.com/w/cpp/concepts/convertible_to.html",
            "wgPageName": "cpp/concepts/convertible_to",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class From, class To>\nconcept convertible_to =\n    std::is_convertible_v<From, To> &&\n    requires {\n  static_cast<To>(std::declval<From>());\n};"
        },
        {
            "title": "std::copy_constructible",
            "path": "en.cppreference.com/w/cpp/concepts/copy_constructible.html",
            "wgPageName": "cpp/concepts/copy_constructible",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept copy_constructible =\n    std::move_constructible<T> &&\n    std::constructible_from<T, T&> &&\n    std::convertible_to<T&, T> &&\n    std::constructible_from<T, const T&> &&\n    std::convertible_to<const T&, T> &&\n    std::constructible_from<T, const T> &&\n    std::convertible_to<const T, T>;"
        },
        {
            "title": "std::copyable",
            "path": "en.cppreference.com/w/cpp/concepts/copyable.html",
            "wgPageName": "cpp/concepts/copyable",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept copyable = std::copy_constructible<T> &&\n    std::movable<T> &&\n    std::assignable_from<T&, T&> &&\n    std::assignable_from<T&, const T&> &&\n    std::assignable_from<T&, const T>;"
        },
        {
            "title": "std::default_initializable",
            "path": "en.cppreference.com/w/cpp/concepts/default_initializable.html",
            "wgPageName": "cpp/concepts/default_initializable",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept default_initializable =\n    std::constructible_from<T> && requires {\n  T{};\n} && /* T t; is well-formed, see below */;"
        },
        {
            "title": "std::derived_from",
            "path": "en.cppreference.com/w/cpp/concepts/derived_from.html",
            "wgPageName": "cpp/concepts/derived_from",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class Derived, class Base>\nconcept derived_from =\n    std::is_base_of_v<Base, Derived> &&\n    std::is_convertible_v<\n        const volatile Derived*,\n        const volatile Base*>;"
        },
        {
            "title": "std::destructible",
            "path": "en.cppreference.com/w/cpp/concepts/destructible.html",
            "wgPageName": "cpp/concepts/destructible",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept destructible =\n    std::is_nothrow_destructible_v<T>;"
        },
        {
            "title": "std::equality_comparable, std::equality_comparable_with",
            "path": "en.cppreference.com/w/cpp/concepts/equality_comparable.html",
            "wgPageName": "cpp/concepts/equality_comparable",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept equality_comparable =\n    __WeaklyEqualityComparableWith<T, T>;",
            "other_declarations": 2
        },
        {
            "title": "std::equivalence_relation",
            "path": "en.cppreference.com/w/cpp/concepts/equivalence_relation.html",
            "wgPageName": "cpp/concepts/equivalence_relation",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class R, class T, class U>\nconcept equivalence_relation =\n    std::relation<R, T, U>;"
        },
        {
            "title": "std::floating_point",
            "path": "en.cppreference.com/w/cpp/concepts/floating_point.html",
            "wgPageName": "cpp/concepts/floating_point",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept floating_point =\n    std::is_floating_point_v<T>;"
        },
        {
            "title": "std::integral",
            "path": "en.cppreference.com/w/cpp/concepts/integral.html",
            "wgPageName": "cpp/concepts/integral",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept integral = std::is_integral_v<T>;"
        },
        {
            "title": "std::invocable, std::regular_invocable",
            "path": "en.cppreference.com/w/cpp/concepts/invocable.html",
            "wgPageName": "cpp/concepts/invocable",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class F, class... Args>\nconcept invocable =\n    requires(F&& f, Args&&... args) {\n  std::invoke(\n      std::forward<F>(f),\n      std::forward<Args>(\n          args)...); /* not required to be\n                        equality preserving */\n};",
            "other_declarations": 1
        },
        {
            "title": "std::movable",
            "path": "en.cppreference.com/w/cpp/concepts/movable.html",
            "wgPageName": "cpp/concepts/movable",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept movable = std::is_object_v<T> &&\n    std::move_constructible<T> &&\n    std::assignable_from<T&, T> &&\n    std::swappable<T>;"
        },
        {
            "title": "std::move_constructible",
            "path": "en.cppreference.com/w/cpp/concepts/move_constructible.html",
            "wgPageName": "cpp/concepts/move_constructible",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept move_constructible =\n    std::constructible_from<T, T> &&\n    std::convertible_to<T, T>;"
        },
        {
            "title": "std::predicate",
            "path": "en.cppreference.com/w/cpp/concepts/predicate.html",
            "wgPageName": "cpp/concepts/predicate",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class F, class... Args>\nconcept predicate =\n    std::regular_invocable<F, Args...> &&\n    boolean -\n    testable<std::invoke_result_t<F, Args...>>;"
        },
        {
            "title": "std::regular",
            "path": "en.cppreference.com/w/cpp/concepts/regular.html",
            "wgPageName": "cpp/concepts/regular",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept regular = std::semiregular<T> &&\n    std::equality_comparable<T>;"
        },
        {
            "title": "std::relation",
            "path": "en.cppreference.com/w/cpp/concepts/relation.html",
            "wgPageName": "cpp/concepts/relation",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class R, class T, class U>\nconcept relation = std::predicate<R, T, T> &&\n    std::predicate<R, U, U> &&\n    std::predicate<R, T, U> &&\n    std::predicate<R, U, T>;"
        },
        {
            "title": "std::same_as",
            "path": "en.cppreference.com/w/cpp/concepts/same_as.html",
            "wgPageName": "cpp/concepts/same_as",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class T, class U>\nconcept same_as = /* see below */;"
        },
        {
            "title": "std::semiregular",
            "path": "en.cppreference.com/w/cpp/concepts/semiregular.html",
            "wgPageName": "cpp/concepts/semiregular",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept semiregular = std::copyable<T> &&\n    std::default_initializable<T>;"
        },
        {
            "title": "std::signed_integral",
            "path": "en.cppreference.com/w/cpp/concepts/signed_integral.html",
            "wgPageName": "cpp/concepts/signed_integral",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept signed_integral =\n    std::integral<T> && std::is_signed_v<T>;"
        },
        {
            "title": "std::strict_weak_order",
            "path": "en.cppreference.com/w/cpp/concepts/strict_weak_order.html",
            "wgPageName": "cpp/concepts/strict_weak_order",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class R, class T, class U>\nconcept strict_weak_order =\n    std::relation<R, T, U>;"
        },
        {
            "title": "std::swappable, std::swappable_with",
            "path": "en.cppreference.com/w/cpp/concepts/swappable.html",
            "wgPageName": "cpp/concepts/swappable",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept swappable = requires(T& a, T& b) {\n  ranges::swap(a, b);\n};",
            "other_declarations": 1
        },
        {
            "title": "std::totally_ordered, std::totally_ordered_with",
            "path": "en.cppreference.com/w/cpp/concepts/totally_ordered.html",
            "wgPageName": "cpp/concepts/totally_ordered",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept totally_ordered =\n    std::equality_comparable<T> &&\n    __PartiallyOrderedWith<T, T>;",
            "other_declarations": 2
        },
        {
            "title": "std::unsigned_integral",
            "path": "en.cppreference.com/w/cpp/concepts/unsigned_integral.html",
            "wgPageName": "cpp/concepts/unsigned_integral",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept unsigned_integral = std::integral<T> &&\n    !std::signed_integral<T>;"
        },
        {
            "title": "Containers library",
            "path": "en.cppreference.com/w/cpp/container.html",
            "wgPageName": "cpp/container"
        },
        {
            "title": "std::array",
            "path": "en.cppreference.com/w/cpp/container/array.html",
            "wgPageName": "cpp/container/array",
            "headers": [
                "<array>"
            ],
            "sample_declaration": "template<class T, std::size_t N>\nstruct array;"
        },
        {
            "title": "std::array<T,N>::at",
            "path": "en.cppreference.com/w/cpp/container/array/at.html",
            "wgPageName": "cpp/container/array/at",
            "sample_declaration": "reference at(size_type pos);",
            "other_declarations": 3
        },
        {
            "title": "std::array<T,N>::back",
            "path": "en.cppreference.com/w/cpp/container/array/back.html",
            "wgPageName": "cpp/container/array/back",
            "sample_declaration": "reference back();",
            "other_declarations": 3
        },
        {
            "title": "std::array<T,N>::begin, std::array<T,N>::cbegin",
            "path": "en.cppreference.com/w/cpp/container/array/begin.html",
            "wgPageName": "cpp/container/array/begin",
            "sample_declaration": "iterator begin() noexcept;",
            "other_declarations": 5
        },
        {
            "title": "std::array<T,N>::data",
            "path": "en.cppreference.com/w/cpp/container/array/data.html",
            "wgPageName": "cpp/container/array/data",
            "sample_declaration": "T* data() noexcept;",
            "other_declarations": 3
        },
        {
            "title": "deduction guides for std::array",
            "path": "en.cppreference.com/w/cpp/container/array/deduction_guides.html",
            "wgPageName": "cpp/container/array/deduction_guides",
            "headers": [
                "<array>"
            ],
            "sample_declaration": "template<class T, class... U>\narray(T, U...) -> array<T, 1 + sizeof...(U)>;"
        },
        {
            "title": "std::array<T,N>::empty",
            "path": "en.cppreference.com/w/cpp/container/array/empty.html",
            "wgPageName": "cpp/container/array/empty",
            "sample_declaration": "constexpr bool empty() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::array<T,N>::end, std::array<T,N>::cend",
            "path": "en.cppreference.com/w/cpp/container/array/end.html",
            "wgPageName": "cpp/container/array/end",
            "sample_declaration": "iterator end() noexcept;",
            "other_declarations": 5
        },
        {
            "title": "std::array<T,N>::fill",
            "path": "en.cppreference.com/w/cpp/container/array/fill.html",
            "wgPageName": "cpp/container/array/fill",
            "sample_declaration": "void fill(const T& value);",
            "other_declarations": 1
        },
        {
            "title": "std::array<T,N>::front",
            "path": "en.cppreference.com/w/cpp/container/array/front.html",
            "wgPageName": "cpp/container/array/front",
            "sample_declaration": "reference front();",
            "other_declarations": 3
        },
        {
            "title": "std::get(std::array)",
            "path": "en.cppreference.com/w/cpp/container/array/get.html",
            "wgPageName": "cpp/container/array/get",
            "headers": [
                "<array>"
            ],
            "sample_declaration": "template<std::size_t I, class T, std::size_t N>\nT& get(std::array<T, N>& a) noexcept;",
            "other_declarations": 7
        },
        {
            "title": "std::array<T,N>::max_size",
            "path": "en.cppreference.com/w/cpp/container/array/max_size.html",
            "wgPageName": "cpp/container/array/max_size",
            "sample_declaration": "constexpr size_type max_size() const noexcept;"
        },
        {
            "title": "std::array<T,N>::operator[]",
            "path": "en.cppreference.com/w/cpp/container/array/operator_at.html",
            "wgPageName": "cpp/container/array/operator_at",
            "sample_declaration": "reference operator[](size_type pos);",
            "other_declarations": 3
        },
        {
            "title": "operator==,!=,<,<=,>,>=,<=>(std::array)",
            "path": "en.cppreference.com/w/cpp/container/array/operator_cmp.html",
            "wgPageName": "cpp/container/array/operator_cmp",
            "headers": [
                "<array>"
            ],
            "sample_declaration": "template<class T, std::size_t N>\nbool operator==(\n    const std::array<T, N>& lhs,\n    const std::array<T, N>& rhs);",
            "other_declarations": 7
        },
        {
            "title": "std::array<T,N>::rbegin, std::array<T,N>::crbegin",
            "path": "en.cppreference.com/w/cpp/container/array/rbegin.html",
            "wgPageName": "cpp/container/array/rbegin",
            "sample_declaration": "reverse_iterator rbegin() noexcept;",
            "other_declarations": 5
        },
        {
            "title": "std::array<T,N>::rend, std::array<T,N>::crend",
            "path": "en.cppreference.com/w/cpp/container/array/rend.html",
            "wgPageName": "cpp/container/array/rend",
            "sample_declaration": "reverse_iterator rend() noexcept;",
            "other_declarations": 5
        },
        {
            "title": "std::array<T,N>::size",
            "path": "en.cppreference.com/w/cpp/container/array/size.html",
            "wgPageName": "cpp/container/array/size",
            "sample_declaration": "constexpr size_type size() const noexcept;"
        },
        {
            "title": "std::array<T,N>::swap",
            "path": "en.cppreference.com/w/cpp/container/array/swap.html",
            "wgPageName": "cpp/container/array/swap",
            "sample_declaration": "void swap(array& other) noexcept(\n    /* see below */);",
            "other_declarations": 1
        },
        {
            "title": "std::swap(std::array)",
            "path": "en.cppreference.com/w/cpp/container/array/swap2.html",
            "wgPageName": "cpp/container/array/swap2",
            "headers": [
                "<array>"
            ],
            "sample_declaration": "template<class T, std::size_t N>\nvoid swap(\n    std::array<T, N>& lhs,\n    std::array<T, N>& rhs);",
            "other_declarations": 2
        },
        {
            "title": "std::to_array",
            "path": "en.cppreference.com/w/cpp/container/array/to_array.html",
            "wgPageName": "cpp/container/array/to_array",
            "headers": [
                "<array>"
            ],
            "sample_declaration": "template<class T, std::size_t N>\nconstexpr std::array<std::remove_cv_t<T>, N>\n    to_array(T (&a)[N]);",
            "other_declarations": 1
        },
        {
            "title": "std::tuple_element<std::array>",
            "path": "en.cppreference.com/w/cpp/container/array/tuple_element.html",
            "wgPageName": "cpp/container/array/tuple_element",
            "headers": [
                "<array>"
            ],
            "sample_declaration": "template<std::size_t I, class T, std::size_t N>\nstruct tuple_element<I, std::array<T, N> >;"
        },
        {
            "title": "std::tuple_size(std::array)",
            "path": "en.cppreference.com/w/cpp/container/array/tuple_size.html",
            "wgPageName": "cpp/container/array/tuple_size",
            "headers": [
                "<array>"
            ],
            "sample_declaration": "template<class T, std::size_t N>\nstruct tuple_size<std::array<T, N> >\n    : std::integral_constant<std::size_t, N> {};"
        },
        {
            "title": "std::deque",
            "path": "en.cppreference.com/w/cpp/container/deque.html",
            "wgPageName": "cpp/container/deque",
            "headers": [
                "<deque>"
            ],
            "sample_declaration": "template<\n    class T,\n    class Allocator = std::allocator<T> >\nclass deque;",
            "other_declarations": 1
        },
        {
            "title": "std::deque<T,Allocator>::~deque",
            "path": "en.cppreference.com/w/cpp/container/deque/~deque.html",
            "wgPageName": "cpp/container/deque/~deque",
            "sample_declaration": "~deque();"
        },
        {
            "title": "std::deque<T,Allocator>::assign",
            "path": "en.cppreference.com/w/cpp/container/deque/assign.html",
            "wgPageName": "cpp/container/deque/assign",
            "sample_declaration": "void assign(size_type count, const T& value);",
            "other_declarations": 2
        },
        {
            "title": "std::deque<T,Allocator>::at",
            "path": "en.cppreference.com/w/cpp/container/deque/at.html",
            "wgPageName": "cpp/container/deque/at",
            "sample_declaration": "reference at(size_type pos);",
            "other_declarations": 1
        },
        {
            "title": "std::deque<T,Allocator>::back",
            "path": "en.cppreference.com/w/cpp/container/deque/back.html",
            "wgPageName": "cpp/container/deque/back",
            "sample_declaration": "reference back();",
            "other_declarations": 1
        },
        {
            "title": "std::deque<T,Allocator>::begin, std::deque<T,Allocator>::cbegin",
            "path": "en.cppreference.com/w/cpp/container/deque/begin.html",
            "wgPageName": "cpp/container/deque/begin",
            "sample_declaration": "iterator begin();",
            "other_declarations": 4
        },
        {
            "title": "std::deque<T,Allocator>::clear",
            "path": "en.cppreference.com/w/cpp/container/deque/clear.html",
            "wgPageName": "cpp/container/deque/clear",
            "sample_declaration": "void clear();",
            "other_declarations": 1
        },
        {
            "title": "deduction guides for std::deque",
            "path": "en.cppreference.com/w/cpp/container/deque/deduction_guides.html",
            "wgPageName": "cpp/container/deque/deduction_guides",
            "headers": [
                "<deque>"
            ],
            "sample_declaration": "template<\n    class InputIt,\n    class Alloc = std::allocator<\n        typename std::iterator_traits<\n            InputIt>::value_type>>\ndeque(InputIt, InputIt, Alloc = Alloc())\n    -> deque<\n        typename std::iterator_traits<\n            InputIt>::value_type,\n        Alloc>;"
        },
        {
            "title": "std::deque<T,Allocator>::deque",
            "path": "en.cppreference.com/w/cpp/container/deque/deque.html",
            "wgPageName": "cpp/container/deque/deque",
            "sample_declaration": "deque();",
            "other_declarations": 11
        },
        {
            "title": "std::deque<T,Allocator>::emplace_back",
            "path": "en.cppreference.com/w/cpp/container/deque/emplace_back.html",
            "wgPageName": "cpp/container/deque/emplace_back",
            "sample_declaration": "template<class... Args>\nvoid emplace_back(Args&&... args);",
            "other_declarations": 1
        },
        {
            "title": "std::deque<T,Allocator>::emplace_front",
            "path": "en.cppreference.com/w/cpp/container/deque/emplace_front.html",
            "wgPageName": "cpp/container/deque/emplace_front",
            "sample_declaration": "template<class... Args>\nvoid emplace_front(Args&&... args);",
            "other_declarations": 1
        },
        {
            "title": "std::deque<T,Allocator>::emplace",
            "path": "en.cppreference.com/w/cpp/container/deque/emplace.html",
            "wgPageName": "cpp/container/deque/emplace",
            "sample_declaration": "template<class... Args>\niterator emplace(\n    const_iterator pos,\n    Args&&... args);"
        },
        {
            "title": "std::deque<T,Allocator>::empty",
            "path": "en.cppreference.com/w/cpp/container/deque/empty.html",
            "wgPageName": "cpp/container/deque/empty",
            "sample_declaration": "bool empty() const;",
            "other_declarations": 2
        },
        {
            "title": "std::deque<T,Allocator>::end, std::deque<T,Allocator>::cend",
            "path": "en.cppreference.com/w/cpp/container/deque/end.html",
            "wgPageName": "cpp/container/deque/end",
            "sample_declaration": "iterator end();",
            "other_declarations": 4
        },
        {
            "title": "std::deque<T,Allocator>::erase",
            "path": "en.cppreference.com/w/cpp/container/deque/erase.html",
            "wgPageName": "cpp/container/deque/erase",
            "sample_declaration": "iterator erase(iterator pos);",
            "other_declarations": 3
        },
        {
            "title": "std::erase, std::erase_if (std::deque)",
            "path": "en.cppreference.com/w/cpp/container/deque/erase2.html",
            "wgPageName": "cpp/container/deque/erase2",
            "headers": [
                "<deque>"
            ],
            "sample_declaration": "template<class T, class Alloc, class U>\ntypename std::deque<T, Alloc>::size_type erase(\n    std::deque<T, Alloc>& c,\n    const U& value);",
            "other_declarations": 1
        },
        {
            "title": "std::deque<T,Allocator>::front",
            "path": "en.cppreference.com/w/cpp/container/deque/front.html",
            "wgPageName": "cpp/container/deque/front",
            "sample_declaration": "reference front();",
            "other_declarations": 1
        },
        {
            "title": "std::deque<T,Allocator>::get_allocator",
            "path": "en.cppreference.com/w/cpp/container/deque/get_allocator.html",
            "wgPageName": "cpp/container/deque/get_allocator",
            "sample_declaration": "allocator_type get_allocator() const;",
            "other_declarations": 1
        },
        {
            "title": "std::deque<T,Allocator>::insert",
            "path": "en.cppreference.com/w/cpp/container/deque/insert.html",
            "wgPageName": "cpp/container/deque/insert",
            "sample_declaration": "iterator insert(\n    const_iterator pos,\n    const T& value);",
            "other_declarations": 4
        },
        {
            "title": "std::deque<T,Allocator>::max_size",
            "path": "en.cppreference.com/w/cpp/container/deque/max_size.html",
            "wgPageName": "cpp/container/deque/max_size",
            "sample_declaration": "size_type max_size() const;",
            "other_declarations": 1
        },
        {
            "title": "std::deque<T,Allocator>::operator[]",
            "path": "en.cppreference.com/w/cpp/container/deque/operator_at.html",
            "wgPageName": "cpp/container/deque/operator_at",
            "sample_declaration": "reference operator[](size_type pos);",
            "other_declarations": 1
        },
        {
            "title": "operator==,!=,<,<=,>,>=,<=>(std::deque)",
            "path": "en.cppreference.com/w/cpp/container/deque/operator_cmp.html",
            "wgPageName": "cpp/container/deque/operator_cmp",
            "headers": [
                "<deque>"
            ],
            "sample_declaration": "template<class T, class Alloc>\nbool operator==(\n    const std::deque<T, Alloc>& lhs,\n    const std::deque<T, Alloc>& rhs);",
            "other_declarations": 6
        },
        {
            "title": "std::deque<T,Allocator>::operator=",
            "path": "en.cppreference.com/w/cpp/container/deque/operator=.html",
            "wgPageName": "cpp/container/deque/operator=",
            "sample_declaration": "deque& operator=(const deque& other);",
            "other_declarations": 3
        },
        {
            "title": "std::deque<T,Allocator>::pop_back",
            "path": "en.cppreference.com/w/cpp/container/deque/pop_back.html",
            "wgPageName": "cpp/container/deque/pop_back",
            "sample_declaration": "void pop_back();"
        },
        {
            "title": "std::deque<T,Allocator>::pop_front",
            "path": "en.cppreference.com/w/cpp/container/deque/pop_front.html",
            "wgPageName": "cpp/container/deque/pop_front",
            "sample_declaration": "void pop_front();"
        },
        {
            "title": "std::deque<T,Allocator>::push_back",
            "path": "en.cppreference.com/w/cpp/container/deque/push_back.html",
            "wgPageName": "cpp/container/deque/push_back",
            "sample_declaration": "void push_back(const T& value);",
            "other_declarations": 1
        },
        {
            "title": "std::deque<T,Allocator>::push_front",
            "path": "en.cppreference.com/w/cpp/container/deque/push_front.html",
            "wgPageName": "cpp/container/deque/push_front",
            "sample_declaration": "void push_front(const T& value);",
            "other_declarations": 1
        },
        {
            "title": "std::deque<T,Allocator>::rbegin, std::deque<T,Allocator>::crbegin",
            "path": "en.cppreference.com/w/cpp/container/deque/rbegin.html",
            "wgPageName": "cpp/container/deque/rbegin",
            "sample_declaration": "reverse_iterator rbegin();",
            "other_declarations": 4
        },
        {
            "title": "std::deque<T,Allocator>::rend, std::deque<T,Allocator>::crend",
            "path": "en.cppreference.com/w/cpp/container/deque/rend.html",
            "wgPageName": "cpp/container/deque/rend",
            "sample_declaration": "reverse_iterator rend();",
            "other_declarations": 4
        },
        {
            "title": "std::deque<T,Allocator>::resize",
            "path": "en.cppreference.com/w/cpp/container/deque/resize.html",
            "wgPageName": "cpp/container/deque/resize",
            "sample_declaration": "void resize(size_type count);",
            "other_declarations": 2
        },
        {
            "title": "std::deque<T,Allocator>::shrink_to_fit",
            "path": "en.cppreference.com/w/cpp/container/deque/shrink_to_fit.html",
            "wgPageName": "cpp/container/deque/shrink_to_fit",
            "sample_declaration": "void shrink_to_fit();"
        },
        {
            "title": "std::deque<T,Allocator>::size",
            "path": "en.cppreference.com/w/cpp/container/deque/size.html",
            "wgPageName": "cpp/container/deque/size",
            "sample_declaration": "size_type size() const;",
            "other_declarations": 1
        },
        {
            "title": "std::deque<T,Allocator>::swap",
            "path": "en.cppreference.com/w/cpp/container/deque/swap.html",
            "wgPageName": "cpp/container/deque/swap",
            "sample_declaration": "void swap(deque& other);",
            "other_declarations": 1
        },
        {
            "title": "std::swap(std::deque)",
            "path": "en.cppreference.com/w/cpp/container/deque/swap2.html",
            "wgPageName": "cpp/container/deque/swap2",
            "headers": [
                "<deque>"
            ],
            "sample_declaration": "template<class T, class Alloc>\nvoid swap(\n    std::deque<T, Alloc>& lhs,\n    std::deque<T, Alloc>& rhs);",
            "other_declarations": 1
        },
        {
            "title": "std::flat_set",
            "path": "en.cppreference.com/w/cpp/container/flat_set.html",
            "wgPageName": "cpp/container/flat_set"
        },
        {
            "title": "std::forward_list",
            "path": "en.cppreference.com/w/cpp/container/forward_list.html",
            "wgPageName": "cpp/container/forward_list",
            "headers": [
                "<forward_list>"
            ],
            "sample_declaration": "template<\n    class T,\n    class Allocator = std::allocator<T> >\nclass forward_list;",
            "other_declarations": 1
        },
        {
            "title": "std::forward_list<T,Allocator>::~forward_list",
            "path": "en.cppreference.com/w/cpp/container/forward_list/~forward_list.html",
            "wgPageName": "cpp/container/forward_list/~forward_list",
            "sample_declaration": "~forward_list();"
        },
        {
            "title": "std::forward_list<T,Allocator>::assign",
            "path": "en.cppreference.com/w/cpp/container/forward_list/assign.html",
            "wgPageName": "cpp/container/forward_list/assign",
            "sample_declaration": "void assign(size_type count, const T& value);",
            "other_declarations": 2
        },
        {
            "title": "std::forward_list<T,Allocator>::before_begin, cbefore_begin",
            "path": "en.cppreference.com/w/cpp/container/forward_list/before_begin.html",
            "wgPageName": "cpp/container/forward_list/before_begin",
            "sample_declaration": "iterator before_begin() noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::forward_list<T,Allocator>::begin, std::forward_list<T,Allocator>::cbegin",
            "path": "en.cppreference.com/w/cpp/container/forward_list/begin.html",
            "wgPageName": "cpp/container/forward_list/begin",
            "sample_declaration": "iterator begin() noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::forward_list<T,Allocator>::clear",
            "path": "en.cppreference.com/w/cpp/container/forward_list/clear.html",
            "wgPageName": "cpp/container/forward_list/clear",
            "sample_declaration": "void clear() noexcept;"
        },
        {
            "title": "deduction guides for std::forward_list",
            "path": "en.cppreference.com/w/cpp/container/forward_list/deduction_guides.html",
            "wgPageName": "cpp/container/forward_list/deduction_guides",
            "headers": [
                "<forward_list>"
            ],
            "sample_declaration": "template<\n    class InputIt,\n    class Alloc = std::allocator<\n        typename std::iterator_traits<\n            InputIt>::value_type>>\nforward_list(InputIt, InputIt, Alloc = Alloc())\n    -> forward_list<\n        typename std::iterator_traits<\n            InputIt>::value_type,\n        Alloc>;"
        },
        {
            "title": "std::forward_list<T,Allocator>::emplace_after",
            "path": "en.cppreference.com/w/cpp/container/forward_list/emplace_after.html",
            "wgPageName": "cpp/container/forward_list/emplace_after",
            "sample_declaration": "template<class... Args>\niterator emplace_after(\n    const_iterator pos,\n    Args&&... args);"
        },
        {
            "title": "std::forward_list<T,Allocator>::emplace_front",
            "path": "en.cppreference.com/w/cpp/container/forward_list/emplace_front.html",
            "wgPageName": "cpp/container/forward_list/emplace_front",
            "sample_declaration": "template<class... Args>\nvoid emplace_front(Args&&... args);",
            "other_declarations": 1
        },
        {
            "title": "std::forward_list<T,Allocator>::empty",
            "path": "en.cppreference.com/w/cpp/container/forward_list/empty.html",
            "wgPageName": "cpp/container/forward_list/empty",
            "sample_declaration": "bool empty() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::forward_list<T,Allocator>::end, std::forward_list<T,Allocator>::cend",
            "path": "en.cppreference.com/w/cpp/container/forward_list/end.html",
            "wgPageName": "cpp/container/forward_list/end",
            "sample_declaration": "iterator end() noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::forward_list<T,Allocator>::erase_after",
            "path": "en.cppreference.com/w/cpp/container/forward_list/erase_after.html",
            "wgPageName": "cpp/container/forward_list/erase_after",
            "sample_declaration": "iterator erase_after(const_iterator pos);",
            "other_declarations": 1
        },
        {
            "title": "std::erase, std::erase_if (std::forward_list)",
            "path": "en.cppreference.com/w/cpp/container/forward_list/erase2.html",
            "wgPageName": "cpp/container/forward_list/erase2",
            "headers": [
                "<forward_list>"
            ],
            "sample_declaration": "template<class T, class Alloc, class U>\ntypename std::forward_list<T, Alloc>::size_type\nerase(\n    std::forward_list<T, Alloc>& c,\n    const U& value);",
            "other_declarations": 1
        },
        {
            "title": "std::forward_list<T,Allocator>::forward_list",
            "path": "en.cppreference.com/w/cpp/container/forward_list/forward_list.html",
            "wgPageName": "cpp/container/forward_list/forward_list",
            "sample_declaration": "forward_list();",
            "other_declarations": 10
        },
        {
            "title": "std::forward_list<T,Allocator>::front",
            "path": "en.cppreference.com/w/cpp/container/forward_list/front.html",
            "wgPageName": "cpp/container/forward_list/front",
            "sample_declaration": "reference front();",
            "other_declarations": 1
        },
        {
            "title": "std::forward_list<T,Allocator>::get_allocator",
            "path": "en.cppreference.com/w/cpp/container/forward_list/get_allocator.html",
            "wgPageName": "cpp/container/forward_list/get_allocator",
            "sample_declaration": "allocator_type get_allocator() const noexcept;"
        },
        {
            "title": "std::forward_list<T,Allocator>::insert_after",
            "path": "en.cppreference.com/w/cpp/container/forward_list/insert_after.html",
            "wgPageName": "cpp/container/forward_list/insert_after",
            "sample_declaration": "iterator insert_after(\n    const_iterator pos,\n    const T& value);",
            "other_declarations": 4
        },
        {
            "title": "std::forward_list<T,Allocator>::max_size",
            "path": "en.cppreference.com/w/cpp/container/forward_list/max_size.html",
            "wgPageName": "cpp/container/forward_list/max_size",
            "sample_declaration": "size_type max_size() const noexcept;"
        },
        {
            "title": "std::forward_list<T,Allocator>::merge",
            "path": "en.cppreference.com/w/cpp/container/forward_list/merge.html",
            "wgPageName": "cpp/container/forward_list/merge",
            "sample_declaration": "void merge(forward_list& other);",
            "other_declarations": 3
        },
        {
            "title": "operator==,!=,<,<=,>,>=,<=>(std::forward_list)",
            "path": "en.cppreference.com/w/cpp/container/forward_list/operator_cmp.html",
            "wgPageName": "cpp/container/forward_list/operator_cmp",
            "headers": [
                "<forward_list>"
            ],
            "sample_declaration": "template<class T, class Alloc>\nbool operator==(\n    const std::forward_list<T, Alloc>& lhs,\n    const std::forward_list<T, Alloc>& rhs);",
            "other_declarations": 6
        },
        {
            "title": "std::forward_list<T,Allocator>::operator=",
            "path": "en.cppreference.com/w/cpp/container/forward_list/operator=.html",
            "wgPageName": "cpp/container/forward_list/operator=",
            "sample_declaration": "forward_list& operator=(\n    const forward_list& other);",
            "other_declarations": 3
        },
        {
            "title": "std::forward_list<T,Allocator>::pop_front",
            "path": "en.cppreference.com/w/cpp/container/forward_list/pop_front.html",
            "wgPageName": "cpp/container/forward_list/pop_front",
            "sample_declaration": "void pop_front();"
        },
        {
            "title": "std::forward_list<T,Allocator>::push_front",
            "path": "en.cppreference.com/w/cpp/container/forward_list/push_front.html",
            "wgPageName": "cpp/container/forward_list/push_front",
            "sample_declaration": "void push_front(const T& value);",
            "other_declarations": 1
        },
        {
            "title": "std::forward_list<T,Allocator>::remove, remove_if",
            "path": "en.cppreference.com/w/cpp/container/forward_list/remove.html",
            "wgPageName": "cpp/container/forward_list/remove",
            "sample_declaration": "void remove(const T& value);",
            "other_declarations": 3
        },
        {
            "title": "std::forward_list<T,Allocator>::resize",
            "path": "en.cppreference.com/w/cpp/container/forward_list/resize.html",
            "wgPageName": "cpp/container/forward_list/resize",
            "sample_declaration": "void resize(size_type count);",
            "other_declarations": 1
        },
        {
            "title": "std::forward_list<T,Allocator>::reverse",
            "path": "en.cppreference.com/w/cpp/container/forward_list/reverse.html",
            "wgPageName": "cpp/container/forward_list/reverse",
            "sample_declaration": "void reverse() noexcept;"
        },
        {
            "title": "std::forward_list<T,Allocator>::sort",
            "path": "en.cppreference.com/w/cpp/container/forward_list/sort.html",
            "wgPageName": "cpp/container/forward_list/sort",
            "sample_declaration": "void sort();",
            "other_declarations": 1
        },
        {
            "title": "std::forward_list<T,Allocator>::splice_after",
            "path": "en.cppreference.com/w/cpp/container/forward_list/splice_after.html",
            "wgPageName": "cpp/container/forward_list/splice_after",
            "sample_declaration": "void splice_after(\n    const_iterator pos,\n    forward_list& other);",
            "other_declarations": 5
        },
        {
            "title": "std::forward_list<T,Allocator>::swap",
            "path": "en.cppreference.com/w/cpp/container/forward_list/swap.html",
            "wgPageName": "cpp/container/forward_list/swap",
            "sample_declaration": "void swap(forward_list& other);",
            "other_declarations": 1
        },
        {
            "title": "std::swap(std::forward_list)",
            "path": "en.cppreference.com/w/cpp/container/forward_list/swap2.html",
            "wgPageName": "cpp/container/forward_list/swap2",
            "headers": [
                "<forward_list>"
            ],
            "sample_declaration": "template<class T, class Alloc>\nvoid swap(\n    std::forward_list<T, Alloc>& lhs,\n    std::forward_list<T, Alloc>& rhs);",
            "other_declarations": 1
        },
        {
            "title": "std::forward_list<T,Allocator>::unique",
            "path": "en.cppreference.com/w/cpp/container/forward_list/unique.html",
            "wgPageName": "cpp/container/forward_list/unique",
            "sample_declaration": "void unique();",
            "other_declarations": 3
        },
        {
            "title": "std::list",
            "path": "en.cppreference.com/w/cpp/container/list.html",
            "wgPageName": "cpp/container/list",
            "headers": [
                "<list>"
            ],
            "sample_declaration": "template<\n    class T,\n    class Allocator = std::allocator<T> >\nclass list;",
            "other_declarations": 1
        },
        {
            "title": "std::list<T,Allocator>::~list",
            "path": "en.cppreference.com/w/cpp/container/list/~list.html",
            "wgPageName": "cpp/container/list/~list",
            "sample_declaration": "~list();"
        },
        {
            "title": "std::list<T,Allocator>::assign",
            "path": "en.cppreference.com/w/cpp/container/list/assign.html",
            "wgPageName": "cpp/container/list/assign",
            "sample_declaration": "void assign(size_type count, const T& value);",
            "other_declarations": 2
        },
        {
            "title": "std::list<T,Allocator>::back",
            "path": "en.cppreference.com/w/cpp/container/list/back.html",
            "wgPageName": "cpp/container/list/back",
            "sample_declaration": "reference back();",
            "other_declarations": 1
        },
        {
            "title": "std::list<T,Allocator>::begin, std::list<T,Allocator>::cbegin",
            "path": "en.cppreference.com/w/cpp/container/list/begin.html",
            "wgPageName": "cpp/container/list/begin",
            "sample_declaration": "iterator begin();",
            "other_declarations": 4
        },
        {
            "title": "std::list<T,Allocator>::clear",
            "path": "en.cppreference.com/w/cpp/container/list/clear.html",
            "wgPageName": "cpp/container/list/clear",
            "sample_declaration": "void clear();",
            "other_declarations": 1
        },
        {
            "title": "deduction guides for std::list",
            "path": "en.cppreference.com/w/cpp/container/list/deduction_guides.html",
            "wgPageName": "cpp/container/list/deduction_guides",
            "headers": [
                "<list>"
            ],
            "sample_declaration": "template<\n    class InputIt,\n    class Alloc = std::allocator<\n        typename std::iterator_traits<\n            InputIt>::value_type>>\nlist(InputIt, InputIt, Alloc = Alloc()) -> list<\n    typename std::iterator_traits<\n        InputIt>::value_type,\n    Alloc>;"
        },
        {
            "title": "std::list<T,Allocator>::emplace_back",
            "path": "en.cppreference.com/w/cpp/container/list/emplace_back.html",
            "wgPageName": "cpp/container/list/emplace_back",
            "sample_declaration": "template<class... Args>\nvoid emplace_back(Args&&... args);",
            "other_declarations": 1
        },
        {
            "title": "std::list<T,Allocator>::emplace_front",
            "path": "en.cppreference.com/w/cpp/container/list/emplace_front.html",
            "wgPageName": "cpp/container/list/emplace_front",
            "sample_declaration": "template<class... Args>\nvoid emplace_front(Args&&... args);",
            "other_declarations": 1
        },
        {
            "title": "std::list<T,Allocator>::emplace",
            "path": "en.cppreference.com/w/cpp/container/list/emplace.html",
            "wgPageName": "cpp/container/list/emplace",
            "sample_declaration": "template<class... Args>\niterator emplace(\n    const_iterator pos,\n    Args&&... args);"
        },
        {
            "title": "std::list<T,Allocator>::empty",
            "path": "en.cppreference.com/w/cpp/container/list/empty.html",
            "wgPageName": "cpp/container/list/empty",
            "sample_declaration": "bool empty() const;",
            "other_declarations": 2
        },
        {
            "title": "std::list<T,Allocator>::end, std::list<T,Allocator>::cend",
            "path": "en.cppreference.com/w/cpp/container/list/end.html",
            "wgPageName": "cpp/container/list/end",
            "sample_declaration": "iterator end();",
            "other_declarations": 4
        },
        {
            "title": "std::list<T,Allocator>::erase",
            "path": "en.cppreference.com/w/cpp/container/list/erase.html",
            "wgPageName": "cpp/container/list/erase",
            "sample_declaration": "iterator erase(iterator pos);",
            "other_declarations": 3
        },
        {
            "title": "std::erase, std::erase_if (std::list)",
            "path": "en.cppreference.com/w/cpp/container/list/erase2.html",
            "wgPageName": "cpp/container/list/erase2",
            "headers": [
                "<list>"
            ],
            "sample_declaration": "template<class T, class Alloc, class U>\ntypename std::list<T, Alloc>::size_type erase(\n    std::list<T, Alloc>& c,\n    const U& value);",
            "other_declarations": 1
        },
        {
            "title": "std::list<T,Allocator>::front",
            "path": "en.cppreference.com/w/cpp/container/list/front.html",
            "wgPageName": "cpp/container/list/front",
            "sample_declaration": "reference front();",
            "other_declarations": 1
        },
        {
            "title": "std::list<T,Allocator>::get_allocator",
            "path": "en.cppreference.com/w/cpp/container/list/get_allocator.html",
            "wgPageName": "cpp/container/list/get_allocator",
            "sample_declaration": "allocator_type get_allocator() const;",
            "other_declarations": 1
        },
        {
            "title": "std::list<T,Allocator>::insert",
            "path": "en.cppreference.com/w/cpp/container/list/insert.html",
            "wgPageName": "cpp/container/list/insert",
            "sample_declaration": "iterator insert(\n    const_iterator pos,\n    const T& value);",
            "other_declarations": 4
        },
        {
            "title": "std::list<T,Allocator>::list",
            "path": "en.cppreference.com/w/cpp/container/list/list.html",
            "wgPageName": "cpp/container/list/list",
            "sample_declaration": "list();",
            "other_declarations": 11
        },
        {
            "title": "std::list<T,Allocator>::max_size",
            "path": "en.cppreference.com/w/cpp/container/list/max_size.html",
            "wgPageName": "cpp/container/list/max_size",
            "sample_declaration": "size_type max_size() const;",
            "other_declarations": 1
        },
        {
            "title": "std::list<T,Allocator>::merge",
            "path": "en.cppreference.com/w/cpp/container/list/merge.html",
            "wgPageName": "cpp/container/list/merge",
            "sample_declaration": "void merge(list& other);",
            "other_declarations": 3
        },
        {
            "title": "operator==,!=,<,<=,>,>=,<=>(std::list)",
            "path": "en.cppreference.com/w/cpp/container/list/operator_cmp.html",
            "wgPageName": "cpp/container/list/operator_cmp",
            "headers": [
                "<list>"
            ],
            "sample_declaration": "template<class T, class Alloc>\nbool operator==(\n    const std::list<T, Alloc>& lhs,\n    const std::list<T, Alloc>& rhs);",
            "other_declarations": 6
        },
        {
            "title": "std::list<T,Allocator>::operator=",
            "path": "en.cppreference.com/w/cpp/container/list/operator=.html",
            "wgPageName": "cpp/container/list/operator=",
            "sample_declaration": "list& operator=(const list& other);",
            "other_declarations": 3
        },
        {
            "title": "std::list<T,Allocator>::pop_back",
            "path": "en.cppreference.com/w/cpp/container/list/pop_back.html",
            "wgPageName": "cpp/container/list/pop_back",
            "sample_declaration": "void pop_back();"
        },
        {
            "title": "std::list<T,Allocator>::pop_front",
            "path": "en.cppreference.com/w/cpp/container/list/pop_front.html",
            "wgPageName": "cpp/container/list/pop_front",
            "sample_declaration": "void pop_front();"
        },
        {
            "title": "std::list<T,Allocator>::push_back",
            "path": "en.cppreference.com/w/cpp/container/list/push_back.html",
            "wgPageName": "cpp/container/list/push_back",
            "sample_declaration": "void push_back(const T& value);",
            "other_declarations": 1
        },
        {
            "title": "std::list<T,Allocator>::push_front",
            "path": "en.cppreference.com/w/cpp/container/list/push_front.html",
            "wgPageName": "cpp/container/list/push_front",
            "sample_declaration": "void push_front(const T& value);",
            "other_declarations": 1
        },
        {
            "title": "std::list<T,Allocator>::rbegin, std::list<T,Allocator>::crbegin",
            "path": "en.cppreference.com/w/cpp/container/list/rbegin.html",
            "wgPageName": "cpp/container/list/rbegin",
            "sample_declaration": "reverse_iterator rbegin();",
            "other_declarations": 4
        },
        {
            "title": "std::list<T,Allocator>::remove, remove_if",
            "path": "en.cppreference.com/w/cpp/container/list/remove.html",
            "wgPageName": "cpp/container/list/remove",
            "sample_declaration": "void remove(const T& value);",
            "other_declarations": 3
        },
        {
            "title": "std::list<T,Allocator>::rend, std::list<T,Allocator>::crend",
            "path": "en.cppreference.com/w/cpp/container/list/rend.html",
            "wgPageName": "cpp/container/list/rend",
            "sample_declaration": "reverse_iterator rend();",
            "other_declarations": 4
        },
        {
            "title": "std::list<T,Allocator>::resize",
            "path": "en.cppreference.com/w/cpp/container/list/resize.html",
            "wgPageName": "cpp/container/list/resize",
            "sample_declaration": "void resize(size_type count);",
            "other_declarations": 2
        },
        {
            "title": "std::list<T,Allocator>::reverse",
            "path": "en.cppreference.com/w/cpp/container/list/reverse.html",
            "wgPageName": "cpp/container/list/reverse",
            "sample_declaration": "void reverse();",
            "other_declarations": 1
        },
        {
            "title": "std::list<T,Allocator>::size",
            "path": "en.cppreference.com/w/cpp/container/list/size.html",
            "wgPageName": "cpp/container/list/size",
            "sample_declaration": "size_type size() const;",
            "other_declarations": 1
        },
        {
            "title": "std::list<T,Allocator>::sort",
            "path": "en.cppreference.com/w/cpp/container/list/sort.html",
            "wgPageName": "cpp/container/list/sort",
            "sample_declaration": "void sort();",
            "other_declarations": 1
        },
        {
            "title": "std::list<T,Allocator>::splice",
            "path": "en.cppreference.com/w/cpp/container/list/splice.html",
            "wgPageName": "cpp/container/list/splice",
            "sample_declaration": "void splice(const_iterator pos, list& other);",
            "other_declarations": 5
        },
        {
            "title": "std::list<T,Allocator>::swap",
            "path": "en.cppreference.com/w/cpp/container/list/swap.html",
            "wgPageName": "cpp/container/list/swap",
            "sample_declaration": "void swap(list& other);",
            "other_declarations": 1
        },
        {
            "title": "std::swap(std::list)",
            "path": "en.cppreference.com/w/cpp/container/list/swap2.html",
            "wgPageName": "cpp/container/list/swap2",
            "headers": [
                "<list>"
            ],
            "sample_declaration": "template<class T, class Alloc>\nvoid swap(\n    std::list<T, Alloc>& lhs,\n    std::list<T, Alloc>& rhs);",
            "other_declarations": 1
        },
        {
            "title": "std::list<T,Allocator>::unique",
            "path": "en.cppreference.com/w/cpp/container/list/unique.html",
            "wgPageName": "cpp/container/list/unique",
            "sample_declaration": "void unique();",
            "other_declarations": 3
        },
        {
            "title": "std::map",
            "path": "en.cppreference.com/w/cpp/container/map.html",
            "wgPageName": "cpp/container/map",
            "headers": [
                "<map>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class T,\n    class Compare = std::less<Key>,\n    class Allocator = std::allocator<\n        std::pair<const Key, T> > >\nclass map;",
            "other_declarations": 1
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::~map",
            "path": "en.cppreference.com/w/cpp/container/map/~map.html",
            "wgPageName": "cpp/container/map/~map",
            "sample_declaration": "~map();"
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::at",
            "path": "en.cppreference.com/w/cpp/container/map/at.html",
            "wgPageName": "cpp/container/map/at",
            "sample_declaration": "T& at(const Key& key);",
            "other_declarations": 1
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::begin, std::map<Key,T,Compare,Allocator>::cbegin",
            "path": "en.cppreference.com/w/cpp/container/map/begin.html",
            "wgPageName": "cpp/container/map/begin",
            "sample_declaration": "iterator begin();",
            "other_declarations": 4
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::clear",
            "path": "en.cppreference.com/w/cpp/container/map/clear.html",
            "wgPageName": "cpp/container/map/clear",
            "sample_declaration": "void clear();",
            "other_declarations": 1
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::contains",
            "path": "en.cppreference.com/w/cpp/container/map/contains.html",
            "wgPageName": "cpp/container/map/contains",
            "sample_declaration": "bool contains(const Key& key) const;",
            "other_declarations": 1
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::count",
            "path": "en.cppreference.com/w/cpp/container/map/count.html",
            "wgPageName": "cpp/container/map/count",
            "sample_declaration": "size_type count(const Key& key) const;",
            "other_declarations": 1
        },
        {
            "title": "deduction guides for std::map",
            "path": "en.cppreference.com/w/cpp/container/map/deduction_guides.html",
            "wgPageName": "cpp/container/map/deduction_guides",
            "headers": [
                "<map>"
            ],
            "sample_declaration": "template<\n    class InputIt,\n    class Comp = std::less<iter_key_t<InputIt>>,\n    class Alloc = std::allocator<\n        iter_to_alloc_t<InputIt>>>\nmap(InputIt,\n    InputIt,\n    Comp = Comp(),\n    Alloc = Alloc())\n    -> map<\n        iter_key_t<InputIt>,\n        iter_val_t<InputIt>,\n        Comp,\n        Alloc>;",
            "other_declarations": 3
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::emplace_hint",
            "path": "en.cppreference.com/w/cpp/container/map/emplace_hint.html",
            "wgPageName": "cpp/container/map/emplace_hint",
            "sample_declaration": "template<class... Args>\niterator emplace_hint(\n    const_iterator hint,\n    Args&&... args);"
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::emplace",
            "path": "en.cppreference.com/w/cpp/container/map/emplace.html",
            "wgPageName": "cpp/container/map/emplace",
            "sample_declaration": "template<class... Args>\nstd::pair<iterator, bool> emplace(\n    Args&&... args);"
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::empty",
            "path": "en.cppreference.com/w/cpp/container/map/empty.html",
            "wgPageName": "cpp/container/map/empty",
            "sample_declaration": "bool empty() const;",
            "other_declarations": 2
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::end, std::map<Key,T,Compare,Allocator>::cend",
            "path": "en.cppreference.com/w/cpp/container/map/end.html",
            "wgPageName": "cpp/container/map/end",
            "sample_declaration": "iterator end();",
            "other_declarations": 4
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::equal_range",
            "path": "en.cppreference.com/w/cpp/container/map/equal_range.html",
            "wgPageName": "cpp/container/map/equal_range",
            "sample_declaration": "std::pair<iterator, iterator> equal_range(\n    const Key& key);",
            "other_declarations": 3
        },
        {
            "title": "std::erase_if (std::map)",
            "path": "en.cppreference.com/w/cpp/container/map/erase_if.html",
            "wgPageName": "cpp/container/map/erase_if",
            "headers": [
                "<map>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class T,\n    class Compare,\n    class Alloc,\n    class Pred>\ntypename std::map<Key, T, Compare, Alloc>::\n    size_type\n    erase_if(\n        std::map<Key, T, Compare, Alloc>& c,\n        Pred pred);"
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::erase",
            "path": "en.cppreference.com/w/cpp/container/map/erase.html",
            "wgPageName": "cpp/container/map/erase",
            "sample_declaration": "iterator erase(iterator pos);",
            "other_declarations": 5
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::extract",
            "path": "en.cppreference.com/w/cpp/container/map/extract.html",
            "wgPageName": "cpp/container/map/extract",
            "sample_declaration": "node_type extract(const_iterator position);",
            "other_declarations": 2
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::find",
            "path": "en.cppreference.com/w/cpp/container/map/find.html",
            "wgPageName": "cpp/container/map/find",
            "sample_declaration": "iterator find(const Key& key);",
            "other_declarations": 3
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::get_allocator",
            "path": "en.cppreference.com/w/cpp/container/map/get_allocator.html",
            "wgPageName": "cpp/container/map/get_allocator",
            "sample_declaration": "allocator_type get_allocator() const;",
            "other_declarations": 1
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::insert_or_assign",
            "path": "en.cppreference.com/w/cpp/container/map/insert_or_assign.html",
            "wgPageName": "cpp/container/map/insert_or_assign",
            "sample_declaration": "template<class M>\nstd::pair<iterator, bool> insert_or_assign(\n    const Key& k,\n    M&& obj);",
            "other_declarations": 3
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::insert",
            "path": "en.cppreference.com/w/cpp/container/map/insert.html",
            "wgPageName": "cpp/container/map/insert",
            "sample_declaration": "std::pair<iterator, bool> insert(\n    const value_type& value);",
            "other_declarations": 10
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::key_comp",
            "path": "en.cppreference.com/w/cpp/container/map/key_comp.html",
            "wgPageName": "cpp/container/map/key_comp",
            "sample_declaration": "key_compare key_comp() const;"
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::lower_bound",
            "path": "en.cppreference.com/w/cpp/container/map/lower_bound.html",
            "wgPageName": "cpp/container/map/lower_bound",
            "sample_declaration": "iterator lower_bound(const Key& key);",
            "other_declarations": 3
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::map",
            "path": "en.cppreference.com/w/cpp/container/map/map.html",
            "wgPageName": "cpp/container/map/map",
            "sample_declaration": "map();",
            "other_declarations": 10
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::max_size",
            "path": "en.cppreference.com/w/cpp/container/map/max_size.html",
            "wgPageName": "cpp/container/map/max_size",
            "sample_declaration": "size_type max_size() const;",
            "other_declarations": 1
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::merge",
            "path": "en.cppreference.com/w/cpp/container/map/merge.html",
            "wgPageName": "cpp/container/map/merge",
            "sample_declaration": "template<class C2>\nvoid merge(\n    std::map<Key, T, C2, Allocator>& source);",
            "other_declarations": 3
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::operator[]",
            "path": "en.cppreference.com/w/cpp/container/map/operator_at.html",
            "wgPageName": "cpp/container/map/operator_at",
            "sample_declaration": "T& operator[](const Key& key);",
            "other_declarations": 1
        },
        {
            "title": "operator==,!=,<,<=,>,>=,<=>(std::map)",
            "path": "en.cppreference.com/w/cpp/container/map/operator_cmp.html",
            "wgPageName": "cpp/container/map/operator_cmp",
            "headers": [
                "<map>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class T,\n    class Compare,\n    class Alloc>\nbool operator==(\n    const std::map<Key, T, Compare, Alloc>& lhs,\n    const std::map<Key, T, Compare, Alloc>&\n        rhs);",
            "other_declarations": 6
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::operator=",
            "path": "en.cppreference.com/w/cpp/container/map/operator=.html",
            "wgPageName": "cpp/container/map/operator=",
            "sample_declaration": "map& operator=(const map& other);",
            "other_declarations": 3
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::rbegin, std::map<Key,T,Compare,Allocator>::crbegin",
            "path": "en.cppreference.com/w/cpp/container/map/rbegin.html",
            "wgPageName": "cpp/container/map/rbegin",
            "sample_declaration": "reverse_iterator rbegin();",
            "other_declarations": 4
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::rend, std::map<Key,T,Compare,Allocator>::crend",
            "path": "en.cppreference.com/w/cpp/container/map/rend.html",
            "wgPageName": "cpp/container/map/rend",
            "sample_declaration": "reverse_iterator rend();",
            "other_declarations": 4
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::size",
            "path": "en.cppreference.com/w/cpp/container/map/size.html",
            "wgPageName": "cpp/container/map/size",
            "sample_declaration": "size_type size() const;",
            "other_declarations": 1
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::swap",
            "path": "en.cppreference.com/w/cpp/container/map/swap.html",
            "wgPageName": "cpp/container/map/swap",
            "sample_declaration": "void swap(map& other);",
            "other_declarations": 1
        },
        {
            "title": "std::swap(std::map)",
            "path": "en.cppreference.com/w/cpp/container/map/swap2.html",
            "wgPageName": "cpp/container/map/swap2",
            "headers": [
                "<map>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class T,\n    class Compare,\n    class Alloc>\nvoid swap(\n    std::map<Key, T, Compare, Alloc>& lhs,\n    std::map<Key, T, Compare, Alloc>& rhs);",
            "other_declarations": 1
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::try_emplace",
            "path": "en.cppreference.com/w/cpp/container/map/try_emplace.html",
            "wgPageName": "cpp/container/map/try_emplace",
            "sample_declaration": "template<class... Args>\npair<iterator, bool> try_emplace(\n    const Key& k,\n    Args&&... args);",
            "other_declarations": 3
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::upper_bound",
            "path": "en.cppreference.com/w/cpp/container/map/upper_bound.html",
            "wgPageName": "cpp/container/map/upper_bound",
            "sample_declaration": "iterator upper_bound(const Key& key);",
            "other_declarations": 3
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::value_comp",
            "path": "en.cppreference.com/w/cpp/container/map/value_comp.html",
            "wgPageName": "cpp/container/map/value_comp",
            "sample_declaration": "std::map::value_compare value_comp() const;"
        },
        {
            "title": "std::map<Key,T,Compare,Allocator>::value_compare",
            "path": "en.cppreference.com/w/cpp/container/map/value_compare.html",
            "wgPageName": "cpp/container/map/value_compare",
            "sample_declaration": "class value_compare;"
        },
        {
            "title": "std::mdspan",
            "path": "en.cppreference.com/w/cpp/container/mdspan.html",
            "wgPageName": "cpp/container/mdspan",
            "headers": [
                "<mdspan>"
            ],
            "sample_declaration": "template<\n    class T,\n    class Extents,\n    class LayoutPolicy = std::layout_right,\n    class AccessorPolicy =\n        std::default_accessor<T> >\nclass mdspan;"
        },
        {
            "title": "std::multimap",
            "path": "en.cppreference.com/w/cpp/container/multimap.html",
            "wgPageName": "cpp/container/multimap",
            "headers": [
                "<map>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class T,\n    class Compare = std::less<Key>,\n    class Allocator = std::allocator<\n        std::pair<const Key, T> > >\nclass multimap;",
            "other_declarations": 1
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::~multimap",
            "path": "en.cppreference.com/w/cpp/container/multimap/~multimap.html",
            "wgPageName": "cpp/container/multimap/~multimap",
            "sample_declaration": "~multimap();"
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::begin, std::multimap<Key,T,Compare,Allocator>::cbegin",
            "path": "en.cppreference.com/w/cpp/container/multimap/begin.html",
            "wgPageName": "cpp/container/multimap/begin",
            "sample_declaration": "iterator begin();",
            "other_declarations": 4
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::clear",
            "path": "en.cppreference.com/w/cpp/container/multimap/clear.html",
            "wgPageName": "cpp/container/multimap/clear",
            "sample_declaration": "void clear();",
            "other_declarations": 1
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::contains",
            "path": "en.cppreference.com/w/cpp/container/multimap/contains.html",
            "wgPageName": "cpp/container/multimap/contains",
            "sample_declaration": "bool contains(const Key& key) const;",
            "other_declarations": 1
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::count",
            "path": "en.cppreference.com/w/cpp/container/multimap/count.html",
            "wgPageName": "cpp/container/multimap/count",
            "sample_declaration": "size_type count(const Key& key) const;",
            "other_declarations": 1
        },
        {
            "title": "deduction guides for std::multimap",
            "path": "en.cppreference.com/w/cpp/container/multimap/deduction_guides.html",
            "wgPageName": "cpp/container/multimap/deduction_guides",
            "headers": [
                "<map>"
            ],
            "sample_declaration": "template<\n    class InputIt,\n    class Comp = std::less<iter_key_t<InputIt>>,\n    class Alloc = std::allocator<\n        iter_to_alloc_t<InputIt>>>\nmultimap(\n    InputIt,\n    InputIt,\n    Comp = Comp(),\n    Alloc = Alloc())\n    -> multimap<\n        iter_key_t<InputIt>,\n        iter_val_t<InputIt>,\n        Comp,\n        Alloc>;",
            "other_declarations": 3
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::emplace_hint",
            "path": "en.cppreference.com/w/cpp/container/multimap/emplace_hint.html",
            "wgPageName": "cpp/container/multimap/emplace_hint",
            "sample_declaration": "template<class... Args>\niterator emplace_hint(\n    const_iterator hint,\n    Args&&... args);"
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::emplace",
            "path": "en.cppreference.com/w/cpp/container/multimap/emplace.html",
            "wgPageName": "cpp/container/multimap/emplace",
            "sample_declaration": "template<class... Args>\niterator emplace(Args&&... args);"
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::empty",
            "path": "en.cppreference.com/w/cpp/container/multimap/empty.html",
            "wgPageName": "cpp/container/multimap/empty",
            "sample_declaration": "bool empty() const;",
            "other_declarations": 2
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::end, std::multimap<Key,T,Compare,Allocator>::cend",
            "path": "en.cppreference.com/w/cpp/container/multimap/end.html",
            "wgPageName": "cpp/container/multimap/end",
            "sample_declaration": "iterator end();",
            "other_declarations": 4
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::equal_range",
            "path": "en.cppreference.com/w/cpp/container/multimap/equal_range.html",
            "wgPageName": "cpp/container/multimap/equal_range",
            "sample_declaration": "std::pair<iterator, iterator> equal_range(\n    const Key& key);",
            "other_declarations": 3
        },
        {
            "title": "std::erase_if (std::multimap)",
            "path": "en.cppreference.com/w/cpp/container/multimap/erase_if.html",
            "wgPageName": "cpp/container/multimap/erase_if",
            "headers": [
                "<map>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class T,\n    class Compare,\n    class Alloc,\n    class Pred>\ntypename std::multimap<Key, T, Compare, Alloc>::\n    size_type\n    erase_if(\n        std::multimap<Key, T, Compare, Alloc>&\n            c,\n        Pred pred);"
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::erase",
            "path": "en.cppreference.com/w/cpp/container/multimap/erase.html",
            "wgPageName": "cpp/container/multimap/erase",
            "sample_declaration": "iterator erase(iterator pos);",
            "other_declarations": 5
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::extract",
            "path": "en.cppreference.com/w/cpp/container/multimap/extract.html",
            "wgPageName": "cpp/container/multimap/extract",
            "sample_declaration": "node_type extract(const_iterator position);",
            "other_declarations": 2
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::find",
            "path": "en.cppreference.com/w/cpp/container/multimap/find.html",
            "wgPageName": "cpp/container/multimap/find",
            "sample_declaration": "iterator find(const Key& key);",
            "other_declarations": 3
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::get_allocator",
            "path": "en.cppreference.com/w/cpp/container/multimap/get_allocator.html",
            "wgPageName": "cpp/container/multimap/get_allocator",
            "sample_declaration": "allocator_type get_allocator() const;",
            "other_declarations": 1
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::insert",
            "path": "en.cppreference.com/w/cpp/container/multimap/insert.html",
            "wgPageName": "cpp/container/multimap/insert",
            "sample_declaration": "iterator insert(const value_type& value);",
            "other_declarations": 10
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::key_comp",
            "path": "en.cppreference.com/w/cpp/container/multimap/key_comp.html",
            "wgPageName": "cpp/container/multimap/key_comp",
            "sample_declaration": "key_compare key_comp() const;"
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::lower_bound",
            "path": "en.cppreference.com/w/cpp/container/multimap/lower_bound.html",
            "wgPageName": "cpp/container/multimap/lower_bound",
            "sample_declaration": "iterator lower_bound(const Key& key);",
            "other_declarations": 3
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::max_size",
            "path": "en.cppreference.com/w/cpp/container/multimap/max_size.html",
            "wgPageName": "cpp/container/multimap/max_size",
            "sample_declaration": "size_type max_size() const;",
            "other_declarations": 1
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::merge",
            "path": "en.cppreference.com/w/cpp/container/multimap/merge.html",
            "wgPageName": "cpp/container/multimap/merge",
            "sample_declaration": "template<class C2>\nvoid merge(\n    std::map<Key, T, C2, Allocator>& source);",
            "other_declarations": 3
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::multimap",
            "path": "en.cppreference.com/w/cpp/container/multimap/multimap.html",
            "wgPageName": "cpp/container/multimap/multimap",
            "sample_declaration": "multimap();",
            "other_declarations": 10
        },
        {
            "title": "operator==,!=,<,<=,>,>=,<=>(std::multimap)",
            "path": "en.cppreference.com/w/cpp/container/multimap/operator_cmp.html",
            "wgPageName": "cpp/container/multimap/operator_cmp",
            "headers": [
                "<map>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class T,\n    class Compare,\n    class Alloc>\nbool operator==(\n    const std::multimap<Key, T, Compare, Alloc>&\n        lhs,\n    const std::multimap<Key, T, Compare, Alloc>&\n        rhs);",
            "other_declarations": 6
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::operator=",
            "path": "en.cppreference.com/w/cpp/container/multimap/operator=.html",
            "wgPageName": "cpp/container/multimap/operator=",
            "sample_declaration": "multimap& operator=(const multimap& other);",
            "other_declarations": 3
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::rbegin, std::multimap<Key,T,Compare,Allocator>::crbegin",
            "path": "en.cppreference.com/w/cpp/container/multimap/rbegin.html",
            "wgPageName": "cpp/container/multimap/rbegin",
            "sample_declaration": "reverse_iterator rbegin();",
            "other_declarations": 4
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::rend, std::multimap<Key,T,Compare,Allocator>::crend",
            "path": "en.cppreference.com/w/cpp/container/multimap/rend.html",
            "wgPageName": "cpp/container/multimap/rend",
            "sample_declaration": "reverse_iterator rend();",
            "other_declarations": 4
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::size",
            "path": "en.cppreference.com/w/cpp/container/multimap/size.html",
            "wgPageName": "cpp/container/multimap/size",
            "sample_declaration": "size_type size() const;",
            "other_declarations": 1
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::swap",
            "path": "en.cppreference.com/w/cpp/container/multimap/swap.html",
            "wgPageName": "cpp/container/multimap/swap",
            "sample_declaration": "void swap(multimap& other);",
            "other_declarations": 1
        },
        {
            "title": "std::swap(std::multimap)",
            "path": "en.cppreference.com/w/cpp/container/multimap/swap2.html",
            "wgPageName": "cpp/container/multimap/swap2",
            "headers": [
                "<map>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class T,\n    class Compare,\n    class Alloc>\nvoid swap(\n    std::multimap<Key, T, Compare, Alloc>& lhs,\n    std::multimap<Key, T, Compare, Alloc>& rhs);",
            "other_declarations": 1
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::upper_bound",
            "path": "en.cppreference.com/w/cpp/container/multimap/upper_bound.html",
            "wgPageName": "cpp/container/multimap/upper_bound",
            "sample_declaration": "iterator upper_bound(const Key& key);",
            "other_declarations": 3
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::value_comp",
            "path": "en.cppreference.com/w/cpp/container/multimap/value_comp.html",
            "wgPageName": "cpp/container/multimap/value_comp",
            "sample_declaration": "std::multimap::value_compare value_comp() const;"
        },
        {
            "title": "std::multimap<Key,T,Compare,Allocator>::value_compare",
            "path": "en.cppreference.com/w/cpp/container/multimap/value_compare.html",
            "wgPageName": "cpp/container/multimap/value_compare",
            "sample_declaration": "class value_compare;"
        },
        {
            "title": "std::multiset",
            "path": "en.cppreference.com/w/cpp/container/multiset.html",
            "wgPageName": "cpp/container/multiset",
            "headers": [
                "<set>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class Compare = std::less<Key>,\n    class Allocator = std::allocator<Key> >\nclass multiset;",
            "other_declarations": 1
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::~multiset",
            "path": "en.cppreference.com/w/cpp/container/multiset/~multiset.html",
            "wgPageName": "cpp/container/multiset/~multiset",
            "sample_declaration": "~multiset();"
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::begin, std::multiset<Key,Compare,Allocator>::cbegin",
            "path": "en.cppreference.com/w/cpp/container/multiset/begin.html",
            "wgPageName": "cpp/container/multiset/begin",
            "sample_declaration": "iterator begin();",
            "other_declarations": 4
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::clear",
            "path": "en.cppreference.com/w/cpp/container/multiset/clear.html",
            "wgPageName": "cpp/container/multiset/clear",
            "sample_declaration": "void clear();",
            "other_declarations": 1
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::contains",
            "path": "en.cppreference.com/w/cpp/container/multiset/contains.html",
            "wgPageName": "cpp/container/multiset/contains",
            "sample_declaration": "bool contains(const Key& key) const;",
            "other_declarations": 1
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::count",
            "path": "en.cppreference.com/w/cpp/container/multiset/count.html",
            "wgPageName": "cpp/container/multiset/count",
            "sample_declaration": "size_type count(const Key& key) const;",
            "other_declarations": 1
        },
        {
            "title": "deduction guides for std::multiset",
            "path": "en.cppreference.com/w/cpp/container/multiset/deduction_guides.html",
            "wgPageName": "cpp/container/multiset/deduction_guides",
            "headers": [
                "<set>"
            ],
            "sample_declaration": "template<\n    class InputIt,\n    class Comp =\n        std::less<typename std::iterator_traits<\n            InputIt>::value_type>,\n    class Alloc = std::allocator<\n        typename std::iterator_traits<\n            InputIt>::value_type>>\nmultiset(\n    InputIt,\n    InputIt,\n    Comp = Comp(),\n    Alloc = Alloc())\n    -> multiset<\n        typename std::iterator_traits<\n            InputIt>::value_type,\n        Comp,\n        Alloc>;",
            "other_declarations": 3
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::emplace_hint",
            "path": "en.cppreference.com/w/cpp/container/multiset/emplace_hint.html",
            "wgPageName": "cpp/container/multiset/emplace_hint",
            "sample_declaration": "template<class... Args>\niterator emplace_hint(\n    const_iterator hint,\n    Args&&... args);"
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::emplace",
            "path": "en.cppreference.com/w/cpp/container/multiset/emplace.html",
            "wgPageName": "cpp/container/multiset/emplace",
            "sample_declaration": "template<class... Args>\niterator emplace(Args&&... args);"
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::empty",
            "path": "en.cppreference.com/w/cpp/container/multiset/empty.html",
            "wgPageName": "cpp/container/multiset/empty",
            "sample_declaration": "bool empty() const;",
            "other_declarations": 2
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::end, std::multiset<Key,Compare,Allocator>::cend",
            "path": "en.cppreference.com/w/cpp/container/multiset/end.html",
            "wgPageName": "cpp/container/multiset/end",
            "sample_declaration": "iterator end();",
            "other_declarations": 4
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::equal_range",
            "path": "en.cppreference.com/w/cpp/container/multiset/equal_range.html",
            "wgPageName": "cpp/container/multiset/equal_range",
            "sample_declaration": "std::pair<iterator, iterator> equal_range(\n    const Key& key);",
            "other_declarations": 3
        },
        {
            "title": "std::erase_if (std::multiset)",
            "path": "en.cppreference.com/w/cpp/container/multiset/erase_if.html",
            "wgPageName": "cpp/container/multiset/erase_if",
            "headers": [
                "<set>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class Compare,\n    class Alloc,\n    class Pred>\ntypename std::multiset<Key, Compare, Alloc>::\n    size_type\n    erase_if(\n        std::multiset<Key, Compare, Alloc>& c,\n        Pred pred);"
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::erase",
            "path": "en.cppreference.com/w/cpp/container/multiset/erase.html",
            "wgPageName": "cpp/container/multiset/erase",
            "sample_declaration": "iterator erase(iterator pos);",
            "other_declarations": 5
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::extract",
            "path": "en.cppreference.com/w/cpp/container/multiset/extract.html",
            "wgPageName": "cpp/container/multiset/extract",
            "sample_declaration": "node_type extract(const_iterator position);",
            "other_declarations": 2
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::find",
            "path": "en.cppreference.com/w/cpp/container/multiset/find.html",
            "wgPageName": "cpp/container/multiset/find",
            "sample_declaration": "iterator find(const Key& key);",
            "other_declarations": 3
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::get_allocator",
            "path": "en.cppreference.com/w/cpp/container/multiset/get_allocator.html",
            "wgPageName": "cpp/container/multiset/get_allocator",
            "sample_declaration": "allocator_type get_allocator() const;",
            "other_declarations": 1
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::insert",
            "path": "en.cppreference.com/w/cpp/container/multiset/insert.html",
            "wgPageName": "cpp/container/multiset/insert",
            "sample_declaration": "iterator insert(const value_type& value);",
            "other_declarations": 8
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::key_comp",
            "path": "en.cppreference.com/w/cpp/container/multiset/key_comp.html",
            "wgPageName": "cpp/container/multiset/key_comp",
            "sample_declaration": "key_compare key_comp() const;"
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::lower_bound",
            "path": "en.cppreference.com/w/cpp/container/multiset/lower_bound.html",
            "wgPageName": "cpp/container/multiset/lower_bound",
            "sample_declaration": "iterator lower_bound(const Key& key);",
            "other_declarations": 3
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::max_size",
            "path": "en.cppreference.com/w/cpp/container/multiset/max_size.html",
            "wgPageName": "cpp/container/multiset/max_size",
            "sample_declaration": "size_type max_size() const;",
            "other_declarations": 1
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::merge",
            "path": "en.cppreference.com/w/cpp/container/multiset/merge.html",
            "wgPageName": "cpp/container/multiset/merge",
            "sample_declaration": "template<class C2>\nvoid merge(\n    std::set<Key, C2, Allocator>& source);",
            "other_declarations": 3
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::multiset",
            "path": "en.cppreference.com/w/cpp/container/multiset/multiset.html",
            "wgPageName": "cpp/container/multiset/multiset",
            "sample_declaration": "multiset();",
            "other_declarations": 10
        },
        {
            "title": "operator==,!=,<,<=,>,>=,<=>(std::multiset)",
            "path": "en.cppreference.com/w/cpp/container/multiset/operator_cmp.html",
            "wgPageName": "cpp/container/multiset/operator_cmp",
            "headers": [
                "<set>"
            ],
            "sample_declaration": "template<class Key, class Compare, class Alloc>\nbool operator==(\n    const std::multiset<Key, Compare, Alloc>&\n        lhs,\n    const std::multiset<Key, Compare, Alloc>&\n        rhs);",
            "other_declarations": 6
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::operator=",
            "path": "en.cppreference.com/w/cpp/container/multiset/operator=.html",
            "wgPageName": "cpp/container/multiset/operator=",
            "sample_declaration": "multiset& operator=(const multiset& other);",
            "other_declarations": 3
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::rbegin, std::multiset<Key,Compare,Allocator>::crbegin",
            "path": "en.cppreference.com/w/cpp/container/multiset/rbegin.html",
            "wgPageName": "cpp/container/multiset/rbegin",
            "sample_declaration": "reverse_iterator rbegin();",
            "other_declarations": 4
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::rend, std::multiset<Key,Compare,Allocator>::crend",
            "path": "en.cppreference.com/w/cpp/container/multiset/rend.html",
            "wgPageName": "cpp/container/multiset/rend",
            "sample_declaration": "reverse_iterator rend();",
            "other_declarations": 4
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::size",
            "path": "en.cppreference.com/w/cpp/container/multiset/size.html",
            "wgPageName": "cpp/container/multiset/size",
            "sample_declaration": "size_type size() const;",
            "other_declarations": 1
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::swap",
            "path": "en.cppreference.com/w/cpp/container/multiset/swap.html",
            "wgPageName": "cpp/container/multiset/swap",
            "sample_declaration": "void swap(multiset& other);",
            "other_declarations": 1
        },
        {
            "title": "std::swap(std::multiset)",
            "path": "en.cppreference.com/w/cpp/container/multiset/swap2.html",
            "wgPageName": "cpp/container/multiset/swap2",
            "headers": [
                "<set>"
            ],
            "sample_declaration": "template<class Key, class Compare, class Alloc>\nvoid swap(\n    std::multiset<Key, Compare, Alloc>& lhs,\n    std::multiset<Key, Compare, Alloc>& rhs);",
            "other_declarations": 1
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::upper_bound",
            "path": "en.cppreference.com/w/cpp/container/multiset/upper_bound.html",
            "wgPageName": "cpp/container/multiset/upper_bound",
            "sample_declaration": "iterator upper_bound(const Key& key);",
            "other_declarations": 3
        },
        {
            "title": "std::multiset<Key,Compare,Allocator>::value_comp",
            "path": "en.cppreference.com/w/cpp/container/multiset/value_comp.html",
            "wgPageName": "cpp/container/multiset/value_comp",
            "sample_declaration": "std::multiset::value_compare value_comp() const;"
        },
        {
            "title": "Node handle (C++17)",
            "path": "en.cppreference.com/w/cpp/container/node_handle.html",
            "wgPageName": "cpp/container/node_handle",
            "sample_declaration": "template</*unspecified*/>\nclass /*node-handle*/;"
        },
        {
            "title": "std::priority_queue",
            "path": "en.cppreference.com/w/cpp/container/priority_queue.html",
            "wgPageName": "cpp/container/priority_queue",
            "headers": [
                "<queue>"
            ],
            "sample_declaration": "template<\n    class T,\n    class Container = std::vector<T>,\n    class Compare = std::less<\n        typename Container::value_type> >\nclass priority_queue;"
        },
        {
            "title": "std::priority_queue<T,Container,Compare>::~priority_queue",
            "path": "en.cppreference.com/w/cpp/container/priority_queue/~priority_queue.html",
            "wgPageName": "cpp/container/priority_queue/~priority_queue",
            "sample_declaration": "~priority_queue();"
        },
        {
            "title": "deduction guides for std::priority_queue",
            "path": "en.cppreference.com/w/cpp/container/priority_queue/deduction_guides.html",
            "wgPageName": "cpp/container/priority_queue/deduction_guides",
            "headers": [
                "<queue>"
            ],
            "sample_declaration": "template<class Comp, class Container>\npriority_queue(Comp, Container)\n    -> priority_queue<\n        typename Container::value_type,\n        Container,\n        Comp>;",
            "other_declarations": 5
        },
        {
            "title": "std::priority_queue<T,Container,Compare>::emplace",
            "path": "en.cppreference.com/w/cpp/container/priority_queue/emplace.html",
            "wgPageName": "cpp/container/priority_queue/emplace",
            "sample_declaration": "template<class... Args>\nvoid emplace(Args&&... args);"
        },
        {
            "title": "std::priority_queue<T,Container,Compare>::empty",
            "path": "en.cppreference.com/w/cpp/container/priority_queue/empty.html",
            "wgPageName": "cpp/container/priority_queue/empty",
            "sample_declaration": "bool empty() const;",
            "other_declarations": 1
        },
        {
            "title": "std::priority_queue<T,Container,Compare>::operator=",
            "path": "en.cppreference.com/w/cpp/container/priority_queue/operator=.html",
            "wgPageName": "cpp/container/priority_queue/operator=",
            "sample_declaration": "priority_queue& operator=(\n    const priority_queue& other);",
            "other_declarations": 1
        },
        {
            "title": "std::priority_queue<T,Container,Compare>::pop",
            "path": "en.cppreference.com/w/cpp/container/priority_queue/pop.html",
            "wgPageName": "cpp/container/priority_queue/pop",
            "sample_declaration": "void pop();"
        },
        {
            "title": "std::priority_queue<T,Container,Compare>::priority_queue",
            "path": "en.cppreference.com/w/cpp/container/priority_queue/priority_queue.html",
            "wgPageName": "cpp/container/priority_queue/priority_queue",
            "sample_declaration": "priority_queue()\n    : priority_queue(Compare(), Container()) {}",
            "other_declarations": 20
        },
        {
            "title": "std::priority_queue<T,Container,Compare>::push",
            "path": "en.cppreference.com/w/cpp/container/priority_queue/push.html",
            "wgPageName": "cpp/container/priority_queue/push",
            "sample_declaration": "void push(const value_type& value);",
            "other_declarations": 1
        },
        {
            "title": "std::priority_queue<T,Container,Compare>::size",
            "path": "en.cppreference.com/w/cpp/container/priority_queue/size.html",
            "wgPageName": "cpp/container/priority_queue/size",
            "sample_declaration": "size_type size() const;"
        },
        {
            "title": "std::priority_queue<T,Container,Compare>::swap",
            "path": "en.cppreference.com/w/cpp/container/priority_queue/swap.html",
            "wgPageName": "cpp/container/priority_queue/swap",
            "sample_declaration": "void swap(priority_queue& other) noexcept(\n    /* see below */);"
        },
        {
            "title": "std::swap(std::priority_queue)",
            "path": "en.cppreference.com/w/cpp/container/priority_queue/swap2.html",
            "wgPageName": "cpp/container/priority_queue/swap2",
            "headers": [
                "<queue>"
            ],
            "sample_declaration": "template<\n    class T,\n    class Container,\n    class Compare>\nvoid swap(\n    std::priority_queue<T, Container, Compare>&\n        lhs,\n    std::priority_queue<T, Container, Compare>&\n        rhs);",
            "other_declarations": 1
        },
        {
            "title": "std::priority_queue<T,Container,Compare>::top",
            "path": "en.cppreference.com/w/cpp/container/priority_queue/top.html",
            "wgPageName": "cpp/container/priority_queue/top",
            "sample_declaration": "const_reference top() const;"
        },
        {
            "title": "std::uses_allocator<std::priority_queue>",
            "path": "en.cppreference.com/w/cpp/container/priority_queue/uses_allocator.html",
            "wgPageName": "cpp/container/priority_queue/uses_allocator",
            "sample_declaration": "template<\n    class T,\n    class Container,\n    class Compare,\n    class Alloc>\nstruct uses_allocator<\n    priority_queue<T, Compare, Container>,\n    Alloc>\n    : std::uses_allocator<Container, Alloc>::\n          type {};"
        },
        {
            "title": "std::queue",
            "path": "en.cppreference.com/w/cpp/container/queue.html",
            "wgPageName": "cpp/container/queue",
            "headers": [
                "<queue>"
            ],
            "sample_declaration": "template<\n    class T,\n    class Container = std::deque<T> >\nclass queue;"
        },
        {
            "title": "std::queue<T,Container>::~queue",
            "path": "en.cppreference.com/w/cpp/container/queue/~queue.html",
            "wgPageName": "cpp/container/queue/~queue",
            "sample_declaration": "~queue();"
        },
        {
            "title": "std::queue<T,Container>::back",
            "path": "en.cppreference.com/w/cpp/container/queue/back.html",
            "wgPageName": "cpp/container/queue/back",
            "sample_declaration": "reference back();",
            "other_declarations": 1
        },
        {
            "title": "deduction guides for std::queue",
            "path": "en.cppreference.com/w/cpp/container/queue/deduction_guides.html",
            "wgPageName": "cpp/container/queue/deduction_guides",
            "headers": [
                "<queue>"
            ],
            "sample_declaration": "template<class Container>\nqueue(Container) -> queue<\n    typename Container::value_type,\n    Container>;",
            "other_declarations": 3
        },
        {
            "title": "std::queue<T,Container>::emplace",
            "path": "en.cppreference.com/w/cpp/container/queue/emplace.html",
            "wgPageName": "cpp/container/queue/emplace",
            "sample_declaration": "template<class... Args>\nvoid emplace(Args&&... args);",
            "other_declarations": 1
        },
        {
            "title": "std::queue<T,Container>::empty",
            "path": "en.cppreference.com/w/cpp/container/queue/empty.html",
            "wgPageName": "cpp/container/queue/empty",
            "sample_declaration": "bool empty() const;",
            "other_declarations": 1
        },
        {
            "title": "std::queue<T,Container>::front",
            "path": "en.cppreference.com/w/cpp/container/queue/front.html",
            "wgPageName": "cpp/container/queue/front",
            "sample_declaration": "reference front();",
            "other_declarations": 1
        },
        {
            "title": "operator==,!=,<,<=,>,>=,<=>(std::queue)",
            "path": "en.cppreference.com/w/cpp/container/queue/operator_cmp.html",
            "wgPageName": "cpp/container/queue/operator_cmp",
            "sample_declaration": "template<class T, class Container>\nbool operator==(\n    const std::queue<T, Container>& lhs,\n    const std::queue<T, Container>& rhs);",
            "other_declarations": 6
        },
        {
            "title": "std::queue<T,Container>::operator=",
            "path": "en.cppreference.com/w/cpp/container/queue/operator=.html",
            "wgPageName": "cpp/container/queue/operator=",
            "sample_declaration": "queue& operator=(const queue& other);",
            "other_declarations": 1
        },
        {
            "title": "std::queue<T,Container>::pop",
            "path": "en.cppreference.com/w/cpp/container/queue/pop.html",
            "wgPageName": "cpp/container/queue/pop",
            "sample_declaration": "void pop();"
        },
        {
            "title": "std::queue<T,Container>::push",
            "path": "en.cppreference.com/w/cpp/container/queue/push.html",
            "wgPageName": "cpp/container/queue/push",
            "sample_declaration": "void push(const value_type& value);",
            "other_declarations": 1
        },
        {
            "title": "std::queue<T,Container>::queue",
            "path": "en.cppreference.com/w/cpp/container/queue/queue.html",
            "wgPageName": "cpp/container/queue/queue",
            "sample_declaration": "queue() : queue(Container()) {}",
            "other_declarations": 12
        },
        {
            "title": "std::queue<T,Container>::size",
            "path": "en.cppreference.com/w/cpp/container/queue/size.html",
            "wgPageName": "cpp/container/queue/size",
            "sample_declaration": "size_type size() const;"
        },
        {
            "title": "std::queue<T,Container>::swap",
            "path": "en.cppreference.com/w/cpp/container/queue/swap.html",
            "wgPageName": "cpp/container/queue/swap",
            "sample_declaration": "void swap(queue& other) noexcept(\n    /* see below */);"
        },
        {
            "title": "std::swap(std::queue)",
            "path": "en.cppreference.com/w/cpp/container/queue/swap2.html",
            "wgPageName": "cpp/container/queue/swap2",
            "headers": [
                "<queue>"
            ],
            "sample_declaration": "template<class T, class Container>\nvoid swap(\n    std::queue<T, Container>& lhs,\n    std::queue<T, Container>& rhs);",
            "other_declarations": 1
        },
        {
            "title": "std::uses_allocator<std::queue>",
            "path": "en.cppreference.com/w/cpp/container/queue/uses_allocator.html",
            "wgPageName": "cpp/container/queue/uses_allocator",
            "sample_declaration": "template<class T, class Container, class Alloc>\nstruct uses_allocator<\n    queue<T, Container>,\n    Alloc>\n    : std::uses_allocator<Container, Alloc>::\n          type {};"
        },
        {
            "title": "std::set",
            "path": "en.cppreference.com/w/cpp/container/set.html",
            "wgPageName": "cpp/container/set",
            "headers": [
                "<set>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class Compare = std::less<Key>,\n    class Allocator = std::allocator<Key> >\nclass set;",
            "other_declarations": 1
        },
        {
            "title": "std::set<Key,Compare,Allocator>::~set",
            "path": "en.cppreference.com/w/cpp/container/set/~set.html",
            "wgPageName": "cpp/container/set/~set",
            "sample_declaration": "~set();"
        },
        {
            "title": "std::set<Key,Compare,Allocator>::begin, std::set<Key,Compare,Allocator>::cbegin",
            "path": "en.cppreference.com/w/cpp/container/set/begin.html",
            "wgPageName": "cpp/container/set/begin",
            "sample_declaration": "iterator begin();",
            "other_declarations": 4
        },
        {
            "title": "std::set<Key,Compare,Allocator>::clear",
            "path": "en.cppreference.com/w/cpp/container/set/clear.html",
            "wgPageName": "cpp/container/set/clear",
            "sample_declaration": "void clear();",
            "other_declarations": 1
        },
        {
            "title": "std::set<Key,Compare,Allocator>::contains",
            "path": "en.cppreference.com/w/cpp/container/set/contains.html",
            "wgPageName": "cpp/container/set/contains",
            "sample_declaration": "bool contains(const Key& key) const;",
            "other_declarations": 1
        },
        {
            "title": "std::set<Key,Compare,Allocator>::count",
            "path": "en.cppreference.com/w/cpp/container/set/count.html",
            "wgPageName": "cpp/container/set/count",
            "sample_declaration": "size_type count(const Key& key) const;",
            "other_declarations": 1
        },
        {
            "title": "deduction guides for std::set",
            "path": "en.cppreference.com/w/cpp/container/set/deduction_guides.html",
            "wgPageName": "cpp/container/set/deduction_guides",
            "headers": [
                "<set>"
            ],
            "sample_declaration": "template<\n    class InputIt,\n    class Comp =\n        std::less<typename std::iterator_traits<\n            InputIt>::value_type>,\n    class Alloc = std::allocator<\n        typename std::iterator_traits<\n            InputIt>::value_type>>\nset(InputIt,\n    InputIt,\n    Comp = Comp(),\n    Alloc = Alloc())\n    -> set<\n        typename std::iterator_traits<\n            InputIt>::value_type,\n        Comp,\n        Alloc>;",
            "other_declarations": 3
        },
        {
            "title": "std::set<Key,Compare,Allocator>::emplace_hint",
            "path": "en.cppreference.com/w/cpp/container/set/emplace_hint.html",
            "wgPageName": "cpp/container/set/emplace_hint",
            "sample_declaration": "template<class... Args>\niterator emplace_hint(\n    const_iterator hint,\n    Args&&... args);"
        },
        {
            "title": "std::set<Key,Compare,Allocator>::emplace",
            "path": "en.cppreference.com/w/cpp/container/set/emplace.html",
            "wgPageName": "cpp/container/set/emplace",
            "sample_declaration": "template<class... Args>\nstd::pair<iterator, bool> emplace(\n    Args&&... args);"
        },
        {
            "title": "std::set<Key,Compare,Allocator>::empty",
            "path": "en.cppreference.com/w/cpp/container/set/empty.html",
            "wgPageName": "cpp/container/set/empty",
            "sample_declaration": "bool empty() const;",
            "other_declarations": 2
        },
        {
            "title": "std::set<Key,Compare,Allocator>::end, std::set<Key,Compare,Allocator>::cend",
            "path": "en.cppreference.com/w/cpp/container/set/end.html",
            "wgPageName": "cpp/container/set/end",
            "sample_declaration": "iterator end();",
            "other_declarations": 4
        },
        {
            "title": "std::set<Key,Compare,Allocator>::equal_range",
            "path": "en.cppreference.com/w/cpp/container/set/equal_range.html",
            "wgPageName": "cpp/container/set/equal_range",
            "sample_declaration": "std::pair<iterator, iterator> equal_range(\n    const Key& key);",
            "other_declarations": 3
        },
        {
            "title": "std::erase_if (std::set)",
            "path": "en.cppreference.com/w/cpp/container/set/erase_if.html",
            "wgPageName": "cpp/container/set/erase_if",
            "headers": [
                "<set>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class Compare,\n    class Alloc,\n    class Pred>\ntypename std::set<Key, Compare, Alloc>::\n    size_type\n    erase_if(\n        std::set<Key, Compare, Alloc>& c,\n        Pred pred);"
        },
        {
            "title": "std::set<Key,Compare,Allocator>::erase",
            "path": "en.cppreference.com/w/cpp/container/set/erase.html",
            "wgPageName": "cpp/container/set/erase",
            "sample_declaration": "iterator erase(iterator pos);",
            "other_declarations": 5
        },
        {
            "title": "std::set<Key,Compare,Allocator>::extract",
            "path": "en.cppreference.com/w/cpp/container/set/extract.html",
            "wgPageName": "cpp/container/set/extract",
            "sample_declaration": "node_type extract(const_iterator position);",
            "other_declarations": 2
        },
        {
            "title": "std::set<Key,Compare,Allocator>::find",
            "path": "en.cppreference.com/w/cpp/container/set/find.html",
            "wgPageName": "cpp/container/set/find",
            "sample_declaration": "iterator find(const Key& key);",
            "other_declarations": 3
        },
        {
            "title": "std::set<Key,Compare,Allocator>::get_allocator",
            "path": "en.cppreference.com/w/cpp/container/set/get_allocator.html",
            "wgPageName": "cpp/container/set/get_allocator",
            "sample_declaration": "allocator_type get_allocator() const;",
            "other_declarations": 1
        },
        {
            "title": "std::set<Key,Compare,Allocator>::insert",
            "path": "en.cppreference.com/w/cpp/container/set/insert.html",
            "wgPageName": "cpp/container/set/insert",
            "sample_declaration": "std::pair<iterator, bool> insert(\n    const value_type& value);",
            "other_declarations": 8
        },
        {
            "title": "std::set<Key,Compare,Allocator>::key_comp",
            "path": "en.cppreference.com/w/cpp/container/set/key_comp.html",
            "wgPageName": "cpp/container/set/key_comp",
            "sample_declaration": "key_compare key_comp() const;"
        },
        {
            "title": "std::set<Key,Compare,Allocator>::lower_bound",
            "path": "en.cppreference.com/w/cpp/container/set/lower_bound.html",
            "wgPageName": "cpp/container/set/lower_bound",
            "sample_declaration": "iterator lower_bound(const Key& key);",
            "other_declarations": 3
        },
        {
            "title": "std::set<Key,Compare,Allocator>::max_size",
            "path": "en.cppreference.com/w/cpp/container/set/max_size.html",
            "wgPageName": "cpp/container/set/max_size",
            "sample_declaration": "size_type max_size() const;",
            "other_declarations": 1
        },
        {
            "title": "std::set<Key,Compare,Allocator>::merge",
            "path": "en.cppreference.com/w/cpp/container/set/merge.html",
            "wgPageName": "cpp/container/set/merge",
            "sample_declaration": "template<class C2>\nvoid merge(\n    std::set<Key, C2, Allocator>& source);",
            "other_declarations": 3
        },
        {
            "title": "operator==,!=,<,<=,>,>=,<=>(std::set)",
            "path": "en.cppreference.com/w/cpp/container/set/operator_cmp.html",
            "wgPageName": "cpp/container/set/operator_cmp",
            "headers": [
                "<set>"
            ],
            "sample_declaration": "template<class Key, class Compare, class Alloc>\nbool operator==(\n    const std::set<Key, Compare, Alloc>& lhs,\n    const std::set<Key, Compare, Alloc>& rhs);",
            "other_declarations": 6
        },
        {
            "title": "std::set<Key,Compare,Allocator>::operator=",
            "path": "en.cppreference.com/w/cpp/container/set/operator=.html",
            "wgPageName": "cpp/container/set/operator=",
            "sample_declaration": "set& operator=(const set& other);",
            "other_declarations": 3
        },
        {
            "title": "std::set<Key,Compare,Allocator>::rbegin, std::set<Key,Compare,Allocator>::crbegin",
            "path": "en.cppreference.com/w/cpp/container/set/rbegin.html",
            "wgPageName": "cpp/container/set/rbegin",
            "sample_declaration": "reverse_iterator rbegin();",
            "other_declarations": 4
        },
        {
            "title": "std::set<Key,Compare,Allocator>::rend, std::set<Key,Compare,Allocator>::crend",
            "path": "en.cppreference.com/w/cpp/container/set/rend.html",
            "wgPageName": "cpp/container/set/rend",
            "sample_declaration": "reverse_iterator rend();",
            "other_declarations": 4
        },
        {
            "title": "std::set<Key,Compare,Allocator>::set",
            "path": "en.cppreference.com/w/cpp/container/set/set.html",
            "wgPageName": "cpp/container/set/set",
            "sample_declaration": "set();\nexplicit set(\n    const Compare& comp,\n    const Allocator& alloc = Allocator());",
            "other_declarations": 9
        },
        {
            "title": "std::set<Key,Compare,Allocator>::size",
            "path": "en.cppreference.com/w/cpp/container/set/size.html",
            "wgPageName": "cpp/container/set/size",
            "sample_declaration": "size_type size() const;",
            "other_declarations": 1
        },
        {
            "title": "std::set<Key,Compare,Allocator>::swap",
            "path": "en.cppreference.com/w/cpp/container/set/swap.html",
            "wgPageName": "cpp/container/set/swap",
            "sample_declaration": "void swap(set& other);",
            "other_declarations": 1
        },
        {
            "title": "std::swap(std::set)",
            "path": "en.cppreference.com/w/cpp/container/set/swap2.html",
            "wgPageName": "cpp/container/set/swap2",
            "headers": [
                "<set>"
            ],
            "sample_declaration": "template<class Key, class Compare, class Alloc>\nvoid swap(\n    std::set<Key, Compare, Alloc>& lhs,\n    std::set<Key, Compare, Alloc>& rhs);",
            "other_declarations": 1
        },
        {
            "title": "std::set<Key,Compare,Allocator>::upper_bound",
            "path": "en.cppreference.com/w/cpp/container/set/upper_bound.html",
            "wgPageName": "cpp/container/set/upper_bound",
            "sample_declaration": "iterator upper_bound(const Key& key);",
            "other_declarations": 3
        },
        {
            "title": "std::set<Key,Compare,Allocator>::value_comp",
            "path": "en.cppreference.com/w/cpp/container/set/value_comp.html",
            "wgPageName": "cpp/container/set/value_comp",
            "sample_declaration": "std::set::value_compare value_comp() const;"
        },
        {
            "title": "std::span",
            "path": "en.cppreference.com/w/cpp/container/span.html",
            "wgPageName": "cpp/container/span",
            "headers": [
                "<span>"
            ],
            "sample_declaration": "template<\n    class T,\n    std::size_t Extent = std::dynamic_extent>\nclass span;"
        },
        {
            "title": "std::as_bytes, std::as_writable_bytes",
            "path": "en.cppreference.com/w/cpp/container/span/as_bytes.html",
            "wgPageName": "cpp/container/span/as_bytes",
            "headers": [
                "<span>"
            ],
            "sample_declaration": "template<class T, std::size_t N>\nstd::span<const std::byte, S /* see below */>\nas_bytes(std::span<T, N> s) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::span<T,Extent>::back",
            "path": "en.cppreference.com/w/cpp/container/span/back.html",
            "wgPageName": "cpp/container/span/back",
            "sample_declaration": "constexpr reference back() const;"
        },
        {
            "title": "std::span<T,Extent>::begin",
            "path": "en.cppreference.com/w/cpp/container/span/begin.html",
            "wgPageName": "cpp/container/span/begin",
            "sample_declaration": "constexpr iterator begin() const noexcept;"
        },
        {
            "title": "std::span<T,Extent>::data",
            "path": "en.cppreference.com/w/cpp/container/span/data.html",
            "wgPageName": "cpp/container/span/data",
            "sample_declaration": "constexpr pointer data() const noexcept;"
        },
        {
            "title": "deduction guides for std::span",
            "path": "en.cppreference.com/w/cpp/container/span/deduction_guides.html",
            "wgPageName": "cpp/container/span/deduction_guides",
            "headers": [
                "<span>"
            ],
            "sample_declaration": "template<class It, class EndOrSize>\nspan(It, EndOrSize)\n    -> span<std::remove_reference_t<\n        std::iter_reference_t<It>>>;",
            "other_declarations": 4
        },
        {
            "title": "std::dynamic_extent",
            "path": "en.cppreference.com/w/cpp/container/span/dynamic_extent.html",
            "wgPageName": "cpp/container/span/dynamic_extent",
            "headers": [
                "<span>"
            ],
            "sample_declaration": "inline constexpr std::size_t dynamic_extent =\n    std::numeric_limits<std::size_t>::max();"
        },
        {
            "title": "std::span<T,Extent>::empty",
            "path": "en.cppreference.com/w/cpp/container/span/empty.html",
            "wgPageName": "cpp/container/span/empty",
            "sample_declaration": "[[nodiscard]] constexpr bool empty()\n    const noexcept;"
        },
        {
            "title": "std::span<T,Extent>::end",
            "path": "en.cppreference.com/w/cpp/container/span/end.html",
            "wgPageName": "cpp/container/span/end",
            "sample_declaration": "constexpr iterator end() const noexcept;"
        },
        {
            "title": "std::span<T,Extent>::first",
            "path": "en.cppreference.com/w/cpp/container/span/first.html",
            "wgPageName": "cpp/container/span/first",
            "sample_declaration": "template<std::size_t Count>\nconstexpr std::span<element_type, Count> first()\n    const;",
            "other_declarations": 1
        },
        {
            "title": "std::span<T,Extent>::front",
            "path": "en.cppreference.com/w/cpp/container/span/front.html",
            "wgPageName": "cpp/container/span/front",
            "sample_declaration": "constexpr reference front() const;"
        },
        {
            "title": "std::span<T,Extent>::last",
            "path": "en.cppreference.com/w/cpp/container/span/last.html",
            "wgPageName": "cpp/container/span/last",
            "sample_declaration": "template<std::size_t Count>\nconstexpr std::span<element_type, Count> last()\n    const;",
            "other_declarations": 1
        },
        {
            "title": "std::span<T,Extent>::operator[]",
            "path": "en.cppreference.com/w/cpp/container/span/operator_at.html",
            "wgPageName": "cpp/container/span/operator_at",
            "sample_declaration": "constexpr reference operator[](\n    size_type idx) const;"
        },
        {
            "title": "std::span<T,Extent>::operator=",
            "path": "en.cppreference.com/w/cpp/container/span/operator=.html",
            "wgPageName": "cpp/container/span/operator=",
            "sample_declaration": "constexpr span& operator=(\n    const span& other) noexcept = default;"
        },
        {
            "title": "std::span<T,Extent>::rbegin",
            "path": "en.cppreference.com/w/cpp/container/span/rbegin.html",
            "wgPageName": "cpp/container/span/rbegin",
            "sample_declaration": "constexpr reverse_iterator rbegin()\n    const noexcept;"
        },
        {
            "title": "std::span<T,Extent>::rend",
            "path": "en.cppreference.com/w/cpp/container/span/rend.html",
            "wgPageName": "cpp/container/span/rend",
            "sample_declaration": "constexpr reverse_iterator rend()\n    const noexcept;"
        },
        {
            "title": "std::span<T,Extent>::size_bytes",
            "path": "en.cppreference.com/w/cpp/container/span/size_bytes.html",
            "wgPageName": "cpp/container/span/size_bytes",
            "sample_declaration": "constexpr size_type size_bytes() const noexcept;"
        },
        {
            "title": "std::span<T,Extent>::size",
            "path": "en.cppreference.com/w/cpp/container/span/size.html",
            "wgPageName": "cpp/container/span/size",
            "sample_declaration": "constexpr size_type size() const noexcept;"
        },
        {
            "title": "std::span<T,Extent>::span",
            "path": "en.cppreference.com/w/cpp/container/span/span.html",
            "wgPageName": "cpp/container/span/span",
            "sample_declaration": "constexpr span() noexcept;",
            "other_declarations": 8
        },
        {
            "title": "std::span<T,Extent>::subspan",
            "path": "en.cppreference.com/w/cpp/container/span/subspan.html",
            "wgPageName": "cpp/container/span/subspan",
            "sample_declaration": "template<\n    std::size_t Offset,\n    std::size_t Count = std::dynamic_extent>\nconstexpr std::\n    span<element_type, E /* see below */>\n    subspan() const;",
            "other_declarations": 1
        },
        {
            "title": "std::stack",
            "path": "en.cppreference.com/w/cpp/container/stack.html",
            "wgPageName": "cpp/container/stack",
            "headers": [
                "<stack>"
            ],
            "sample_declaration": "template<\n    class T,\n    class Container = std::deque<T> >\nclass stack;"
        },
        {
            "title": "std::stack<T,Container>::~stack",
            "path": "en.cppreference.com/w/cpp/container/stack/~stack.html",
            "wgPageName": "cpp/container/stack/~stack",
            "sample_declaration": "~stack();"
        },
        {
            "title": "deduction guides for std::stack",
            "path": "en.cppreference.com/w/cpp/container/stack/deduction_guides.html",
            "wgPageName": "cpp/container/stack/deduction_guides",
            "headers": [
                "<stack>"
            ],
            "sample_declaration": "template<class Container>\nstack(Container) -> stack<\n    typename Container::value_type,\n    Container>;",
            "other_declarations": 3
        },
        {
            "title": "std::stack<T,Container>::emplace",
            "path": "en.cppreference.com/w/cpp/container/stack/emplace.html",
            "wgPageName": "cpp/container/stack/emplace",
            "sample_declaration": "template<class... Args>\nvoid emplace(Args&&... args);",
            "other_declarations": 1
        },
        {
            "title": "std::stack<T,Container>::empty",
            "path": "en.cppreference.com/w/cpp/container/stack/empty.html",
            "wgPageName": "cpp/container/stack/empty",
            "sample_declaration": "bool empty() const;",
            "other_declarations": 1
        },
        {
            "title": "operator==,!=,<,<=,>,>=,<=>(std::stack)",
            "path": "en.cppreference.com/w/cpp/container/stack/operator_cmp.html",
            "wgPageName": "cpp/container/stack/operator_cmp",
            "sample_declaration": "template<class T, class Container>\nbool operator==(\n    const std::stack<T, Container>& lhs,\n    const std::stack<T, Container>& rhs);",
            "other_declarations": 6
        },
        {
            "title": "std::stack<T,Container>::operator=",
            "path": "en.cppreference.com/w/cpp/container/stack/operator=.html",
            "wgPageName": "cpp/container/stack/operator=",
            "sample_declaration": "stack& operator=(const stack& other);",
            "other_declarations": 1
        },
        {
            "title": "std::stack<T,Container>::pop",
            "path": "en.cppreference.com/w/cpp/container/stack/pop.html",
            "wgPageName": "cpp/container/stack/pop",
            "sample_declaration": "void pop();"
        },
        {
            "title": "std::stack<T,Container>::push",
            "path": "en.cppreference.com/w/cpp/container/stack/push.html",
            "wgPageName": "cpp/container/stack/push",
            "sample_declaration": "void push(const value_type& value);",
            "other_declarations": 1
        },
        {
            "title": "std::stack<T,Container>::size",
            "path": "en.cppreference.com/w/cpp/container/stack/size.html",
            "wgPageName": "cpp/container/stack/size",
            "sample_declaration": "size_type size() const;"
        },
        {
            "title": "std::stack<T,Container>::stack",
            "path": "en.cppreference.com/w/cpp/container/stack/stack.html",
            "wgPageName": "cpp/container/stack/stack",
            "sample_declaration": "stack() : stack(Container()) {}",
            "other_declarations": 12
        },
        {
            "title": "std::stack<T,Container>::swap",
            "path": "en.cppreference.com/w/cpp/container/stack/swap.html",
            "wgPageName": "cpp/container/stack/swap",
            "sample_declaration": "void swap(stack& other) noexcept(\n    /* see below */);"
        },
        {
            "title": "std::swap(std::stack)",
            "path": "en.cppreference.com/w/cpp/container/stack/swap2.html",
            "wgPageName": "cpp/container/stack/swap2",
            "headers": [
                "<stack>"
            ],
            "sample_declaration": "template<class T, class Container>\nvoid swap(\n    std::stack<T, Container>& lhs,\n    std::stack<T, Container>& rhs);",
            "other_declarations": 1
        },
        {
            "title": "std::stack<T,Container>::top",
            "path": "en.cppreference.com/w/cpp/container/stack/top.html",
            "wgPageName": "cpp/container/stack/top",
            "sample_declaration": "reference top();",
            "other_declarations": 1
        },
        {
            "title": "std::uses_allocator<std::stack>",
            "path": "en.cppreference.com/w/cpp/container/stack/uses_allocator.html",
            "wgPageName": "cpp/container/stack/uses_allocator",
            "sample_declaration": "template<class T, class Container, class Alloc>\nstruct uses_allocator<\n    stack<T, Container>,\n    Alloc>\n    : std::uses_allocator<Container, Alloc>::\n          type {};"
        },
        {
            "title": "std::unordered_map",
            "path": "en.cppreference.com/w/cpp/container/unordered_map.html",
            "wgPageName": "cpp/container/unordered_map",
            "headers": [
                "<unordered_map>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class T,\n    class Hash = std::hash<Key>,\n    class KeyEqual = std::equal_to<Key>,\n    class Allocator = std::allocator<\n        std::pair<const Key, T> > >\nclass unordered_map;",
            "other_declarations": 1
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::~unordered_map",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/~unordered_map.html",
            "wgPageName": "cpp/container/unordered_map/~unordered_map",
            "sample_declaration": "~unordered_map();"
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::at",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/at.html",
            "wgPageName": "cpp/container/unordered_map/at",
            "sample_declaration": "T& at(const Key& key);",
            "other_declarations": 1
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::begin, std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::cbegin",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/begin.html",
            "wgPageName": "cpp/container/unordered_map/begin",
            "sample_declaration": "iterator begin() noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::begin(size_type), std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::cbegin(size_type)",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/begin2.html",
            "wgPageName": "cpp/container/unordered_map/begin2",
            "sample_declaration": "local_iterator begin(size_type n);",
            "other_declarations": 2
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::bucket_count",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/bucket_count.html",
            "wgPageName": "cpp/container/unordered_map/bucket_count",
            "sample_declaration": "size_type bucket_count() const;"
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::bucket_size",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/bucket_size.html",
            "wgPageName": "cpp/container/unordered_map/bucket_size",
            "sample_declaration": "size_type bucket_size(size_type n) const;"
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::bucket",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/bucket.html",
            "wgPageName": "cpp/container/unordered_map/bucket",
            "sample_declaration": "size_type bucket(const Key& key) const;"
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::clear",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/clear.html",
            "wgPageName": "cpp/container/unordered_map/clear",
            "sample_declaration": "void clear() noexcept;"
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::contains",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/contains.html",
            "wgPageName": "cpp/container/unordered_map/contains",
            "sample_declaration": "bool contains(const Key& key) const;",
            "other_declarations": 1
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::count",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/count.html",
            "wgPageName": "cpp/container/unordered_map/count",
            "sample_declaration": "size_type count(const Key& key) const;",
            "other_declarations": 1
        },
        {
            "title": "deduction guides for std::unordered_map",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/deduction_guides.html",
            "wgPageName": "cpp/container/unordered_map/deduction_guides",
            "headers": [
                "<unordered_map>"
            ],
            "sample_declaration": "template<\n    class InputIt,\n    class Hash = std::hash<iter_key_t<InputIt>>,\n    class Pred =\n        std::equal_to<iter_key_t<InputIt>>,\n    class Alloc = std::allocator<\n        iter_to_alloc_t<InputIt>>>\nunordered_map(\n    InputIt,\n    InputIt,\n    typename /*see below*/ ::size_type =\n        /*see below*/,\n    Hash = Hash(),\n    Pred = Pred(),\n    Alloc = Alloc())\n    -> unordered_map<\n        iter_key_t<InputIt>,\n        iter_val_t<InputIt>,\n        Hash,\n        Pred,\n        Alloc>;",
            "other_declarations": 7
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::emplace_hint",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/emplace_hint.html",
            "wgPageName": "cpp/container/unordered_map/emplace_hint",
            "sample_declaration": "template<class... Args>\niterator emplace_hint(\n    const_iterator hint,\n    Args&&... args);"
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::emplace",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/emplace.html",
            "wgPageName": "cpp/container/unordered_map/emplace",
            "sample_declaration": "template<class... Args>\nstd::pair<iterator, bool> emplace(\n    Args&&... args);"
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::empty",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/empty.html",
            "wgPageName": "cpp/container/unordered_map/empty",
            "sample_declaration": "bool empty() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::end, std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::cend",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/end.html",
            "wgPageName": "cpp/container/unordered_map/end",
            "sample_declaration": "iterator end() noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::end(size_type), std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::cend(size_type)",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/end2.html",
            "wgPageName": "cpp/container/unordered_map/end2",
            "sample_declaration": "local_iterator end(size_type n);",
            "other_declarations": 2
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::equal_range",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/equal_range.html",
            "wgPageName": "cpp/container/unordered_map/equal_range",
            "sample_declaration": "std::pair<iterator, iterator> equal_range(\n    const Key& key);",
            "other_declarations": 3
        },
        {
            "title": "std::erase_if (std::unordered_map)",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/erase_if.html",
            "wgPageName": "cpp/container/unordered_map/erase_if",
            "headers": [
                "<unordered_map>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class T,\n    class Hash,\n    class KeyEqual,\n    class Alloc,\n    class Pred>\ntypename std::unordered_map<\n    Key,\n    T,\n    Hash,\n    KeyEqual,\n    Alloc>::size_type\nerase_if(\n    std::unordered_map<\n        Key,\n        T,\n        Hash,\n        KeyEqual,\n        Alloc>& c,\n    Pred pred);"
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::erase",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/erase.html",
            "wgPageName": "cpp/container/unordered_map/erase",
            "sample_declaration": "iterator erase(iterator pos);",
            "other_declarations": 4
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::extract",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/extract.html",
            "wgPageName": "cpp/container/unordered_map/extract",
            "sample_declaration": "node_type extract(const_iterator position);",
            "other_declarations": 2
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::find",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/find.html",
            "wgPageName": "cpp/container/unordered_map/find",
            "sample_declaration": "iterator find(const Key& key);",
            "other_declarations": 3
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::get_allocator",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/get_allocator.html",
            "wgPageName": "cpp/container/unordered_map/get_allocator",
            "sample_declaration": "allocator_type get_allocator() const noexcept;"
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::hash_function",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/hash_function.html",
            "wgPageName": "cpp/container/unordered_map/hash_function",
            "sample_declaration": "hasher hash_function() const;"
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::insert_or_assign",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/insert_or_assign.html",
            "wgPageName": "cpp/container/unordered_map/insert_or_assign",
            "sample_declaration": "template<class M>\nstd::pair<iterator, bool> insert_or_assign(\n    const Key& k,\n    M&& obj);",
            "other_declarations": 3
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::insert",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/insert.html",
            "wgPageName": "cpp/container/unordered_map/insert",
            "sample_declaration": "std::pair<iterator, bool> insert(\n    const value_type& value);",
            "other_declarations": 9
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::key_eq",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/key_eq.html",
            "wgPageName": "cpp/container/unordered_map/key_eq",
            "sample_declaration": "key_equal key_eq() const;"
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::load_factor",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/load_factor.html",
            "wgPageName": "cpp/container/unordered_map/load_factor",
            "sample_declaration": "float load_factor() const;"
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::max_bucket_count",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/max_bucket_count.html",
            "wgPageName": "cpp/container/unordered_map/max_bucket_count",
            "sample_declaration": "size_type max_bucket_count() const;"
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::max_load_factor",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/max_load_factor.html",
            "wgPageName": "cpp/container/unordered_map/max_load_factor",
            "sample_declaration": "float max_load_factor() const;",
            "other_declarations": 1
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::max_size",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/max_size.html",
            "wgPageName": "cpp/container/unordered_map/max_size",
            "sample_declaration": "size_type max_size() const noexcept;"
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::merge",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/merge.html",
            "wgPageName": "cpp/container/unordered_map/merge",
            "sample_declaration": "template<class H2, class P2>\nvoid merge(std::unordered_map<\n           Key,\n           T,\n           H2,\n           P2,\n           Allocator>& source);",
            "other_declarations": 3
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::operator[]",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/operator_at.html",
            "wgPageName": "cpp/container/unordered_map/operator_at",
            "sample_declaration": "T& operator[](const Key& key);",
            "other_declarations": 1
        },
        {
            "title": "operator==,!=(std::unordered_map)",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/operator_cmp.html",
            "wgPageName": "cpp/container/unordered_map/operator_cmp",
            "sample_declaration": "template<\n    class Key,\n    class T,\n    class Hash,\n    class KeyEqual,\n    class Alloc>\nbool operator==(\n    const std::unordered_map<\n        Key,\n        T,\n        Hash,\n        KeyEqual,\n        Alloc>& lhs,\n    const std::unordered_map<\n        Key,\n        T,\n        Hash,\n        KeyEqual,\n        Alloc>& rhs);",
            "other_declarations": 1
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::operator=",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/operator=.html",
            "wgPageName": "cpp/container/unordered_map/operator=",
            "sample_declaration": "unordered_map& operator=(\n    const unordered_map& other);",
            "other_declarations": 3
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::rehash",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/rehash.html",
            "wgPageName": "cpp/container/unordered_map/rehash",
            "sample_declaration": "void rehash(size_type count);"
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::reserve",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/reserve.html",
            "wgPageName": "cpp/container/unordered_map/reserve",
            "sample_declaration": "void reserve(size_type count);"
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::size",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/size.html",
            "wgPageName": "cpp/container/unordered_map/size",
            "sample_declaration": "size_type size() const noexcept;"
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::swap",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/swap.html",
            "wgPageName": "cpp/container/unordered_map/swap",
            "sample_declaration": "void swap(unordered_map& other);",
            "other_declarations": 1
        },
        {
            "title": "std::swap(std::unordered_map)",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/swap2.html",
            "wgPageName": "cpp/container/unordered_map/swap2",
            "headers": [
                "<unordered_map>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class T,\n    class Hash,\n    class KeyEqual,\n    class Alloc>\nvoid swap(\n    std::unordered_map<\n        Key,\n        T,\n        Hash,\n        KeyEqual,\n        Alloc>& lhs,\n    std::unordered_map<\n        Key,\n        T,\n        Hash,\n        KeyEqual,\n        Alloc>& rhs);",
            "other_declarations": 1
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::try_emplace",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/try_emplace.html",
            "wgPageName": "cpp/container/unordered_map/try_emplace",
            "sample_declaration": "template<class... Args>\npair<iterator, bool> try_emplace(\n    const Key& k,\n    Args&&... args);",
            "other_declarations": 3
        },
        {
            "title": "std::unordered_map<Key,T,Hash,KeyEqual,Allocator>::unordered_map",
            "path": "en.cppreference.com/w/cpp/container/unordered_map/unordered_map.html",
            "wgPageName": "cpp/container/unordered_map/unordered_map",
            "sample_declaration": "unordered_map()\n    : unordered_map(size_type(\n          /*implementation-defined*/)) {}\nexplicit unordered_map(\n    size_type bucket_count,\n    const Hash& hash = Hash(),\n    const key_equal& equal = key_equal(),\n    const Allocator& alloc = Allocator());",
            "other_declarations": 12
        },
        {
            "title": "std::unordered_multimap",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap.html",
            "wgPageName": "cpp/container/unordered_multimap",
            "headers": [
                "<unordered_map>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class T,\n    class Hash = std::hash<Key>,\n    class KeyEqual = std::equal_to<Key>,\n    class Allocator = std::allocator<\n        std::pair<const Key, T> > >\nclass unordered_multimap;",
            "other_declarations": 1
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::~unordered_multimap",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/~unordered_multimap.html",
            "wgPageName": "cpp/container/unordered_multimap/~unordered_multimap",
            "sample_declaration": "~unordered_multimap();"
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::begin, std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::cbegin",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/begin.html",
            "wgPageName": "cpp/container/unordered_multimap/begin",
            "sample_declaration": "iterator begin() noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::begin(size_type), std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::cbegin(size_type)",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/begin2.html",
            "wgPageName": "cpp/container/unordered_multimap/begin2",
            "sample_declaration": "local_iterator begin(size_type n);",
            "other_declarations": 2
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::bucket_count",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/bucket_count.html",
            "wgPageName": "cpp/container/unordered_multimap/bucket_count",
            "sample_declaration": "size_type bucket_count() const;"
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::bucket_size",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/bucket_size.html",
            "wgPageName": "cpp/container/unordered_multimap/bucket_size",
            "sample_declaration": "size_type bucket_size(size_type n) const;"
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::bucket",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/bucket.html",
            "wgPageName": "cpp/container/unordered_multimap/bucket",
            "sample_declaration": "size_type bucket(const Key& key) const;"
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::clear",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/clear.html",
            "wgPageName": "cpp/container/unordered_multimap/clear",
            "sample_declaration": "void clear() noexcept;"
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::contains",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/contains.html",
            "wgPageName": "cpp/container/unordered_multimap/contains",
            "sample_declaration": "bool contains(const Key& key) const;",
            "other_declarations": 1
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::count",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/count.html",
            "wgPageName": "cpp/container/unordered_multimap/count",
            "sample_declaration": "size_type count(const Key& key) const;",
            "other_declarations": 1
        },
        {
            "title": "deduction guides for std::unordered_multimap",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/deduction_guides.html",
            "wgPageName": "cpp/container/unordered_multimap/deduction_guides",
            "headers": [
                "<unordered_map>"
            ],
            "sample_declaration": "template<\n    class InputIt,\n    class Hash = std::hash<iter_key_t<InputIt>>,\n    class Pred =\n        std::equal_to<iter_key_t<InputIt>>,\n    class Alloc = std::allocator<\n        iter_to_alloc_t<InputIt>>>\nunordered_multimap(\n    InputIt,\n    InputIt,\n    typename /*see below*/ ::size_type =\n        /*see below*/,\n    Hash = Hash(),\n    Pred = Pred(),\n    Alloc = Alloc())\n    -> unordered_multimap<\n        iter_key_t<InputIt>,\n        iter_val_t<InputIt>,\n        Hash,\n        Pred,\n        Alloc>;",
            "other_declarations": 7
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::emplace_hint",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/emplace_hint.html",
            "wgPageName": "cpp/container/unordered_multimap/emplace_hint",
            "sample_declaration": "template<class... Args>\niterator emplace_hint(\n    const_iterator hint,\n    Args&&... args);"
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::emplace",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/emplace.html",
            "wgPageName": "cpp/container/unordered_multimap/emplace",
            "sample_declaration": "template<class... Args>\niterator emplace(Args&&... args);"
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::empty",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/empty.html",
            "wgPageName": "cpp/container/unordered_multimap/empty",
            "sample_declaration": "bool empty() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::end, std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::cend",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/end.html",
            "wgPageName": "cpp/container/unordered_multimap/end",
            "sample_declaration": "iterator end() noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::end(size_type), std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::cend(size_type)",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/end2.html",
            "wgPageName": "cpp/container/unordered_multimap/end2",
            "sample_declaration": "local_iterator end(size_type n);",
            "other_declarations": 2
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::equal_range",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/equal_range.html",
            "wgPageName": "cpp/container/unordered_multimap/equal_range",
            "sample_declaration": "std::pair<iterator, iterator> equal_range(\n    const Key& key);",
            "other_declarations": 3
        },
        {
            "title": "std::erase_if (std::unordered_multimap)",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/erase_if.html",
            "wgPageName": "cpp/container/unordered_multimap/erase_if",
            "headers": [
                "<unordered_map>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class T,\n    class Hash,\n    class KeyEqual,\n    class Alloc,\n    class Pred>\ntypename std::unordered_multimap<\n    Key,\n    T,\n    Hash,\n    KeyEqual,\n    Alloc>::size_type\nerase_if(\n    std::unordered_multimap<\n        Key,\n        T,\n        Hash,\n        KeyEqual,\n        Alloc>& c,\n    Pred pred);"
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::erase",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/erase.html",
            "wgPageName": "cpp/container/unordered_multimap/erase",
            "sample_declaration": "iterator erase(iterator pos);",
            "other_declarations": 4
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::extract",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/extract.html",
            "wgPageName": "cpp/container/unordered_multimap/extract",
            "sample_declaration": "node_type extract(const_iterator position);",
            "other_declarations": 2
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::find",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/find.html",
            "wgPageName": "cpp/container/unordered_multimap/find",
            "sample_declaration": "iterator find(const Key& key);",
            "other_declarations": 3
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::get_allocator",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/get_allocator.html",
            "wgPageName": "cpp/container/unordered_multimap/get_allocator",
            "sample_declaration": "allocator_type get_allocator() const noexcept;"
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::hash_function",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/hash_function.html",
            "wgPageName": "cpp/container/unordered_multimap/hash_function",
            "sample_declaration": "hasher hash_function() const;"
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::insert",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/insert.html",
            "wgPageName": "cpp/container/unordered_multimap/insert",
            "headers": [
                "<unordered_map>"
            ],
            "sample_declaration": "iterator insert(const value_type& value);",
            "other_declarations": 9
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::key_eq",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/key_eq.html",
            "wgPageName": "cpp/container/unordered_multimap/key_eq",
            "sample_declaration": "key_equal key_eq() const;"
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::load_factor",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/load_factor.html",
            "wgPageName": "cpp/container/unordered_multimap/load_factor",
            "sample_declaration": "float load_factor() const;"
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::max_bucket_count",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/max_bucket_count.html",
            "wgPageName": "cpp/container/unordered_multimap/max_bucket_count",
            "sample_declaration": "size_type max_bucket_count() const;"
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::max_load_factor",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/max_load_factor.html",
            "wgPageName": "cpp/container/unordered_multimap/max_load_factor",
            "sample_declaration": "float max_load_factor() const;",
            "other_declarations": 1
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::max_size",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/max_size.html",
            "wgPageName": "cpp/container/unordered_multimap/max_size",
            "sample_declaration": "size_type max_size() const noexcept;"
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::merge",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/merge.html",
            "wgPageName": "cpp/container/unordered_multimap/merge",
            "sample_declaration": "template<class H2, class P2>\nvoid merge(std::unordered_map<\n           Key,\n           T,\n           H2,\n           P2,\n           Allocator>& source);",
            "other_declarations": 3
        },
        {
            "title": "operator==,!=(std::unordered_multimap)",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/operator_cmp.html",
            "wgPageName": "cpp/container/unordered_multimap/operator_cmp",
            "sample_declaration": "template<\n    class Key,\n    class T,\n    class Hash,\n    class KeyEqual,\n    class Alloc>\nbool operator==(\n    const std::unordered_multimap<\n        Key,\n        T,\n        Hash,\n        KeyEqual,\n        Alloc>& lhs,\n    const std::unordered_multimap<\n        Key,\n        T,\n        Hash,\n        KeyEqual,\n        Alloc>& rhs);",
            "other_declarations": 1
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::operator=",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/operator=.html",
            "wgPageName": "cpp/container/unordered_multimap/operator=",
            "sample_declaration": "unordered_multimap& operator=(\n    const unordered_multimap& other);",
            "other_declarations": 3
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::rehash",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/rehash.html",
            "wgPageName": "cpp/container/unordered_multimap/rehash",
            "sample_declaration": "void rehash(size_type count);"
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::reserve",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/reserve.html",
            "wgPageName": "cpp/container/unordered_multimap/reserve",
            "sample_declaration": "void reserve(size_type count);"
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::size",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/size.html",
            "wgPageName": "cpp/container/unordered_multimap/size",
            "sample_declaration": "size_type size() const noexcept;"
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::swap",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/swap.html",
            "wgPageName": "cpp/container/unordered_multimap/swap",
            "sample_declaration": "void swap(unordered_multimap& other);",
            "other_declarations": 1
        },
        {
            "title": "std::swap(std::unordered_multimap)",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/swap2.html",
            "wgPageName": "cpp/container/unordered_multimap/swap2",
            "headers": [
                "<unordered_map>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class T,\n    class Hash,\n    class KeyEqual,\n    class Alloc>\nvoid swap(\n    std::unordered_multimap<\n        Key,\n        T,\n        Hash,\n        KeyEqual,\n        Alloc>& lhs,\n    std::unordered_multimap<\n        Key,\n        T,\n        Hash,\n        KeyEqual,\n        Alloc>& rhs);",
            "other_declarations": 1
        },
        {
            "title": "std::unordered_multimap<Key,T,Hash,KeyEqual,Allocator>::unordered_multimap",
            "path": "en.cppreference.com/w/cpp/container/unordered_multimap/unordered_multimap.html",
            "wgPageName": "cpp/container/unordered_multimap/unordered_multimap",
            "sample_declaration": "unordered_multimap()\n    : unordered_multimap(size_type(\n          /*implementation-defined*/)) {}\nexplicit unordered_multimap(\n    size_type bucket_count,\n    const Hash& hash = Hash(),\n    const key_equal& equal = key_equal(),\n    const Allocator& alloc = Allocator());",
            "other_declarations": 12
        },
        {
            "title": "std::unordered_multiset",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset.html",
            "wgPageName": "cpp/container/unordered_multiset",
            "headers": [
                "<unordered_set>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class Hash = std::hash<Key>,\n    class KeyEqual = std::equal_to<Key>,\n    class Allocator = std::allocator<Key> >\nclass unordered_multiset;",
            "other_declarations": 1
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::~unordered_multiset",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/~unordered_multiset.html",
            "wgPageName": "cpp/container/unordered_multiset/~unordered_multiset",
            "sample_declaration": "~unordered_multiset();"
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::begin, std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::cbegin",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/begin.html",
            "wgPageName": "cpp/container/unordered_multiset/begin",
            "sample_declaration": "iterator begin() noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::begin(size_type), std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::cbegin(size_type)",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/begin2.html",
            "wgPageName": "cpp/container/unordered_multiset/begin2",
            "sample_declaration": "local_iterator begin(size_type n);",
            "other_declarations": 2
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::bucket_count",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/bucket_count.html",
            "wgPageName": "cpp/container/unordered_multiset/bucket_count",
            "sample_declaration": "size_type bucket_count() const;"
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::bucket_size",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/bucket_size.html",
            "wgPageName": "cpp/container/unordered_multiset/bucket_size",
            "sample_declaration": "size_type bucket_size(size_type n) const;"
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::bucket",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/bucket.html",
            "wgPageName": "cpp/container/unordered_multiset/bucket",
            "sample_declaration": "size_type bucket(const Key& key) const;"
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::clear",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/clear.html",
            "wgPageName": "cpp/container/unordered_multiset/clear",
            "sample_declaration": "void clear() noexcept;"
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::contains",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/contains.html",
            "wgPageName": "cpp/container/unordered_multiset/contains",
            "sample_declaration": "bool contains(const Key& key) const;",
            "other_declarations": 1
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::count",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/count.html",
            "wgPageName": "cpp/container/unordered_multiset/count",
            "sample_declaration": "size_type count(const Key& key) const;",
            "other_declarations": 1
        },
        {
            "title": "deduction guides for std::unordered_multiset",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/deduction_guides.html",
            "wgPageName": "cpp/container/unordered_multiset/deduction_guides",
            "headers": [
                "<unordered_set>"
            ],
            "sample_declaration": "template<\n    class InputIt,\n    class Hash =\n        std::hash<typename std::iterator_traits<\n            InputIt>::value_type>,\n    class Pred = std::equal_to<\n        typename std::iterator_traits<\n            InputIt>::value_type>,\n    class Alloc = std::allocator<\n        typename std::iterator_traits<\n            InputIt>::value_type>>\nunordered_multiset(\n    InputIt,\n    InputIt,\n    typename /*see below*/ ::size_type =\n        /*see below*/,\n    Hash = Hash(),\n    Pred = Pred(),\n    Alloc = Alloc())\n    -> unordered_multiset<\n        typename std::iterator_traits<\n            InputIt>::value_type,\n        Hash,\n        Pred,\n        Alloc>;",
            "other_declarations": 5
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::emplace_hint",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/emplace_hint.html",
            "wgPageName": "cpp/container/unordered_multiset/emplace_hint",
            "sample_declaration": "template<class... Args>\niterator emplace_hint(\n    const_iterator hint,\n    Args&&... args);"
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::emplace",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/emplace.html",
            "wgPageName": "cpp/container/unordered_multiset/emplace",
            "sample_declaration": "template<class... Args>\niterator emplace(Args&&... args);"
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::empty",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/empty.html",
            "wgPageName": "cpp/container/unordered_multiset/empty",
            "sample_declaration": "bool empty() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::end, std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::cend",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/end.html",
            "wgPageName": "cpp/container/unordered_multiset/end",
            "sample_declaration": "iterator end() noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::end(size_type), std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::cend(size_type)",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/end2.html",
            "wgPageName": "cpp/container/unordered_multiset/end2",
            "sample_declaration": "local_iterator end(size_type n);",
            "other_declarations": 2
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::equal_range",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/equal_range.html",
            "wgPageName": "cpp/container/unordered_multiset/equal_range",
            "sample_declaration": "std::pair<iterator, iterator> equal_range(\n    const Key& key);",
            "other_declarations": 3
        },
        {
            "title": "std::erase_if (std::unordered_multiset)",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/erase_if.html",
            "wgPageName": "cpp/container/unordered_multiset/erase_if",
            "headers": [
                "<unordered_set>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class Hash,\n    class KeyEqual,\n    class Alloc,\n    class Pred>\ntypename std::unordered_multiset<\n    Key,\n    Hash,\n    KeyEqual,\n    Alloc>::size_type\nerase_if(\n    std::unordered_multiset<\n        Key,\n        Hash,\n        KeyEqual,\n        Alloc>& c,\n    Pred pred);"
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::erase",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/erase.html",
            "wgPageName": "cpp/container/unordered_multiset/erase",
            "sample_declaration": "iterator erase(iterator pos);",
            "other_declarations": 4
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::extract",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/extract.html",
            "wgPageName": "cpp/container/unordered_multiset/extract",
            "sample_declaration": "node_type extract(const_iterator position);",
            "other_declarations": 2
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::find",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/find.html",
            "wgPageName": "cpp/container/unordered_multiset/find",
            "sample_declaration": "iterator find(const Key& key);",
            "other_declarations": 3
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::get_allocator",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/get_allocator.html",
            "wgPageName": "cpp/container/unordered_multiset/get_allocator",
            "sample_declaration": "allocator_type get_allocator() const noexcept;"
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::hash_function",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/hash_function.html",
            "wgPageName": "cpp/container/unordered_multiset/hash_function",
            "sample_declaration": "hasher hash_function() const;"
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::insert",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/insert.html",
            "wgPageName": "cpp/container/unordered_multiset/insert",
            "sample_declaration": "iterator insert(const value_type& value);",
            "other_declarations": 7
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::key_eq",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/key_eq.html",
            "wgPageName": "cpp/container/unordered_multiset/key_eq",
            "sample_declaration": "key_equal key_eq() const;"
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::load_factor",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/load_factor.html",
            "wgPageName": "cpp/container/unordered_multiset/load_factor",
            "sample_declaration": "float load_factor() const;"
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::max_bucket_count",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/max_bucket_count.html",
            "wgPageName": "cpp/container/unordered_multiset/max_bucket_count",
            "sample_declaration": "size_type max_bucket_count() const;"
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::max_load_factor",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/max_load_factor.html",
            "wgPageName": "cpp/container/unordered_multiset/max_load_factor",
            "sample_declaration": "float max_load_factor() const;",
            "other_declarations": 1
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::max_size",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/max_size.html",
            "wgPageName": "cpp/container/unordered_multiset/max_size",
            "sample_declaration": "size_type max_size() const noexcept;"
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::merge",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/merge.html",
            "wgPageName": "cpp/container/unordered_multiset/merge",
            "sample_declaration": "template<class H2, class P2>\nvoid merge(\n    std::unordered_set<Key, H2, P2, Allocator>&\n        source);",
            "other_declarations": 3
        },
        {
            "title": "operator==,!=(std::unordered_multiset)",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/operator_cmp.html",
            "wgPageName": "cpp/container/unordered_multiset/operator_cmp",
            "sample_declaration": "template<\n    class Key,\n    class Hash,\n    class KeyEqual,\n    class Alloc>\nbool operator==(\n    const std::unordered_multiset<\n        Key,\n        Hash,\n        KeyEqual,\n        Alloc>& lhs,\n    const std::unordered_multiset<\n        Key,\n        Hash,\n        KeyEqual,\n        Alloc>& rhs);",
            "other_declarations": 1
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::operator=",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/operator=.html",
            "wgPageName": "cpp/container/unordered_multiset/operator=",
            "sample_declaration": "unordered_multiset& operator=(\n    const unordered_multiset& other);",
            "other_declarations": 3
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::rehash",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/rehash.html",
            "wgPageName": "cpp/container/unordered_multiset/rehash",
            "sample_declaration": "void rehash(size_type count);"
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::reserve",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/reserve.html",
            "wgPageName": "cpp/container/unordered_multiset/reserve",
            "sample_declaration": "void reserve(size_type count);"
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::size",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/size.html",
            "wgPageName": "cpp/container/unordered_multiset/size",
            "sample_declaration": "size_type size() const noexcept;"
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::swap",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/swap.html",
            "wgPageName": "cpp/container/unordered_multiset/swap",
            "sample_declaration": "void swap(unordered_multiset& other);",
            "other_declarations": 1
        },
        {
            "title": "std::swap(std::unordered_multiset)",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/swap2.html",
            "wgPageName": "cpp/container/unordered_multiset/swap2",
            "headers": [
                "<unordered_set>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class Hash,\n    class KeyEqual,\n    class Alloc>\nvoid swap(\n    std::unordered_multiset<\n        Key,\n        Hash,\n        KeyEqual,\n        Alloc>& lhs,\n    std::unordered_multiset<\n        Key,\n        Hash,\n        KeyEqual,\n        Alloc>& rhs);",
            "other_declarations": 1
        },
        {
            "title": "std::unordered_multiset<Key,Hash,KeyEqual,Allocator>::unordered_multiset",
            "path": "en.cppreference.com/w/cpp/container/unordered_multiset/unordered_multiset.html",
            "wgPageName": "cpp/container/unordered_multiset/unordered_multiset",
            "sample_declaration": "unordered_multiset()\n    : unordered_multiset(size_type(\n          /*implementation-defined*/)) {}\nexplicit unordered_multiset(\n    size_type bucket_count,\n    const Hash& hash = Hash(),\n    const key_equal& equal = key_equal(),\n    const Allocator& alloc = Allocator());",
            "other_declarations": 12
        },
        {
            "title": "std::unordered_set",
            "path": "en.cppreference.com/w/cpp/container/unordered_set.html",
            "wgPageName": "cpp/container/unordered_set",
            "headers": [
                "<unordered_set>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class Hash = std::hash<Key>,\n    class KeyEqual = std::equal_to<Key>,\n    class Allocator = std::allocator<Key> >\nclass unordered_set;",
            "other_declarations": 1
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::~unordered_set",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/~unordered_set.html",
            "wgPageName": "cpp/container/unordered_set/~unordered_set",
            "sample_declaration": "~unordered_set();"
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::begin, std::unordered_set<Key,Hash,KeyEqual,Allocator>::cbegin",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/begin.html",
            "wgPageName": "cpp/container/unordered_set/begin",
            "sample_declaration": "iterator begin() noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::begin(size_type), std::unordered_set<Key,Hash,KeyEqual,Allocator>::cbegin(size_type)",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/begin2.html",
            "wgPageName": "cpp/container/unordered_set/begin2",
            "sample_declaration": "local_iterator begin(size_type n);",
            "other_declarations": 2
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::bucket_count",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/bucket_count.html",
            "wgPageName": "cpp/container/unordered_set/bucket_count",
            "sample_declaration": "size_type bucket_count() const;"
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::bucket_size",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/bucket_size.html",
            "wgPageName": "cpp/container/unordered_set/bucket_size",
            "sample_declaration": "size_type bucket_size(size_type n) const;"
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::bucket",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/bucket.html",
            "wgPageName": "cpp/container/unordered_set/bucket",
            "sample_declaration": "size_type bucket(const Key& key) const;"
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::clear",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/clear.html",
            "wgPageName": "cpp/container/unordered_set/clear",
            "sample_declaration": "void clear() noexcept;"
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::contains",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/contains.html",
            "wgPageName": "cpp/container/unordered_set/contains",
            "sample_declaration": "bool contains(const Key& key) const;",
            "other_declarations": 1
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::count",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/count.html",
            "wgPageName": "cpp/container/unordered_set/count",
            "sample_declaration": "size_type count(const Key& key) const;",
            "other_declarations": 1
        },
        {
            "title": "deduction guides for std::unordered_set",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/deduction_guides.html",
            "wgPageName": "cpp/container/unordered_set/deduction_guides",
            "headers": [
                "<unordered_set>"
            ],
            "sample_declaration": "template<\n    class InputIt,\n    class Hash =\n        std::hash<typename std::iterator_traits<\n            InputIt>::value_type>,\n    class Pred = std::equal_to<\n        typename std::iterator_traits<\n            InputIt>::value_type>,\n    class Alloc = std::allocator<\n        typename std::iterator_traits<\n            InputIt>::value_type>>\nunordered_set(\n    InputIt,\n    InputIt,\n    typename /*see below*/ ::size_type =\n        /*see below*/,\n    Hash = Hash(),\n    Pred = Pred(),\n    Alloc = Alloc())\n    -> unordered_set<\n        typename std::iterator_traits<\n            InputIt>::value_type,\n        Hash,\n        Pred,\n        Alloc>;",
            "other_declarations": 5
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::emplace_hint",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/emplace_hint.html",
            "wgPageName": "cpp/container/unordered_set/emplace_hint",
            "sample_declaration": "template<class... Args>\niterator emplace_hint(\n    const_iterator hint,\n    Args&&... args);"
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::emplace",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/emplace.html",
            "wgPageName": "cpp/container/unordered_set/emplace",
            "sample_declaration": "template<class... Args>\nstd::pair<iterator, bool> emplace(\n    Args&&... args);"
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::empty",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/empty.html",
            "wgPageName": "cpp/container/unordered_set/empty",
            "sample_declaration": "bool empty() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::end, std::unordered_set<Key,Hash,KeyEqual,Allocator>::cend",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/end.html",
            "wgPageName": "cpp/container/unordered_set/end",
            "sample_declaration": "iterator end() noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::end(size_type), std::unordered_set<Key,Hash,KeyEqual,Allocator>::cend(size_type)",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/end2.html",
            "wgPageName": "cpp/container/unordered_set/end2",
            "sample_declaration": "local_iterator end(size_type n);",
            "other_declarations": 2
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::equal_range",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/equal_range.html",
            "wgPageName": "cpp/container/unordered_set/equal_range",
            "sample_declaration": "std::pair<iterator, iterator> equal_range(\n    const Key& key);",
            "other_declarations": 3
        },
        {
            "title": "std::erase_if (std::unordered_set)",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/erase_if.html",
            "wgPageName": "cpp/container/unordered_set/erase_if",
            "headers": [
                "<unordered_set>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class Hash,\n    class KeyEqual,\n    class Alloc,\n    class Pred>\ntypename std::\n    unordered_set<Key, Hash, KeyEqual, Alloc>::\n        size_type\n        erase_if(\n            std::unordered_set<\n                Key,\n                Hash,\n                KeyEqual,\n                Alloc>& c,\n            Pred pred);"
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::erase",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/erase.html",
            "wgPageName": "cpp/container/unordered_set/erase",
            "sample_declaration": "iterator erase(iterator pos);",
            "other_declarations": 4
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::extract",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/extract.html",
            "wgPageName": "cpp/container/unordered_set/extract",
            "sample_declaration": "node_type extract(const_iterator position);",
            "other_declarations": 2
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::find",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/find.html",
            "wgPageName": "cpp/container/unordered_set/find",
            "sample_declaration": "iterator find(const Key& key);",
            "other_declarations": 3
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::get_allocator",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/get_allocator.html",
            "wgPageName": "cpp/container/unordered_set/get_allocator",
            "sample_declaration": "allocator_type get_allocator() const noexcept;"
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::hash_function",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/hash_function.html",
            "wgPageName": "cpp/container/unordered_set/hash_function",
            "sample_declaration": "hasher hash_function() const;"
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::insert",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/insert.html",
            "wgPageName": "cpp/container/unordered_set/insert",
            "sample_declaration": "std::pair<iterator, bool> insert(\n    const value_type& value);",
            "other_declarations": 7
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::key_eq",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/key_eq.html",
            "wgPageName": "cpp/container/unordered_set/key_eq",
            "sample_declaration": "key_equal key_eq() const;"
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::load_factor",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/load_factor.html",
            "wgPageName": "cpp/container/unordered_set/load_factor",
            "sample_declaration": "float load_factor() const;"
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::max_bucket_count",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/max_bucket_count.html",
            "wgPageName": "cpp/container/unordered_set/max_bucket_count",
            "sample_declaration": "size_type max_bucket_count() const;"
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::max_load_factor",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/max_load_factor.html",
            "wgPageName": "cpp/container/unordered_set/max_load_factor",
            "sample_declaration": "float max_load_factor() const;",
            "other_declarations": 1
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::max_size",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/max_size.html",
            "wgPageName": "cpp/container/unordered_set/max_size",
            "sample_declaration": "size_type max_size() const noexcept;"
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::merge",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/merge.html",
            "wgPageName": "cpp/container/unordered_set/merge",
            "sample_declaration": "template<class H2, class P2>\nvoid merge(\n    std::unordered_set<Key, H2, P2, Allocator>&\n        source);",
            "other_declarations": 3
        },
        {
            "title": "operator==,!=(std::unordered_set)",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/operator_cmp.html",
            "wgPageName": "cpp/container/unordered_set/operator_cmp",
            "sample_declaration": "template<\n    class Key,\n    class Hash,\n    class KeyEqual,\n    class Alloc>\nbool operator==(\n    const std::unordered_set<\n        Key,\n        Hash,\n        KeyEqual,\n        Alloc>& lhs,\n    const std::unordered_set<\n        Key,\n        Hash,\n        KeyEqual,\n        Alloc>& rhs);",
            "other_declarations": 1
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::operator=",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/operator=.html",
            "wgPageName": "cpp/container/unordered_set/operator=",
            "sample_declaration": "unordered_set& operator=(\n    const unordered_set& other);",
            "other_declarations": 3
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::rehash",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/rehash.html",
            "wgPageName": "cpp/container/unordered_set/rehash",
            "sample_declaration": "void rehash(size_type count);"
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::reserve",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/reserve.html",
            "wgPageName": "cpp/container/unordered_set/reserve",
            "sample_declaration": "void reserve(size_type count);"
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::size",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/size.html",
            "wgPageName": "cpp/container/unordered_set/size",
            "sample_declaration": "size_type size() const noexcept;"
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::swap",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/swap.html",
            "wgPageName": "cpp/container/unordered_set/swap",
            "sample_declaration": "void swap(unordered_set& other);",
            "other_declarations": 1
        },
        {
            "title": "std::swap(std::unordered_set)",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/swap2.html",
            "wgPageName": "cpp/container/unordered_set/swap2",
            "headers": [
                "<unordered_set>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class Hash,\n    class KeyEqual,\n    class Alloc>\nvoid swap(\n    std::unordered_set<\n        Key,\n        Hash,\n        KeyEqual,\n        Alloc>& lhs,\n    std::unordered_set<\n        Key,\n        Hash,\n        KeyEqual,\n        Alloc>& rhs);",
            "other_declarations": 1
        },
        {
            "title": "std::unordered_set<Key,Hash,KeyEqual,Allocator>::unordered_set",
            "path": "en.cppreference.com/w/cpp/container/unordered_set/unordered_set.html",
            "wgPageName": "cpp/container/unordered_set/unordered_set",
            "sample_declaration": "unordered_set()\n    : unordered_set(size_type(\n          /*implementation-defined*/)) {}\nexplicit unordered_set(\n    size_type bucket_count,\n    const Hash& hash = Hash(),\n    const key_equal& equal = key_equal(),\n    const Allocator& alloc = Allocator());",
            "other_declarations": 12
        },
        {
            "title": "std::vector<bool>",
            "path": "en.cppreference.com/w/cpp/container/vector_bool.html",
            "wgPageName": "cpp/container/vector_bool",
            "headers": [
                "<vector>"
            ],
            "sample_declaration": "template<class Allocator>\nclass vector<bool, Allocator>;"
        },
        {
            "title": "std::vector<bool,Allocator>::flip",
            "path": "en.cppreference.com/w/cpp/container/vector_bool/flip.html",
            "wgPageName": "cpp/container/vector_bool/flip",
            "headers": [
                "<vector>"
            ],
            "sample_declaration": "void flip();",
            "other_declarations": 1
        },
        {
            "title": "std::hash (std::vector<bool>)",
            "path": "en.cppreference.com/w/cpp/container/vector_bool/hash.html",
            "wgPageName": "cpp/container/vector_bool/hash",
            "sample_declaration": "template<class Allocator>\nstruct hash<vector<bool, Allocator>>;"
        },
        {
            "title": "std::vector<bool>::reference",
            "path": "en.cppreference.com/w/cpp/container/vector_bool/reference.html",
            "wgPageName": "cpp/container/vector_bool/reference",
            "sample_declaration": "class reference;"
        },
        {
            "title": "std::vector<bool,Allocator>::swap",
            "path": "en.cppreference.com/w/cpp/container/vector_bool/swap.html",
            "wgPageName": "cpp/container/vector_bool/swap",
            "headers": [
                "<vector>"
            ],
            "sample_declaration": "static void swap(reference x, reference y);",
            "other_declarations": 1
        },
        {
            "title": "std::vector",
            "path": "en.cppreference.com/w/cpp/container/vector.html",
            "wgPageName": "cpp/container/vector",
            "headers": [
                "<vector>"
            ],
            "sample_declaration": "template<\n    class T,\n    class Allocator = std::allocator<T> >\nclass vector;",
            "other_declarations": 1
        },
        {
            "title": "std::vector<T,Allocator>::~vector",
            "path": "en.cppreference.com/w/cpp/container/vector/~vector.html",
            "wgPageName": "cpp/container/vector/~vector",
            "sample_declaration": "~vector();",
            "other_declarations": 1
        },
        {
            "title": "std::vector<T,Allocator>::assign",
            "path": "en.cppreference.com/w/cpp/container/vector/assign.html",
            "wgPageName": "cpp/container/vector/assign",
            "sample_declaration": "void assign(size_type count, const T& value);",
            "other_declarations": 5
        },
        {
            "title": "std::vector<T,Allocator>::at",
            "path": "en.cppreference.com/w/cpp/container/vector/at.html",
            "wgPageName": "cpp/container/vector/at",
            "sample_declaration": "reference at(size_type pos);",
            "other_declarations": 3
        },
        {
            "title": "std::vector<T,Allocator>::back",
            "path": "en.cppreference.com/w/cpp/container/vector/back.html",
            "wgPageName": "cpp/container/vector/back",
            "sample_declaration": "reference back();",
            "other_declarations": 3
        },
        {
            "title": "std::vector<T,Allocator>::begin, std::vector<T,Allocator>::cbegin",
            "path": "en.cppreference.com/w/cpp/container/vector/begin.html",
            "wgPageName": "cpp/container/vector/begin",
            "sample_declaration": "iterator begin();",
            "other_declarations": 7
        },
        {
            "title": "std::vector<T,Allocator>::capacity",
            "path": "en.cppreference.com/w/cpp/container/vector/capacity.html",
            "wgPageName": "cpp/container/vector/capacity",
            "sample_declaration": "size_type capacity() const;",
            "other_declarations": 2
        },
        {
            "title": "std::vector<T,Allocator>::clear",
            "path": "en.cppreference.com/w/cpp/container/vector/clear.html",
            "wgPageName": "cpp/container/vector/clear",
            "sample_declaration": "void clear();",
            "other_declarations": 2
        },
        {
            "title": "std::vector<T,Allocator>::data",
            "path": "en.cppreference.com/w/cpp/container/vector/data.html",
            "wgPageName": "cpp/container/vector/data",
            "sample_declaration": "T* data();",
            "other_declarations": 5
        },
        {
            "title": "deduction guides for std::vector",
            "path": "en.cppreference.com/w/cpp/container/vector/deduction_guides.html",
            "wgPageName": "cpp/container/vector/deduction_guides",
            "headers": [
                "<vector>"
            ],
            "sample_declaration": "template<\n    class InputIt,\n    class Alloc = std::allocator<\n        typename std::iterator_traits<\n            InputIt>::value_type>>\nvector(InputIt, InputIt, Alloc = Alloc())\n    -> vector<\n        typename std::iterator_traits<\n            InputIt>::value_type,\n        Alloc>;"
        },
        {
            "title": "std::vector<T,Allocator>::emplace_back",
            "path": "en.cppreference.com/w/cpp/container/vector/emplace_back.html",
            "wgPageName": "cpp/container/vector/emplace_back",
            "sample_declaration": "template<class... Args>\nvoid emplace_back(Args&&... args);",
            "other_declarations": 2
        },
        {
            "title": "std::vector<T,Allocator>::emplace",
            "path": "en.cppreference.com/w/cpp/container/vector/emplace.html",
            "wgPageName": "cpp/container/vector/emplace",
            "sample_declaration": "template<class... Args>\niterator emplace(\n    const_iterator pos,\n    Args&&... args);",
            "other_declarations": 1
        },
        {
            "title": "std::vector<T,Allocator>::empty",
            "path": "en.cppreference.com/w/cpp/container/vector/empty.html",
            "wgPageName": "cpp/container/vector/empty",
            "sample_declaration": "bool empty() const;",
            "other_declarations": 2
        },
        {
            "title": "std::vector<T,Allocator>::end, std::vector<T,Allocator>::cend",
            "path": "en.cppreference.com/w/cpp/container/vector/end.html",
            "wgPageName": "cpp/container/vector/end",
            "sample_declaration": "iterator end();",
            "other_declarations": 7
        },
        {
            "title": "std::vector<T,Allocator>::erase",
            "path": "en.cppreference.com/w/cpp/container/vector/erase.html",
            "wgPageName": "cpp/container/vector/erase",
            "sample_declaration": "iterator erase(iterator pos);",
            "other_declarations": 5
        },
        {
            "title": "std::erase, std::erase_if (std::vector)",
            "path": "en.cppreference.com/w/cpp/container/vector/erase2.html",
            "wgPageName": "cpp/container/vector/erase2",
            "headers": [
                "<vector>"
            ],
            "sample_declaration": "template<class T, class Alloc, class U>\nconstexpr\n    typename std::vector<T, Alloc>::size_type\n    erase(\n        std::vector<T, Alloc>& c,\n        const U& value);",
            "other_declarations": 1
        },
        {
            "title": "std::vector<T,Allocator>::front",
            "path": "en.cppreference.com/w/cpp/container/vector/front.html",
            "wgPageName": "cpp/container/vector/front",
            "sample_declaration": "reference front();",
            "other_declarations": 3
        },
        {
            "title": "std::vector<T,Allocator>::get_allocator",
            "path": "en.cppreference.com/w/cpp/container/vector/get_allocator.html",
            "wgPageName": "cpp/container/vector/get_allocator",
            "sample_declaration": "allocator_type get_allocator() const;",
            "other_declarations": 2
        },
        {
            "title": "std::vector<T,Allocator>::insert",
            "path": "en.cppreference.com/w/cpp/container/vector/insert.html",
            "wgPageName": "cpp/container/vector/insert",
            "sample_declaration": "iterator insert(\n    const_iterator pos,\n    const T& value);",
            "other_declarations": 9
        },
        {
            "title": "std::vector<T,Allocator>::max_size",
            "path": "en.cppreference.com/w/cpp/container/vector/max_size.html",
            "wgPageName": "cpp/container/vector/max_size",
            "sample_declaration": "size_type max_size() const;",
            "other_declarations": 2
        },
        {
            "title": "std::vector<T,Allocator>::operator[]",
            "path": "en.cppreference.com/w/cpp/container/vector/operator_at.html",
            "wgPageName": "cpp/container/vector/operator_at",
            "sample_declaration": "reference operator[](size_type pos);",
            "other_declarations": 3
        },
        {
            "title": "operator==,!=,<,<=,>,>=,<=>(std::vector)",
            "path": "en.cppreference.com/w/cpp/container/vector/operator_cmp.html",
            "wgPageName": "cpp/container/vector/operator_cmp",
            "headers": [
                "<vector>"
            ],
            "sample_declaration": "template<class T, class Alloc>\nbool operator==(\n    const std::vector<T, Alloc>& lhs,\n    const std::vector<T, Alloc>& rhs);",
            "other_declarations": 7
        },
        {
            "title": "std::vector<T,Allocator>::operator=",
            "path": "en.cppreference.com/w/cpp/container/vector/operator=.html",
            "wgPageName": "cpp/container/vector/operator=",
            "sample_declaration": "vector& operator=(const vector& other);",
            "other_declarations": 6
        },
        {
            "title": "std::vector<T,Allocator>::pop_back",
            "path": "en.cppreference.com/w/cpp/container/vector/pop_back.html",
            "wgPageName": "cpp/container/vector/pop_back",
            "sample_declaration": "void pop_back();",
            "other_declarations": 1
        },
        {
            "title": "std::vector<T,Allocator>::push_back",
            "path": "en.cppreference.com/w/cpp/container/vector/push_back.html",
            "wgPageName": "cpp/container/vector/push_back",
            "sample_declaration": "void push_back(const T& value);",
            "other_declarations": 3
        },
        {
            "title": "std::vector<T,Allocator>::rbegin, std::vector<T,Allocator>::crbegin",
            "path": "en.cppreference.com/w/cpp/container/vector/rbegin.html",
            "wgPageName": "cpp/container/vector/rbegin",
            "sample_declaration": "reverse_iterator rbegin();",
            "other_declarations": 7
        },
        {
            "title": "std::vector<T,Allocator>::rend, std::vector<T,Allocator>::crend",
            "path": "en.cppreference.com/w/cpp/container/vector/rend.html",
            "wgPageName": "cpp/container/vector/rend",
            "sample_declaration": "reverse_iterator rend();",
            "other_declarations": 7
        },
        {
            "title": "std::vector<T,Allocator>::reserve",
            "path": "en.cppreference.com/w/cpp/container/vector/reserve.html",
            "wgPageName": "cpp/container/vector/reserve",
            "sample_declaration": "void reserve(size_type new_cap);",
            "other_declarations": 1
        },
        {
            "title": "std::vector<T,Allocator>::resize",
            "path": "en.cppreference.com/w/cpp/container/vector/resize.html",
            "wgPageName": "cpp/container/vector/resize",
            "sample_declaration": "void resize(size_type count);",
            "other_declarations": 4
        },
        {
            "title": "std::vector<T,Allocator>::shrink_to_fit",
            "path": "en.cppreference.com/w/cpp/container/vector/shrink_to_fit.html",
            "wgPageName": "cpp/container/vector/shrink_to_fit",
            "sample_declaration": "void shrink_to_fit();",
            "other_declarations": 1
        },
        {
            "title": "std::vector<T,Allocator>::size",
            "path": "en.cppreference.com/w/cpp/container/vector/size.html",
            "wgPageName": "cpp/container/vector/size",
            "sample_declaration": "size_type size() const;",
            "other_declarations": 2
        },
        {
            "title": "std::vector<T,Allocator>::swap",
            "path": "en.cppreference.com/w/cpp/container/vector/swap.html",
            "wgPageName": "cpp/container/vector/swap",
            "sample_declaration": "void swap(vector& other);",
            "other_declarations": 2
        },
        {
            "title": "std::swap(std::vector)",
            "path": "en.cppreference.com/w/cpp/container/vector/swap2.html",
            "wgPageName": "cpp/container/vector/swap2",
            "headers": [
                "<vector>"
            ],
            "sample_declaration": "template<class T, class Alloc>\nvoid swap(\n    std::vector<T, Alloc>& lhs,\n    std::vector<T, Alloc>& rhs);",
            "other_declarations": 2
        },
        {
            "title": "std::vector<T,Allocator>::vector",
            "path": "en.cppreference.com/w/cpp/container/vector/vector.html",
            "wgPageName": "cpp/container/vector/vector",
            "sample_declaration": "vector();",
            "other_declarations": 24
        },
        {
            "title": "Coroutine support (C++20)",
            "path": "en.cppreference.com/w/cpp/coroutine.html",
            "wgPageName": "cpp/coroutine"
        },
        {
            "title": "std::coroutine_handle, std::noop_coroutine_handle",
            "path": "en.cppreference.com/w/cpp/coroutine/coroutine_handle.html",
            "wgPageName": "cpp/coroutine/coroutine_handle",
            "headers": [
                "<coroutine>"
            ],
            "sample_declaration": "template<class Promise = void>\nstruct coroutine_handle;",
            "other_declarations": 3
        },
        {
            "title": "std::coroutine_handle<Promise>::address",
            "path": "en.cppreference.com/w/cpp/coroutine/coroutine_handle/address.html",
            "wgPageName": "cpp/coroutine/coroutine_handle/address",
            "sample_declaration": "constexpr void* address() const noexcept;"
        },
        {
            "title": "std::coroutine_handle<Promise>::coroutine_handle",
            "path": "en.cppreference.com/w/cpp/coroutine/coroutine_handle/coroutine_handle.html",
            "wgPageName": "cpp/coroutine/coroutine_handle/coroutine_handle",
            "sample_declaration": "constexpr coroutine_handle() noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::coroutine_handle<Promise>::destroy",
            "path": "en.cppreference.com/w/cpp/coroutine/coroutine_handle/destroy.html",
            "wgPageName": "cpp/coroutine/coroutine_handle/destroy",
            "sample_declaration": "void destroy() const;",
            "other_declarations": 1
        },
        {
            "title": "std::coroutine_handle<Promise>::done",
            "path": "en.cppreference.com/w/cpp/coroutine/coroutine_handle/done.html",
            "wgPageName": "cpp/coroutine/coroutine_handle/done",
            "sample_declaration": "bool done() const;",
            "other_declarations": 1
        },
        {
            "title": "std::coroutine_handle<Promise>::from_address",
            "path": "en.cppreference.com/w/cpp/coroutine/coroutine_handle/from_address.html",
            "wgPageName": "cpp/coroutine/coroutine_handle/from_address",
            "sample_declaration": "static constexpr coroutine_handle from_address(\n    void* addr);"
        },
        {
            "title": "std::coroutine_handle<Promise>::from_promise",
            "path": "en.cppreference.com/w/cpp/coroutine/coroutine_handle/from_promise.html",
            "wgPageName": "cpp/coroutine/coroutine_handle/from_promise",
            "sample_declaration": "static coroutine_handle from_promise(\n    Promise& p);"
        },
        {
            "title": "std::hash(std::coroutine_handle)",
            "path": "en.cppreference.com/w/cpp/coroutine/coroutine_handle/hash.html",
            "wgPageName": "cpp/coroutine/coroutine_handle/hash",
            "headers": [
                "<coroutine>"
            ],
            "sample_declaration": "template<class Promise>\nstruct hash<std::coroutine_handle<Promise>>;"
        },
        {
            "title": "std::coroutine_handle<Promise>::operator bool",
            "path": "en.cppreference.com/w/cpp/coroutine/coroutine_handle/operator_bool.html",
            "wgPageName": "cpp/coroutine/coroutine_handle/operator_bool",
            "sample_declaration": "explicit constexpr operator bool()\n    const noexcept;"
        },
        {
            "title": "std::operator==, operator<=>(std::coroutine_handle)",
            "path": "en.cppreference.com/w/cpp/coroutine/coroutine_handle/operator_cmp.html",
            "wgPageName": "cpp/coroutine/coroutine_handle/operator_cmp",
            "headers": [
                "<coroutine>"
            ],
            "sample_declaration": "constexpr bool operator==(\n    std::coroutine_handle<> x,\n    std::coroutine_handle<> y) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::coroutine_handle<Promise>::operator coroutine_handle<>",
            "path": "en.cppreference.com/w/cpp/coroutine/coroutine_handle/operator_coroutine_handle_void.html",
            "wgPageName": "cpp/coroutine/coroutine_handle/operator_coroutine_handle_void",
            "sample_declaration": "constexpr operator coroutine_handle<>()\n    const noexcept;"
        },
        {
            "title": "std::coroutine_handle<Promise>::operator=",
            "path": "en.cppreference.com/w/cpp/coroutine/coroutine_handle/operator=.html",
            "wgPageName": "cpp/coroutine/coroutine_handle/operator=",
            "sample_declaration": "coroutine_handle& operator=(\n    std::nullptr_t) noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::coroutine_handle<Promise>::promise",
            "path": "en.cppreference.com/w/cpp/coroutine/coroutine_handle/promise.html",
            "wgPageName": "cpp/coroutine/coroutine_handle/promise",
            "sample_declaration": "Promise& promise() const;",
            "other_declarations": 1
        },
        {
            "title": "std::coroutine_handle<Promise>::operator(), std::coroutine_handle<Promise>::resume",
            "path": "en.cppreference.com/w/cpp/coroutine/coroutine_handle/resume.html",
            "wgPageName": "cpp/coroutine/coroutine_handle/resume",
            "sample_declaration": "void operator()() const;\nvoid resume() const;",
            "other_declarations": 1
        },
        {
            "title": "std::coroutine_traits",
            "path": "en.cppreference.com/w/cpp/coroutine/coroutine_traits.html",
            "wgPageName": "cpp/coroutine/coroutine_traits",
            "headers": [
                "<coroutine>"
            ],
            "sample_declaration": "template<class R, class... Args>\nstruct coroutine_traits;"
        },
        {
            "title": "std::noop_coroutine_promise",
            "path": "en.cppreference.com/w/cpp/coroutine/noop_coroutine_promise.html",
            "wgPageName": "cpp/coroutine/noop_coroutine_promise",
            "headers": [
                "<coroutine>"
            ],
            "sample_declaration": "struct noop_coroutine_promise {};"
        },
        {
            "title": "std::noop_coroutine",
            "path": "en.cppreference.com/w/cpp/coroutine/noop_coroutine.html",
            "wgPageName": "cpp/coroutine/noop_coroutine",
            "headers": [
                "<coroutine>"
            ],
            "sample_declaration": "std::noop_coroutine_handle\nnoop_coroutine() noexcept;"
        },
        {
            "title": "std::suspend_always",
            "path": "en.cppreference.com/w/cpp/coroutine/suspend_always.html",
            "wgPageName": "cpp/coroutine/suspend_always",
            "headers": [
                "<coroutine>"
            ],
            "sample_declaration": "struct suspend_always;"
        },
        {
            "title": "std::suspend_never",
            "path": "en.cppreference.com/w/cpp/coroutine/suspend_never.html",
            "wgPageName": "cpp/coroutine/suspend_never",
            "headers": [
                "<coroutine>"
            ],
            "sample_declaration": "struct suspend_never;"
        },
        {
            "title": "Current Status",
            "path": "en.cppreference.com/w/cpp/current_status.html",
            "wgPageName": "cpp/current_status"
        },
        {
            "title": "Error handling",
            "path": "en.cppreference.com/w/cpp/error.html",
            "wgPageName": "cpp/error"
        },
        {
            "title": "assert",
            "path": "en.cppreference.com/w/cpp/error/assert.html",
            "wgPageName": "cpp/error/assert",
            "headers": [
                "<cassert>"
            ],
            "sample_declaration": "#ifdef NDEBUG #define assert(condition)((                              \\\n    void)0) #else #define assert(condition) /*implementation defined*/ \\\n    #endif"
        },
        {
            "title": "std::bad_exception",
            "path": "en.cppreference.com/w/cpp/error/bad_exception.html",
            "wgPageName": "cpp/error/bad_exception",
            "headers": [
                "<exception>"
            ],
            "sample_declaration": "class bad_exception;"
        },
        {
            "title": "std::bad_exception::bad_exception",
            "path": "en.cppreference.com/w/cpp/error/bad_exception/bad_exception.html",
            "wgPageName": "cpp/error/bad_exception/bad_exception",
            "sample_declaration": "bad_exception() throw();",
            "other_declarations": 3
        },
        {
            "title": "std::bad_exception::operator=",
            "path": "en.cppreference.com/w/cpp/error/bad_exception/operator=.html",
            "wgPageName": "cpp/error/bad_exception/operator=",
            "sample_declaration": "bad_exception& operator=(\n    const bad_exception& other) throw();",
            "other_declarations": 1
        },
        {
            "title": "std::bad_exception::what",
            "path": "en.cppreference.com/w/cpp/error/bad_exception/what.html",
            "wgPageName": "cpp/error/bad_exception/what",
            "sample_declaration": "virtual const char* what() const noexcept;"
        },
        {
            "title": "std::current_exception",
            "path": "en.cppreference.com/w/cpp/error/current_exception.html",
            "wgPageName": "cpp/error/current_exception",
            "headers": [
                "<exception>"
            ],
            "sample_declaration": "std::exception_ptr current_exception() noexcept;"
        },
        {
            "title": "std::domain_error",
            "path": "en.cppreference.com/w/cpp/error/domain_error.html",
            "wgPageName": "cpp/error/domain_error",
            "headers": [
                "<stdexcept>"
            ],
            "sample_declaration": "class domain_error;"
        },
        {
            "title": "std::errc",
            "path": "en.cppreference.com/w/cpp/error/errc.html",
            "wgPageName": "cpp/error/errc",
            "headers": [
                "<system_error>"
            ],
            "sample_declaration": "enum class errc;"
        },
        {
            "title": "std::is_error_condition_enum<std::errc>",
            "path": "en.cppreference.com/w/cpp/error/errc/is_error_condition_enum.html",
            "wgPageName": "cpp/error/errc/is_error_condition_enum",
            "headers": [
                "<system_error>"
            ],
            "sample_declaration": "template<>\nstruct is_error_condition_enum<std::errc>\n    : std::true_type;"
        },
        {
            "title": "std::make_error_code(std::errc)",
            "path": "en.cppreference.com/w/cpp/error/errc/make_error_code.html",
            "wgPageName": "cpp/error/errc/make_error_code",
            "headers": [
                "<system_error>"
            ],
            "sample_declaration": "std::error_code make_error_code(\n    std::errc e) noexcept;"
        },
        {
            "title": "std::make_error_condition(std::errc)",
            "path": "en.cppreference.com/w/cpp/error/errc/make_error_condition.html",
            "wgPageName": "cpp/error/errc/make_error_condition",
            "headers": [
                "<system_error>"
            ],
            "sample_declaration": "std::error_condition make_error_condition(\n    std::errc e) noexcept;"
        },
        {
            "title": "Error numbers",
            "path": "en.cppreference.com/w/cpp/error/errno_macros.html",
            "wgPageName": "cpp/error/errno_macros"
        },
        {
            "title": "errno",
            "path": "en.cppreference.com/w/cpp/error/errno.html",
            "wgPageName": "cpp/error/errno",
            "headers": [
                "<cerrno>"
            ],
            "sample_declaration": "#define errno /*implementation-defined*/"
        },
        {
            "title": "std::error_category",
            "path": "en.cppreference.com/w/cpp/error/error_category.html",
            "wgPageName": "cpp/error/error_category",
            "headers": [
                "<system_error>"
            ],
            "sample_declaration": "class error_category;"
        },
        {
            "title": "std::error_category::~error_category",
            "path": "en.cppreference.com/w/cpp/error/error_category/~error_category.html",
            "wgPageName": "cpp/error/error_category/~error_category",
            "sample_declaration": "virtual ~error_category();"
        },
        {
            "title": "std::error_category::default_error_condition",
            "path": "en.cppreference.com/w/cpp/error/error_category/default_error_condition.html",
            "wgPageName": "cpp/error/error_category/default_error_condition",
            "sample_declaration": "virtual std::error_condition\ndefault_error_condition(\n    int code) const noexcept;"
        },
        {
            "title": "std::error_category::equivalent",
            "path": "en.cppreference.com/w/cpp/error/error_category/equivalent.html",
            "wgPageName": "cpp/error/error_category/equivalent",
            "sample_declaration": "virtual bool equivalent(\n    int code,\n    const std::error_condition& condition)\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::error_category::error_category",
            "path": "en.cppreference.com/w/cpp/error/error_category/error_category.html",
            "wgPageName": "cpp/error/error_category/error_category",
            "sample_declaration": "constexpr error_category() noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::error_category::message",
            "path": "en.cppreference.com/w/cpp/error/error_category/message.html",
            "wgPageName": "cpp/error/error_category/message",
            "sample_declaration": "virtual std::string message(\n    int condition) const = 0;"
        },
        {
            "title": "std::error_category::name",
            "path": "en.cppreference.com/w/cpp/error/error_category/name.html",
            "wgPageName": "cpp/error/error_category/name",
            "sample_declaration": "virtual const char* name() const noexcept = 0;"
        },
        {
            "title": "std::error_category::operator==,!=,<,<=>",
            "path": "en.cppreference.com/w/cpp/error/error_category/operator_cmp.html",
            "wgPageName": "cpp/error/error_category/operator_cmp",
            "sample_declaration": "bool operator==(\n    const error_category& rhs) const noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::error_code",
            "path": "en.cppreference.com/w/cpp/error/error_code.html",
            "wgPageName": "cpp/error/error_code",
            "headers": [
                "<system_error>"
            ],
            "sample_declaration": "class error_code;"
        },
        {
            "title": "std::error_code::assign",
            "path": "en.cppreference.com/w/cpp/error/error_code/assign.html",
            "wgPageName": "cpp/error/error_code/assign",
            "sample_declaration": "void assign(\n    int ec,\n    const error_category& ecat) noexcept;"
        },
        {
            "title": "std::error_code::category",
            "path": "en.cppreference.com/w/cpp/error/error_code/category.html",
            "wgPageName": "cpp/error/error_code/category",
            "sample_declaration": "const std::error_category& category()\n    const noexcept;"
        },
        {
            "title": "std::error_code::clear",
            "path": "en.cppreference.com/w/cpp/error/error_code/clear.html",
            "wgPageName": "cpp/error/error_code/clear",
            "sample_declaration": "void clear() noexcept;"
        },
        {
            "title": "std::error_code::default_error_condition",
            "path": "en.cppreference.com/w/cpp/error/error_code/default_error_condition.html",
            "wgPageName": "cpp/error/error_code/default_error_condition",
            "sample_declaration": "std::error_condition default_error_condition()\n    const noexcept;"
        },
        {
            "title": "std::error_code::error_code",
            "path": "en.cppreference.com/w/cpp/error/error_code/error_code.html",
            "wgPageName": "cpp/error/error_code/error_code",
            "sample_declaration": "error_code() noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::hash<std::error_code>",
            "path": "en.cppreference.com/w/cpp/error/error_code/hash.html",
            "wgPageName": "cpp/error/error_code/hash",
            "headers": [
                "<system_error>"
            ],
            "sample_declaration": "template<>\nstruct hash<error_code>;"
        },
        {
            "title": "std::is_error_code_enum",
            "path": "en.cppreference.com/w/cpp/error/error_code/is_error_code_enum.html",
            "wgPageName": "cpp/error/error_code/is_error_code_enum",
            "headers": [
                "<system_error>"
            ],
            "sample_declaration": "template<class T>\nstruct is_error_code_enum;"
        },
        {
            "title": "std::error_code::message",
            "path": "en.cppreference.com/w/cpp/error/error_code/message.html",
            "wgPageName": "cpp/error/error_code/message",
            "sample_declaration": "std::string message() const;"
        },
        {
            "title": "std::error_code::operator bool",
            "path": "en.cppreference.com/w/cpp/error/error_code/operator_bool.html",
            "wgPageName": "cpp/error/error_code/operator_bool",
            "sample_declaration": "explicit operator bool() const noexcept;"
        },
        {
            "title": "std::operator==,!=,<,<=>(std::error_code)",
            "path": "en.cppreference.com/w/cpp/error/error_code/operator_cmp.html",
            "wgPageName": "cpp/error/error_code/operator_cmp",
            "headers": [
                "<system_error>"
            ],
            "sample_declaration": "bool operator==(\n    const std::error_code& lhs,\n    const std::error_code& rhs) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::operator<<(std::error_code)",
            "path": "en.cppreference.com/w/cpp/error/error_code/operator_ltlt.html",
            "wgPageName": "cpp/error/error_code/operator_ltlt",
            "headers": [
                "<system_error>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    basic_ostream<CharT, Traits>& os,\n    const error_code& ec);"
        },
        {
            "title": "std::error_code::operator=",
            "path": "en.cppreference.com/w/cpp/error/error_code/operator=.html",
            "wgPageName": "cpp/error/error_code/operator=",
            "sample_declaration": "template<class ErrorCodeEnum>\nerror_code& operator=(ErrorCodeEnum e) noexcept;"
        },
        {
            "title": "std::error_code::value",
            "path": "en.cppreference.com/w/cpp/error/error_code/value.html",
            "wgPageName": "cpp/error/error_code/value",
            "sample_declaration": "int value() const noexcept;"
        },
        {
            "title": "std::error_condition",
            "path": "en.cppreference.com/w/cpp/error/error_condition.html",
            "wgPageName": "cpp/error/error_condition",
            "headers": [
                "<system_error>"
            ],
            "sample_declaration": "class error_condition;"
        },
        {
            "title": "std::error_condition::assign",
            "path": "en.cppreference.com/w/cpp/error/error_condition/assign.html",
            "wgPageName": "cpp/error/error_condition/assign",
            "sample_declaration": "void assign(\n    int val,\n    const error_category& cat) noexcept;"
        },
        {
            "title": "std::error_condition::category",
            "path": "en.cppreference.com/w/cpp/error/error_condition/category.html",
            "wgPageName": "cpp/error/error_condition/category",
            "sample_declaration": "const error_category& category() const noexcept;"
        },
        {
            "title": "std::error_condition::clear",
            "path": "en.cppreference.com/w/cpp/error/error_condition/clear.html",
            "wgPageName": "cpp/error/error_condition/clear",
            "sample_declaration": "void clear() noexcept;"
        },
        {
            "title": "std::error_condition::error_condition",
            "path": "en.cppreference.com/w/cpp/error/error_condition/error_condition.html",
            "wgPageName": "cpp/error/error_condition/error_condition",
            "sample_declaration": "error_condition() noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::hash<std::error_condition>",
            "path": "en.cppreference.com/w/cpp/error/error_condition/hash.html",
            "wgPageName": "cpp/error/error_condition/hash",
            "headers": [
                "<system_error>"
            ],
            "sample_declaration": "template<>\nstruct hash<std::error_condition>;"
        },
        {
            "title": "std::is_error_condition_enum",
            "path": "en.cppreference.com/w/cpp/error/error_condition/is_error_condition_enum.html",
            "wgPageName": "cpp/error/error_condition/is_error_condition_enum",
            "headers": [
                "<system_error>"
            ],
            "sample_declaration": "template<class T>\nstruct is_error_condition_enum;"
        },
        {
            "title": "std::error_condition::message",
            "path": "en.cppreference.com/w/cpp/error/error_condition/message.html",
            "wgPageName": "cpp/error/error_condition/message",
            "sample_declaration": "std::string message() const;"
        },
        {
            "title": "std::error_condition::operator bool",
            "path": "en.cppreference.com/w/cpp/error/error_condition/operator_bool.html",
            "wgPageName": "cpp/error/error_condition/operator_bool",
            "sample_declaration": "explicit operator bool() const noexcept;"
        },
        {
            "title": "operator==,!=,<,<=>(std::error_condition)",
            "path": "en.cppreference.com/w/cpp/error/error_condition/operator_cmp.html",
            "wgPageName": "cpp/error/error_condition/operator_cmp",
            "headers": [
                "<system_error>"
            ],
            "sample_declaration": "bool operator==(\n    const std::error_condition& lhs,\n    const std::error_condition& rhs) noexcept;",
            "other_declarations": 7
        },
        {
            "title": "std::error_condition::operator=",
            "path": "en.cppreference.com/w/cpp/error/error_condition/operator=.html",
            "wgPageName": "cpp/error/error_condition/operator=",
            "sample_declaration": "error_condition& operator=(\n    const error_condition& other) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::error_condition::value",
            "path": "en.cppreference.com/w/cpp/error/error_condition/value.html",
            "wgPageName": "cpp/error/error_condition/value",
            "sample_declaration": "int value() const noexcept;"
        },
        {
            "title": "std::exception_ptr",
            "path": "en.cppreference.com/w/cpp/error/exception_ptr.html",
            "wgPageName": "cpp/error/exception_ptr",
            "headers": [
                "<exception>"
            ],
            "sample_declaration": "typedef /*unspecified*/ exception_ptr;"
        },
        {
            "title": "std::exception",
            "path": "en.cppreference.com/w/cpp/error/exception.html",
            "wgPageName": "cpp/error/exception",
            "headers": [
                "<exception>"
            ],
            "sample_declaration": "class exception;"
        },
        {
            "title": "std::exception::~exception",
            "path": "en.cppreference.com/w/cpp/error/exception/~exception.html",
            "wgPageName": "cpp/error/exception/~exception",
            "sample_declaration": "virtual ~exception();"
        },
        {
            "title": "std::exception::exception",
            "path": "en.cppreference.com/w/cpp/error/exception/exception.html",
            "wgPageName": "cpp/error/exception/exception",
            "sample_declaration": "exception() throw();",
            "other_declarations": 3
        },
        {
            "title": "std::get_unexpected",
            "path": "en.cppreference.com/w/cpp/error/exception/get_unexpected.html",
            "wgPageName": "cpp/error/get_unexpected",
            "headers": [
                "<exception>"
            ],
            "sample_declaration": "std::unexpected_handler\nget_unexpected() noexcept;"
        },
        {
            "title": "std::exception::operator=",
            "path": "en.cppreference.com/w/cpp/error/exception/operator=.html",
            "wgPageName": "cpp/error/exception/operator=",
            "sample_declaration": "exception& operator=(\n    const exception& other) throw();",
            "other_declarations": 1
        },
        {
            "title": "std::set_unexpected",
            "path": "en.cppreference.com/w/cpp/error/exception/set_unexpected.html",
            "wgPageName": "cpp/error/set_unexpected",
            "headers": [
                "<exception>"
            ],
            "sample_declaration": "std::unexpected_handler set_unexpected(\n    std::unexpected_handler f) throw();",
            "other_declarations": 1
        },
        {
            "title": "std::uncaught_exception, std::uncaught_exceptions",
            "path": "en.cppreference.com/w/cpp/error/exception/uncaught_exception.html",
            "wgPageName": "cpp/error/uncaught_exception",
            "headers": [
                "<exception>"
            ],
            "sample_declaration": "bool uncaught_exception() throw();",
            "other_declarations": 2
        },
        {
            "title": "std::unexpected_handler",
            "path": "en.cppreference.com/w/cpp/error/exception/unexpected_handler.html",
            "wgPageName": "cpp/error/unexpected_handler",
            "headers": [
                "<exception>"
            ],
            "sample_declaration": "typedef void (*unexpected_handler)();"
        },
        {
            "title": "std::exception::what",
            "path": "en.cppreference.com/w/cpp/error/exception/what.html",
            "wgPageName": "cpp/error/exception/what",
            "sample_declaration": "virtual const char* what() const throw();",
            "other_declarations": 1
        },
        {
            "title": "std::generic_category",
            "path": "en.cppreference.com/w/cpp/error/generic_category.html",
            "wgPageName": "cpp/error/generic_category",
            "headers": [
                "<system_error>"
            ],
            "sample_declaration": "const std::error_category&\ngeneric_category() noexcept;"
        },
        {
            "title": "std::get_terminate",
            "path": "en.cppreference.com/w/cpp/error/get_terminate.html",
            "wgPageName": "cpp/error/get_terminate",
            "headers": [
                "<exception>"
            ],
            "sample_declaration": "std::terminate_handler get_terminate() noexcept;"
        },
        {
            "title": "std::get_unexpected",
            "path": "en.cppreference.com/w/cpp/error/get_unexpected.html",
            "wgPageName": "cpp/error/get_unexpected",
            "headers": [
                "<exception>"
            ],
            "sample_declaration": "std::unexpected_handler\nget_unexpected() noexcept;"
        },
        {
            "title": "std::invalid_argument",
            "path": "en.cppreference.com/w/cpp/error/invalid_argument.html",
            "wgPageName": "cpp/error/invalid_argument",
            "headers": [
                "<stdexcept>"
            ],
            "sample_declaration": "class invalid_argument;"
        },
        {
            "title": "std::length_error",
            "path": "en.cppreference.com/w/cpp/error/length_error.html",
            "wgPageName": "cpp/error/length_error",
            "headers": [
                "<stdexcept>"
            ],
            "sample_declaration": "class length_error;"
        },
        {
            "title": "std::logic_error",
            "path": "en.cppreference.com/w/cpp/error/logic_error.html",
            "wgPageName": "cpp/error/logic_error",
            "headers": [
                "<stdexcept>"
            ],
            "sample_declaration": "class logic_error;"
        },
        {
            "title": "std::make_exception_ptr",
            "path": "en.cppreference.com/w/cpp/error/make_exception_ptr.html",
            "wgPageName": "cpp/error/make_exception_ptr",
            "headers": [
                "<exception>"
            ],
            "sample_declaration": "template<class E>\nstd::exception_ptr make_exception_ptr(\n    E e) noexcept;"
        },
        {
            "title": "std::nested_exception",
            "path": "en.cppreference.com/w/cpp/error/nested_exception.html",
            "wgPageName": "cpp/error/nested_exception",
            "headers": [
                "<exception>"
            ],
            "sample_declaration": "class nested_exception;"
        },
        {
            "title": "std::nested_exception::~nested_exception",
            "path": "en.cppreference.com/w/cpp/error/nested_exception/~nested_exception.html",
            "wgPageName": "cpp/error/nested_exception/~nested_exception",
            "sample_declaration": "virtual ~nested_exception() = default;"
        },
        {
            "title": "std::nested_exception::nested_exception",
            "path": "en.cppreference.com/w/cpp/error/nested_exception/nested_exception.html",
            "wgPageName": "cpp/error/nested_exception/nested_exception",
            "sample_declaration": "nested_exception() noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::nested_exception::nested_ptr",
            "path": "en.cppreference.com/w/cpp/error/nested_exception/nested_ptr.html",
            "wgPageName": "cpp/error/nested_exception/nested_ptr",
            "sample_declaration": "std::exception_ptr nested_ptr() const noexcept;"
        },
        {
            "title": "std::nested_exception::operator=",
            "path": "en.cppreference.com/w/cpp/error/nested_exception/operator=.html",
            "wgPageName": "cpp/error/nested_exception/operator=",
            "sample_declaration": "nested_exception& operator=(\n    const nested_exception& other) noexcept =\n    default;"
        },
        {
            "title": "std::nested_exception::rethrow_nested",
            "path": "en.cppreference.com/w/cpp/error/nested_exception/rethrow_nested.html",
            "wgPageName": "cpp/error/nested_exception/rethrow_nested",
            "sample_declaration": "[[noreturn]] void rethrow_nested() const;"
        },
        {
            "title": "std::out_of_range",
            "path": "en.cppreference.com/w/cpp/error/out_of_range.html",
            "wgPageName": "cpp/error/out_of_range",
            "headers": [
                "<stdexcept>"
            ],
            "sample_declaration": "class out_of_range;"
        },
        {
            "title": "std::overflow_error",
            "path": "en.cppreference.com/w/cpp/error/overflow_error.html",
            "wgPageName": "cpp/error/overflow_error",
            "headers": [
                "<stdexcept>"
            ],
            "sample_declaration": "class overflow_error;"
        },
        {
            "title": "std::range_error",
            "path": "en.cppreference.com/w/cpp/error/range_error.html",
            "wgPageName": "cpp/error/range_error",
            "headers": [
                "<stdexcept>"
            ],
            "sample_declaration": "class range_error;"
        },
        {
            "title": "std::rethrow_exception",
            "path": "en.cppreference.com/w/cpp/error/rethrow_exception.html",
            "wgPageName": "cpp/error/rethrow_exception",
            "headers": [
                "<exception>"
            ],
            "sample_declaration": "[[noreturn]] void rethrow_exception(\n    std::exception_ptr p);"
        },
        {
            "title": "std::rethrow_if_nested",
            "path": "en.cppreference.com/w/cpp/error/rethrow_if_nested.html",
            "wgPageName": "cpp/error/rethrow_if_nested",
            "headers": [
                "<exception>"
            ],
            "sample_declaration": "template<class E>\nvoid rethrow_if_nested(const E& e);"
        },
        {
            "title": "std::runtime_error",
            "path": "en.cppreference.com/w/cpp/error/runtime_error.html",
            "wgPageName": "cpp/error/runtime_error",
            "headers": [
                "<stdexcept>"
            ],
            "sample_declaration": "class runtime_error;"
        },
        {
            "title": "std::set_terminate",
            "path": "en.cppreference.com/w/cpp/error/set_terminate.html",
            "wgPageName": "cpp/error/set_terminate",
            "headers": [
                "<exception>"
            ],
            "sample_declaration": "std::terminate_handler set_terminate(\n    std::terminate_handler f) throw();",
            "other_declarations": 1
        },
        {
            "title": "std::set_unexpected",
            "path": "en.cppreference.com/w/cpp/error/set_unexpected.html",
            "wgPageName": "cpp/error/set_unexpected",
            "headers": [
                "<exception>"
            ],
            "sample_declaration": "std::unexpected_handler set_unexpected(\n    std::unexpected_handler f) throw();",
            "other_declarations": 1
        },
        {
            "title": "std::system_category",
            "path": "en.cppreference.com/w/cpp/error/system_category.html",
            "wgPageName": "cpp/error/system_category",
            "headers": [
                "<system_error>"
            ],
            "sample_declaration": "const std::error_category&\nsystem_category() noexcept;"
        },
        {
            "title": "std::system_error",
            "path": "en.cppreference.com/w/cpp/error/system_error.html",
            "wgPageName": "cpp/error/system_error",
            "headers": [
                "<system_error>"
            ],
            "sample_declaration": "class system_error;"
        },
        {
            "title": "std::system_error::code",
            "path": "en.cppreference.com/w/cpp/error/system_error/code.html",
            "wgPageName": "cpp/error/system_error/code",
            "sample_declaration": "const std::error_code& code() const noexcept;"
        },
        {
            "title": "std::system_error::operator=",
            "path": "en.cppreference.com/w/cpp/error/system_error/operator=.html",
            "wgPageName": "cpp/error/system_error/operator=",
            "sample_declaration": "system_error& operator=(\n    const system_error& other) noexcept;"
        },
        {
            "title": "std::system_error::system_error",
            "path": "en.cppreference.com/w/cpp/error/system_error/system_error.html",
            "wgPageName": "cpp/error/system_error/system_error",
            "sample_declaration": "system_error(std::error_code ec);",
            "other_declarations": 6
        },
        {
            "title": "std::system_error::what",
            "path": "en.cppreference.com/w/cpp/error/system_error/what.html",
            "wgPageName": "cpp/error/system_error/what",
            "sample_declaration": "virtual const char* what() const noexcept;"
        },
        {
            "title": "std::terminate_handler",
            "path": "en.cppreference.com/w/cpp/error/terminate_handler.html",
            "wgPageName": "cpp/error/terminate_handler",
            "headers": [
                "<exception>"
            ],
            "sample_declaration": "typedef void (*terminate_handler)();"
        },
        {
            "title": "std::terminate",
            "path": "en.cppreference.com/w/cpp/error/terminate.html",
            "wgPageName": "cpp/error/terminate",
            "headers": [
                "<exception>"
            ],
            "sample_declaration": "void terminate();",
            "other_declarations": 1
        },
        {
            "title": "std::throw_with_nested",
            "path": "en.cppreference.com/w/cpp/error/throw_with_nested.html",
            "wgPageName": "cpp/error/throw_with_nested",
            "headers": [
                "<exception>"
            ],
            "sample_declaration": "template<class T>\n[[noreturn]] void throw_with_nested(T&& t);"
        },
        {
            "title": "std::tx_exception",
            "path": "en.cppreference.com/w/cpp/error/tx_exception.html",
            "wgPageName": "cpp/error/tx_exception",
            "headers": [
                "<stdexcept>"
            ],
            "sample_declaration": "template<class T>\nclass tx_exception : public std::runtime_error;"
        },
        {
            "title": "std::uncaught_exception, std::uncaught_exceptions",
            "path": "en.cppreference.com/w/cpp/error/uncaught_exception.html",
            "wgPageName": "cpp/error/uncaught_exception",
            "headers": [
                "<exception>"
            ],
            "sample_declaration": "bool uncaught_exception() throw();",
            "other_declarations": 2
        },
        {
            "title": "std::underflow_error",
            "path": "en.cppreference.com/w/cpp/error/underflow_error.html",
            "wgPageName": "cpp/error/underflow_error",
            "headers": [
                "<stdexcept>"
            ],
            "sample_declaration": "class underflow_error;"
        },
        {
            "title": "std::unexpected_handler",
            "path": "en.cppreference.com/w/cpp/error/unexpected_handler.html",
            "wgPageName": "cpp/error/unexpected_handler",
            "headers": [
                "<exception>"
            ],
            "sample_declaration": "typedef void (*unexpected_handler)();"
        },
        {
            "title": "std::unexpected",
            "path": "en.cppreference.com/w/cpp/error/unexpected.html",
            "wgPageName": "cpp/error/unexpected",
            "headers": [
                "<exception>"
            ],
            "sample_declaration": "void unexpected();",
            "other_declarations": 1
        },
        {
            "title": "Experimental C++ Features",
            "path": "en.cppreference.com/w/cpp/experimental.html",
            "wgPageName": "cpp/experimental"
        },
        {
            "title": "std::experimental::any",
            "path": "en.cppreference.com/w/cpp/experimental/any.html",
            "wgPageName": "cpp/experimental/any",
            "headers": [
                "<experimental/any>"
            ],
            "sample_declaration": "class any;"
        },
        {
            "title": "std::experimental::any::~any",
            "path": "en.cppreference.com/w/cpp/experimental/any/~any.html",
            "wgPageName": "cpp/experimental/any/~any",
            "sample_declaration": "~any();"
        },
        {
            "title": "std::experimental::any_cast",
            "path": "en.cppreference.com/w/cpp/experimental/any/any_cast.html",
            "wgPageName": "cpp/experimental/any/any_cast",
            "sample_declaration": "template<class ValueType>\nValueType any_cast(const any& operand);",
            "other_declarations": 4
        },
        {
            "title": "std::experimental::any::any",
            "path": "en.cppreference.com/w/cpp/experimental/any/any.html",
            "wgPageName": "cpp/experimental/any/any",
            "sample_declaration": "any() noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::bad_any_cast",
            "path": "en.cppreference.com/w/cpp/experimental/any/bad_any_cast.html",
            "wgPageName": "cpp/experimental/any/bad_any_cast",
            "headers": [
                "<experimental/any>"
            ],
            "sample_declaration": "class bad_any_cast : public std::bad_cast;"
        },
        {
            "title": "std::experimental::any::clear",
            "path": "en.cppreference.com/w/cpp/experimental/any/clear.html",
            "wgPageName": "cpp/experimental/any/clear",
            "sample_declaration": "void clear() noexcept;"
        },
        {
            "title": "std::experimental::any::empty",
            "path": "en.cppreference.com/w/cpp/experimental/any/empty.html",
            "wgPageName": "cpp/experimental/any/empty",
            "sample_declaration": "bool empty() const noexcept;"
        },
        {
            "title": "std::experimental::any::operator=",
            "path": "en.cppreference.com/w/cpp/experimental/any/operator=.html",
            "wgPageName": "cpp/experimental/any/operator=",
            "sample_declaration": "any& operator=(const any& rhs);",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::any::swap",
            "path": "en.cppreference.com/w/cpp/experimental/any/swap.html",
            "wgPageName": "cpp/experimental/any/swap",
            "sample_declaration": "void swap(any& other) noexcept;"
        },
        {
            "title": "std::experimental::swap(std::experimental::any)",
            "path": "en.cppreference.com/w/cpp/experimental/any/swap2.html",
            "wgPageName": "cpp/experimental/any/swap2",
            "sample_declaration": "void swap(any& lhs, any& rhs) noexcept;"
        },
        {
            "title": "std::experimental::any::type",
            "path": "en.cppreference.com/w/cpp/experimental/any/type.html",
            "wgPageName": "cpp/experimental/any/type",
            "sample_declaration": "const type_info& type() const noexcept;"
        },
        {
            "title": "std::experimental::apply",
            "path": "en.cppreference.com/w/cpp/experimental/apply.html",
            "wgPageName": "cpp/experimental/apply",
            "headers": [
                "<experimental/tuple>"
            ],
            "sample_declaration": "template<class F, class Tuple>\nconstexpr decltype(auto) apply(\n    F&& f,\n    Tuple&& t);"
        },
        {
            "title": "std::experimental::atomic_shared_ptr",
            "path": "en.cppreference.com/w/cpp/experimental/atomic_shared_ptr.html",
            "wgPageName": "cpp/experimental/atomic_shared_ptr",
            "headers": [
                "<experimental/atomic>"
            ],
            "sample_declaration": "template<class T>\nclass atomic_shared_ptr;"
        },
        {
            "title": "std::experimental::atomic_shared_ptr<T>::atomic_shared_ptr",
            "path": "en.cppreference.com/w/cpp/experimental/atomic_shared_ptr/atomic_shared_ptr.html",
            "wgPageName": "cpp/experimental/atomic_shared_ptr/atomic_shared_ptr",
            "sample_declaration": "constexpr atomic_shared_ptr() noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::atomic_shared_ptr<T>::compare_exchange_strong, std::experimental::atomic_shared_ptr<T>::compare_exchange_weak",
            "path": "en.cppreference.com/w/cpp/experimental/atomic_shared_ptr/compare_exchange.html",
            "wgPageName": "cpp/experimental/atomic_shared_ptr/compare_exchange",
            "sample_declaration": "bool compare_exchange_weak(\n    std::shared_ptr<T>& expected,\n    const std::shared_ptr<T>& desired,\n    std::memory_order success,\n    std::memory_order failure) noexcept;",
            "other_declarations": 7
        },
        {
            "title": "std::experimental::atomic_shared_ptr<T>::exchange",
            "path": "en.cppreference.com/w/cpp/experimental/atomic_shared_ptr/exchange.html",
            "wgPageName": "cpp/experimental/atomic_shared_ptr/exchange",
            "sample_declaration": "shared_ptr<T> exchange(\n    shared_ptr<T> desired,\n    std::memory_order order =\n        std::memory_order_seq_cst) noexcept;"
        },
        {
            "title": "std::experimental::atomic_shared_ptr<T>::is_lock_free",
            "path": "en.cppreference.com/w/cpp/experimental/atomic_shared_ptr/is_lock_free.html",
            "wgPageName": "cpp/experimental/atomic_shared_ptr/is_lock_free",
            "sample_declaration": "bool is_lock_free() const noexcept;"
        },
        {
            "title": "std::experimental::atomic_shared_ptr<T>::load",
            "path": "en.cppreference.com/w/cpp/experimental/atomic_shared_ptr/load.html",
            "wgPageName": "cpp/experimental/atomic_shared_ptr/load",
            "sample_declaration": "shared_ptr<T> load(\n    std::memory_order order =\n        std::memory_order_seq_cst)\n    const noexcept;"
        },
        {
            "title": "std::experimental::atomic_shared_ptr<T>::operator shared_ptr<T>",
            "path": "en.cppreference.com/w/cpp/experimental/atomic_shared_ptr/operator_shared_ptr.html",
            "wgPageName": "cpp/experimental/atomic_shared_ptr/operator_shared_ptr",
            "sample_declaration": "operator shared_ptr<T>() const noexcept;"
        },
        {
            "title": "std::experimental::atomic_shared_ptr<T>::operator=",
            "path": "en.cppreference.com/w/cpp/experimental/atomic_shared_ptr/operator=.html",
            "wgPageName": "cpp/experimental/atomic_shared_ptr/operator=",
            "sample_declaration": "void operator=(shared_ptr<T> desired) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::atomic_shared_ptr<T>::store",
            "path": "en.cppreference.com/w/cpp/experimental/atomic_shared_ptr/store.html",
            "wgPageName": "cpp/experimental/atomic_shared_ptr/store",
            "sample_declaration": "void store(\n    shared_ptr<T> desired,\n    std::memory_order order =\n        std::memory_order_seq_cst) noexcept;"
        },
        {
            "title": "std::experimental::atomic_weak_ptr",
            "path": "en.cppreference.com/w/cpp/experimental/atomic_weak_ptr.html",
            "wgPageName": "cpp/experimental/atomic_weak_ptr",
            "headers": [
                "<experimental/atomic>"
            ],
            "sample_declaration": "template<class T>\nclass atomic_weak_ptr;"
        },
        {
            "title": "std::experimental::atomic_weak_ptr<T>::atomic_weak_ptr",
            "path": "en.cppreference.com/w/cpp/experimental/atomic_weak_ptr/atomic_weak_ptr.html",
            "wgPageName": "cpp/experimental/atomic_weak_ptr/atomic_weak_ptr",
            "sample_declaration": "constexpr atomic_weak_ptr() noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::atomic_weak_ptr<T>::compare_exchange_strong, std::experimental::atomic_weak_ptr<T>::compare_exchange_weak",
            "path": "en.cppreference.com/w/cpp/experimental/atomic_weak_ptr/compare_exchange.html",
            "wgPageName": "cpp/experimental/atomic_weak_ptr/compare_exchange",
            "sample_declaration": "bool compare_exchange_weak(\n    std::weak_ptr<T>& expected,\n    const std::weak_ptr<T>& desired,\n    std::memory_order success,\n    std::memory_order failure) noexcept;",
            "other_declarations": 7
        },
        {
            "title": "std::experimental::atomic_weak_ptr<T>::exchange",
            "path": "en.cppreference.com/w/cpp/experimental/atomic_weak_ptr/exchange.html",
            "wgPageName": "cpp/experimental/atomic_weak_ptr/exchange",
            "sample_declaration": "weak_ptr<T> exchange(\n    weak_ptr<T> desired,\n    std::memory_order order =\n        std::memory_order_seq_cst) noexcept;"
        },
        {
            "title": "std::experimental::atomic_weak_ptr<T>::is_lock_free",
            "path": "en.cppreference.com/w/cpp/experimental/atomic_weak_ptr/is_lock_free.html",
            "wgPageName": "cpp/experimental/atomic_weak_ptr/is_lock_free",
            "sample_declaration": "bool is_lock_free() const noexcept;"
        },
        {
            "title": "std::experimental::atomic_weak_ptr<T>::load",
            "path": "en.cppreference.com/w/cpp/experimental/atomic_weak_ptr/load.html",
            "wgPageName": "cpp/experimental/atomic_weak_ptr/load",
            "sample_declaration": "weak_ptr<T> load(\n    std::memory_order order =\n        std::memory_order_seq_cst)\n    const noexcept;"
        },
        {
            "title": "std::experimental::atomic_weak_ptr<T>::operator weak_ptr<T>",
            "path": "en.cppreference.com/w/cpp/experimental/atomic_weak_ptr/operator_weak_ptr.html",
            "wgPageName": "cpp/experimental/atomic_weak_ptr/operator_weak_ptr",
            "sample_declaration": "operator weak_ptr<T>() const noexcept;"
        },
        {
            "title": "std::experimental::atomic_weak_ptr<T>::operator=",
            "path": "en.cppreference.com/w/cpp/experimental/atomic_weak_ptr/operator=.html",
            "wgPageName": "cpp/experimental/atomic_weak_ptr/operator=",
            "sample_declaration": "void operator=(weak_ptr<T> desired) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::atomic_weak_ptr<T>::store",
            "path": "en.cppreference.com/w/cpp/experimental/atomic_weak_ptr/store.html",
            "wgPageName": "cpp/experimental/atomic_weak_ptr/store",
            "sample_declaration": "void store(\n    weak_ptr<T> desired,\n    std::memory_order order =\n        std::memory_order_seq_cst) noexcept;"
        },
        {
            "title": "std::experimental::barrier",
            "path": "en.cppreference.com/w/cpp/experimental/barrier.html",
            "wgPageName": "cpp/experimental/barrier",
            "headers": [
                "<experimental/barrier>"
            ],
            "sample_declaration": "class barrier;"
        },
        {
            "title": "std::experimental::barrier::~barrier",
            "path": "en.cppreference.com/w/cpp/experimental/barrier/~barrier.html",
            "wgPageName": "cpp/experimental/barrier/~barrier",
            "sample_declaration": "~barrier();"
        },
        {
            "title": "std::experimental::barrier::arrive_and_drop",
            "path": "en.cppreference.com/w/cpp/experimental/barrier/arrive_and_drop.html",
            "wgPageName": "cpp/experimental/barrier/arrive_and_drop",
            "sample_declaration": "void arrive_and_drop();"
        },
        {
            "title": "std::experimental::barrier::arrive_and_wait",
            "path": "en.cppreference.com/w/cpp/experimental/barrier/arrive_and_wait.html",
            "wgPageName": "cpp/experimental/barrier/arrive_and_wait",
            "sample_declaration": "void arrive_and_wait();"
        },
        {
            "title": "std::experimental::barrier::barrier",
            "path": "en.cppreference.com/w/cpp/experimental/barrier/barrier.html",
            "wgPageName": "cpp/experimental/barrier/barrier",
            "sample_declaration": "explicit barrier(std::ptrdiff_t num_threads);",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::basic_string_view",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view.html",
            "wgPageName": "cpp/experimental/basic_string_view",
            "headers": [
                "<experimental/string_view>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT> >\nclass basic_string_view;"
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::at",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/at.html",
            "wgPageName": "cpp/experimental/basic_string_view/at",
            "sample_declaration": "constexpr const_reference at(\n    size_type pos) const;"
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::back",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/back.html",
            "wgPageName": "cpp/experimental/basic_string_view/back",
            "sample_declaration": "constexpr const_reference back() const;"
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::basic_string_view",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/basic_string_view.html",
            "wgPageName": "cpp/experimental/basic_string_view/basic_string_view",
            "sample_declaration": "constexpr basic_string_view() noexcept;",
            "other_declarations": 4
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::begin, std::experimental::basic_string_view<CharT,Traits>::cbegin",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/begin.html",
            "wgPageName": "cpp/experimental/basic_string_view/begin",
            "sample_declaration": "constexpr const_iterator begin() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::compare",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/compare.html",
            "wgPageName": "cpp/experimental/basic_string_view/compare",
            "sample_declaration": "constexpr int compare(\n    basic_string_view v) const noexcept;",
            "other_declarations": 5
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::copy",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/copy.html",
            "wgPageName": "cpp/experimental/basic_string_view/copy",
            "sample_declaration": "size_type copy(\n    CharT* dest,\n    size_type count,\n    size_type pos = 0) const;"
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::data",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/data.html",
            "wgPageName": "cpp/experimental/basic_string_view/data",
            "sample_declaration": "constexpr const_pointer data() const noexcept;"
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::empty",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/empty.html",
            "wgPageName": "cpp/experimental/basic_string_view/empty",
            "sample_declaration": "constexpr bool empty() const noexcept;"
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::end, std::experimental::basic_string_view<CharT,Traits>::cend",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/end.html",
            "wgPageName": "cpp/experimental/basic_string_view/end",
            "sample_declaration": "constexpr const_iterator end() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::find_first_not_of",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/find_first_not_of.html",
            "wgPageName": "cpp/experimental/basic_string_view/find_first_not_of",
            "sample_declaration": "constexpr size_type find_first_not_of(\n    basic_string_view v,\n    size_type pos = 0) const noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::find_first_of",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/find_first_of.html",
            "wgPageName": "cpp/experimental/basic_string_view/find_first_of",
            "sample_declaration": "constexpr size_type find_first_of(\n    basic_string_view v,\n    size_type pos = 0) const noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::find_last_not_of",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/find_last_not_of.html",
            "wgPageName": "cpp/experimental/basic_string_view/find_last_not_of",
            "sample_declaration": "constexpr size_type find_last_not_of(\n    basic_string_view v,\n    size_type pos = npos) const noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::find_last_of",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/find_last_of.html",
            "wgPageName": "cpp/experimental/basic_string_view/find_last_of",
            "sample_declaration": "constexpr size_type find_last_of(\n    basic_string_view v,\n    size_type pos = npos) const noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::find",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/find.html",
            "wgPageName": "cpp/experimental/basic_string_view/find",
            "sample_declaration": "constexpr size_type find(\n    basic_string_view v,\n    size_type pos = 0) const noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::front",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/front.html",
            "wgPageName": "cpp/experimental/basic_string_view/front",
            "sample_declaration": "constexpr const_reference front() const;"
        },
        {
            "title": "std::hash (std::experimental::string_view, std::experimental::wstring_view, std::experimental::u16string_view, std::experimental::u32string_view)",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/hash.html",
            "wgPageName": "cpp/experimental/basic_string_view/hash",
            "headers": [
                "<experimental/string_view>"
            ],
            "sample_declaration": "template<>\nstruct hash<std::experimental::string_view>;\ntemplate<>\nstruct hash<std::experimental::wstring_view>;\ntemplate<>\nstruct hash<std::experimental::u16string_view>;\ntemplate<>\nstruct hash<std::experimental::u32string_view>;"
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::max_size",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/max_size.html",
            "wgPageName": "cpp/experimental/basic_string_view/max_size",
            "sample_declaration": "constexpr size_type max_size() const noexcept;"
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::npos",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/npos.html",
            "wgPageName": "cpp/experimental/basic_string_view/npos",
            "sample_declaration": "static constexpr size_type npos = size_type(-1);"
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::operator[]",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/operator_at.html",
            "wgPageName": "cpp/experimental/basic_string_view/operator_at",
            "sample_declaration": "constexpr const_reference operator[](\n    size_type pos) const;"
        },
        {
            "title": "operator==,!=,<,<=,>,>=(std::experimental::basic_string_view)",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/operator_cmp.html",
            "wgPageName": "cpp/experimental/basic_string_view/operator_cmp",
            "headers": [
                "<experimental/string_view>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nconstexpr bool operator==(\n    basic_string_view<CharT, Traits> lhs,\n    basic_string_view<CharT, Traits>\n        rhs) noexcept;",
            "other_declarations": 5
        },
        {
            "title": "operator<<(std::experimental::basic_string_view)",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/operator_ltlt.html",
            "wgPageName": "cpp/experimental/basic_string_view/operator_ltlt",
            "headers": [
                "<experimental/string_view>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    std::basic_string_view<CharT, Traits> v);"
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::operator=",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/operator=.html",
            "wgPageName": "cpp/experimental/basic_string_view/operator=",
            "sample_declaration": "basic_string_view& operator=(\n    const basic_string_view& view) noexcept =\n    default;"
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::rbegin, std::experimental::basic_string_view<CharT,Traits>::crbegin",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/rbegin.html",
            "wgPageName": "cpp/experimental/basic_string_view/rbegin",
            "sample_declaration": "constexpr const_reverse_iterator rbegin()\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::remove_prefix",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/remove_prefix.html",
            "wgPageName": "cpp/experimental/basic_string_view/remove_prefix",
            "sample_declaration": "constexpr void remove_prefix(size_type n);"
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::remove_suffix",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/remove_suffix.html",
            "wgPageName": "cpp/experimental/basic_string_view/remove_suffix",
            "sample_declaration": "constexpr void remove_suffix(size_type n);"
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::rend, std::experimental::basic_string_view<CharT,Traits>::crend",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/rend.html",
            "wgPageName": "cpp/experimental/basic_string_view/rend",
            "sample_declaration": "constexpr const_reverse_iterator rend()\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::rfind",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/rfind.html",
            "wgPageName": "cpp/experimental/basic_string_view/rfind",
            "sample_declaration": "constexpr size_type rfind(\n    basic_string_view v,\n    size_type pos = npos) const noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::size, std::experimental::basic_string_view<CharT,Traits>::length",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/size.html",
            "wgPageName": "cpp/experimental/basic_string_view/size",
            "sample_declaration": "constexpr size_type size() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::substr",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/substr.html",
            "wgPageName": "cpp/experimental/basic_string_view/substr",
            "sample_declaration": "constexpr basic_string_view substr(\n    size_type pos = 0,\n    size_type count = npos) const;"
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::swap",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/swap.html",
            "wgPageName": "cpp/experimental/basic_string_view/swap",
            "sample_declaration": "constexpr void swap(\n    basic_string_view& v) noexcept;"
        },
        {
            "title": "std::experimental::basic_string_view<CharT,Traits>::to_string, std::experimental::basic_string_view<CharT,Traits>::operator basic_string",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string_view/to_string.html",
            "wgPageName": "cpp/experimental/basic_string_view/to_string",
            "sample_declaration": "template<class Allocator = allocator<CharT>>\nbasic_string<CharT, Traits, Allocator>\nto_string(\n    const Allocator& a = Allocator()) const;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::erase_if (std::basic_string)",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string/erase_if.html",
            "wgPageName": "cpp/experimental/basic_string/erase_if",
            "headers": [
                "<experimental/string>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Alloc,\n    class Pred>\nvoid erase_if(\n    std::basic_string<CharT, Traits, Alloc>& c,\n    Pred pred);"
        },
        {
            "title": "std::experimental::erase (std::basic_string)",
            "path": "en.cppreference.com/w/cpp/experimental/basic_string/erase.html",
            "wgPageName": "cpp/experimental/basic_string/erase",
            "headers": [
                "<experimental/string>"
            ],
            "sample_declaration": "template<\n    class charT,\n    class traits,\n    class A,\n    class U>\nvoid erase(\n    std::basic_string<charT, traits, A>& c,\n    const U& value);"
        },
        {
            "title": "std::experimental::boyer_moore_horspool_searcher, std::experimental::make_boyer_moore_horspool_searcher",
            "path": "en.cppreference.com/w/cpp/experimental/boyer_moore_horspool_searcher.html",
            "wgPageName": "cpp/experimental/boyer_moore_horspool_searcher",
            "headers": [
                "<experimental/functional>"
            ],
            "sample_declaration": "template<\n    class RandomIt1,\n    class Hash =\n        std::hash<typename std::iterator_traits<\n            RandomIt1>::value_type>,\n    class BinaryPredicate = std::equal_to<> >\nclass boyer_moore_horspool_searcher;"
        },
        {
            "title": "std::experimental::boyer_moore_searcher, std::experimental::make_boyer_moore_searcher",
            "path": "en.cppreference.com/w/cpp/experimental/boyer_moore_searcher.html",
            "wgPageName": "cpp/experimental/boyer_moore_searcher",
            "headers": [
                "<experimental/functional>"
            ],
            "sample_declaration": "template<\n    class RandomIt1,\n    class Hash =\n        std::hash<typename std::iterator_traits<\n            RandomIt1>::value_type>,\n    class BinaryPredicate = std::equal_to<> >\nclass boyer_moore_searcher;"
        },
        {
            "title": "Extensions for concurrency",
            "path": "en.cppreference.com/w/cpp/experimental/concurrency.html",
            "wgPageName": "cpp/experimental/concurrency"
        },
        {
            "title": "std::experimental::packaged_task (concurrency TS)",
            "path": "en.cppreference.com/w/cpp/experimental/concurrency/packaged_task.html",
            "wgPageName": "cpp/experimental/concurrency/packaged_task",
            "headers": [
                "<experimental/future>"
            ],
            "sample_declaration": "template<class>\nclass packaged_task;  // not defined",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::promise (concurrency TS)",
            "path": "en.cppreference.com/w/cpp/experimental/concurrency/promise.html",
            "wgPageName": "cpp/experimental/concurrency/promise",
            "headers": [
                "<experimental/future>"
            ],
            "sample_declaration": "template<class R>\nclass promise;",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::conjunction",
            "path": "en.cppreference.com/w/cpp/experimental/conjunction.html",
            "wgPageName": "cpp/experimental/conjunction",
            "headers": [
                "<experimental/type_traits>"
            ],
            "sample_declaration": "template<class... B>\nstruct conjunction;"
        },
        {
            "title": "Constraints and concepts",
            "path": "en.cppreference.com/w/cpp/experimental/constraints.html",
            "wgPageName": "cpp/experimental/constraints"
        },
        {
            "title": "std::experimental::default_searcher, std::experimental::make_default_searcher",
            "path": "en.cppreference.com/w/cpp/experimental/default_searcher.html",
            "wgPageName": "cpp/experimental/default_searcher",
            "headers": [
                "<experimental/functional>"
            ],
            "sample_declaration": "template<\n    class ForwardIterator1,\n    class BinaryPredicate = std::equal_to<> >\nclass default_searcher;"
        },
        {
            "title": "std::experimental::erase_if (std::deque)",
            "path": "en.cppreference.com/w/cpp/experimental/deque/erase_if.html",
            "wgPageName": "cpp/experimental/deque/erase_if",
            "headers": [
                "<experimental/deque>"
            ],
            "sample_declaration": "template<class T, class Alloc, class Pred>\nvoid erase_if(\n    std::deque<T, Alloc>& c,\n    Pred pred);"
        },
        {
            "title": "std::experimental::erase (std::deque)",
            "path": "en.cppreference.com/w/cpp/experimental/deque/erase.html",
            "wgPageName": "cpp/experimental/deque/erase",
            "headers": [
                "<experimental/deque>"
            ],
            "sample_declaration": "template<class T, class A, class U>\nvoid erase(std::deque<T, A>& c, const U& value);"
        },
        {
            "title": "std::experimental::disjunction",
            "path": "en.cppreference.com/w/cpp/experimental/disjunction.html",
            "wgPageName": "cpp/experimental/disjunction",
            "headers": [
                "<experimental/type_traits>"
            ],
            "sample_declaration": "template<class... B>\nstruct disjunction;"
        },
        {
            "title": "std::experimental::erased_type",
            "path": "en.cppreference.com/w/cpp/experimental/erased_type.html",
            "wgPageName": "cpp/experimental/erased_type",
            "headers": [
                "<experimental/utility>"
            ],
            "sample_declaration": "struct erased_type {};"
        },
        {
            "title": "std::experimental::parallel::sequential_execution_policy, std::experimental::parallel::parallel_execution_policy, std::experimental::parallel::parallel_vector_execution_policy",
            "path": "en.cppreference.com/w/cpp/experimental/execution_policy_tag_t.html",
            "wgPageName": "cpp/experimental/execution_policy_tag_t",
            "headers": [
                "<experimental/execution_policy>"
            ],
            "sample_declaration": "class sequential_execution_policy { /* unspecified\n                                     */\n};",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::parallel::seq, std::experimental::parallel::par, std::experimental::parallel::par_vec",
            "path": "en.cppreference.com/w/cpp/experimental/execution_policy_tag.html",
            "wgPageName": "cpp/experimental/execution_policy_tag",
            "headers": [
                "<experimental/execution_policy>"
            ],
            "sample_declaration": "constexpr sequential_execution_policy seq{};",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::flex_barrier",
            "path": "en.cppreference.com/w/cpp/experimental/flex_barrier.html",
            "wgPageName": "cpp/experimental/flex_barrier",
            "headers": [
                "<experimental/barrier>"
            ],
            "sample_declaration": "class flex_barrier;"
        },
        {
            "title": "std::experimental::flex_barrier::~flex_barrier",
            "path": "en.cppreference.com/w/cpp/experimental/flex_barrier/~flex_barrier.html",
            "wgPageName": "cpp/experimental/flex_barrier/~flex_barrier",
            "sample_declaration": "~flex_barrier();"
        },
        {
            "title": "std::experimental::flex_barrier::arrive_and_drop",
            "path": "en.cppreference.com/w/cpp/experimental/flex_barrier/arrive_and_drop.html",
            "wgPageName": "cpp/experimental/flex_barrier/arrive_and_drop",
            "sample_declaration": "void arrive_and_drop();"
        },
        {
            "title": "std::experimental::flex_barrier::arrive_and_wait",
            "path": "en.cppreference.com/w/cpp/experimental/flex_barrier/arrive_and_wait.html",
            "wgPageName": "cpp/experimental/flex_barrier/arrive_and_wait",
            "sample_declaration": "void arrive_and_wait();"
        },
        {
            "title": "std::experimental::flex_barrier::flex_barrier",
            "path": "en.cppreference.com/w/cpp/experimental/flex_barrier/flex_barrier.html",
            "wgPageName": "cpp/experimental/flex_barrier/flex_barrier",
            "sample_declaration": "explicit flex_barrier(\n    std::ptrdiff_t num_threads);",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::erase_if (std::forward_list)",
            "path": "en.cppreference.com/w/cpp/experimental/forward_list/erase_if.html",
            "wgPageName": "cpp/experimental/forward_list/erase_if",
            "headers": [
                "<experimental/forward_list>"
            ],
            "sample_declaration": "template<class T, class Alloc, class Pred>\nvoid erase_if(\n    std::forward_list<T, Alloc>& c,\n    Pred pred);"
        },
        {
            "title": "std::experimental::erase (std::forward_list)",
            "path": "en.cppreference.com/w/cpp/experimental/forward_list/erase.html",
            "wgPageName": "cpp/experimental/forward_list/erase",
            "headers": [
                "<experimental/forward_list>"
            ],
            "sample_declaration": "template<class T, class A, class U>\nvoid erase(\n    std::forward_list<T, A>& c,\n    const U& value);"
        },
        {
            "title": "Filesystem library",
            "path": "en.cppreference.com/w/cpp/experimental/fs.html",
            "wgPageName": "cpp/experimental/fs"
        },
        {
            "title": "std::experimental::filesystem::absolute, std::experimental::filesystem::system_complete",
            "path": "en.cppreference.com/w/cpp/experimental/fs/absolute.html",
            "wgPageName": "cpp/experimental/fs/absolute",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "path absolute(\n    const path& p,\n    const path& base = current_path());",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::canonical",
            "path": "en.cppreference.com/w/cpp/experimental/fs/canonical.html",
            "wgPageName": "cpp/experimental/fs/canonical",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "path canonical(\n    const path& p,\n    const path& base = current_path());",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::filesystem::copy_file",
            "path": "en.cppreference.com/w/cpp/experimental/fs/copy_file.html",
            "wgPageName": "cpp/experimental/fs/copy_file",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "bool copy_file(\n    const path& from,\n    const path& to);\nbool copy_file(\n    const path& from,\n    const path& to,\n    error_code& ec);",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::copy_options",
            "path": "en.cppreference.com/w/cpp/experimental/fs/copy_options.html",
            "wgPageName": "cpp/experimental/fs/copy_options",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "enum class copy_options {\n  none = 0,\n  skip_existing = 1,\n  overwrite_existing = 2,\n  update_existing = 4,\n  recursive = 8,\n  copy_symlinks = 16,\n  skip_symlinks = 32,\n  directories_only = 64,\n  create_symlinks = 128,\n  create_hard_links = 256\n};"
        },
        {
            "title": "std::experimental::filesystem::copy_symlink",
            "path": "en.cppreference.com/w/cpp/experimental/fs/copy_symlink.html",
            "wgPageName": "cpp/experimental/fs/copy_symlink",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "void copy_symlink(\n    const path& from,\n    const path& to);",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::copy",
            "path": "en.cppreference.com/w/cpp/experimental/fs/copy.html",
            "wgPageName": "cpp/experimental/fs/copy",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "void copy(const path& from, const path& to);\nvoid copy(\n    const path& from,\n    const path& to,\n    error_code& ec);",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::create_directory, std::experimental::filesystem::create_directories",
            "path": "en.cppreference.com/w/cpp/experimental/fs/create_directory.html",
            "wgPageName": "cpp/experimental/fs/create_directory",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "bool create_directory(const path& p);\nbool create_directory(\n    const path& p,\n    error_code& ec);",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::filesystem::create_hard_link",
            "path": "en.cppreference.com/w/cpp/experimental/fs/create_hard_link.html",
            "wgPageName": "cpp/experimental/fs/create_hard_link",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "void create_hard_link(\n    const path& target,\n    const path& link);\nvoid create_hard_link(\n    const path& target,\n    const path& link,\n    error_code& ec);"
        },
        {
            "title": "std::experimental::filesystem::create_symlink, std::experimental::filesystem::create_directory_symlink",
            "path": "en.cppreference.com/w/cpp/experimental/fs/create_symlink.html",
            "wgPageName": "cpp/experimental/fs/create_symlink",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "void create_symlink(\n    const path& target,\n    const path& link);\nvoid create_symlink(\n    const path& target,\n    const path& link,\n    error_code& ec);",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::current_path",
            "path": "en.cppreference.com/w/cpp/experimental/fs/current_path.html",
            "wgPageName": "cpp/experimental/fs/current_path",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "path current_path();",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::filesystem::directory_entry",
            "path": "en.cppreference.com/w/cpp/experimental/fs/directory_entry.html",
            "wgPageName": "cpp/experimental/fs/directory_entry",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "class directory_entry;"
        },
        {
            "title": "std::experimental::filesystem::directory_entry::assign",
            "path": "en.cppreference.com/w/cpp/experimental/fs/directory_entry/assign.html",
            "wgPageName": "cpp/experimental/fs/directory_entry/assign",
            "sample_declaration": "void assign(const path& p);"
        },
        {
            "title": "std::experimental::filesystem::directory_entry::directory_entry",
            "path": "en.cppreference.com/w/cpp/experimental/fs/directory_entry/directory_entry.html",
            "wgPageName": "cpp/experimental/fs/directory_entry/directory_entry",
            "sample_declaration": "directory_entry() = default;",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::filesystem::directory_entry::operator==,!=,<,<=,>,>=",
            "path": "en.cppreference.com/w/cpp/experimental/fs/directory_entry/operator_cmp.html",
            "wgPageName": "cpp/experimental/fs/directory_entry/operator_cmp",
            "sample_declaration": "bool operator==(\n    const directory_entry& rhs) const;",
            "other_declarations": 5
        },
        {
            "title": "std::experimental::filesystem::directory_entry::operator=",
            "path": "en.cppreference.com/w/cpp/experimental/fs/directory_entry/operator=.html",
            "wgPageName": "cpp/experimental/fs/directory_entry/operator=",
            "sample_declaration": "directory_entry& operator=(\n    const directory_entry&) = default;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::directory_entry::path",
            "path": "en.cppreference.com/w/cpp/experimental/fs/directory_entry/path.html",
            "wgPageName": "cpp/experimental/fs/directory_entry/path",
            "sample_declaration": "const path& path() const;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::directory_entry::replace_filename",
            "path": "en.cppreference.com/w/cpp/experimental/fs/directory_entry/replace_filename.html",
            "wgPageName": "cpp/experimental/fs/directory_entry/replace_filename",
            "sample_declaration": "void replace_filename(const path& p);"
        },
        {
            "title": "std::experimental::filesystem::directory_entry::status, std::experimental::filesystem::directory_entry::symlink_status",
            "path": "en.cppreference.com/w/cpp/experimental/fs/directory_entry/status.html",
            "wgPageName": "cpp/experimental/fs/directory_entry/status",
            "sample_declaration": "file_status status() const;\nfile_status status(error_code& ec) const;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::directory_iterator",
            "path": "en.cppreference.com/w/cpp/experimental/fs/directory_iterator.html",
            "wgPageName": "cpp/experimental/fs/directory_iterator",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "class directory_iterator;"
        },
        {
            "title": "std::experimental::filesystem::begin(directory_iterator), std::experimental::filesystem::end(directory_iterator)",
            "path": "en.cppreference.com/w/cpp/experimental/fs/directory_iterator/begin.html",
            "wgPageName": "cpp/experimental/fs/directory_iterator/begin",
            "sample_declaration": "directory_iterator begin(\n    directory_iterator iter);",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::directory_iterator::directory_iterator",
            "path": "en.cppreference.com/w/cpp/experimental/fs/directory_iterator/directory_iterator.html",
            "wgPageName": "cpp/experimental/fs/directory_iterator/directory_iterator",
            "sample_declaration": "directory_iterator();",
            "other_declarations": 4
        },
        {
            "title": "std::experimental::filesystem::directory_iterator::operator=",
            "path": "en.cppreference.com/w/cpp/experimental/fs/directory_iterator/increment.html",
            "wgPageName": "cpp/experimental/fs/directory_iterator/increment",
            "sample_declaration": "directory_iterator& operator++();\ndirectory_iterator& increment(\n    error_code& ec) noexcept;"
        },
        {
            "title": "std::experimental::filesystem::directory_iterator::operator*,operator->",
            "path": "en.cppreference.com/w/cpp/experimental/fs/directory_iterator/operator*.html",
            "wgPageName": "cpp/experimental/fs/directory_iterator/operator*",
            "sample_declaration": "const directory_entry& operator*() const;\nconst directory_entry* operator->() const;"
        },
        {
            "title": "std::experimental::filesystem::directory_iterator::operator=",
            "path": "en.cppreference.com/w/cpp/experimental/fs/directory_iterator/operator=.html",
            "wgPageName": "cpp/experimental/fs/directory_iterator/operator=",
            "sample_declaration": "directory_iterator& operator=(\n    const directory_iterator&) = default;\ndirectory_iterator& operator=(\n    directory_iterator&&) = default;"
        },
        {
            "title": "std::experimental::filesystem::directory_options",
            "path": "en.cppreference.com/w/cpp/experimental/fs/directory_options.html",
            "wgPageName": "cpp/experimental/fs/directory_options",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "enum class directory_options {\n  none,\n  follow_directory_symlink,\n  skip_permission_denied\n};"
        },
        {
            "title": "std::experimental::filesystem::equivalent",
            "path": "en.cppreference.com/w/cpp/experimental/fs/equivalent.html",
            "wgPageName": "cpp/experimental/fs/equivalent",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "bool equivalent(const path& p1, const path& p2);\nbool equivalent(\n    const path& p1,\n    const path& p2,\n    error_code& ec);"
        },
        {
            "title": "std::experimental::filesystem::exists",
            "path": "en.cppreference.com/w/cpp/experimental/fs/exists.html",
            "wgPageName": "cpp/experimental/fs/exists",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "bool exists(file_status s)",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::file_size",
            "path": "en.cppreference.com/w/cpp/experimental/fs/file_size.html",
            "wgPageName": "cpp/experimental/fs/file_size",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "std::uintmax_t file_size(const path& p);\nstd::uintmax_t file_size(\n    const path& p,\n    error_code& ec);"
        },
        {
            "title": "std::experimental::filesystem::file_status",
            "path": "en.cppreference.com/w/cpp/experimental/fs/file_status.html",
            "wgPageName": "cpp/experimental/fs/file_status",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "class file_status;"
        },
        {
            "title": "std::experimental::filesystem::file_status::file_status",
            "path": "en.cppreference.com/w/cpp/experimental/fs/file_status/file_status.html",
            "wgPageName": "cpp/experimental/fs/file_status/file_status",
            "sample_declaration": "file_status(const file_status&) = default;",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::filesystem::file_status::operator=",
            "path": "en.cppreference.com/w/cpp/experimental/fs/file_status/operator=.html",
            "wgPageName": "cpp/experimental/fs/file_status/operator=",
            "sample_declaration": "file_status& operator=(\n    const file_status& other) = default;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::file_status::permissions",
            "path": "en.cppreference.com/w/cpp/experimental/fs/file_status/permissions.html",
            "wgPageName": "cpp/experimental/fs/file_status/permissions",
            "sample_declaration": "perms permissions() const;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::file_status::type",
            "path": "en.cppreference.com/w/cpp/experimental/fs/file_status/type.html",
            "wgPageName": "cpp/experimental/fs/file_status/type",
            "sample_declaration": "file_type type() const;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::file_time_type",
            "path": "en.cppreference.com/w/cpp/experimental/fs/file_time_type.html",
            "wgPageName": "cpp/experimental/fs/file_time_type",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "using file_time_type =\n    chrono::time_point</*trivial-clock*/>;"
        },
        {
            "title": "std::experimental::filesystem::file_type",
            "path": "en.cppreference.com/w/cpp/experimental/fs/file_type.html",
            "wgPageName": "cpp/experimental/fs/file_type",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "enum class file_type {\n  none = 0,\n  not_found = -1,\n  regular = 1,\n  directory = 2,\n  symlink = 3,\n  block = 4,\n  character = 5,\n  fifo = 6,\n  socket = 7,\n  unknown = 8\n};"
        },
        {
            "title": "std::experimental::filesystem::filesystem_error",
            "path": "en.cppreference.com/w/cpp/experimental/fs/filesystem_error.html",
            "wgPageName": "cpp/experimental/fs/filesystem_error",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "class filesystem_error;"
        },
        {
            "title": "std::experimental::filesystem::filesystem_error::filesystem_error",
            "path": "en.cppreference.com/w/cpp/experimental/fs/filesystem_error/filesystem_error.html",
            "wgPageName": "cpp/experimental/fs/filesystem_error/filesystem_error",
            "sample_declaration": "filesystem_error(\n    const string& what_arg,\n    error_code ec);",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::filesystem::filesystem_error::path1,path2",
            "path": "en.cppreference.com/w/cpp/experimental/fs/filesystem_error/path.html",
            "wgPageName": "cpp/experimental/fs/filesystem_error/path",
            "sample_declaration": "const path& path1() const;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::filesystem_error::what",
            "path": "en.cppreference.com/w/cpp/experimental/fs/filesystem_error/what.html",
            "wgPageName": "cpp/experimental/fs/filesystem_error/what",
            "sample_declaration": "const char* what() const;"
        },
        {
            "title": "std::experimental::filesystem::hard_link_count",
            "path": "en.cppreference.com/w/cpp/experimental/fs/hard_link_count.html",
            "wgPageName": "cpp/experimental/fs/hard_link_count",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "std::uintmax_t hard_link_count(const path& p);\nstd::uintmax_t hard_link_count(\n    const path& p,\n    error_code& ec);"
        },
        {
            "title": "std::experimental::filesystem::is_block_file",
            "path": "en.cppreference.com/w/cpp/experimental/fs/is_block_file.html",
            "wgPageName": "cpp/experimental/fs/is_block_file",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "bool is_block_file(file_status s);",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::is_character_file",
            "path": "en.cppreference.com/w/cpp/experimental/fs/is_character_file.html",
            "wgPageName": "cpp/experimental/fs/is_character_file",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "bool is_character_file(file_status s);",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::is_directory",
            "path": "en.cppreference.com/w/cpp/experimental/fs/is_directory.html",
            "wgPageName": "cpp/experimental/fs/is_directory",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "bool is_directory(file_status s);",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::filesystem::is_empty",
            "path": "en.cppreference.com/w/cpp/experimental/fs/is_empty.html",
            "wgPageName": "cpp/experimental/fs/is_empty",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "bool is_empty(const path& p);",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::is_fifo",
            "path": "en.cppreference.com/w/cpp/experimental/fs/is_fifo.html",
            "wgPageName": "cpp/experimental/fs/is_fifo",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "bool is_fifo(file_status s);",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::filesystem::is_other",
            "path": "en.cppreference.com/w/cpp/experimental/fs/is_other.html",
            "wgPageName": "cpp/experimental/fs/is_other",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "bool is_other(file_status s);",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::filesystem::is_regular_file",
            "path": "en.cppreference.com/w/cpp/experimental/fs/is_regular_file.html",
            "wgPageName": "cpp/experimental/fs/is_regular_file",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "bool is_regular_file(file_status s);",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::filesystem::is_socket",
            "path": "en.cppreference.com/w/cpp/experimental/fs/is_socket.html",
            "wgPageName": "cpp/experimental/fs/is_socket",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "bool is_socket(file_status s);",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::is_symlink",
            "path": "en.cppreference.com/w/cpp/experimental/fs/is_symlink.html",
            "wgPageName": "cpp/experimental/fs/is_symlink",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "bool is_symlink(file_status s);",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::last_write_time",
            "path": "en.cppreference.com/w/cpp/experimental/fs/last_write_time.html",
            "wgPageName": "cpp/experimental/fs/last_write_time",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "file_time_type last_write_time(const path& p);\nfile_time_type last_write_time(\n    const path& p,\n    error_code& ec)",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::path",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path.html",
            "wgPageName": "cpp/experimental/fs/path",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "class path;"
        },
        {
            "title": "std::experimental::filesystem::path::~path",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/~path.html",
            "wgPageName": "cpp/experimental/fs/path/~path",
            "sample_declaration": "~path();"
        },
        {
            "title": "std::experimental::filesystem::path::append, std::experimental::filesystem::path::operator/=",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/append.html",
            "wgPageName": "cpp/experimental/fs/path/append",
            "sample_declaration": "path& operator/=(const path& p);",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::filesystem::path::assign",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/assign.html",
            "wgPageName": "cpp/experimental/fs/path/assign",
            "sample_declaration": "template<class Source>\npath& assign(const Source& source);",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::path::begin, std::experimental::filesystem::path::end",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/begin.html",
            "wgPageName": "cpp/experimental/fs/path/begin",
            "sample_declaration": "iterator begin() const;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::path::clear",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/clear.html",
            "wgPageName": "cpp/experimental/fs/path/clear",
            "sample_declaration": "void clear();"
        },
        {
            "title": "std::experimental::filesystem::path::compare",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/compare.html",
            "wgPageName": "cpp/experimental/fs/path/compare",
            "sample_declaration": "int compare(const path& p) const noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::filesystem::path::concat, std::experimental::filesystem::path::operator+=",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/concat.html",
            "wgPageName": "cpp/experimental/fs/path/concat",
            "sample_declaration": "path& operator+=(const path& p);",
            "other_declarations": 7
        },
        {
            "title": "std::experimental::filesystem::path::empty",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/empty.html",
            "wgPageName": "cpp/experimental/fs/path/empty",
            "sample_declaration": "bool empty() const;"
        },
        {
            "title": "std::experimental::filesystem::path::extension",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/extension.html",
            "wgPageName": "cpp/experimental/fs/path/extension",
            "sample_declaration": "path extension() const;"
        },
        {
            "title": "std::experimental::filesystem::path::filename",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/filename.html",
            "wgPageName": "cpp/experimental/fs/path/filename",
            "sample_declaration": "path filename() const;"
        },
        {
            "title": "std::experimental::filesystem::path::generic_string,generic_wstring,generic_u8string,...",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/generic_string.html",
            "wgPageName": "cpp/experimental/fs/path/generic_string",
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT>,\n    class Alloc = std::allocator<CharT> >\nstd::basic_string<CharT, Traits, Alloc>\ngeneric_string(const Alloc& a = Alloc()) const;",
            "other_declarations": 5
        },
        {
            "title": "std::experimental::filesystem::path::has_...",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/has_path.html",
            "wgPageName": "cpp/experimental/fs/path/has_path",
            "sample_declaration": "bool has_root_path() const;",
            "other_declarations": 7
        },
        {
            "title": "std::experimental::filesystem::path::is_absolute,is_relative",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/is_absrel.html",
            "wgPageName": "cpp/experimental/fs/path/is_absrel",
            "sample_declaration": "bool is_absolute() const;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::path::make_preferred",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/make_preferred.html",
            "wgPageName": "cpp/experimental/fs/path/make_preferred",
            "sample_declaration": "path& make_preferred()"
        },
        {
            "title": "std::experimental::filesystem::path::c_str, std::experimental::filesystem::path::native, std::experimental::filesystem::path::operator string_type()",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/native.html",
            "wgPageName": "cpp/experimental/fs/path/native",
            "sample_declaration": "const value_type* c_str() const;",
            "other_declarations": 2
        },
        {
            "title": "operator==,!=,<,<=,>,>=(std::experimental::filesystem::path)",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/operator_cmp.html",
            "wgPageName": "cpp/experimental/fs/path/operator_cmp",
            "sample_declaration": "bool operator==(\n    const path& lhs,\n    const path& rhs);",
            "other_declarations": 5
        },
        {
            "title": "operator<<,>>(std::experimental::filesystem::path)",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/operator_ltltgtgt.html",
            "wgPageName": "cpp/experimental/fs/path/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const path& p);",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::operator/(std::experimental::filesystem::path)",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/operator_slash.html",
            "wgPageName": "cpp/experimental/fs/path/operator_slash",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "path operator/(\n    const path& lhs,\n    const path& rhs);"
        },
        {
            "title": "std::experimental::filesystem::path::operator=",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/operator=.html",
            "wgPageName": "cpp/experimental/fs/path/operator=",
            "sample_declaration": "path& operator=(const path& p);",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::filesystem::path::parent_path",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/parent_path.html",
            "wgPageName": "cpp/experimental/fs/path/parent_path",
            "sample_declaration": "path parent_path() const;"
        },
        {
            "title": "std::experimental::filesystem::path::path",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/path.html",
            "wgPageName": "cpp/experimental/fs/path/path",
            "sample_declaration": "path();",
            "other_declarations": 6
        },
        {
            "title": "std::experimental::filesystem::path::relative_path",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/relative_path.html",
            "wgPageName": "cpp/experimental/fs/path/relative_path",
            "sample_declaration": "path relative_path() const;"
        },
        {
            "title": "std::experimental::filesystem::path::remove_filename",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/remove_filename.html",
            "wgPageName": "cpp/experimental/fs/path/remove_filename",
            "sample_declaration": "path& remove_filename()"
        },
        {
            "title": "std::experimental::filesystem::path::replace_extension",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/replace_extension.html",
            "wgPageName": "cpp/experimental/fs/path/replace_extension",
            "sample_declaration": "path& replace_extension(\n    const path& replacement = path());"
        },
        {
            "title": "std::experimental::filesystem::path::replace_filename",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/replace_filename.html",
            "wgPageName": "cpp/experimental/fs/path/replace_filename",
            "sample_declaration": "path& replace_filename(const path& replacement);"
        },
        {
            "title": "std::experimental::filesystem::path::root_directory",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/root_directory.html",
            "wgPageName": "cpp/experimental/fs/path/root_directory",
            "sample_declaration": "path root_directory() const;"
        },
        {
            "title": "std::experimental::filesystem::path::root_name",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/root_name.html",
            "wgPageName": "cpp/experimental/fs/path/root_name",
            "sample_declaration": "path root_name() const;"
        },
        {
            "title": "std::experimental::filesystem::path::root_path",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/root_path.html",
            "wgPageName": "cpp/experimental/fs/path/root_path",
            "sample_declaration": "path root_path() const;"
        },
        {
            "title": "std::experimental::filesystem::path::stem",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/stem.html",
            "wgPageName": "cpp/experimental/fs/path/stem",
            "sample_declaration": "path stem() const;"
        },
        {
            "title": "std::experimental::filesystem::path::string,wstring,u8string,...",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/string.html",
            "wgPageName": "cpp/experimental/fs/path/string",
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT>,\n    class Alloc = std::allocator<CharT> >\nstd::basic_string<CharT, Traits, Alloc> string(\n    const Alloc& a = Alloc()) const;",
            "other_declarations": 5
        },
        {
            "title": "std::experimental::filesystem::path::swap",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/swap.html",
            "wgPageName": "cpp/experimental/fs/path/swap",
            "sample_declaration": "void swap(path& other);"
        },
        {
            "title": "std::experimental::filesystem::swap(std::experimental::filesystem::path)",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/swap2.html",
            "wgPageName": "cpp/experimental/fs/path/swap2",
            "sample_declaration": "void swap(path& lhs, path& rhs);"
        },
        {
            "title": "std::experimental::filesystem::u8path",
            "path": "en.cppreference.com/w/cpp/experimental/fs/path/u8path.html",
            "wgPageName": "cpp/experimental/fs/path/u8path",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "template<class Source>\npath u8path(const Source& source);",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::permissions",
            "path": "en.cppreference.com/w/cpp/experimental/fs/permissions.html",
            "wgPageName": "cpp/experimental/fs/permissions",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "void permissions(const path& p, perms prms);\nvoid permissions(\n    const path& p,\n    perms prms,\n    error_code& ec);"
        },
        {
            "title": "std::experimental::filesystem::perms",
            "path": "en.cppreference.com/w/cpp/experimental/fs/perms.html",
            "wgPageName": "cpp/experimental/fs/perms",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "enum class perms;"
        },
        {
            "title": "std::experimental::filesystem::read_symlink",
            "path": "en.cppreference.com/w/cpp/experimental/fs/read_symlink.html",
            "wgPageName": "cpp/experimental/fs/read_symlink",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "path read_symlink(const path& p);\npath read_symlink(\n    const path& p,\n    error_code& ec);"
        },
        {
            "title": "std::experimental::filesystem::recursive_directory_iterator",
            "path": "en.cppreference.com/w/cpp/experimental/fs/recursive_directory_iterator.html",
            "wgPageName": "cpp/experimental/fs/recursive_directory_iterator",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "class recursive_directory_iterator;"
        },
        {
            "title": "std::experimental::filesystem::begin(recursive_directory_iterator), std::experimental::filesystem::end(recursive_directory_iterator)",
            "path": "en.cppreference.com/w/cpp/experimental/fs/recursive_directory_iterator/begin.html",
            "wgPageName": "cpp/experimental/fs/recursive_directory_iterator/begin",
            "sample_declaration": "recursive_directory_iterator begin(\n    recursive_directory_iterator iter);",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::recursive_directory_iterator::depth",
            "path": "en.cppreference.com/w/cpp/experimental/fs/recursive_directory_iterator/depth.html",
            "wgPageName": "cpp/experimental/fs/recursive_directory_iterator/depth",
            "sample_declaration": "int depth() const;"
        },
        {
            "title": "std::experimental::filesystem::recursive_directory_iterator::disable_recursion_pending",
            "path": "en.cppreference.com/w/cpp/experimental/fs/recursive_directory_iterator/disable_recursion_pending.html",
            "wgPageName": "cpp/experimental/fs/recursive_directory_iterator/disable_recursion_pending",
            "sample_declaration": "void disable_recursion_pending();"
        },
        {
            "title": "std::experimental::filesystem::recursive_directory_iterator::operator++, increment",
            "path": "en.cppreference.com/w/cpp/experimental/fs/recursive_directory_iterator/increment.html",
            "wgPageName": "cpp/experimental/fs/recursive_directory_iterator/increment",
            "sample_declaration": "recursive_directory_iterator& operator++();",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::recursive_directory_iterator::operator*, std::experimental::filesystem::recursive_directory_iterator::operator->",
            "path": "en.cppreference.com/w/cpp/experimental/fs/recursive_directory_iterator/operator*.html",
            "wgPageName": "cpp/experimental/fs/recursive_directory_iterator/operator*",
            "sample_declaration": "const directory_entry& operator*() const;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::recursive_directory_iterator::operator=",
            "path": "en.cppreference.com/w/cpp/experimental/fs/recursive_directory_iterator/operator=.html",
            "wgPageName": "cpp/experimental/fs/recursive_directory_iterator/operator=",
            "sample_declaration": "recursive_directory_iterator& operator=(\n    const recursive_directory_iterator&) =\n    default;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::recursive_directory_iterator::options",
            "path": "en.cppreference.com/w/cpp/experimental/fs/recursive_directory_iterator/options.html",
            "wgPageName": "cpp/experimental/fs/recursive_directory_iterator/options",
            "sample_declaration": "directory_options options() const;"
        },
        {
            "title": "std::experimental::filesystem::recursive_directory_iterator::pop",
            "path": "en.cppreference.com/w/cpp/experimental/fs/recursive_directory_iterator/pop.html",
            "wgPageName": "cpp/experimental/fs/recursive_directory_iterator/pop",
            "sample_declaration": "void pop();"
        },
        {
            "title": "std::experimental::filesystem::recursive_directory_iterator::recursion_pending",
            "path": "en.cppreference.com/w/cpp/experimental/fs/recursive_directory_iterator/recursion_pending.html",
            "wgPageName": "cpp/experimental/fs/recursive_directory_iterator/recursion_pending",
            "sample_declaration": "bool recursion_pending() const;"
        },
        {
            "title": "std::experimental::filesystem::recursive_directory_iterator::recursive_directory_iterator",
            "path": "en.cppreference.com/w/cpp/experimental/fs/recursive_directory_iterator/recursive_directory_iterator.html",
            "wgPageName": "cpp/experimental/fs/recursive_directory_iterator/recursive_directory_iterator",
            "sample_declaration": "recursive_directory_iterator();",
            "other_declarations": 5
        },
        {
            "title": "std::experimental::filesystem::remove, std::experimental::filesystem::remove_all",
            "path": "en.cppreference.com/w/cpp/experimental/fs/remove.html",
            "wgPageName": "cpp/experimental/fs/remove",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "bool remove(const path& p);\nbool remove(const path& p, error_code& ec);",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::rename",
            "path": "en.cppreference.com/w/cpp/experimental/fs/rename.html",
            "wgPageName": "cpp/experimental/fs/rename",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "void rename(\n    const path& old_p,\n    const path& new_p);\nvoid rename(\n    const path& old_p,\n    const path& new_p,\n    std::error_code& ec);"
        },
        {
            "title": "std::experimental::filesystem::resize_file",
            "path": "en.cppreference.com/w/cpp/experimental/fs/resize_file.html",
            "wgPageName": "cpp/experimental/fs/resize_file",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "void resize_file(\n    const path& p,\n    std::uintmax_t new_size);\nvoid resize_file(\n    const path& p,\n    std::uintmax_t new_size,\n    error_code& ec);"
        },
        {
            "title": "std::experimental::filesystem::space_info",
            "path": "en.cppreference.com/w/cpp/experimental/fs/space_info.html",
            "wgPageName": "cpp/experimental/fs/space_info",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "struct space_info {\n  uintmax_t capacity;\n  uintmax_t free;\n  uintmax_t available;\n};"
        },
        {
            "title": "std::experimental::filesystem::space",
            "path": "en.cppreference.com/w/cpp/experimental/fs/space.html",
            "wgPageName": "cpp/experimental/fs/space",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "space_info space(const path& p);\nspace_info space(\n    const path& p,\n    error_code& ec) noexcept;"
        },
        {
            "title": "std::experimental::filesystem::status_known",
            "path": "en.cppreference.com/w/cpp/experimental/fs/status_known.html",
            "wgPageName": "cpp/experimental/fs/status_known",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "bool status_known(file_status s);"
        },
        {
            "title": "std::experimental::filesystem::status, std::experimental::filesystem::symlink_status",
            "path": "en.cppreference.com/w/cpp/experimental/fs/status.html",
            "wgPageName": "cpp/experimental/fs/status",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "file_status status(const path& p);\nfile_status status(\n    const path& p,\n    error_code& ec) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::filesystem::temp_directory_path",
            "path": "en.cppreference.com/w/cpp/experimental/fs/temp_directory_path.html",
            "wgPageName": "cpp/experimental/fs/temp_directory_path",
            "headers": [
                "<experimental/filesystem>"
            ],
            "sample_declaration": "path temp_directory_path();\npath temp_directory_path(error_code& ec);"
        },
        {
            "title": "std::experimental::function",
            "path": "en.cppreference.com/w/cpp/experimental/function.html",
            "wgPageName": "cpp/experimental/function",
            "headers": [
                "<experimental/functional>"
            ],
            "sample_declaration": "template<class>\nclass function; /* undefined */",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::function<R(Args...)>::function",
            "path": "en.cppreference.com/w/cpp/experimental/function/function.html",
            "wgPageName": "cpp/experimental/function/function",
            "sample_declaration": "function() noexcept;",
            "other_declarations": 9
        },
        {
            "title": "std::experimental::function<R(Args...)>::get_memory_resource",
            "path": "en.cppreference.com/w/cpp/experimental/function/get_memory_resource.html",
            "wgPageName": "cpp/experimental/function/get_memory_resource",
            "sample_declaration": "std::experimental::pmr::memory_resource*\nget_memory_resource() const noexcept;"
        },
        {
            "title": "operator==,!=(std::experimental::function)",
            "path": "en.cppreference.com/w/cpp/experimental/function/operator_cmp.html",
            "wgPageName": "cpp/experimental/function/operator_cmp",
            "sample_declaration": "template<class R, class... ArgTypes>\nbool operator==(\n    const std::experimental::function<\n        R(ArgTypes...)>& f,\n    std::nullptr_t) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::function<R(Args...)>::operator=",
            "path": "en.cppreference.com/w/cpp/experimental/function/operator=.html",
            "wgPageName": "cpp/experimental/function/operator=",
            "sample_declaration": "function& operator=(const function& other);",
            "other_declarations": 4
        },
        {
            "title": "std::experimental::function<R(Args...)>::swap",
            "path": "en.cppreference.com/w/cpp/experimental/function/swap.html",
            "wgPageName": "cpp/experimental/function/swap",
            "sample_declaration": "void swap(function& other);"
        },
        {
            "title": "std::experimental::swap(std::experimental::function)",
            "path": "en.cppreference.com/w/cpp/experimental/function/swap2.html",
            "wgPageName": "cpp/experimental/function/swap2",
            "sample_declaration": "template<class R, class... Args>\nvoid swap(\n    std::experimental::function<R(Args...)>&\n        lhs,\n    std::experimental::function<R(Args...)>&\n        rhs);"
        },
        {
            "title": "std::uses_allocator<std::experimental::function>",
            "path": "en.cppreference.com/w/cpp/experimental/function/uses_allocator.html",
            "wgPageName": "cpp/experimental/function/uses_allocator",
            "headers": [
                "<experimental/functional>"
            ],
            "sample_declaration": "template<\n    class R,\n    class... ArgTypes,\n    class Alloc>\nstruct uses_allocator<\n    std::experimental::function<R(ArgTypes...)>,\n    Alloc> : std::true_type {};"
        },
        {
            "title": "std::experimental::future",
            "path": "en.cppreference.com/w/cpp/experimental/future.html",
            "wgPageName": "cpp/experimental/future",
            "headers": [
                "<experimental/future>"
            ],
            "sample_declaration": "template<class T>\nclass future;",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::future<T>::future",
            "path": "en.cppreference.com/w/cpp/experimental/future/future.html",
            "wgPageName": "cpp/experimental/future/future",
            "sample_declaration": "future() noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::future<T>::is_ready",
            "path": "en.cppreference.com/w/cpp/experimental/future/is_ready.html",
            "wgPageName": "cpp/experimental/future/is_ready",
            "sample_declaration": "bool is_ready() const;"
        },
        {
            "title": "std::experimental::future<T>::operator=",
            "path": "en.cppreference.com/w/cpp/experimental/future/operator=.html",
            "wgPageName": "cpp/experimental/future/operator=",
            "sample_declaration": "std::experimental::future<T>& operator=(\n    std::experimental::future<T>&&\n        other) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::future<T>::then",
            "path": "en.cppreference.com/w/cpp/experimental/future/then.html",
            "wgPageName": "cpp/experimental/future/then",
            "sample_declaration": "template<class F>\nfuture</* see below */> then(F&& func);"
        },
        {
            "title": "std::experimental::gcd",
            "path": "en.cppreference.com/w/cpp/experimental/gcd.html",
            "wgPageName": "cpp/experimental/gcd",
            "headers": [
                "<experimental/numeric>"
            ],
            "sample_declaration": "template<class M, class N>\nconstexpr std::common_type_t<M, N> gcd(\n    M m,\n    N n);"
        },
        {
            "title": "std::experimental::pmr::get_default_resource",
            "path": "en.cppreference.com/w/cpp/experimental/get_default_resource.html",
            "wgPageName": "cpp/experimental/get_default_resource",
            "headers": [
                "<experimental/memory_resource>"
            ],
            "sample_declaration": "memory_resource*\nget_default_resource() noexcept;"
        },
        {
            "title": "std::experimental::invocation_type, std::experimental::raw_invocation_type",
            "path": "en.cppreference.com/w/cpp/experimental/invocation_type.html",
            "wgPageName": "cpp/experimental/invocation_type",
            "headers": [
                "<experimental/type_traits>"
            ],
            "sample_declaration": "template<class>\nstruct\n    raw_invocation_type;  // undefined\n                          // template<class Fn,\n                          // class... ArgTypes>\n                          // struct\n                          // raw_invocation_type<Fn(ArgTypes...)>;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::is_detected, std::experimental::detected_t, std::experimental::detected_or",
            "path": "en.cppreference.com/w/cpp/experimental/is_detected.html",
            "wgPageName": "cpp/experimental/is_detected",
            "headers": [
                "<experimental/type_traits>"
            ],
            "sample_declaration": "template<\n    template<class...>\n    class Op,\n    class... Args>\nusing is_detected = /* see below */;",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::parallel::is_execution_policy",
            "path": "en.cppreference.com/w/cpp/experimental/is_execution_policy.html",
            "wgPageName": "cpp/experimental/is_execution_policy",
            "headers": [
                "<experimental/execution_policy>"
            ],
            "sample_declaration": "template<class T>\nstruct is_execution_policy;"
        },
        {
            "title": "std::experimental::latch",
            "path": "en.cppreference.com/w/cpp/experimental/latch.html",
            "wgPageName": "cpp/experimental/latch",
            "headers": [
                "<experimental/latch>"
            ],
            "sample_declaration": "class latch;"
        },
        {
            "title": "std::experimental::latch::~latch",
            "path": "en.cppreference.com/w/cpp/experimental/latch/~latch.html",
            "wgPageName": "cpp/experimental/latch/~latch",
            "sample_declaration": "~latch();"
        },
        {
            "title": "std::experimental::latch::count_down_and_wait",
            "path": "en.cppreference.com/w/cpp/experimental/latch/count_down_and_wait.html",
            "wgPageName": "cpp/experimental/latch/count_down_and_wait",
            "sample_declaration": "void count_down_and_wait();"
        },
        {
            "title": "std::experimental::latch::count_down",
            "path": "en.cppreference.com/w/cpp/experimental/latch/count_down.html",
            "wgPageName": "cpp/experimental/latch/count_down",
            "sample_declaration": "void count_down(ptrdiff_t n = 1);"
        },
        {
            "title": "std::experimental::latch::is_ready",
            "path": "en.cppreference.com/w/cpp/experimental/latch/is_ready.html",
            "wgPageName": "cpp/experimental/latch/is_ready",
            "sample_declaration": "bool is_ready() const noexcept;"
        },
        {
            "title": "std::experimental::latch::latch",
            "path": "en.cppreference.com/w/cpp/experimental/latch/latch.html",
            "wgPageName": "cpp/experimental/latch/latch",
            "sample_declaration": "explicit latch(ptrdiff_t value);",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::latch::wait",
            "path": "en.cppreference.com/w/cpp/experimental/latch/wait.html",
            "wgPageName": "cpp/experimental/latch/wait",
            "sample_declaration": "void wait() const;"
        },
        {
            "title": "std::experimental::lcm",
            "path": "en.cppreference.com/w/cpp/experimental/lcm.html",
            "wgPageName": "cpp/experimental/lcm",
            "headers": [
                "<experimental/numeric>"
            ],
            "sample_declaration": "template<class M, class N>\nconstexpr std::common_type_t<M, N> lcm(\n    M m,\n    N n);"
        },
        {
            "title": "C++ standard libraries extensions, version 2",
            "path": "en.cppreference.com/w/cpp/experimental/lib_extensions_2.html",
            "wgPageName": "cpp/experimental/lib_extensions_2"
        },
        {
            "title": "C++ standard libraries extensions, version 3",
            "path": "en.cppreference.com/w/cpp/experimental/lib_extensions_3.html",
            "wgPageName": "cpp/experimental/lib_extensions_3"
        },
        {
            "title": "C++ standard libraries extensions",
            "path": "en.cppreference.com/w/cpp/experimental/lib_extensions.html",
            "wgPageName": "cpp/experimental/lib_extensions"
        },
        {
            "title": "std::experimental::packaged_task (library fundamentals TS)",
            "path": "en.cppreference.com/w/cpp/experimental/lib_extensions/packaged_task.html",
            "wgPageName": "cpp/experimental/lib_extensions/packaged_task",
            "headers": [
                "<experimental/future>"
            ],
            "sample_declaration": "template<class>\nclass packaged_task;  // not defined",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::packaged_task<R(Args...)>::get_memory_resource",
            "path": "en.cppreference.com/w/cpp/experimental/lib_extensions/packaged_task/get_memory_resource.html",
            "wgPageName": "cpp/experimental/lib_extensions/packaged_task/get_memory_resource",
            "sample_declaration": "std::experimental::pmr::memory_resource*\nget_memory_resource() const noexcept;"
        },
        {
            "title": "std::experimental::packaged_task<R(Args...)>::packaged_task (library fundamentals TS)",
            "path": "en.cppreference.com/w/cpp/experimental/lib_extensions/packaged_task/packaged_task.html",
            "wgPageName": "cpp/experimental/lib_extensions/packaged_task/packaged_task",
            "sample_declaration": "packaged_task() noexcept;",
            "other_declarations": 4
        },
        {
            "title": "std::experimental::swap(std::experimental::packaged_task)",
            "path": "en.cppreference.com/w/cpp/experimental/lib_extensions/packaged_task/swap2.html",
            "wgPageName": "cpp/experimental/lib_extensions/packaged_task/swap2",
            "sample_declaration": "template<class R, class... Args>\nvoid swap(\n    std::experimental::packaged_task<\n        R(Args...)>& lhs,\n    std::experimental::packaged_task<\n        R(Args...)>& rhs) noexcept;"
        },
        {
            "title": "std::uses_allocator<std::experimental::packaged_task>",
            "path": "en.cppreference.com/w/cpp/experimental/lib_extensions/packaged_task/uses_allocator.html",
            "wgPageName": "cpp/experimental/lib_extensions/packaged_task/uses_allocator",
            "headers": [
                "<experimental/future>"
            ],
            "sample_declaration": "template<class R, class Alloc>\nstruct uses_allocator<\n    std::experimental::packaged_task<R>,\n    Alloc> : std::true_type {};"
        },
        {
            "title": "Convenience aliases for containers using polymorphic allocators (library fundamentals TS)",
            "path": "en.cppreference.com/w/cpp/experimental/lib_extensions/pmr_container.html",
            "wgPageName": "cpp/experimental/lib_extensions/pmr_container"
        },
        {
            "title": "std::experimental::promise (library fundamentals TS)",
            "path": "en.cppreference.com/w/cpp/experimental/lib_extensions/promise.html",
            "wgPageName": "cpp/experimental/lib_extensions/promise",
            "headers": [
                "<experimental/future>"
            ],
            "sample_declaration": "template<class R>\nclass promise;",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::promise<R>::get_memory_resource",
            "path": "en.cppreference.com/w/cpp/experimental/lib_extensions/promise/get_memory_resource.html",
            "wgPageName": "cpp/experimental/lib_extensions/promise/get_memory_resource",
            "sample_declaration": "std::experimental::pmr::memory_resource*\nget_memory_resource() const noexcept;"
        },
        {
            "title": "std::experimental::promise<R>::promise (library fundamentals TS)",
            "path": "en.cppreference.com/w/cpp/experimental/lib_extensions/promise/promise.html",
            "wgPageName": "cpp/experimental/lib_extensions/promise/promise",
            "sample_declaration": "promise();",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::swap(std::experimental::promise)",
            "path": "en.cppreference.com/w/cpp/experimental/lib_extensions/promise/swap2.html",
            "wgPageName": "cpp/experimental/lib_extensions/promise/swap2",
            "sample_declaration": "template<class R>\nvoid swap(\n    std::experimental::promise<R>& lhs,\n    std::experimental::promise<R>&\n        rhs) noexcept;"
        },
        {
            "title": "std::uses_allocator<std::experimental::promise>",
            "path": "en.cppreference.com/w/cpp/experimental/lib_extensions/promise/uses_allocator.html",
            "wgPageName": "cpp/experimental/lib_extensions/promise/uses_allocator",
            "headers": [
                "<experimental/future>"
            ],
            "sample_declaration": "template<class R, class Alloc>\nstruct uses_allocator<\n    std::experimental::promise<R>,\n    Alloc> : std::true_type {};"
        },
        {
            "title": "std::experimental::erase_if (std::list)",
            "path": "en.cppreference.com/w/cpp/experimental/list/erase_if.html",
            "wgPageName": "cpp/experimental/list/erase_if",
            "headers": [
                "<experimental/list>"
            ],
            "sample_declaration": "template<class T, class Alloc, class Pred>\nvoid erase_if(\n    std::list<T, Alloc>& c,\n    Pred pred);"
        },
        {
            "title": "std::experimental::erase (std::list)",
            "path": "en.cppreference.com/w/cpp/experimental/list/erase.html",
            "wgPageName": "cpp/experimental/list/erase",
            "headers": [
                "<experimental/list>"
            ],
            "sample_declaration": "template<class T, class A, class U>\nvoid erase(std::list<T, A>& c, const U& value);"
        },
        {
            "title": "std::experimental::make_array",
            "path": "en.cppreference.com/w/cpp/experimental/make_array.html",
            "wgPageName": "cpp/experimental/make_array",
            "headers": [
                "<experimental/array>"
            ],
            "sample_declaration": "template<class D = void, class... Types>\nconstexpr std::\n    array<VT /* see below */, sizeof...(Types)>\n    make_array(Types&&... t);"
        },
        {
            "title": "std::experimental::make_exceptional_future",
            "path": "en.cppreference.com/w/cpp/experimental/make_exceptional_future.html",
            "wgPageName": "cpp/experimental/make_exceptional_future",
            "headers": [
                "<experimental/future>"
            ],
            "sample_declaration": "template<class T>\nfuture<T> make_exceptional_future(\n    std::exception_ptr ex);",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::make_ready_future",
            "path": "en.cppreference.com/w/cpp/experimental/make_ready_future.html",
            "wgPageName": "cpp/experimental/make_ready_future",
            "headers": [
                "<experimental/future>"
            ],
            "sample_declaration": "template<class T>\nfuture<V /* see below */> make_ready_future(\n    T&& value);",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::erase_if (std::map)",
            "path": "en.cppreference.com/w/cpp/experimental/map/erase_if.html",
            "wgPageName": "cpp/experimental/map/erase_if",
            "headers": [
                "<experimental/map>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class T,\n    class Compare,\n    class Alloc,\n    class Pred>\nvoid erase_if(\n    std::map<Key, T, Compare, Alloc>& c,\n    Pred pred);"
        },
        {
            "title": "std::experimental::pmr::memory_resource",
            "path": "en.cppreference.com/w/cpp/experimental/memory_resource.html",
            "wgPageName": "cpp/experimental/memory_resource",
            "headers": [
                "<experimental/memory_resource>"
            ],
            "sample_declaration": "class memory_resource;"
        },
        {
            "title": "std::experimental::pmr::memory_resource::allocate",
            "path": "en.cppreference.com/w/cpp/experimental/memory_resource/allocate.html",
            "wgPageName": "cpp/experimental/memory_resource/allocate",
            "sample_declaration": "void* allocate(\n    std::size_t bytes,\n    std::size_t alignment =\n        alignof(std::max_align_t));"
        },
        {
            "title": "std::experimental::pmr::memory_resource::deallocate",
            "path": "en.cppreference.com/w/cpp/experimental/memory_resource/deallocate.html",
            "wgPageName": "cpp/experimental/memory_resource/deallocate",
            "sample_declaration": "void* deallocate(\n    void* p,\n    std::size_t bytes,\n    std::size_t alignment =\n        alignof(std::max_align_t));"
        },
        {
            "title": "std::experimental::pmr::memory_resource::do_allocate",
            "path": "en.cppreference.com/w/cpp/experimental/memory_resource/do_allocate.html",
            "wgPageName": "cpp/experimental/memory_resource/do_allocate",
            "sample_declaration": "virtual void* do_allocate(\n    std::size_t bytes,\n    std::size_t alignment) = 0;"
        },
        {
            "title": "std::experimental::pmr::memory_resource::do_deallocate",
            "path": "en.cppreference.com/w/cpp/experimental/memory_resource/do_deallocate.html",
            "wgPageName": "cpp/experimental/memory_resource/do_deallocate",
            "sample_declaration": "virtual void* do_deallocate(\n    void* p,\n    std::size_t bytes,\n    std::size_t alignment) = 0;"
        },
        {
            "title": "std::experimental::pmr::memory_resource::do_is_equal",
            "path": "en.cppreference.com/w/cpp/experimental/memory_resource/do_is_equal.html",
            "wgPageName": "cpp/experimental/memory_resource/do_is_equal",
            "sample_declaration": "virtual bool is_equal(\n    const memory_resource& other)\n    const noexcept = 0;"
        },
        {
            "title": "std::experimental::pmr::memory_resource::is_equal",
            "path": "en.cppreference.com/w/cpp/experimental/memory_resource/is_equal.html",
            "wgPageName": "cpp/experimental/memory_resource/is_equal",
            "sample_declaration": "bool is_equal(const memory_resource& other)\n    const noexcept;"
        },
        {
            "title": "std::experimental::pmr::memory_resource::memory_resource",
            "path": "en.cppreference.com/w/cpp/experimental/memory_resource/memory_resource.html",
            "wgPageName": "cpp/experimental/memory_resource/memory_resource",
            "sample_declaration": "memory_resource() = default;",
            "other_declarations": 1
        },
        {
            "title": "operator==, operator!= (std::experimental::pmr::memory_resource)",
            "path": "en.cppreference.com/w/cpp/experimental/memory_resource/operator_eq.html",
            "wgPageName": "cpp/experimental/memory_resource/operator_eq",
            "sample_declaration": "bool operator==(\n    const memory_resource& a,\n    const memory_resource& b) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "C++ standard libraries extensions",
            "path": "en.cppreference.com/w/cpp/experimental/memory.html",
            "wgPageName": "cpp/experimental/lib_extensions"
        },
        {
            "title": "std::experimental::pmr::monotonic_buffer_resource",
            "path": "en.cppreference.com/w/cpp/experimental/monotonic_buffer_resource.html",
            "wgPageName": "cpp/experimental/monotonic_buffer_resource",
            "headers": [
                "<experimental/memory_resource>"
            ],
            "sample_declaration": "class monotonic_buffer_resource\n    : public memory_resource;"
        },
        {
            "title": "std::experimental::pmr::monotonic_buffer_resource::~monotonic_buffer_resource",
            "path": "en.cppreference.com/w/cpp/experimental/monotonic_buffer_resource/~monotonic_buffer_resource.html",
            "wgPageName": "cpp/experimental/monotonic_buffer_resource/~monotonic_buffer_resource",
            "sample_declaration": "virtual ~monotonic_buffer_resource();"
        },
        {
            "title": "std::experimental::pmr::monotonic_buffer_resource::do_allocate",
            "path": "en.cppreference.com/w/cpp/experimental/monotonic_buffer_resource/do_allocate.html",
            "wgPageName": "cpp/experimental/monotonic_buffer_resource/do_allocate",
            "sample_declaration": "virtual void* do_allocate(\n    std::size_t bytes,\n    std::size_t alignment);"
        },
        {
            "title": "std::experimental::pmr::monotonic_buffer_resource::do_deallocate",
            "path": "en.cppreference.com/w/cpp/experimental/monotonic_buffer_resource/do_deallocate.html",
            "wgPageName": "cpp/experimental/monotonic_buffer_resource/do_deallocate",
            "sample_declaration": "virtual void do_deallocate(\n    void* p,\n    std::size_t bytes,\n    std::size_t alignment);"
        },
        {
            "title": "std::experimental::pmr::monotonic_buffer_resource::do_is_equal",
            "path": "en.cppreference.com/w/cpp/experimental/monotonic_buffer_resource/do_is_equal.html",
            "wgPageName": "cpp/experimental/monotonic_buffer_resource/do_is_equal",
            "sample_declaration": "virtual bool do_is_equal(\n    const memory_resource& other)\n    const noexcept;"
        },
        {
            "title": "std::experimental::pmr::monotonic_buffer_resource::monotonic_buffer_resource",
            "path": "en.cppreference.com/w/cpp/experimental/monotonic_buffer_resource/monotonic_buffer_resource.html",
            "wgPageName": "cpp/experimental/monotonic_buffer_resource/monotonic_buffer_resource",
            "sample_declaration": "monotonic_buffer_resource();",
            "other_declarations": 6
        },
        {
            "title": "std::experimental::pmr::monotonic_buffer_resource::release",
            "path": "en.cppreference.com/w/cpp/experimental/monotonic_buffer_resource/release.html",
            "wgPageName": "cpp/experimental/monotonic_buffer_resource/release",
            "sample_declaration": "void release();"
        },
        {
            "title": "std::experimental::pmr::monotonic_buffer_resource::upstream_resource",
            "path": "en.cppreference.com/w/cpp/experimental/monotonic_buffer_resource/upstream_resource.html",
            "wgPageName": "cpp/experimental/monotonic_buffer_resource/upstream_resource",
            "sample_declaration": "memory_resource* upstream_resource() const;"
        },
        {
            "title": "std::experimental::erase_if (std::multimap)",
            "path": "en.cppreference.com/w/cpp/experimental/multimap/erase_if.html",
            "wgPageName": "cpp/experimental/multimap/erase_if",
            "headers": [
                "<experimental/map>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class T,\n    class Compare,\n    class Alloc,\n    class Pred>\nvoid erase_if(\n    std::multimap<Key, T, Compare, Alloc>& c,\n    Pred pred);"
        },
        {
            "title": "std::experimental::erase_if (std::multiset)",
            "path": "en.cppreference.com/w/cpp/experimental/multiset/erase_if.html",
            "wgPageName": "cpp/experimental/multiset/erase_if",
            "headers": [
                "<experimental/set>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class Compare,\n    class Alloc,\n    class Pred>\nvoid erase_if(\n    std::multiset<Key, Compare, Alloc>& c,\n    Pred pred);"
        },
        {
            "title": "std::experimental::negation",
            "path": "en.cppreference.com/w/cpp/experimental/negation.html",
            "wgPageName": "cpp/experimental/negation",
            "headers": [
                "<experimental/type_traits>"
            ],
            "sample_declaration": "template<class B>\nstruct negation;"
        },
        {
            "title": "Extensions for networking",
            "path": "en.cppreference.com/w/cpp/experimental/networking.html",
            "wgPageName": "cpp/experimental/networking"
        },
        {
            "title": "std::experimental::pmr::new_delete_resource",
            "path": "en.cppreference.com/w/cpp/experimental/new_delete_resource.html",
            "wgPageName": "cpp/experimental/new_delete_resource",
            "headers": [
                "<experimental/memory_resource>"
            ],
            "sample_declaration": "memory_resource* new_delete_resource() noexcept;"
        },
        {
            "title": "std::experimental::nonesuch",
            "path": "en.cppreference.com/w/cpp/experimental/nonesuch.html",
            "wgPageName": "cpp/experimental/nonesuch",
            "headers": [
                "<experimental/type_traits>"
            ],
            "sample_declaration": "struct nonesuch {\n  ~nonesuch() = delete;\n  nonesuch(nonesuch const&) = delete;\n  void operator=(nonesuch const&) = delete;\n};"
        },
        {
            "title": "std::experimental::not_fn",
            "path": "en.cppreference.com/w/cpp/experimental/not_fn.html",
            "wgPageName": "cpp/experimental/not_fn",
            "headers": [
                "<experimental/functional>"
            ],
            "sample_declaration": "template<class F> /*unspecified*/ not_fn(F&& f);"
        },
        {
            "title": "std::experimental::pmr::null_memory_resource",
            "path": "en.cppreference.com/w/cpp/experimental/null_memory_resource.html",
            "wgPageName": "cpp/experimental/null_memory_resource",
            "headers": [
                "<experimental/memory_resource>"
            ],
            "sample_declaration": "memory_resource*\nnull_memory_resource() noexcept;"
        },
        {
            "title": "std::experimental::observer_ptr",
            "path": "en.cppreference.com/w/cpp/experimental/observer_ptr.html",
            "wgPageName": "cpp/experimental/observer_ptr",
            "headers": [
                "<experimental/memory>"
            ],
            "sample_declaration": "template<class W>\nclass observer_ptr;"
        },
        {
            "title": "std::experimental::observer_ptr<W>::get",
            "path": "en.cppreference.com/w/cpp/experimental/observer_ptr/get.html",
            "wgPageName": "cpp/experimental/observer_ptr/get",
            "sample_declaration": "constexpr element_type* get() const noexcept;"
        },
        {
            "title": "std::hash(std::experimental::observer_ptr)",
            "path": "en.cppreference.com/w/cpp/experimental/observer_ptr/hash.html",
            "wgPageName": "cpp/experimental/observer_ptr/hash",
            "headers": [
                "<experimental/memory>"
            ],
            "sample_declaration": "template<class T>\nstruct hash<std::experimental::observer_ptr<T>>;"
        },
        {
            "title": "std::experimental::make_observer",
            "path": "en.cppreference.com/w/cpp/experimental/observer_ptr/make_observer.html",
            "wgPageName": "cpp/experimental/observer_ptr/make_observer",
            "headers": [
                "<experimental/memory>"
            ],
            "sample_declaration": "template<class W>\nstd::experimental::observer_ptr<W>\nmake_observer(W* p) noexcept;"
        },
        {
            "title": "std::experimental::observer_ptr<W>::observer_ptr",
            "path": "en.cppreference.com/w/cpp/experimental/observer_ptr/observer_ptr.html",
            "wgPageName": "cpp/experimental/observer_ptr/observer_ptr",
            "sample_declaration": "constexpr observer_ptr() noexcept;\nconstexpr observer_ptr(nullptr_t) noexcept;",
            "other_declarations": 4
        },
        {
            "title": "std::experimental::observer_ptr<W>::operator bool",
            "path": "en.cppreference.com/w/cpp/experimental/observer_ptr/operator_bool.html",
            "wgPageName": "cpp/experimental/observer_ptr/operator_bool",
            "sample_declaration": "constexpr explicit operator bool()\n    const noexcept;"
        },
        {
            "title": "operator==,!=,<,<=,>,>=(std::experimental::observer_ptr)",
            "path": "en.cppreference.com/w/cpp/experimental/observer_ptr/operator_cmp.html",
            "wgPageName": "cpp/experimental/observer_ptr/operator_cmp",
            "sample_declaration": "template<class W1, class W2>\nbool operator==(\n    const observer_ptr<W1>& p1,\n    const observer_ptr<W2>& p2);",
            "other_declarations": 9
        },
        {
            "title": "std::experimental::observer_ptr<W>::operator element_type*",
            "path": "en.cppreference.com/w/cpp/experimental/observer_ptr/operator_pointer.html",
            "wgPageName": "cpp/experimental/observer_ptr/operator_pointer",
            "sample_declaration": "constexpr explicit operator element_type*()\n    const noexcept;"
        },
        {
            "title": "std::experimental::observer_ptr<W>::operator*, std::experimental::observer_ptr<W>::operator->",
            "path": "en.cppreference.com/w/cpp/experimental/observer_ptr/operator*.html",
            "wgPageName": "cpp/experimental/observer_ptr/operator*",
            "sample_declaration": "constexpr std::add_lvalue_reference_t<\n    element_type>\noperator*() const;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::observer_ptr<W>::release",
            "path": "en.cppreference.com/w/cpp/experimental/observer_ptr/release.html",
            "wgPageName": "cpp/experimental/observer_ptr/release",
            "sample_declaration": "constexpr element_type* release() noexcept;"
        },
        {
            "title": "std::experimental::observer_ptr<W>::reset",
            "path": "en.cppreference.com/w/cpp/experimental/observer_ptr/reset.html",
            "wgPageName": "cpp/experimental/observer_ptr/reset",
            "sample_declaration": "constexpr void reset(\n    element_type* p = nullptr) noexcept;"
        },
        {
            "title": "std::experimental::observer_ptr<W>::swap",
            "path": "en.cppreference.com/w/cpp/experimental/observer_ptr/swap.html",
            "wgPageName": "cpp/experimental/observer_ptr/swap",
            "sample_declaration": "constexpr void swap(\n    observer_ptr& other) noexcept;"
        },
        {
            "title": "std::experimental::swap(std::experimental::observer_ptr)",
            "path": "en.cppreference.com/w/cpp/experimental/observer_ptr/swap2.html",
            "wgPageName": "cpp/experimental/observer_ptr/swap2",
            "sample_declaration": "template<class W>\nvoid swap(\n    observer_ptr<W>& lhs,\n    observer_ptr<W>& rhs) noexcept;"
        },
        {
            "title": "std::experimental::optional",
            "path": "en.cppreference.com/w/cpp/experimental/optional.html",
            "wgPageName": "cpp/experimental/optional",
            "headers": [
                "<experimental/optional>"
            ],
            "sample_declaration": "template<class T>\nclass optional;"
        },
        {
            "title": "std::experimental::optional<T>::~optional",
            "path": "en.cppreference.com/w/cpp/experimental/optional/~optional.html",
            "wgPageName": "cpp/experimental/optional/~optional",
            "sample_declaration": "~optional();"
        },
        {
            "title": "std::experimental::bad_optional_access",
            "path": "en.cppreference.com/w/cpp/experimental/optional/bad_optional_access.html",
            "wgPageName": "cpp/experimental/optional/bad_optional_access",
            "headers": [
                "<experimental/optional>"
            ],
            "sample_declaration": "class bad_optional_access;"
        },
        {
            "title": "std::experimental::optional<T>::emplace",
            "path": "en.cppreference.com/w/cpp/experimental/optional/emplace.html",
            "wgPageName": "cpp/experimental/optional/emplace",
            "sample_declaration": "template<class... Args>\nvoid emplace(Args&&... args);",
            "other_declarations": 1
        },
        {
            "title": "std::hash <std::experimental::optional>",
            "path": "en.cppreference.com/w/cpp/experimental/optional/hash.html",
            "wgPageName": "cpp/experimental/optional/hash",
            "headers": [
                "<experimental/optional>"
            ],
            "sample_declaration": "template<class T>\nstruct hash<std::experimental::optional<T>>;"
        },
        {
            "title": "std::experimental::in_place_t",
            "path": "en.cppreference.com/w/cpp/experimental/optional/in_place_t.html",
            "wgPageName": "cpp/experimental/optional/in_place_t",
            "headers": [
                "<experimental/optional>"
            ],
            "sample_declaration": "struct in_place_t {};"
        },
        {
            "title": "std::experimental::in_place",
            "path": "en.cppreference.com/w/cpp/experimental/optional/in_place.html",
            "wgPageName": "cpp/experimental/optional/in_place",
            "headers": [
                "<experimental/optional>"
            ],
            "sample_declaration": "constexpr in_place_t in_place{};"
        },
        {
            "title": "std::experimental::make_optional",
            "path": "en.cppreference.com/w/cpp/experimental/optional/make_optional.html",
            "wgPageName": "cpp/experimental/optional/make_optional",
            "headers": [
                "<experimental/optional>"
            ],
            "sample_declaration": "template<class T>\nconstexpr optional<typename std::decay<T>::type>\nmake_optional(T&& value);"
        },
        {
            "title": "std::experimental::nullopt_t",
            "path": "en.cppreference.com/w/cpp/experimental/optional/nullopt_t.html",
            "wgPageName": "cpp/experimental/optional/nullopt_t",
            "headers": [
                "<experimental/optional>"
            ],
            "sample_declaration": "struct nullopt_t;"
        },
        {
            "title": "std::experimental::nullopt",
            "path": "en.cppreference.com/w/cpp/experimental/optional/nullopt.html",
            "wgPageName": "cpp/experimental/optional/nullopt",
            "headers": [
                "<experimental/optional>"
            ],
            "sample_declaration": "constexpr nullopt_t nullopt{/*unspecified*/};"
        },
        {
            "title": "std::experimental::optional<T>::operator bool",
            "path": "en.cppreference.com/w/cpp/experimental/optional/operator_bool.html",
            "wgPageName": "cpp/experimental/optional/operator_bool",
            "sample_declaration": "constexpr explicit operator bool()\n    const noexcept;"
        },
        {
            "title": "operator==, !=, <, <=, >, >=(std::experimental::optional)",
            "path": "en.cppreference.com/w/cpp/experimental/optional/operator_cmp.html",
            "wgPageName": "cpp/experimental/optional/operator_cmp",
            "headers": [
                "<experimental/optional>"
            ],
            "sample_declaration": "template<class T>\nconstexpr bool operator==(\n    const optional<T>& lhs,\n    const optional<T>& rhs);",
            "other_declarations": 29
        },
        {
            "title": "std::experimental::optional<T>::operator->, std::experimental::optional<T>::operator*",
            "path": "en.cppreference.com/w/cpp/experimental/optional/operator*.html",
            "wgPageName": "cpp/experimental/optional/operator*",
            "sample_declaration": "constexpr const T* operator->() const;",
            "other_declarations": 5
        },
        {
            "title": "std::experimental::optional<T>::operator=",
            "path": "en.cppreference.com/w/cpp/experimental/optional/operator=.html",
            "wgPageName": "cpp/experimental/optional/operator=",
            "sample_declaration": "optional& operator=(\n    std::experimental::nullopt_t) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::optional<T>::optional",
            "path": "en.cppreference.com/w/cpp/experimental/optional/optional.html",
            "wgPageName": "cpp/experimental/optional/optional",
            "sample_declaration": "constexpr optional() noexcept;\nconstexpr optional(\n    std::experimental::nullopt_t) noexcept;",
            "other_declarations": 6
        },
        {
            "title": "std::experimental::optional<T>::swap",
            "path": "en.cppreference.com/w/cpp/experimental/optional/swap.html",
            "wgPageName": "cpp/experimental/optional/swap",
            "sample_declaration": "void swap(optional& other) noexcept(\n    /* see below */);"
        },
        {
            "title": "std::experimental::swap(std::experimental::optional)",
            "path": "en.cppreference.com/w/cpp/experimental/optional/swap2.html",
            "wgPageName": "cpp/experimental/optional/swap2",
            "headers": [
                "<experimental/optional>"
            ],
            "sample_declaration": "template<class T>\nvoid swap(\n    optional<T>& lhs,\n    optional<T>& rhs) noexcept(/* see below */);"
        },
        {
            "title": "std::experimental::optional<T>::value_or",
            "path": "en.cppreference.com/w/cpp/experimental/optional/value_or.html",
            "wgPageName": "cpp/experimental/optional/value_or",
            "sample_declaration": "template<class U>\nconstexpr T value_or(U&& default_value) const&;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::optional<T>::value",
            "path": "en.cppreference.com/w/cpp/experimental/optional/value.html",
            "wgPageName": "cpp/experimental/optional/value",
            "sample_declaration": "constexpr T& value() &;\nconstexpr const T& value() const&;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::ostream_joiner",
            "path": "en.cppreference.com/w/cpp/experimental/ostream_joiner.html",
            "wgPageName": "cpp/experimental/ostream_joiner",
            "headers": [
                "<experimental/iterator>"
            ],
            "sample_declaration": "template<\n    class DelimT,\n    class CharT = char,\n    class Traits = std::char_traits<CharT>>\nclass ostream_joiner;"
        },
        {
            "title": "std::experimental::make_ostream_joiner",
            "path": "en.cppreference.com/w/cpp/experimental/ostream_joiner/make_ostream_joiner.html",
            "wgPageName": "cpp/experimental/ostream_joiner/make_ostream_joiner",
            "headers": [
                "<experimental/iterator>"
            ],
            "sample_declaration": "template<\n    class charT,\n    class traits,\n    class DelimT>\nstd::experimental::ostream_joiner<\n    std::decay_t<DelimT>,\n    charT,\n    traits>\nmake_ostream_joiner(\n    std::basic_ostream<charT, traits>& os,\n    DelimT&& delimiter);"
        },
        {
            "title": "std::experimental::ostream_joiner<DelimT,CharT,Traits>::operator++",
            "path": "en.cppreference.com/w/cpp/experimental/ostream_joiner/operator_arith.html",
            "wgPageName": "cpp/experimental/ostream_joiner/operator_arith",
            "sample_declaration": "ostream_joiner& operator++() noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::ostream_joiner<DelimT,CharT,Traits>::operator*",
            "path": "en.cppreference.com/w/cpp/experimental/ostream_joiner/operator*.html",
            "wgPageName": "cpp/experimental/ostream_joiner/operator*",
            "sample_declaration": "ostream_joiner& operator*() noexcept;"
        },
        {
            "title": "std::experimental::ostream_joiner<DelimT,CharT,Traits>::operator=",
            "path": "en.cppreference.com/w/cpp/experimental/ostream_joiner/operator=.html",
            "wgPageName": "cpp/experimental/ostream_joiner/operator=",
            "sample_declaration": "template<class T>\nostream_joiner& operator=(const T& value);",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::ostream_joiner<DelimT,CharT,Traits>::ostream_joiner",
            "path": "en.cppreference.com/w/cpp/experimental/ostream_joiner/ostream_joiner.html",
            "wgPageName": "cpp/experimental/ostream_joiner/ostream_joiner",
            "sample_declaration": "ostream_joiner(\n    ostream_type& stream,\n    const DelimT& delimiter);",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::packaged_task",
            "path": "en.cppreference.com/w/cpp/experimental/packaged_task.html",
            "wgPageName": "cpp/experimental/packaged_task"
        },
        {
            "title": "Extensions for parallelism, version 2",
            "path": "en.cppreference.com/w/cpp/experimental/parallelism_2.html",
            "wgPageName": "cpp/experimental/parallelism_2"
        },
        {
            "title": "Extensions for parallelism",
            "path": "en.cppreference.com/w/cpp/experimental/parallelism.html",
            "wgPageName": "cpp/experimental/parallelism"
        },
        {
            "title": "Parallelized version of existing algorithms (parallelism TS)",
            "path": "en.cppreference.com/w/cpp/experimental/parallelism/existing.html",
            "wgPageName": "cpp/experimental/parallelism/existing"
        },
        {
            "title": "std::experimental::pmr::polymorphic_allocator",
            "path": "en.cppreference.com/w/cpp/experimental/polymorphic_allocator.html",
            "wgPageName": "cpp/experimental/polymorphic_allocator",
            "headers": [
                "<experimental/memory_resource>"
            ],
            "sample_declaration": "template<class T>\nclass polymorphic_allocator;"
        },
        {
            "title": "std::experimental::pmr::polymorphic_allocator<T>::allocate",
            "path": "en.cppreference.com/w/cpp/experimental/polymorphic_allocator/allocate.html",
            "wgPageName": "cpp/experimental/polymorphic_allocator/allocate",
            "sample_declaration": "T* allocate(std::size_t n);"
        },
        {
            "title": "std::experimental::pmr::polymorphic_allocator<T>::construct",
            "path": "en.cppreference.com/w/cpp/experimental/polymorphic_allocator/construct.html",
            "wgPageName": "cpp/experimental/polymorphic_allocator/construct",
            "sample_declaration": "template<class U, class... Args>\nvoid construct(U* p, Args&&... args);",
            "other_declarations": 5
        },
        {
            "title": "std::experimental::pmr::polymorphic_allocator<T>::deallocate",
            "path": "en.cppreference.com/w/cpp/experimental/polymorphic_allocator/deallocate.html",
            "wgPageName": "cpp/experimental/polymorphic_allocator/deallocate",
            "sample_declaration": "void deallocate(T* p, std::size_t n);"
        },
        {
            "title": "std::experimental::pmr::polymorphic_allocator<T>::destroy",
            "path": "en.cppreference.com/w/cpp/experimental/polymorphic_allocator/destroy.html",
            "wgPageName": "cpp/experimental/polymorphic_allocator/destroy",
            "sample_declaration": "template<class U>\nvoid destroy(U* p);"
        },
        {
            "title": "operator==,!=(std::experimental::pmr::polymorphic_allocator)",
            "path": "en.cppreference.com/w/cpp/experimental/polymorphic_allocator/operator_eq.html",
            "wgPageName": "cpp/experimental/polymorphic_allocator/operator_eq",
            "sample_declaration": "template<class T1, class T2>\nbool operator==(\n    const polymorphic_allocator<T1>& lhs,\n    const polymorphic_allocator<T2>&\n        rhs) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::pmr::polymorphic_allocator<T>::operator=",
            "path": "en.cppreference.com/w/cpp/experimental/polymorphic_allocator/operator=.html",
            "wgPageName": "cpp/experimental/polymorphic_allocator/operator=",
            "sample_declaration": "polymorphic_allocator& operator=(\n    const polymorphic_allocator& rhs) = default;"
        },
        {
            "title": "std::experimental::pmr::polymorphic_allocator<T>::polymorphic_allocator",
            "path": "en.cppreference.com/w/cpp/experimental/polymorphic_allocator/polymorphic_allocator.html",
            "wgPageName": "cpp/experimental/polymorphic_allocator/polymorphic_allocator",
            "sample_declaration": "polymorphic_allocator() noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::pmr::polymorphic_allocator<T>::resource",
            "path": "en.cppreference.com/w/cpp/experimental/polymorphic_allocator/resource.html",
            "wgPageName": "cpp/experimental/polymorphic_allocator/resource",
            "sample_declaration": "memory_resource* resource() const;"
        },
        {
            "title": "std::experimental::pmr::polymorphic_allocator<T>::select_on_container_copy_construction",
            "path": "en.cppreference.com/w/cpp/experimental/polymorphic_allocator/select_on_container_copy_construction.html",
            "wgPageName": "cpp/experimental/polymorphic_allocator/select_on_container_copy_construction",
            "sample_declaration": "polymorphic_allocator\nselect_on_container_copy_construction() const;"
        },
        {
            "title": "std::experimental::pmr::pool_options",
            "path": "en.cppreference.com/w/cpp/experimental/pool_options.html",
            "wgPageName": "cpp/experimental/pool_options",
            "headers": [
                "<experimental/memory_resource>"
            ],
            "sample_declaration": "struct pool_options {\n  std::size_t max_blocks_per_chunk = 0;\n  std::size_t largest_required_pool_block = 0;\n};"
        },
        {
            "title": "std::experimental::promise",
            "path": "en.cppreference.com/w/cpp/experimental/promise.html",
            "wgPageName": "cpp/experimental/promise"
        },
        {
            "title": "std::experimental::propagate_const",
            "path": "en.cppreference.com/w/cpp/experimental/propagate_const.html",
            "wgPageName": "cpp/experimental/propagate_const",
            "headers": [
                "<experimental/propagate_const>"
            ],
            "sample_declaration": "template<class T>\nclass propagate_const;"
        },
        {
            "title": "std::equal_to, not_equal_to, less, greater, less_equal, greater_equal(std::experimental::propagate_const)",
            "path": "en.cppreference.com/w/cpp/experimental/propagate_const/cmp_func.html",
            "wgPageName": "cpp/experimental/propagate_const/cmp_func",
            "headers": [
                "<experimental/propagate_const>"
            ],
            "sample_declaration": "template<class T>\nstruct equal_to<\n    std::experimental::propagate_const<T>>;",
            "other_declarations": 5
        },
        {
            "title": "std::experimental::get_underlying",
            "path": "en.cppreference.com/w/cpp/experimental/propagate_const/get_underlying.html",
            "wgPageName": "cpp/experimental/propagate_const/get_underlying",
            "sample_declaration": "template<class T>\nconstexpr T& get_underlying(\n    propagate_const<T>& pt) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::propagate_const<T>::get",
            "path": "en.cppreference.com/w/cpp/experimental/propagate_const/get.html",
            "wgPageName": "cpp/experimental/propagate_const/get",
            "sample_declaration": "constexpr element_type* get();",
            "other_declarations": 1
        },
        {
            "title": "std::hash(std::experimental::propagate_const)",
            "path": "en.cppreference.com/w/cpp/experimental/propagate_const/hash.html",
            "wgPageName": "cpp/experimental/propagate_const/hash",
            "headers": [
                "<experimental/propagate_const>"
            ],
            "sample_declaration": "template<class T>\nstruct hash<\n    std::experimental::propagate_const<T>>;"
        },
        {
            "title": "std::experimental::propagate_const<T>::operator bool",
            "path": "en.cppreference.com/w/cpp/experimental/propagate_const/operator_bool.html",
            "wgPageName": "cpp/experimental/propagate_const/operator_bool",
            "sample_declaration": "constexpr explicit operator bool() const;"
        },
        {
            "title": "operator==,!=,<,<=,>,>=(std::experimental::propagate_const)",
            "path": "en.cppreference.com/w/cpp/experimental/propagate_const/operator_cmp.html",
            "wgPageName": "cpp/experimental/propagate_const/operator_cmp",
            "sample_declaration": "template<class T>\nconstexpr bool operator==(\n    const propagate_const<T>& pt,\n    nullptr_t);",
            "other_declarations": 21
        },
        {
            "title": "std::experimental::propagate_const<T>::operator element_type*, std::experimental::propagate_const<T>::operator const element_type*",
            "path": "en.cppreference.com/w/cpp/experimental/propagate_const/operator_element_type*.html",
            "wgPageName": "cpp/experimental/propagate_const/operator_element_type*",
            "sample_declaration": "constexpr operator element_type*();",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::propagate_const<T>::operator*, std::experimental::propagate_const<T>::operator->",
            "path": "en.cppreference.com/w/cpp/experimental/propagate_const/operator*.html",
            "wgPageName": "cpp/experimental/propagate_const/operator*",
            "sample_declaration": "constexpr element_type& operator*();",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::propagate_const<T>::operator=",
            "path": "en.cppreference.com/w/cpp/experimental/propagate_const/operator=.html",
            "wgPageName": "cpp/experimental/propagate_const/operator=",
            "sample_declaration": "constexpr propagate_const& operator=(\n    propagate_const&& p) = default;",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::propagate_const<T>::propagate_const",
            "path": "en.cppreference.com/w/cpp/experimental/propagate_const/propagate_const.html",
            "wgPageName": "cpp/experimental/propagate_const/propagate_const",
            "sample_declaration": "constexpr propagate_const() = default;",
            "other_declarations": 4
        },
        {
            "title": "std::experimental::propagate_const<T>::swap",
            "path": "en.cppreference.com/w/cpp/experimental/propagate_const/swap.html",
            "wgPageName": "cpp/experimental/propagate_const/swap",
            "sample_declaration": "constexpr void\nswap(propagate_const& pt) noexcept(\n    /* see below */);"
        },
        {
            "title": "std::experimental::swap(std::experimental::propagate_const)",
            "path": "en.cppreference.com/w/cpp/experimental/propagate_const/swap2.html",
            "wgPageName": "cpp/experimental/propagate_const/swap2",
            "sample_declaration": "template<class T>\nconstexpr void swap(\n    std::experimental::propagate_const<T>& lhs,\n    std::experimental::propagate_const<T>&\n        rhs) noexcept(/* see below */);"
        },
        {
            "title": "std::experimental::randint",
            "path": "en.cppreference.com/w/cpp/experimental/randint.html",
            "wgPageName": "cpp/experimental/randint",
            "headers": [
                "<experimental/random>"
            ],
            "sample_declaration": "template<class IntType>\nIntType randint(IntType a, IntType b);"
        },
        {
            "title": "Extensions for ranges",
            "path": "en.cppreference.com/w/cpp/experimental/ranges.html",
            "wgPageName": "cpp/experimental/ranges"
        },
        {
            "title": "std::experimental::ranges::adjacent_find",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/algorithm/adjacent_find.html",
            "wgPageName": "cpp/experimental/ranges/algorithm/adjacent_find",
            "headers": [
                "<experimental/ranges/algorithm>"
            ],
            "sample_declaration": "template<\n    ForwardIterator I,\n    Sentinel<I> S,\n    class Proj = ranges::identity,\n    IndirectRelation<projected<I, Proj>> Pred =\n        ranges::equal_to<>>\nI adjacent_find(\n    I first,\n    S last,\n    Pred pred = Pred{},\n    Proj proj = Proj{});",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::ranges::all_of, std::experimental::ranges::any_of, std::experimental::ranges::none_of",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/algorithm/all_any_none_of.html",
            "wgPageName": "cpp/experimental/ranges/algorithm/all_any_none_of",
            "headers": [
                "<experimental/ranges/algorithm>"
            ],
            "sample_declaration": "template<\n    InputIterator I,\n    Sentinel<I> S,\n    class Proj = ranges::identity,\n    IndirectUnaryPredicate<projected<I, Proj>>\n        Pred>\nbool all_of(\n    I first,\n    S last,\n    Pred pred,\n    Proj proj = Proj{});",
            "other_declarations": 5
        },
        {
            "title": "std::experimental::ranges::copy, std::experimental::ranges::copy_if",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/algorithm/copy.html",
            "wgPageName": "cpp/experimental/ranges/algorithm/copy",
            "headers": [
                "<experimental/ranges/algorithm>"
            ],
            "sample_declaration": "template<\n    InputIterator I,\n    Sentinel<I> S,\n    WeaklyIncrementable O>\nrequires IndirectlyCopyable<I, O>\n    ranges::tagged_pair<tag::in(I), tag::out(O)>\n    copy(I first, S last, O result);",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::ranges::count, std::experimental::ranges::count_if",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/algorithm/count.html",
            "wgPageName": "cpp/experimental/ranges/algorithm/count",
            "headers": [
                "<experimental/ranges/algorithm>"
            ],
            "sample_declaration": "template<\n    InputIterator I,\n    Sentinel<I> S,\n    class T,\n    class Proj = ranges::identity>\nrequires IndirectRelation < ranges::equal_to<>,\n    projected<I, Proj>,\nconst T* > ranges::difference_type_t<I> count(\n               I first,\n               S last,\n               const T& value,\n               Proj proj = Proj{});",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::ranges::equal",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/algorithm/equal.html",
            "wgPageName": "cpp/experimental/ranges/algorithm/equal",
            "headers": [
                "<experimental/ranges/algorithm>"
            ],
            "sample_declaration": "template<\n    InputIterator I1,\n    Sentinel<I1> S1,\n    InputIterator I2,\n    Sentinel<I2> S2,\n    class Pred = ranges::equal_to<>,\n    class Proj1 = ranges::identity,\n    class Proj2 = ranges::identity>\nrequires IndirectlyComparable<\n    I1,\n    I2,\n    Pred,\n    Proj1,\n    Proj2>\nbool equal(\n    I1 first1,\n    S1 last1,\n    I2 first2,\n    S2 last2,\n    Pred pred = Pred{},\n    Proj1 proj1 = Proj1{},\n    Proj2 proj2 = Proj2{});",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::ranges::find_end",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/algorithm/find_end.html",
            "wgPageName": "cpp/experimental/ranges/algorithm/find_end",
            "headers": [
                "<experimental/ranges/algorithm>"
            ],
            "sample_declaration": "template<\n    ForwardIterator I1,\n    Sentinel<I1> S1,\n    ForwardIterator I2,\n    Sentinel<I2> S2,\n    class Proj = ranges::identity,\n    IndirectRelation<I2, projected<I1, Proj>>\n        Pred = ranges::equal_to<>>\nI1 find_end(\n    I1 first1,\n    S1 last1,\n    I2 first2,\n    S2 last2,\n    Pred pred = Pred{},\n    Proj proj = Proj{});",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::ranges::find_first_of",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/algorithm/find_first_of.html",
            "wgPageName": "cpp/experimental/ranges/algorithm/find_first_of",
            "headers": [
                "<experimental/ranges/algorithm>"
            ],
            "sample_declaration": "template<\n    InputIterator I1,\n    Sentinel<I1> S1,\n    ForwardIterator I2,\n    Sentinel<I2> S2,\n    class Proj1 = ranges::identity,\n    class Proj2 = ranges::identity,\n    IndirectRelation<\n        projected<I1, Proj1>,\n        projected<I2, Proj2>> Pred =\n        ranges::equal_to<>>\nI1 find_first_of(\n    I1 first1,\n    S1 last1,\n    I2 first2,\n    S2 last2,\n    Pred pred = Pred{},\n    Proj1 proj1 = Proj1{},\n    Proj2 proj2 = Proj2{});",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::ranges::find, std::experimental::ranges::find_if, std::experimental::ranges::find_if_not",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/algorithm/find.html",
            "wgPageName": "cpp/experimental/ranges/algorithm/find",
            "headers": [
                "<experimental/ranges/algorithm>"
            ],
            "sample_declaration": "template<\n    InputIterator I,\n    Sentinel<I> S,\n    class T,\n    class Proj = ranges::identity>\nrequires IndirectRelation < ranges::equal_to<>,\n    projected<I, Proj>,\nconst T* > I find(\n               I first,\n               S last,\n               const T& value,\n               Proj proj = Proj{});",
            "other_declarations": 5
        },
        {
            "title": "std::experimental::ranges::for_each",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/algorithm/for_each.html",
            "wgPageName": "cpp/experimental/ranges/algorithm/for_each",
            "headers": [
                "<experimental/ranges/algorithm>"
            ],
            "sample_declaration": "template<\n    InputIterator I,\n    Sentinel<I> S,\n    class Proj = ranges::identity,\n    IndirectUnaryInvocable<projected<I, Proj>>\n        Fun>\nranges::tagged_pair<tag::in(I), tag::fun(Fun)>\nfor_each(\n    I first,\n    S last,\n    Fun f,\n    Proj proj = Proj{});",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::ranges::is_permutation",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/algorithm/is_permutation.html",
            "wgPageName": "cpp/experimental/ranges/algorithm/is_permutation",
            "headers": [
                "<experimental/ranges/algorithm>"
            ],
            "sample_declaration": "template<\n    ForwardIterator I1,\n    Sentinel<I1> S1,\n    ForwardIterator I2,\n    Sentinel<I2> S2,\n    class Pred = ranges::equal_to<>,\n    class Proj1 = ranges::identity,\n    class Proj2 = ranges::identity>\nrequires IndirectlyComparable<\n    I1,\n    I2,\n    Pred,\n    Proj1,\n    Proj2>\nbool is_permutation(\n    I1 first1,\n    S1 last1,\n    I2 first2,\n    S2 last2,\n    Pred pred = Pred{},\n    Proj1 proj1 = Proj1{},\n    Proj2 proj2 = Proj2{});",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::ranges::lexicographical_compare",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/algorithm/lexicographical_compare.html",
            "wgPageName": "cpp/experimental/ranges/algorithm/lexicographical_compare",
            "headers": [
                "<experimental/ranges/algorithm>"
            ],
            "sample_declaration": "template<\n    InputIterator I1,\n    Sentinel<I1> S1,\n    InputIterator I2,\n    Sentinel<I2> S2,\n    class Proj1 = ranges::identity,\n    class Proj2 = ranges::identity,\n    class Comp = ranges::less<>>\nrequires IndirectStrictWeakOrder<\n    Comp,\n    projected<I1, Proj1>,\n    projected<I2, Proj2>>\nbool lexicographical_compare(\n    I1 first1,\n    S1 last1,\n    I2 first2,\n    S2 last2,\n    Comp comp = Comp{},\n    Proj1 proj1 = Proj1{},\n    Proj2 proj2 = Proj2{});",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::ranges::mismatch",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/algorithm/mismatch.html",
            "wgPageName": "cpp/experimental/ranges/algorithm/mismatch",
            "headers": [
                "<experimental/ranges/algorithm>"
            ],
            "sample_declaration": "template<\n    InputIterator I1,\n    Sentinel<I1> S1,\n    InputIterator I2,\n    Sentinel<I2> S2,\n    class Proj1 = ranges::identity,\n    class Proj2 = ranges::identity,\n    class Pred = ranges::equal_to<>>\nrequires IndirectRelation<\n    Pred,\n    projected<I1, Proj1>,\n    projected<I2, Proj2>>\nauto mismatch(\n    I1 first1,\n    S1 last1,\n    I2 first2,\n    S2 last2,\n    Pred pred = Pred{},\n    Proj1 proj1 = Proj1{},\n    Proj2 proj2 = Proj2{}) -> ranges::\n    tagged_pair<tag::in1(I1), tag::in2(I2)>;",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::ranges::search_n",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/algorithm/search_n.html",
            "wgPageName": "cpp/experimental/ranges/algorithm/search_n",
            "headers": [
                "<experimental/ranges/algorithm>"
            ],
            "sample_declaration": "template<\n    ForwardIterator I,\n    Sentinel<I> S,\n    class T,\n    class Pred = ranges::equal_to<>,\n    class Proj = ranges::identity>\nrequires IndirectlyComparable<\n    I,\n    const T*,\n    Pred,\n    Proj>\n    I search_n(\n        I first,\n        S last,\n        ranges::difference_type_t<I> count,\n        const T& value,\n        Pred pred = Pred{},\n        Proj proj = Proj{});",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::ranges::search",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/algorithm/search.html",
            "wgPageName": "cpp/experimental/ranges/algorithm/search",
            "headers": [
                "<experimental/ranges/algorithm>"
            ],
            "sample_declaration": "template<\n    ForwardIterator I1,\n    Sentinel<I1> S1,\n    ForwardIterator I2,\n    Sentinel<I2> S2,\n    class Pred = ranges::equal_to<>,\n    class Proj1 = ranges::identity,\n    class Proj2 = ranges::identity>\nrequires IndirectlyComparable<\n    I1,\n    I2,\n    Pred,\n    Proj1,\n    Proj2>\n    I1 search(\n        I1 first1,\n        S1 last1,\n        I2 first2,\n        S2 last2,\n        Pred pred = Pred{},\n        Proj1 proj1 = Proj1{},\n        Proj2 proj2 = Proj2{});",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::ranges::sort",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/algorithm/sort.html",
            "wgPageName": "cpp/experimental/ranges/algorithm/sort",
            "headers": [
                "<experimental/ranges/algorithm>"
            ],
            "sample_declaration": "template<\n    RandomAccessIterator I,\n    Sentinel<I> S,\n    class Comp = ranges::less<>,\n    class Proj = ranges::identity>\nrequires Sortable<I, Comp, Proj> I sort(\n    I first,\n    S last,\n    Comp comp = Comp{},\n    Proj proj = Proj{});",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::ranges::tag::in, in1, in2, out, out1, out2, fun, min, max, begin, end",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/algorithm/tags.html",
            "wgPageName": "cpp/experimental/ranges/algorithm/tags",
            "headers": [
                "<experimental/ranges/algorithm>"
            ],
            "sample_declaration": "struct in { /* implementation-defined */\n};\nstruct in1 { /* implementation-defined */\n};\nstruct in2 { /* implementation-defined */\n};\nstruct out { /* implementation-defined */\n};\nstruct out1 { /* implementation-defined */\n};\nstruct out2 { /* implementation-defined */\n};\nstruct fun { /* implementation-defined */\n};\nstruct min { /* implementation-defined */\n};\nstruct max { /* implementation-defined */\n};\nstruct begin { /* implementation-defined */\n};\nstruct end { /* implementation-defined */\n};"
        },
        {
            "title": "std::experimental::ranges::Assignable",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/Assignable.html",
            "wgPageName": "cpp/experimental/ranges/concepts/Assignable",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class T, class U>\nconcept bool Assignable =\n    std::is_lvalue_reference<T>::value&&\n        CommonReference<\n            const std::remove_reference_t<T>&,\n            const std::remove_reference_t<\n                U>&>&& requires(T t, U&& u) {\n  { t = std::forward<U>(u) } -> Same<T>&&;\n};"
        },
        {
            "title": "std::experimental::ranges::Boolean",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/Boolean.html",
            "wgPageName": "cpp/experimental/ranges/concepts/Boolean",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class B>\nconcept bool Boolean =\n    Movable<std::decay_t<B>>&& requires(\n        const std::remove_reference_t<B>& b1,\n        const std::remove_reference_t<B>& b2,\n        const bool a) {\n  { b1 } -> ConvertibleTo<bool>&&;\n  { !b1 } -> ConvertibleTo<bool>&&;\n  { b1&& a } -> Same<bool>&&;\n  { b1 || a } -> Same<bool>&&;\n  { b1&& b2 } -> Same<bool>&&;\n  { a&& b2 } -> Same<bool>&&;\n  { b1 || b2 } -> Same<bool>&&;\n  { a || b2 } -> Same<bool>&&;\n  { b1 == b2 } -> ConvertibleTo<bool>&&;\n  { b1 == a } -> ConvertibleTo<bool>&&;\n  { a == b2 } -> ConvertibleTo<bool>&&;\n  { b1 != b2 } -> ConvertibleTo<bool>&&;\n  { b1 != a } -> ConvertibleTo<bool>&&;\n  { a != b2 } -> ConvertibleTo<bool>&&;\n};"
        },
        {
            "title": "std::experimental::ranges::Common",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/Common.html",
            "wgPageName": "cpp/experimental/ranges/concepts/Common",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class T, class U>\nconcept bool Common = Same<\n    ranges::common_type_t<T, U>,\n    ranges::common_type_t<U, T>>&&\n    ConvertibleTo<\n        T,\n        ranges::common_type_t<T, U>>&&\n        ConvertibleTo<\n            U,\n            ranges::common_type_t<T, U>>&&\n            CommonReference<\n                std::add_lvalue_reference_t<\n                    const T>,\n                std::add_lvalue_reference_t<\n                    const U>>&&\n                CommonReference<\n                    std::add_lvalue_reference_t<\n                        ranges::common_type_t<\n                            T,\n                            U>>,\n                    ranges::common_reference_t<\n                        std::\n                            add_lvalue_reference_t<\n                                const T>,\n                        std::\n                            add_lvalue_reference_t<\n                                const U>>>;"
        },
        {
            "title": "std::experimental::ranges::CommonReference",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/CommonReference.html",
            "wgPageName": "cpp/experimental/ranges/concepts/CommonReference",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class T, class U>\nconcept bool CommonReference = Same<\n    ranges::common_reference_t<T, U>,\n    ranges::common_reference_t<U, T>>&&\n    ConvertibleTo<\n        T,\n        ranges::common_reference_t<T, U>>&&\n        ConvertibleTo<\n            U,\n            ranges::common_reference_t<T, U>>;"
        },
        {
            "title": "std::experimental::ranges::Constructible",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/Constructible.html",
            "wgPageName": "cpp/experimental/ranges/concepts/Constructible",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class T, class... Args>\nconcept bool Constructible = Destructible<T>&&\n    std::is_constructible<T, Args...>::value;"
        },
        {
            "title": "std::experimental::ranges::ConvertibleTo",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/ConvertibleTo.html",
            "wgPageName": "cpp/experimental/ranges/concepts/ConvertibleTo",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class From, class To>\nconcept bool ConvertibleTo =\n    std::is_convertible<From, To>::\n        value&& requires(From (&f)()) {\n  static_cast<To>(f());\n};"
        },
        {
            "title": "std::experimental::ranges::Copyable",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/Copyable.html",
            "wgPageName": "cpp/experimental/ranges/concepts/Copyable",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept bool Copyable = CopyConstructible<T>&&\n    Movable<T>&& Assignable<T&, const T&>;"
        },
        {
            "title": "std::experimental::ranges::CopyConstructible",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/CopyConstructible.html",
            "wgPageName": "cpp/experimental/ranges/concepts/CopyConstructible",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept bool CopyConstructible =\n    MoveConstructible<T>&& Constructible<\n        T,\n        T&>&& ConvertibleTo<T&, T>&&\n        Constructible<T, const T&>&&\n            ConvertibleTo<const T&, T>&&\n                Constructible<T, const T>&&\n                    ConvertibleTo<const T, T>;"
        },
        {
            "title": "std::experimental::ranges::DefaultConstructible",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/DefaultConstructible.html",
            "wgPageName": "cpp/experimental/ranges/concepts/DefaultConstructible",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept bool DefaultConstructible =\n    Constructible<T>;"
        },
        {
            "title": "std::experimental::ranges::DerivedFrom",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/DerivedFrom.html",
            "wgPageName": "cpp/experimental/ranges/concepts/DerivedFrom",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class T, class U>\nconcept bool DerivedFrom =\n    std::is_base_of<U, T>::value&&\n        std::is_convertible<\n            std::remove_cv_t<T>*,\n            std::remove_cv_t<U>*>::value;"
        },
        {
            "title": "std::experimental::ranges::Destructible",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/Destructible.html",
            "wgPageName": "cpp/experimental/ranges/concepts/Destructible",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept bool Destructible =\n    std::is_nothrow_destructible<T>::value;"
        },
        {
            "title": "std::experimental::ranges::EqualityComparable, std::experimental::ranges::EqualityComparableWith",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/EqualityComparable.html",
            "wgPageName": "cpp/experimental/ranges/concepts/EqualityComparable",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept bool EqualityComparable =\n    WeaklyEqualityComparableWith<T, T>;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::ranges::Integral",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/Integral.html",
            "wgPageName": "cpp/experimental/ranges/concepts/Integral",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept bool Integral =\n    std::is_integral<T>::value;"
        },
        {
            "title": "std::experimental::ranges::Invocable, std::experimental::ranges::RegularInvocable",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/Invocable.html",
            "wgPageName": "cpp/experimental/ranges/concepts/Invocable",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class F, class... Args>\nconcept bool Invocable =\n    requires(F&& f, Args&&... args) {\n  ranges::invoke(\n      std::forward<F>(f),\n      std::forward<Args>(\n          args)...); /* not required to be\n                        equality preserving */\n};",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::ranges::Movable",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/Movable.html",
            "wgPageName": "cpp/experimental/ranges/concepts/Movable",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept bool Movable =\n    std::is_object<T>::value&&\n        MoveConstructible<T>&&\n            Assignable<T&, T>&& Swappable<T>;"
        },
        {
            "title": "std::experimental::ranges::MoveConstructible",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/MoveConstructible.html",
            "wgPageName": "cpp/experimental/ranges/concepts/MoveConstructible",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept bool MoveConstructible =\n    Constructible<T, T>&& ConvertibleTo<T, T>;"
        },
        {
            "title": "std::experimental::ranges::Predicate",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/Predicate.html",
            "wgPageName": "cpp/experimental/ranges/concepts/Predicate",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class F, class... Args>\nconcept bool Predicate =\n    RegularInvocable<F, Args...>&& Boolean<\n        std::result_of_t<F && (Args && ...)>>;"
        },
        {
            "title": "std::experimental::ranges::Regular",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/Regular.html",
            "wgPageName": "cpp/experimental/ranges/concepts/Regular",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept bool Regular =\n    Semiregular<T>&& EqualityComparable<T>;"
        },
        {
            "title": "std::experimental::ranges::Relation",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/Relation.html",
            "wgPageName": "cpp/experimental/ranges/concepts/Relation",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class R, class T, class U>\nconcept bool Relation = Predicate<R, T, T>&&\n    Predicate<R, U, U>&& CommonReference<\n        const std::remove_reference_t<T>&,\n        const std::remove_reference_t<U>&>&&\n        Predicate<\n            R,\n            ranges::common_reference_t<\n                const std::remove_reference_t<\n                    T>&,\n                const std::remove_reference_t<\n                    U>&>,\n            ranges::common_reference_t<\n                const std::remove_reference_t<\n                    T>&,\n                const std::remove_reference_t<\n                    U>&>>&& Predicate<R, T, U>&&\n            Predicate<R, U, T>;"
        },
        {
            "title": "std::experimental::ranges::Same",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/Same.html",
            "wgPageName": "cpp/experimental/ranges/concepts/Same",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class T, class U>\nconcept bool Same =\n    std::is_same<T, U>::value;  // see below"
        },
        {
            "title": "std::experimental::ranges::Semiregular",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/Semiregular.html",
            "wgPageName": "cpp/experimental/ranges/concepts/Semiregular",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept bool Semiregular =\n    Copyable<T>&& DefaultConstructible<T>;"
        },
        {
            "title": "std::experimental::ranges::SignedIntegral",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/SignedIntegral.html",
            "wgPageName": "cpp/experimental/ranges/concepts/SignedIntegral",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept bool SignedIntegral =\n    Integral<T>&& std::is_signed<T>::value;"
        },
        {
            "title": "std::experimental::ranges::StrictTotallyOrdered, std::experimental::ranges::StrictTotallyOrderedWith",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/StrictTotallyOrdered.html",
            "wgPageName": "cpp/experimental/ranges/concepts/StrictTotallyOrdered",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept bool StrictTotallyOrdered =\n    EqualityComparable<T>&& requires(\n        const std::remove_reference_t<T>& a,\n        const std::remove_reference_t<T>& b) {\n  { a < b } -> Boolean&&;\n  { a > b } -> Boolean&&;\n  { a <= b } -> Boolean&&;\n  { a >= b } -> Boolean&&;\n};",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::ranges::StrictWeakOrder",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/StrictWeakOrder.html",
            "wgPageName": "cpp/experimental/ranges/concepts/StrictWeakOrder",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class R, class T, class U>\nconcept bool StrictWeakOrder =\n    Relation<R, T, U>;"
        },
        {
            "title": "std::experimental::ranges::Swappable, std::experimental::ranges::SwappableWith",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/Swappable.html",
            "wgPageName": "cpp/experimental/ranges/concepts/Swappable",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept bool Swappable = requires(T& a, T& b) {\n  ranges::swap(a, b);\n};",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::ranges::UniformRandomNumberGenerator",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/UniformRandomNumberGenerator.html",
            "wgPageName": "cpp/experimental/ranges/concepts/UniformRandomNumberGenerator",
            "headers": [
                "<experimental/ranges/random>"
            ],
            "sample_declaration": "template<class G>\nconcept bool UniformRandomNumberGenerator =\n    Invocable<G&>&& UnsignedIntegral<\n        std::result_of_t<G&()>>&& requires {\n  {\n    G::min()\n    } -> Same<std::result_of_t<G&()>>&&;\n  {\n    G::max()\n    } -> Same<std::result_of_t<G&()>>&&;\n};"
        },
        {
            "title": "std::experimental::ranges::UnsignedIntegral",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/UnsignedIntegral.html",
            "wgPageName": "cpp/experimental/ranges/concepts/UnsignedIntegral",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class T>\nconcept bool UnsignedIntegral =\n    Integral<T> && !SignedIntegral<T>;"
        },
        {
            "title": "std::experimental::ranges::WeaklyEqualityComparableWith",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/concepts/WeaklyEqualityComparableWith.html",
            "wgPageName": "cpp/experimental/ranges/concepts/WeaklyEqualityComparableWith",
            "headers": [
                "<experimental/ranges/concepts>"
            ],
            "sample_declaration": "template<class T, class U>\nconcept bool WeaklyEqualityComparableWith =\n    requires(\n        const std::remove_reference_t<T>& t,\n        const std::remove_reference_t<U>& u) {\n  { t == u } -> Boolean&&;\n  { t != u } -> Boolean&&;\n  { u == t } -> Boolean&&;\n  { u != t } -> Boolean&&;\n};"
        },
        {
            "title": "std::experimental::ranges::equal_to",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/functional/equal_to.html",
            "wgPageName": "cpp/experimental/ranges/functional/equal_to",
            "headers": [
                "<experimental/ranges/functional>"
            ],
            "sample_declaration": "template<class T = void>\nrequires EqualityComparable<T> ||\n    Same<T, void> ||\n    /* == on two const T lvalues invokes a\n       built-in operator comparing pointers */\n    struct equal_to;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::ranges::greater_equal",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/functional/greater_equal.html",
            "wgPageName": "cpp/experimental/ranges/functional/greater_equal",
            "headers": [
                "<experimental/ranges/functional>"
            ],
            "sample_declaration": "template<class T = void>\nrequires StrictTotallyOrdered<T> ||\n    Same<T, void> ||\n    /* < on two const T lvalues invokes a\n       built-in operator comparing pointers */\n    struct greater_equal;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::ranges::greater",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/functional/greater.html",
            "wgPageName": "cpp/experimental/ranges/functional/greater",
            "headers": [
                "<experimental/ranges/functional>"
            ],
            "sample_declaration": "template<class T = void>\nrequires StrictTotallyOrdered<T> ||\n    Same<T, void> ||\n    /* < on two const T lvalues invokes a\n       built-in operator comparing pointers */\n    struct greater;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::ranges::identity",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/functional/identity.html",
            "wgPageName": "cpp/experimental/ranges/functional/identity",
            "headers": [
                "<experimental/ranges/functional>"
            ],
            "sample_declaration": "struct identity;"
        },
        {
            "title": "std::experimental::ranges::invoke",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/functional/invoke.html",
            "wgPageName": "cpp/experimental/ranges/functional/invoke",
            "headers": [
                "<experimental/ranges/functional>"
            ],
            "sample_declaration": "template<class F, class... Args>\nstd::result_of_t<F && (Args && ...)> invoke(\n    F&& f,\n    Args&&... args);"
        },
        {
            "title": "std::experimental::ranges::less_equal",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/functional/less_equal.html",
            "wgPageName": "cpp/experimental/ranges/functional/less_equal",
            "headers": [
                "<experimental/ranges/functional>"
            ],
            "sample_declaration": "template<class T = void>\nrequires StrictTotallyOrdered<T> ||\n    Same<T, void> ||\n    /* < on two const T lvalues invokes a\n       built-in operator comparing pointers */\n    struct less_equal;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::ranges::less",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/functional/less.html",
            "wgPageName": "cpp/experimental/ranges/functional/less",
            "headers": [
                "<experimental/ranges/functional>"
            ],
            "sample_declaration": "template<class T = void>\nrequires StrictTotallyOrdered<T> ||\n    Same<T, void> ||\n    /* < on two const T lvalues invokes a\n       built-in operator comparing pointers */\n    struct less;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::ranges::not_equal_to",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/functional/not_equal_to.html",
            "wgPageName": "cpp/experimental/ranges/functional/not_equal_to",
            "headers": [
                "<experimental/ranges/functional>"
            ],
            "sample_declaration": "template<class T = void>\nrequires EqualityComparable<T> ||\n    Same<T, void> ||\n    /* == on two const T lvalues invokes a\n       built-in operator comparing pointers */\n    struct not_equal_to;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::ranges::advance",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/advance.html",
            "wgPageName": "cpp/experimental/ranges/iterator/advance",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "namespace {\nconstexpr /* unspecified */ advance =\n    /* unspecified */;\n}",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::ranges::BidirectionalIterator",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/BidirectionalIterator.html",
            "wgPageName": "cpp/experimental/ranges/iterator/BidirectionalIterator",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class I>\nconcept bool BidirectionalIterator =\n    ForwardIterator<I>&& DerivedFrom<\n        ranges::iterator_category_t<I>,\n        ranges::\n            bidirectional_iterator_tag>&& requires(I i) {\n  { --i } -> Same<I>&;\n  { i-- } -> Same<I>&&;\n};"
        },
        {
            "title": "std::experimental::ranges::dangling, std::experimental::ranges::safe_iterator_t",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/dangling.html",
            "wgPageName": "cpp/experimental/ranges/iterator/dangling",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<CopyConstructible T>\nclass dangling {\n public:\n  dangling() requires DefaultConstructible<T>();\n  dangling(T t);\n  T get_unsafe() const;\n};",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::ranges::difference_type",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/difference_type.html",
            "wgPageName": "cpp/experimental/ranges/iterator/difference_type",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class I>\nstruct difference_type {};",
            "other_declarations": 4
        },
        {
            "title": "std::experimental::ranges::distance",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/distance.html",
            "wgPageName": "cpp/experimental/ranges/iterator/distance",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "namespace {\nconstexpr /* unspecified */ distance =\n    /* unspecified */;\n}",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::ranges::ForwardIterator",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/ForwardIterator.html",
            "wgPageName": "cpp/experimental/ranges/iterator/ForwardIterator",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class I>\nconcept bool ForwardIterator =\n    InputIterator<I>&& DerivedFrom<\n        ranges::iterator_category_t<I>,\n        ranges::forward_iterator_tag>&&\n        Incrementable<I>&& Sentinel<I, I>;"
        },
        {
            "title": "std::experimental::ranges::Incrementable",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/Incrementable.html",
            "wgPageName": "cpp/experimental/ranges/iterator/Incrementable",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class I>\nconcept bool Incrementable = Regular<I>&&\n    WeaklyIncrementable<I>&& requires(I i) {\n  { i++ } -> Same<I>&&;\n};"
        },
        {
            "title": "std::experimental::ranges::indirect_result_of",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/indirect_result_of.html",
            "wgPageName": "cpp/experimental/ranges/iterator/indirect_result_of",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class>\nstruct indirect_result_of {};\ntemplate<class F, class... Is>\nrequires Invocable<\n    F,\n    ranges::reference_t<Is>...>\nstruct indirect_result_of<F(Is...)>\n    : std::result_of<F(\n          ranges::reference_t<Is>&&...)> {\n};"
        },
        {
            "title": "std::experimental::ranges::IndirectlyComparable",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/IndirectlyComparable.html",
            "wgPageName": "cpp/experimental/ranges/iterator/IndirectlyComparable",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<\n    class I1,\n    class I2,\n    class R = ranges::equal_to<>,\n    class P1 = ranges::identity,\n    class P2 = ranges::identity>\nconcept bool IndirectlyComparable =\n    IndirectRelation<\n        R,\n        ranges::projected<I1, P1>,\n        ranges::projected<I2, P2>>;"
        },
        {
            "title": "std::experimental::ranges::IndirectlyCopyable",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/IndirectlyCopyable.html",
            "wgPageName": "cpp/experimental/ranges/iterator/IndirectlyCopyable",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class In, class Out>\nconcept bool IndirectlyCopyable = Readable<In>&&\n    Writable<Out, ranges::reference_t<In>>;"
        },
        {
            "title": "std::experimental::ranges::IndirectlyCopyableStorable",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/IndirectlyCopyableStorable.html",
            "wgPageName": "cpp/experimental/ranges/iterator/IndirectlyCopyableStorable",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class In, class Out>\nconcept bool IndirectlyCopyableStorable =\n    IndirectlyCopyable<In, Out>&& Writable<\n        Out,\n        const ranges::value_type_t<In>&>&&\n        Copyable<ranges::value_type_t<In>>&&\n            Constructible<\n                ranges::value_type_t<In>,\n                ranges::reference_t<In>>&&\n                Assignable<\n                    ranges::value_type_t<In>&,\n                    ranges::reference_t<In>>;"
        },
        {
            "title": "std::experimental::ranges::IndirectlyMovable",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/IndirectlyMovable.html",
            "wgPageName": "cpp/experimental/ranges/iterator/IndirectlyMovable",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class In, class Out>\nconcept bool IndirectlyMovable =\n    Readable<In>&& Writable<\n        Out,\n        ranges::rvalue_reference_t<In>>;"
        },
        {
            "title": "std::experimental::ranges::IndirectlyMovableStorable",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/IndirectlyMovableStorable.html",
            "wgPageName": "cpp/experimental/ranges/iterator/IndirectlyMovableStorable",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class In, class Out>\nconcept bool IndirectlyMovableStorable =\n    IndirectlyMovable<In, Out>&& Writable<\n        Out,\n        ranges::value_type_t<In>>&&\n        Movable<ranges::value_type_t<In>>&&\n            Constructible<\n                ranges::value_type_t<In>,\n                ranges::rvalue_reference_t<\n                    In>>&&\n                Assignable<\n                    ranges::value_type_t<In>&,\n                    ranges::rvalue_reference_t<\n                        In>>;"
        },
        {
            "title": "std::experimental::ranges::IndirectlySwappable",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/IndirectlySwappable.html",
            "wgPageName": "cpp/experimental/ranges/iterator/IndirectlySwappable",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class I1, class I2 = I1>\nconcept bool IndirectlySwappable =\n    Readable<I1>&& Readable<I2>&& requires(\n        I1&& i1,\n        I2&& i2) {\n  ranges::iter_swap(\n      std::forward<I1>(i1),\n      std::forward<I2>(i2));\n  ranges::iter_swap(\n      std::forward<I2>(i2),\n      std::forward<I1>(i1));\n  ranges::iter_swap(\n      std::forward<I1>(i1),\n      std::forward<I1>(i1));\n  ranges::iter_swap(\n      std::forward<I2>(i2),\n      std::forward<I2>(i2));\n};"
        },
        {
            "title": "std::experimental::ranges::IndirectRelation",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/IndirectRelation.html",
            "wgPageName": "cpp/experimental/ranges/iterator/IndirectRelation",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class F, class I1, class I2 = I1>\nconcept bool IndirectRelation = Readable<\n    I1>&& Readable<I2>&& CopyConstructible<F>&&\n    Relation<\n        F&,\n        ranges::value_type_t<I1>&,\n        ranges::value_type_t<I2>&>&&\n        Relation<\n            F&,\n            ranges::value_type_t<I1>&,\n            ranges::reference_t<I2>>&&\n            Relation<\n                F&,\n                ranges::reference_t<I1>,\n                ranges::value_type_t<I2>&>&&\n                Relation<\n                    F&,\n                    ranges::reference_t<I1>,\n                    ranges::reference_t<I2>>&&\n                    Relation<\n                        F&,\n                        ranges::\n                            iter_common_reference_t<\n                                I1>,\n                        ranges::\n                            iter_common_reference_t<\n                                I2>>;"
        },
        {
            "title": "std::experimental::ranges::IndirectStrictWeakOrder",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/IndirectStrictWeakOrder.html",
            "wgPageName": "cpp/experimental/ranges/iterator/IndirectStrictWeakOrder",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class F, class I1, class I2 = I1>\nconcept bool IndirectStrictWeakOrder = Readable<\n    I1>&& Readable<I2>&& CopyConstructible<F>&&\n    StrictWeakOrder<\n        F&,\n        ranges::value_type_t<I1>&,\n        ranges::value_type_t<I2>&>&&\n        StrictWeakOrder<\n            F&,\n            ranges::value_type_t<I1>&,\n            ranges::reference_t<I2>>&&\n            StrictWeakOrder<\n                F&,\n                ranges::reference_t<I1>,\n                ranges::value_type_t<I2>&>&&\n                StrictWeakOrder<\n                    F&,\n                    ranges::reference_t<I1>,\n                    ranges::reference_t<I2>>&&\n                    StrictWeakOrder<\n                        F&,\n                        ranges::\n                            iter_common_reference_t<\n                                I1>,\n                        ranges::\n                            iter_common_reference_t<\n                                I2>>;"
        },
        {
            "title": "std::experimental::ranges::IndirectUnaryInvocable, std::experimental::ranges::IndirectRegularUnaryInvocable",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/IndirectUnaryInvocable.html",
            "wgPageName": "cpp/experimental/ranges/iterator/IndirectUnaryInvocable",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class F, class I>\nconcept bool IndirectUnaryInvocable = Readable<\n    I>&& CopyConstructible<F>&&\n    Invocable<F&, ranges::value_type_t<I>&>&&\n        Invocable<F&, ranges::reference_t<I>>&&\n            Invocable<\n                F&,\n                ranges::iter_common_reference_t<\n                    I>>&&\n                CommonReference<\n                    std::result_of_t<F&(\n                        ranges::value_type_t<\n                            I>&)>,\n                    std::result_of_t<F&(\n                        ranges::reference_t<\n                            I>&&)>>;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::ranges::IndirectUnaryPredicate",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/IndirectUnaryPredicate.html",
            "wgPageName": "cpp/experimental/ranges/iterator/IndirectUnaryPredicate",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class F, class I>\nconcept bool IndirectUnaryPredicate = Readable<\n    I>&& CopyConstructible<F>&&\n    Predicate<F&, ranges::value_type_t<I>&>&&\n        Predicate<F&, ranges::reference_t<I>>&&\n            Predicate<\n                F&,\n                ranges::iter_common_reference_t<\n                    I>>;"
        },
        {
            "title": "std::experimental::ranges::InputIterator",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/InputIterator.html",
            "wgPageName": "cpp/experimental/ranges/iterator/InputIterator",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class I>\nconcept bool InputIterator =\n    Iterator<I>&& Readable<I>&& requires {\n  typename ranges::iterator_category_t<I>;\n}\n&&DerivedFrom<\n    ranges::iterator_category_t<I>,\n    ranges::input_iterator_tag>;"
        },
        {
            "title": "std::experimental::ranges::iterator_category",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/iterator_category.html",
            "wgPageName": "cpp/experimental/ranges/iterator/iterator_category",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class I>\nstruct iterator_category {};",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::ranges::input_iterator_tag, std::experimental::ranges::output_iterator_tag, std::experimental::ranges::forward_iterator_tag, std::experimental::ranges::bidirectional_iterator_tag, std::experimental::ranges::random_access_iterator_tag",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/iterator_tags.html",
            "wgPageName": "cpp/experimental/ranges/iterator/iterator_tags",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "struct input_iterator_tag {};",
            "other_declarations": 4
        },
        {
            "title": "std::experimental::ranges::Iterator",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/Iterator.html",
            "wgPageName": "cpp/experimental/ranges/iterator/Iterator",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class I>\nconcept bool Iterator = requires(I i) {\n  {\n    *i\n    } -> auto&&;  // Requires: i is\n                  // dereferenceable } &&\n                  // WeaklyIncrementable<I>;"
        },
        {
            "title": "std::experimental::ranges::Mergeable",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/Mergeable.html",
            "wgPageName": "cpp/experimental/ranges/iterator/Mergeable",
            "sample_declaration": "template<\n    class I1,\n    class I2,\n    class Out,\n    class R = ranges::less<>,\n    class P1 = ranges::identity,\n    class P2 = ranges::identity>\nconcept bool Mergeable = InputIterator<I1>&&\n    InputIterator<I2>&& WeaklyIncrementable<\n        Out>&& IndirectlyCopyable<I1, Out>&&\n        IndirectlyCopyable<I2, Out>&&\n            IndirectStrictWeakOrder<\n                R,\n                ranges::projected<I1, P1>,\n                ranges::projected<I2, P2>>;"
        },
        {
            "title": "std::experimental::ranges::next",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/next.html",
            "wgPageName": "cpp/experimental/ranges/iterator/next",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "namespace {\nconstexpr /* unspecified */ next =\n    /* unspecified */;\n}",
            "other_declarations": 4
        },
        {
            "title": "std::experimental::ranges::OutputIterator",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/OutputIterator.html",
            "wgPageName": "cpp/experimental/ranges/iterator/OutputIterator",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class I, class T>\nconcept bool OutputIterator = Iterator<I>&&\n    Writable<I, T>&& requires(I i, T&& t) {\n  *i++ = std::forward<T>(\n      t);  // not required to be equality\n           // preserving };"
        },
        {
            "title": "std::experimental::ranges::Permutable",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/Permutable.html",
            "wgPageName": "cpp/experimental/ranges/iterator/Permutable",
            "sample_declaration": "template<class I>\nconcept bool Permutable = ForwardIterator<I>&&\n    IndirectlyMovableStorable<I, I>&&\n        IndirectlySwappable<I, I>;"
        },
        {
            "title": "std::experimental::ranges::prev",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/prev.html",
            "wgPageName": "cpp/experimental/ranges/iterator/prev",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "namespace {\nconstexpr /* unspecified */ prev =\n    /* unspecified */;\n}",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::ranges::projected",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/projected.html",
            "wgPageName": "cpp/experimental/ranges/iterator/projected",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<\n    Readable I,\n    IndirectRegularUnaryInvocable<I> Proj>\nstruct projected {\n  using value_type =\n      std::remove_cv_t<std::remove_reference_t<\n          ranges::indirect_result_of_t<Proj&(\n              I)>>>;\n  ranges::indirect_result_of_t<Proj&(I)>\n  operator*() const;\n};\ntemplate<WeaklyIncrementable I, class Proj>\nstruct difference_type<projected<I, Proj>> {\n  using type = ranges::difference_type_t<I>;\n};"
        },
        {
            "title": "std::experimental::ranges::RandomAccessIterator",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/RandomAccessIterator.html",
            "wgPageName": "cpp/experimental/ranges/iterator/RandomAccessIterator",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class I>\nconcept bool RandomAccessIterator =\n    BidirectionalIterator<I>&& DerivedFrom<\n        ranges::iterator_category_t<I>,\n        ranges::random_access_iterator_tag>&&\n        StrictTotallyOrdered<I>&&\n            SizedSentinel<I, I>&& requires(\n                I i,\n                const I j,\n                const ranges::difference_type_t<\n                    I> n) {\n  { i += n } -> Same<I>&;\n  { j + n } -> Same<I>&&;\n  { n + j } -> Same<I>&&;\n  { i -= n } -> Same<I>&;\n  { j - n } -> Same<I>&&;\n  j[n];\n  requires Same<\n      decltype(j[n]), ranges::reference_t<I>>;\n};"
        },
        {
            "title": "std::experimental::ranges::Readable",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/Readable.html",
            "wgPageName": "cpp/experimental/ranges/iterator/Readable",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class In>\nconcept bool Readable = requires {\n  typename ranges::value_type_t<In>;\n  typename ranges::reference_t<In>;\n  typename ranges::rvalue_reference_t<In>;\n}\n&&CommonReference<\n    ranges::reference_t<In>&&,\n    ranges::value_type_t<In>&>&&\n    CommonReference<\n        ranges::reference_t<In>&&,\n        ranges::rvalue_reference_t<In>&&>&&\n        CommonReference<\n            ranges::rvalue_reference_t<In>&&,\n            const ranges::value_type_t<In>&>;"
        },
        {
            "title": "std::experimental::ranges::reference_t, std::experimental::ranges::rvalue_reference_t, std::experimental::ranges::iter_common_reference_t",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/reference_t.html",
            "wgPageName": "cpp/experimental/ranges/iterator/reference_t",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class T>\nconcept bool /*dereferenceable*/ =\n    requires(T& t) {\n  { *t } -> auto&&;\n};  // exposition only",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::ranges::Sentinel",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/Sentinel.html",
            "wgPageName": "cpp/experimental/ranges/iterator/Sentinel",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class S, class I>\nconcept bool Sentinel =\n    Semiregular<S>&& Iterator<I>&&\n        WeaklyEqualityComparableWith<S, I>;"
        },
        {
            "title": "std::experimental::ranges::SizedSentinel",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/SizedSentinel.html",
            "wgPageName": "cpp/experimental/ranges/iterator/SizedSentinel",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class S, class I>\nconcept bool SizedSentinel =\n    Sentinel<S, I> &&\n    !ranges::disable_sized_sentinel<\n        std::remove_cv_t<S>,\n        std::remove_cv_t<I>> &&\n    requires(const I& i, const S& s) {\n  {\n    s - i\n    } -> Same<ranges::difference_type_t<I>>&&;\n  {\n    i - s\n    } -> Same<ranges::difference_type_t<I>>&&;\n};",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::ranges::Sortable",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/Sortable.html",
            "wgPageName": "cpp/experimental/ranges/iterator/Sortable",
            "sample_declaration": "template<\n    class I,\n    class R = ranges::less<>,\n    class P = ranges::identity>\nconcept bool Sortable =\n    Permutable<I>&& IndirectStrictWeakOrder<\n        R,\n        ranges::projected<I, P>>;"
        },
        {
            "title": "std::experimental::ranges::value_type",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/value_type.html",
            "wgPageName": "cpp/experimental/ranges/iterator/value_type",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class I>\nstruct value_type {};",
            "other_declarations": 5
        },
        {
            "title": "std::experimental::ranges::WeaklyIncrementable",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/WeaklyIncrementable.html",
            "wgPageName": "cpp/experimental/ranges/iterator/WeaklyIncrementable",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class I>\nconcept bool WeaklyIncrementable =\n    Semiregular<I>&& requires(I i) {\n  typename ranges::difference_type_t<I>;\n  requires SignedIntegral<\n      ranges::difference_type_t<I>>;\n  {\n    ++i\n    } -> Same<I>&; /* not required to be\n                      equality preserving */\n  i++; /* not required to be equality preserving\n        */\n};"
        },
        {
            "title": "std::experimental::ranges::Writable",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/iterator/Writable.html",
            "wgPageName": "cpp/experimental/ranges/iterator/Writable",
            "headers": [
                "<experimental/ranges/iterator>"
            ],
            "sample_declaration": "template<class Out, class T>\nconcept bool Writable =\n    requires(Out&& o, T&& t) {\n  *o = std::forward<T>(t);\n  *std::forward<Out>(o) = std::forward<T>(t);\n  const_cast<const ranges::reference_t<Out>&&>(\n      *o) = std::forward<T>(t);\n  const_cast<const ranges::reference_t<Out>&&>(\n      *std::forward<Out>(o)) =\n      std::forward<T>(t);\n}; /* none of the four expressions above are\n      required to be equality-preserving */"
        },
        {
            "title": "std::experimental::ranges::BidirectionalRange",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/range/BidirectionalRange.html",
            "wgPageName": "cpp/experimental/ranges/range/BidirectionalRange",
            "headers": [
                "<experimental/ranges/range>"
            ],
            "sample_declaration": "template<class T>\nconcept bool BidirectionalRange =\n    ForwardRange<T>&& BidirectionalIterator<\n        ranges::iterator_t<T>>;"
        },
        {
            "title": "std::experimental::ranges::BoundedRange",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/range/BoundedRange.html",
            "wgPageName": "cpp/experimental/ranges/range/BoundedRange",
            "headers": [
                "<experimental/ranges/range>"
            ],
            "sample_declaration": "template<class T>\nconcept bool BoundedRange = Range<T>&& Same<\n    ranges::iterator_t<T>,\n    ranges::sentinel_t<T>>;"
        },
        {
            "title": "std::experimental::ranges::ForwardRange",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/range/ForwardRange.html",
            "wgPageName": "cpp/experimental/ranges/range/ForwardRange",
            "headers": [
                "<experimental/ranges/range>"
            ],
            "sample_declaration": "template<class T>\nconcept bool ForwardRange = InputRange<T>&&\n    ForwardIterator<ranges::iterator_t<T>>;"
        },
        {
            "title": "std::experimental::ranges::InputRange",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/range/InputRange.html",
            "wgPageName": "cpp/experimental/ranges/range/InputRange",
            "headers": [
                "<experimental/ranges/range>"
            ],
            "sample_declaration": "template<class T>\nconcept bool InputRange = Range<T>&&\n    InputIterator<ranges::iterator_t<T>>;"
        },
        {
            "title": "std::experimental::ranges::iterator_t, std::experimental::ranges::sentinel_t",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/range/iterator_t.html",
            "wgPageName": "cpp/experimental/ranges/range/iterator_t",
            "headers": [
                "<experimental/ranges/range>"
            ],
            "sample_declaration": "template<class T>\nusing iterator_t =\n    decltype(ranges::begin(std::declval<T&>()));",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::ranges::OutputRange",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/range/OutputRange.html",
            "wgPageName": "cpp/experimental/ranges/range/OutputRange",
            "headers": [
                "<experimental/ranges/range>"
            ],
            "sample_declaration": "template<class R, class T>\nconcept bool OutputRange = Range<R>&&\n    OutputIterator<ranges::iterator_t<R>, T>;"
        },
        {
            "title": "std::experimental::ranges::RandomAccessRange",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/range/RandomAccessRange.html",
            "wgPageName": "cpp/experimental/ranges/range/RandomAccessRange",
            "headers": [
                "<experimental/ranges/range>"
            ],
            "sample_declaration": "template<class T>\nconcept bool RandomAccessRange =\n    BidirectionalRange<T>&&\n        RandomAccessIterator<\n            ranges::iterator_t<T>>;"
        },
        {
            "title": "std::experimental::ranges::Range",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/range/Range.html",
            "wgPageName": "cpp/experimental/ranges/range/Range",
            "headers": [
                "<experimental/ranges/range>"
            ],
            "sample_declaration": "template<class T>\nconcept bool Range = requires(T&& t) {\n  ranges::begin(\n      t); /* not necessarily equality-preserving\n             (see below) */\n  ranges::end(t);\n};"
        },
        {
            "title": "std::experimental::ranges::SizedRange",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/range/SizedRange.html",
            "wgPageName": "cpp/experimental/ranges/range/SizedRange",
            "headers": [
                "<experimental/ranges/range>"
            ],
            "sample_declaration": "template<class T>\nconcept bool SizedRange =\n    Range<T> &&\n    !ranges::disable_sized_range<\n        std::remove_cv_t<\n            std::remove_reference_t<T>>> &&\n    requires(T & t) {\n  {\n    ranges::size(t)\n    }\n    -> ConvertibleTo<ranges::difference_type_t<\n        ranges::iterator_t<T>>>;\n};"
        },
        {
            "title": "std::experimental::ranges::View",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/range/View.html",
            "wgPageName": "cpp/experimental/ranges/range/View",
            "headers": [
                "<experimental/ranges/range>"
            ],
            "sample_declaration": "template<class T>\nconcept bool View = Range<T>&&\n    Semiregular<T>&& /* view-predicate<T> */;",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::ranges::common_reference",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/type_traits/common_reference.html",
            "wgPageName": "cpp/experimental/ranges/type_traits/common_reference",
            "headers": [
                "<experimental/ranges/type_traits>"
            ],
            "sample_declaration": "template<class... T>\nstruct common_reference;"
        },
        {
            "title": "std::experimental::ranges::common_type",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/type_traits/common_type.html",
            "wgPageName": "cpp/experimental/ranges/type_traits/common_type",
            "headers": [
                "<experimental/ranges/type_traits>"
            ],
            "sample_declaration": "template<class... T>\nstruct common_type;"
        },
        {
            "title": "std::experimental::ranges::is_swappable_with, std::experimental::ranges::is_swappable, std::experimental::ranges::is_nothrow_swappable_with, std::experimental::ranges::is_nothrow_swappable",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/type_traits/is_swappable.html",
            "wgPageName": "cpp/experimental/ranges/type_traits/is_swappable",
            "headers": [
                "<experimental/ranges/type_traits>"
            ],
            "sample_declaration": "template<class T, class U>\nstruct is_swappable_with;",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::ranges::exchange",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/utility/exchange.html",
            "wgPageName": "cpp/experimental/ranges/utility/exchange",
            "headers": [
                "<experimental/ranges/utility>"
            ],
            "sample_declaration": "template<MoveConstructible T, class U = T>\nrequires Assignable<T&, U>\nconstexpr T exchange(\n    T& obj,\n    U&& new_val) noexcept(/* see below */);"
        },
        {
            "title": "std::experimental::ranges::make_tagged_pair",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/utility/make_tagged_pair.html",
            "wgPageName": "cpp/experimental/ranges/utility/make_tagged_pair",
            "headers": [
                "<experimental/ranges/utility>"
            ],
            "sample_declaration": "template<\n    TagSpecifier Tag1,\n    TagSpecifier Tag2,\n    class T1,\n    class T2>\nconstexpr ranges::\n    tagged</*see below*/, Tag1, Tag2>\n    make_tagged_pair(T1&& x, T2&& y);"
        },
        {
            "title": "std::experimental::ranges::make_tagged_tuple",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/utility/make_tagged_tuple.html",
            "wgPageName": "cpp/experimental/ranges/utility/make_tagged_tuple",
            "headers": [
                "<experimental/ranges/tuple>"
            ],
            "sample_declaration": "template<TagSpecifier... Tags, class... Types>\nrequires sizeof...(Tags) ==\n    sizeof...(Types) constexpr ranges::tagged<\n        /*see below*/,\n        Tags...> make_tagged_tuple(Types&&... t);"
        },
        {
            "title": "std::experimental::ranges::swap",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/utility/swap.html",
            "wgPageName": "cpp/experimental/ranges/utility/swap",
            "headers": [
                "<experimental/ranges/utility>"
            ],
            "sample_declaration": "namespace {\nconstexpr /* unspecified */ swap =\n    /* unspecified */;\n}",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::ranges::tagged_pair",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/utility/tagged_pair.html",
            "wgPageName": "cpp/experimental/ranges/utility/tagged_pair",
            "headers": [
                "<experimental/ranges/utility>"
            ],
            "sample_declaration": "template<TaggedType T1, TaggedType T2>\nusing tagged_pair = /* see below */;"
        },
        {
            "title": "std::experimental::ranges::tagged_tuple",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/utility/tagged_tuple.html",
            "wgPageName": "cpp/experimental/ranges/utility/tagged_tuple",
            "headers": [
                "<experimental/ranges/tuple>"
            ],
            "sample_declaration": "template<TaggedType... Types>\nusing tagged_tuple = /* see below */;"
        },
        {
            "title": "std::experimental::ranges::tagged",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/utility/tagged.html",
            "wgPageName": "cpp/experimental/ranges/utility/tagged",
            "headers": [
                "<experimental/ranges/utility>"
            ],
            "sample_declaration": "template<class Base, TagSpecifier... Tags>\nrequires sizeof...(\n    Tags) <= std::tuple_size<Base>::value\n    struct tagged;"
        },
        {
            "title": "std::experimental::ranges::tagged<Base,Tags...>::operator=",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/utility/tagged/operator=.html",
            "wgPageName": "cpp/experimental/ranges/utility/tagged/operator=",
            "sample_declaration": "tagged& operator=(tagged&& that) = default;",
            "other_declarations": 4
        },
        {
            "title": "std::experimental::ranges::tagged<Base,Tags...>::swap",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/utility/tagged/swap.html",
            "wgPageName": "cpp/experimental/ranges/utility/tagged/swap",
            "sample_declaration": "constexpr void swap(tagged& rhs) noexcept(\n    /* see below */) requires Swappable<Base>;"
        },
        {
            "title": "std::experimental::ranges::swap (ranges::tagged)",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/utility/tagged/swap2.html",
            "wgPageName": "cpp/experimental/ranges/utility/tagged/swap2",
            "sample_declaration": "friend constexpr void\nswap(tagged& lhs, tagged& rhs) noexcept(\n    noexcept(lhs.swap(rhs))) requires\n    Swappable<Base>;"
        },
        {
            "title": "std::experimental::ranges::tagged<Base,Tags...>::tagged",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/utility/tagged/tagged.html",
            "wgPageName": "cpp/experimental/ranges/utility/tagged/tagged",
            "sample_declaration": "using Base::Base;",
            "other_declarations": 7
        },
        {
            "title": "std::tuple_element<std::experimental::ranges::tagged>",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/utility/tagged/tuple_element.html",
            "wgPageName": "cpp/experimental/ranges/utility/tagged/tuple_element",
            "sample_declaration": "template<\n    std::size_t N,\n    class Base,\n    class... Tags>\nstruct tuple_element<\n    N,\n    std::experimental::ranges::\n        tagged<Base, Tags...>>\n    : std::tuple_element<N, Base> {};"
        },
        {
            "title": "std::tuple_size<std::experimental::ranges::tagged>",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/utility/tagged/tuple_size.html",
            "wgPageName": "cpp/experimental/ranges/utility/tagged/tuple_size",
            "sample_declaration": "template<class Base, class... Tags>\nstruct tuple_size<std::experimental::ranges::\n                      tagged<Base, Tags...>>\n    : std::tuple_size<Base> {};"
        },
        {
            "title": "std::experimental::ranges::TaggedType",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/utility/TaggedType.html",
            "wgPageName": "cpp/experimental/ranges/utility/TaggedType",
            "headers": [
                "<experimental/ranges/utility>"
            ],
            "sample_declaration": "template<class T>\nconcept bool TaggedType =\n    /* implementation-defined */;"
        },
        {
            "title": "std::experimental::ranges::TagSpecifier",
            "path": "en.cppreference.com/w/cpp/experimental/ranges/utility/TagSpecifier.html",
            "wgPageName": "cpp/experimental/ranges/utility/TagSpecifier",
            "headers": [
                "<experimental/ranges/utility>"
            ],
            "sample_declaration": "template<class T>\nconcept bool TagSpecifier =\n    /* implementation-defined */;"
        },
        {
            "title": "std::experimental::parallel::reduce",
            "path": "en.cppreference.com/w/cpp/experimental/reduce.html",
            "wgPageName": "cpp/experimental/reduce",
            "headers": [
                "<experimental/numeric>"
            ],
            "sample_declaration": "template<class InputIt>\ntypename std::iterator_traits<\n    InputIt>::value_type\nreduce(InputIt first, InputIt last);",
            "other_declarations": 5
        },
        {
            "title": "Extensions for reflection",
            "path": "en.cppreference.com/w/cpp/experimental/reflect.html",
            "wgPageName": "cpp/experimental/reflect"
        },
        {
            "title": "std::experimental::reflect::Alias",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/Alias.html",
            "wgPageName": "cpp/experimental/reflect/Alias",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept Alias = Named<T> &&\n    ScopedMember<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::Base",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/Base.html",
            "wgPageName": "cpp/experimental/reflect/Base",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept Base = Object<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::Callable",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/Callable.html",
            "wgPageName": "cpp/experimental/reflect/Callable",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept Callable = ScopeMember<T> &&\n    Scope<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::Class",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/Class.html",
            "wgPageName": "cpp/experimental/reflect/Class",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept Class = Record<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::Constant",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/Constant.html",
            "wgPageName": "cpp/experimental/reflect/Constant",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept Constant = ScopeMember<T> &&\n    Typed<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::Constructor",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/Constructor.html",
            "wgPageName": "cpp/experimental/reflect/Constructor",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept Constructor = Callable<T> &&\n    RecordMember<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::ConversionOperator",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/ConversionOperator.html",
            "wgPageName": "cpp/experimental/reflect/ConversionOperator",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept ConversionOperator = Operator<T> &&\n    MemberFunction<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::Destructor",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/Destructor.html",
            "wgPageName": "cpp/experimental/reflect/Destructor",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept Destructor = Callable<T> &&\n    SpecialMemberFunction<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::Enum",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/Enum.html",
            "wgPageName": "cpp/experimental/reflect/Enum",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept Enum =\n    Type<T> && Scope<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::Enumerator",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/Enumerator.html",
            "wgPageName": "cpp/experimental/reflect/Enumerator",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept Enumerator = Typed<T> &&\n    ScopeMember<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::Expression",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/Expression.html",
            "wgPageName": "cpp/experimental/reflect/Expression",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept Expression =\n    Object<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::Function",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/Function.html",
            "wgPageName": "cpp/experimental/reflect/Function",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept Function =\n    Callable<T> && Typed<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::FunctionalTypeConversion",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/FunctionalTypeConversion.html",
            "wgPageName": "cpp/experimental/reflect/FunctionalTypeConversion",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept FunctionalTypeConversion =\n    Expression<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::FunctionCallExpression",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/FunctionCallExpression.html",
            "wgPageName": "cpp/experimental/reflect/FunctionCallExpression",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept FunctionCallExpression =\n    Expression<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::FunctionParameter",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/FunctionParameter.html",
            "wgPageName": "cpp/experimental/reflect/FunctionParameter",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept FunctionParameter = Typed<T> &&\n    ScopeMember<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::get_source_column",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/get_source_column.html",
            "wgPageName": "cpp/experimental/reflect/get_source_column",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<Object T>\nstruct get_source_column;"
        },
        {
            "title": "std::experimental::reflect::get_source_line",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/get_source_line.html",
            "wgPageName": "cpp/experimental/reflect/get_source_line",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<Object T>\nstruct get_source_line;"
        },
        {
            "title": "std::experimental::reflect::GlobalScope",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/GlobalScope.html",
            "wgPageName": "cpp/experimental/reflect/GlobalScope",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept GlobalScope =\n    Namespace<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::Lambda",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/Lambda.html",
            "wgPageName": "cpp/experimental/reflect/Lambda",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept Lambda =\n    Type<T> && Scope<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::LambdaCapture",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/LambdaCapture.html",
            "wgPageName": "cpp/experimental/reflect/LambdaCapture",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept LambdaCapture =\n    Variable<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::MemberFunction",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/MemberFunction.html",
            "wgPageName": "cpp/experimental/reflect/MemberFunction",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept MemberFunction = RecordMember<T> &&\n    Function<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::Named",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/Named.html",
            "wgPageName": "cpp/experimental/reflect/Named",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept Named = Object<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::Namespace",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/Namespace.html",
            "wgPageName": "cpp/experimental/reflect/Namespace",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept Namespace = Scope<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::Object",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/Object.html",
            "wgPageName": "cpp/experimental/reflect/Object",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept Object = /* see below */;"
        },
        {
            "title": "std::experimental::reflect::ObjectSequence",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/ObjectSequence.html",
            "wgPageName": "cpp/experimental/reflect/ObjectSequence",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept ObjectSequence =\n    Object<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::Operator",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/Operator.html",
            "wgPageName": "cpp/experimental/reflect/Operator",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept Operator =\n    Function<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::ParenthesizedExpression",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/ParenthesizedExpression.html",
            "wgPageName": "cpp/experimental/reflect/ParenthesizedExpression",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept ParenthesizedExpression =\n    Expression<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::Record",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/Record.html",
            "wgPageName": "cpp/experimental/reflect/Record",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept Record =\n    Type<T> && Scope<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::RecordMember",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/RecordMember.html",
            "wgPageName": "cpp/experimental/reflect/RecordMember",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept RecordMember =\n    ScopeMember<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::Scope",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/Scope.html",
            "wgPageName": "cpp/experimental/reflect/Scope",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept Scope = Object<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::ScopeMember",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/ScopeMember.html",
            "wgPageName": "cpp/experimental/reflect/ScopeMember",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept ScopeMember =\n    Named<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::SpecialMemberFunction",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/SpecialMemberFunction.html",
            "wgPageName": "cpp/experimental/reflect/SpecialMemberFunction",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept SpecialMemberFunction =\n    RecordMember<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::Type",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/Type.html",
            "wgPageName": "cpp/experimental/reflect/Type",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept Type = Named<T> &&\n    ScopeMember<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::Typed",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/Typed.html",
            "wgPageName": "cpp/experimental/reflect/Typed",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept Typed = Named<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reflect::Variable",
            "path": "en.cppreference.com/w/cpp/experimental/reflect/Variable.html",
            "wgPageName": "cpp/experimental/reflect/Variable",
            "headers": [
                "<experimental/reflect>"
            ],
            "sample_declaration": "template<class T>\nconcept Variable = Typed<T> && /* see below */;"
        },
        {
            "title": "std::experimental::reseed",
            "path": "en.cppreference.com/w/cpp/experimental/reseed.html",
            "wgPageName": "cpp/experimental/reseed",
            "headers": [
                "<experimental/random>"
            ],
            "sample_declaration": "void reseed();",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::pmr::resource_adaptor",
            "path": "en.cppreference.com/w/cpp/experimental/resource_adaptor.html",
            "wgPageName": "cpp/experimental/resource_adaptor",
            "headers": [
                "<experimental/memory_resource>"
            ],
            "sample_declaration": "template<class Alloc>\nusing resource_adaptor =\n    /*resource-adaptor-imp*/<\n        typename std::allocator_traits<\n            Allocator>::\n            template rebind_alloc<char>>;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::sample",
            "path": "en.cppreference.com/w/cpp/experimental/sample.html",
            "wgPageName": "cpp/experimental/sample",
            "headers": [
                "<experimental/algorithm>"
            ],
            "sample_declaration": "template<\n    class PopulationIterator,\n    class SampleIterator,\n    class Distance,\n    class URBG>\nSampleIterator sample(\n    PopulationIterator first,\n    PopulationIterator last,\n    SampleIterator out,\n    Distance n,\n    URBG&& g);",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::scope_exit",
            "path": "en.cppreference.com/w/cpp/experimental/scope_exit.html",
            "wgPageName": "cpp/experimental/scope_exit",
            "headers": [
                "<experimental/scope>"
            ],
            "sample_declaration": "template<class EF>\nclass scope_exit;"
        },
        {
            "title": "std::experimental::scope_exit<EF>::~scope_exit",
            "path": "en.cppreference.com/w/cpp/experimental/scope_exit/~scope_exit.html",
            "wgPageName": "cpp/experimental/scope_exit/~scope_exit",
            "sample_declaration": "~scope_exit() noexcept;"
        },
        {
            "title": "deduction guides for std::experimental::scope_exit",
            "path": "en.cppreference.com/w/cpp/experimental/scope_exit/deduction_guides.html",
            "wgPageName": "cpp/experimental/scope_exit/deduction_guides",
            "headers": [
                "<experimental/scope>"
            ],
            "sample_declaration": "template<class EF>\nscope_exit(EF) -> scope_exit<EF>;"
        },
        {
            "title": "std::experimental::scope_exit<EF>::release",
            "path": "en.cppreference.com/w/cpp/experimental/scope_exit/release.html",
            "wgPageName": "cpp/experimental/scope_exit/release",
            "sample_declaration": "void release() noexcept;"
        },
        {
            "title": "std::experimental::scope_exit<EF>::scope_exit",
            "path": "en.cppreference.com/w/cpp/experimental/scope_exit/scope_exit.html",
            "wgPageName": "cpp/experimental/scope_exit/scope_exit",
            "sample_declaration": "template<class Fn>\nexplicit scope_exit(Fn&& fn) noexcept(\n    /*see below*/);",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::scope_fail",
            "path": "en.cppreference.com/w/cpp/experimental/scope_fail.html",
            "wgPageName": "cpp/experimental/scope_fail",
            "headers": [
                "<experimental/scope>"
            ],
            "sample_declaration": "template<class EF>\nclass scope_fail;"
        },
        {
            "title": "std::experimental::scope_fail<EF>::~scope_fail",
            "path": "en.cppreference.com/w/cpp/experimental/scope_fail/~scope_fail.html",
            "wgPageName": "cpp/experimental/scope_fail/~scope_fail",
            "sample_declaration": "~scope_fail() noexcept;"
        },
        {
            "title": "deduction guides for std::experimental::scope_fail",
            "path": "en.cppreference.com/w/cpp/experimental/scope_fail/deduction_guides.html",
            "wgPageName": "cpp/experimental/scope_fail/deduction_guides",
            "headers": [
                "<experimental/scope>"
            ],
            "sample_declaration": "template<class EF>\nscope_fail(EF) -> scope_fail<EF>;"
        },
        {
            "title": "std::experimental::scope_fail<EF>::release",
            "path": "en.cppreference.com/w/cpp/experimental/scope_fail/release.html",
            "wgPageName": "cpp/experimental/scope_fail/release",
            "sample_declaration": "void release() noexcept;"
        },
        {
            "title": "std::experimental::scope_fail<EF>::scope_fail",
            "path": "en.cppreference.com/w/cpp/experimental/scope_fail/scope_fail.html",
            "wgPageName": "cpp/experimental/scope_fail/scope_fail",
            "sample_declaration": "template<class Fn>\nexplicit scope_fail(Fn&& fn) noexcept(\n    /*see below*/);",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::scope_success",
            "path": "en.cppreference.com/w/cpp/experimental/scope_success.html",
            "wgPageName": "cpp/experimental/scope_success",
            "headers": [
                "<experimental/scope>"
            ],
            "sample_declaration": "template<class EF>\nclass scope_success;"
        },
        {
            "title": "std::experimental::scope_success<EF>::~scope_success",
            "path": "en.cppreference.com/w/cpp/experimental/scope_success/~scope_success.html",
            "wgPageName": "cpp/experimental/scope_success/~scope_success",
            "sample_declaration": "~scope_success() noexcept(\n    noexcept(std::declval<EF&>()()));"
        },
        {
            "title": "deduction guides for std::experimental::scope_success",
            "path": "en.cppreference.com/w/cpp/experimental/scope_success/deduction_guides.html",
            "wgPageName": "cpp/experimental/scope_success/deduction_guides",
            "headers": [
                "<experimental/scope>"
            ],
            "sample_declaration": "template<class EF>\nscope_success(EF) -> scope_success<EF>;"
        },
        {
            "title": "std::experimental::scope_success<EF>::release",
            "path": "en.cppreference.com/w/cpp/experimental/scope_success/release.html",
            "wgPageName": "cpp/experimental/scope_success/release",
            "sample_declaration": "void release() noexcept;"
        },
        {
            "title": "std::experimental::scope_success<EF>::scope_success",
            "path": "en.cppreference.com/w/cpp/experimental/scope_success/scope_success.html",
            "wgPageName": "cpp/experimental/scope_success/scope_success",
            "sample_declaration": "template<class Fn>\nexplicit scope_success(Fn&& fn) noexcept(\n    /*see below*/);",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::search",
            "path": "en.cppreference.com/w/cpp/experimental/search.html",
            "wgPageName": "cpp/experimental/search",
            "headers": [
                "<experimental/algorithm>"
            ],
            "sample_declaration": "template<class ForwardIterator, class Searcher>\nForwardIterator search(\n    ForwardIterator first,\n    ForwardIterator last,\n    const Searcher& searcher);"
        },
        {
            "title": "std::experimental::pmr::set_default_resource",
            "path": "en.cppreference.com/w/cpp/experimental/set_default_resource.html",
            "wgPageName": "cpp/experimental/set_default_resource",
            "headers": [
                "<experimental/memory_resource>"
            ],
            "sample_declaration": "memory_resource* set_default_resource(\n    memory_resource* r) noexcept;"
        },
        {
            "title": "std::experimental::erase_if (std::set)",
            "path": "en.cppreference.com/w/cpp/experimental/set/erase_if.html",
            "wgPageName": "cpp/experimental/set/erase_if",
            "headers": [
                "<experimental/set>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class Compare,\n    class Alloc,\n    class Pred>\nvoid erase_if(\n    std::set<Key, Compare, Alloc>& c,\n    Pred pred);"
        },
        {
            "title": "std::experimental::shared_future",
            "path": "en.cppreference.com/w/cpp/experimental/shared_future.html",
            "wgPageName": "cpp/experimental/shared_future",
            "headers": [
                "<experimental/shared_future>"
            ],
            "sample_declaration": "template<class T>\nclass shared_future;",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::shared_future<T>::is_ready",
            "path": "en.cppreference.com/w/cpp/experimental/shared_future/is_ready.html",
            "wgPageName": "cpp/experimental/shared_future/is_ready",
            "sample_declaration": "bool is_ready() const;"
        },
        {
            "title": "std::experimental::shared_future<T>::operator=",
            "path": "en.cppreference.com/w/cpp/experimental/shared_future/operator=.html",
            "wgPageName": "cpp/experimental/shared_future/operator=",
            "sample_declaration": "std::experimental::shared_future<T>& operator=(\n    const std::experimental::shared_future<T>&\n        other);",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::shared_future<T>::shared_future",
            "path": "en.cppreference.com/w/cpp/experimental/shared_future/shared_future.html",
            "wgPageName": "cpp/experimental/shared_future/shared_future",
            "sample_declaration": "shared_future() noexcept;",
            "other_declarations": 4
        },
        {
            "title": "std::experimental::shared_future<T>::then",
            "path": "en.cppreference.com/w/cpp/experimental/shared_future/then.html",
            "wgPageName": "cpp/experimental/shared_future/then",
            "sample_declaration": "template<class F>\nfuture</* see below */> then(F&& func) const;"
        },
        {
            "title": "std::experimental::shared_ptr",
            "path": "en.cppreference.com/w/cpp/experimental/shared_ptr.html",
            "wgPageName": "cpp/experimental/shared_ptr",
            "headers": [
                "<experimental/memory>"
            ],
            "sample_declaration": "template<class T>\nclass shared_ptr;"
        },
        {
            "title": "std::experimental::shared_ptr<T>::get",
            "path": "en.cppreference.com/w/cpp/experimental/shared_ptr/get.html",
            "wgPageName": "cpp/experimental/shared_ptr/get",
            "sample_declaration": "element_type* get() const noexcept;"
        },
        {
            "title": "std::hash(std::experimental::shared_ptr)",
            "path": "en.cppreference.com/w/cpp/experimental/shared_ptr/hash.html",
            "wgPageName": "cpp/experimental/shared_ptr/hash",
            "sample_declaration": "template<class T>\nstruct hash<std::experimental::shared_ptr<T>>;"
        },
        {
            "title": "std::experimental::shared_ptr<T>::operator[]",
            "path": "en.cppreference.com/w/cpp/experimental/shared_ptr/operator_at.html",
            "wgPageName": "cpp/experimental/shared_ptr/operator_at",
            "sample_declaration": "element_type& operator[](\n    std::ptrdiff_t i) const noexcept;"
        },
        {
            "title": "std::experimental::shared_ptr<T>::operator*, std::experimental::shared_ptr<T>::operator->",
            "path": "en.cppreference.com/w/cpp/experimental/shared_ptr/operator*.html",
            "wgPageName": "cpp/experimental/shared_ptr/operator*",
            "sample_declaration": "T& operator*() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::static_pointer_cast, std::experimental::dynamic_pointer_cast, std::experimental::const_pointer_cast, std::experimental::reinterpret_pointer_cast",
            "path": "en.cppreference.com/w/cpp/experimental/shared_ptr/pointer_cast.html",
            "wgPageName": "cpp/experimental/shared_ptr/pointer_cast",
            "sample_declaration": "template<class T, class U>\nstd::experimental::shared_ptr<T>\nstatic_pointer_cast(\n    const std::experimental::shared_ptr<U>&\n        r) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::shared_ptr<T>::shared_ptr",
            "path": "en.cppreference.com/w/cpp/experimental/shared_ptr/shared_ptr.html",
            "wgPageName": "cpp/experimental/shared_ptr/shared_ptr",
            "sample_declaration": "constexpr shared_ptr() noexcept;",
            "other_declarations": 14
        },
        {
            "title": "std::experimental::shuffle",
            "path": "en.cppreference.com/w/cpp/experimental/shuffle.html",
            "wgPageName": "cpp/experimental/shuffle",
            "headers": [
                "<experimental/algorithm>"
            ],
            "sample_declaration": "template<class RandomIt>\nvoid shuffle(RandomIt first, RandomIt last);"
        },
        {
            "title": "Data-parallel vector library",
            "path": "en.cppreference.com/w/cpp/experimental/simd.html",
            "wgPageName": "cpp/experimental/simd"
        },
        {
            "title": "std::experimental::to_fixed_size, std::experimental::to_native, std::experimental::to_compatible",
            "path": "en.cppreference.com/w/cpp/experimental/simd/abi_cast.html",
            "wgPageName": "cpp/experimental/simd/abi_cast",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "template<class T, class Abi>\nfixed_size_simd<T, simd_size_v<T, Abi>>\nto_fixed_size(const simd<T, Abi>& v) noexcept;",
            "other_declarations": 5
        },
        {
            "title": "std::experimental::clamp",
            "path": "en.cppreference.com/w/cpp/experimental/simd/clamp.html",
            "wgPageName": "cpp/experimental/simd/clamp",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "template<class T, class Abi>\nsimd<T, Abi> clamp(\n    const simd<T, Abi>& v,\n    const simd<T, Abi>& lo,\n    const simd<T, Abi>& hi);"
        },
        {
            "title": "std::experimental::simd_abi::compatible",
            "path": "en.cppreference.com/w/cpp/experimental/simd/compatible.html",
            "wgPageName": "cpp/experimental/simd/compatible",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "template<class T>\nusing compatible = /*implementation-defined*/;"
        },
        {
            "title": "std::experimental::concat",
            "path": "en.cppreference.com/w/cpp/experimental/simd/concat.html",
            "wgPageName": "cpp/experimental/simd/concat",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "template<class T, class... Abis>\nsimd<\n    T,\n    simd_abi::deduce_t<\n        T,\n        (simd_size_v<T, Abis> + ...)>>\nconcat(const simd<T, Abis>&... vs);",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::const_where_expression",
            "path": "en.cppreference.com/w/cpp/experimental/simd/const_where_expression.html",
            "wgPageName": "cpp/experimental/simd/const_where_expression",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "template<class M, class V>\nclass const_where_expression;"
        },
        {
            "title": "std::experimental::simd_abi::deduce",
            "path": "en.cppreference.com/w/cpp/experimental/simd/deduce.html",
            "wgPageName": "cpp/experimental/simd/deduce",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "template<class T, std::size_t N, class... Abis>\nstruct deduce;"
        },
        {
            "title": "std::experimental::element_aligned_tag, std::experimental::element_aligned",
            "path": "en.cppreference.com/w/cpp/experimental/simd/element_aligned.html",
            "wgPageName": "cpp/experimental/simd/element_aligned",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "struct element_aligned_tag {};\ninline constexpr element_aligned_tag\n    element_aligned{};"
        },
        {
            "title": "std::experimental::simd_abi::fixed_size",
            "path": "en.cppreference.com/w/cpp/experimental/simd/fixed_size.html",
            "wgPageName": "cpp/experimental/simd/fixed_size",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "template<int N>\nstruct fixed_size {};"
        },
        {
            "title": "std::experimental::is_abi_tag",
            "path": "en.cppreference.com/w/cpp/experimental/simd/is_abi_tag.html",
            "wgPageName": "cpp/experimental/simd/is_abi_tag",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "template<class T>\nstruct is_abi_tag;"
        },
        {
            "title": "std::experimental::is_simd_flag_type",
            "path": "en.cppreference.com/w/cpp/experimental/simd/is_simd_flag_type.html",
            "wgPageName": "cpp/experimental/simd/is_simd_flag_type",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "template<class T>\nstruct is_simd_flag_type;"
        },
        {
            "title": "std::experimental::is_simd, std::experimental::is_simd_mask",
            "path": "en.cppreference.com/w/cpp/experimental/simd/is_simd.html",
            "wgPageName": "cpp/experimental/simd/is_simd",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "template<class T>\nstruct is_simd;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::simd_abi::max_fixed_size",
            "path": "en.cppreference.com/w/cpp/experimental/simd/max_fixed_size.html",
            "wgPageName": "cpp/experimental/simd/max_fixed_size",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "template<class T>\ninline constexpr int max_fixed_size =\n    /*implementation-defined*/;"
        },
        {
            "title": "std::experimental::max",
            "path": "en.cppreference.com/w/cpp/experimental/simd/max.html",
            "wgPageName": "cpp/experimental/simd/max",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "template<class T, class Abi>\nsimd<T, Abi> max(\n    const simd<T, Abi>& a,\n    const simd<T, Abi>& b) noexcept;"
        },
        {
            "title": "std::experimental::min",
            "path": "en.cppreference.com/w/cpp/experimental/simd/min.html",
            "wgPageName": "cpp/experimental/simd/min",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "template<class T, class Abi>\nsimd<T, Abi> min(\n    const simd<T, Abi>& a,\n    const simd<T, Abi>& b) noexcept;"
        },
        {
            "title": "std::experimental::minmax",
            "path": "en.cppreference.com/w/cpp/experimental/simd/minmax.html",
            "wgPageName": "cpp/experimental/simd/minmax",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "template<class T, class Abi>\nstd::pair<simd<T, Abi>, simd<T, Abi>> minmax(\n    const simd<T, Abi>& a,\n    const simd<T, Abi>& b) noexcept;"
        },
        {
            "title": "std::experimental::simd_abi::native",
            "path": "en.cppreference.com/w/cpp/experimental/simd/native.html",
            "wgPageName": "cpp/experimental/simd/native",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "template<class T>\nusing native = /*implementation-defined*/;"
        },
        {
            "title": "std::experimental::overaligned_tag, std::experimental::overaligned",
            "path": "en.cppreference.com/w/cpp/experimental/simd/overaligned.html",
            "wgPageName": "cpp/experimental/simd/overaligned",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "template<std::size_t N>\nstruct overaligned_tag {};\ntemplate<std::size_t N>\ninline constexpr overaligned_tag<N>\n    overaligned{};"
        },
        {
            "title": "std::experimental::rebind_simd, std::experimental::resize_simd",
            "path": "en.cppreference.com/w/cpp/experimental/simd/rebind_simd.html",
            "wgPageName": "cpp/experimental/simd/rebind_simd",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "template<class T, class V>\nstruct rebind_simd;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::reduce",
            "path": "en.cppreference.com/w/cpp/experimental/simd/reduce.html",
            "wgPageName": "cpp/experimental/simd/reduce",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "template<\n    class T,\n    class Abi,\n    class BinaryOperation = plus<> >\nT reduce(\n    const simd<T, Abi>& v,\n    BinaryOperation binary_op = {});",
            "other_declarations": 6
        },
        {
            "title": "std::experimental::simd_abi::scalar",
            "path": "en.cppreference.com/w/cpp/experimental/simd/scalar.html",
            "wgPageName": "cpp/experimental/simd/scalar",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "using scalar = /*unspecified*/;"
        },
        {
            "title": "std::experimental::simd_cast, std::experimental::static_simd_cast",
            "path": "en.cppreference.com/w/cpp/experimental/simd/simd_cast.html",
            "wgPageName": "cpp/experimental/simd/simd_cast",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "template<class V, class T, class Abi>\n/*see below*/ simd_cast(const simd<T, Abi>& v);",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::simd_mask",
            "path": "en.cppreference.com/w/cpp/experimental/simd/simd_mask.html",
            "wgPageName": "cpp/experimental/simd/simd_mask",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "template<\n    class T,\n    class Abi = simd_abi::compatible<T> >\nclass simd_mask;"
        },
        {
            "title": "std::experimental::simd",
            "path": "en.cppreference.com/w/cpp/experimental/simd/simd.html",
            "wgPageName": "cpp/experimental/simd/simd",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "template<\n    class T,\n    class Abi = simd_abi::compatible<T> >\nclass simd;"
        },
        {
            "title": "std::experimental::split",
            "path": "en.cppreference.com/w/cpp/experimental/simd/split.html",
            "wgPageName": "cpp/experimental/simd/split",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "template<\n    std::size_t... Sizes,\n    class T,\n    class Abi>\nstd::tuple<\n    simd<T, simd_abi::deduce_t<T, Sizes>>...>\nsplit(const simd<T, Abi>& v);",
            "other_declarations": 3
        },
        {
            "title": "std::experimental::vector_aligned_tag, std::experimental::vector_aligned",
            "path": "en.cppreference.com/w/cpp/experimental/simd/vector_aligned.html",
            "wgPageName": "cpp/experimental/simd/vector_aligned",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "struct vector_aligned_tag {};\ninline constexpr vector_aligned_tag\n    vector_aligned{};"
        },
        {
            "title": "std::experimental::where_expression",
            "path": "en.cppreference.com/w/cpp/experimental/simd/where_expression.html",
            "wgPageName": "cpp/experimental/simd/where_expression",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "template<class M, class V>\nclass where_expression;"
        },
        {
            "title": "std::experimental::where",
            "path": "en.cppreference.com/w/cpp/experimental/simd/where.html",
            "wgPageName": "cpp/experimental/simd/where",
            "headers": [
                "<experimental/simd>"
            ],
            "sample_declaration": "template<class T, class Abi>\nwhere_expression<\n    simd_mask<T, Abi>,\n    simd<T, Abi>>\nwhere(\n    const typename simd<T, Abi>::mask_type&\n        mask,\n    simd<T, Abi>& value) noexcept;",
            "other_declarations": 5
        },
        {
            "title": "std::experimental::source_location",
            "path": "en.cppreference.com/w/cpp/experimental/source_location.html",
            "wgPageName": "cpp/experimental/source_location",
            "headers": [
                "<experimental/source_location>"
            ],
            "sample_declaration": "struct source_location;"
        },
        {
            "title": "std::experimental::source_location::column",
            "path": "en.cppreference.com/w/cpp/experimental/source_location/column.html",
            "wgPageName": "cpp/experimental/source_location/column",
            "sample_declaration": "constexpr std::uint_least32_t column()\n    const noexcept;"
        },
        {
            "title": "std::experimental::source_location::current",
            "path": "en.cppreference.com/w/cpp/experimental/source_location/current.html",
            "wgPageName": "cpp/experimental/source_location/current",
            "sample_declaration": "static constexpr source_location\ncurrent() noexcept;"
        },
        {
            "title": "std::experimental::source_location::file_name",
            "path": "en.cppreference.com/w/cpp/experimental/source_location/file_name.html",
            "wgPageName": "cpp/experimental/source_location/file_name",
            "sample_declaration": "constexpr const char* file_name()\n    const noexcept;"
        },
        {
            "title": "std::experimental::source_location::function_name",
            "path": "en.cppreference.com/w/cpp/experimental/source_location/function_name.html",
            "wgPageName": "cpp/experimental/source_location/function_name",
            "sample_declaration": "constexpr const char* function_name()\n    const noexcept;"
        },
        {
            "title": "std::experimental::source_location::line",
            "path": "en.cppreference.com/w/cpp/experimental/source_location/line.html",
            "wgPageName": "cpp/experimental/source_location/line",
            "sample_declaration": "constexpr std::uint_least32_t line()\n    const noexcept;"
        },
        {
            "title": "std::experimental::source_location::source_location",
            "path": "en.cppreference.com/w/cpp/experimental/source_location/source_location.html",
            "wgPageName": "cpp/experimental/source_location/source_location",
            "sample_declaration": "constexpr source_location() noexcept;",
            "other_declarations": 2
        },
        {
            "title": "Mathematical special functions",
            "path": "en.cppreference.com/w/cpp/experimental/special_functions.html",
            "wgPageName": "cpp/experimental/special_functions"
        },
        {
            "title": "std::assoc_laguerre, std::assoc_laguerref, std::assoc_laguerrel",
            "path": "en.cppreference.com/w/cpp/experimental/special_functions/assoc_laguerre.html",
            "wgPageName": "cpp/experimental/special_functions/assoc_laguerre",
            "sample_declaration": "double assoc_laguerre(\n    unsigned int n,\n    unsigned int m,\n    double x);\ndouble assoc_laguerre(\n    unsigned int n,\n    unsigned int m,\n    float x);\ndouble assoc_laguerre(\n    unsigned int n,\n    unsigned int m,\n    long double x);\nfloat assoc_laguerref(\n    unsigned int n,\n    unsigned int m,\n    float x);\nlong double assoc_laguerrel(\n    unsigned int n,\n    unsigned int m,\n    long double x);",
            "other_declarations": 1
        },
        {
            "title": "std::assoc_legendre, std::assoc_legendref, std::assoc_legendrel",
            "path": "en.cppreference.com/w/cpp/experimental/special_functions/assoc_legendre.html",
            "wgPageName": "cpp/experimental/special_functions/assoc_legendre",
            "sample_declaration": "double assoc_legendre(\n    unsigned int n,\n    unsigned int m,\n    double x);\ndouble assoc_legendre(\n    unsigned int n,\n    unsigned int m,\n    float x);\ndouble assoc_legendre(\n    unsigned int n,\n    unsigned int m,\n    long double x);\nfloat assoc_legendref(\n    unsigned int n,\n    unsigned int m,\n    float x);\nlong double assoc_legendrel(\n    unsigned int n,\n    unsigned int m,\n    long double x);",
            "other_declarations": 1
        },
        {
            "title": "std::beta, std::betaf, std::betal",
            "path": "en.cppreference.com/w/cpp/experimental/special_functions/beta.html",
            "wgPageName": "cpp/experimental/special_functions/beta",
            "sample_declaration": "double beta(double x, double y);\nfloat betaf(float x, float y);\nlong double betal(long double x, long double y);",
            "other_declarations": 1
        },
        {
            "title": "std::comp_ellint_1, std::comp_ellint_1f, std::comp_ellint_1l",
            "path": "en.cppreference.com/w/cpp/experimental/special_functions/comp_ellint_1.html",
            "wgPageName": "cpp/experimental/special_functions/comp_ellint_1",
            "sample_declaration": "double comp_ellint_1(double arg);\ndouble comp_ellint_1(float arg);\ndouble comp_ellint_1(long double arg);\nfloat comp_ellint_1f(float arg);\nlong double comp_ellint_1l(long double arg);",
            "other_declarations": 1
        },
        {
            "title": "std::comp_ellint_2, std::comp_ellint_2f, std::comp_ellint_2l",
            "path": "en.cppreference.com/w/cpp/experimental/special_functions/comp_ellint_2.html",
            "wgPageName": "cpp/experimental/special_functions/comp_ellint_2",
            "sample_declaration": "double comp_ellint_2(double arg);\ndouble comp_ellint_2(float arg);\ndouble comp_ellint_2(long double arg);\nfloat comp_ellint_2f(float arg);\nlong double comp_ellint_2l(long double arg);",
            "other_declarations": 1
        },
        {
            "title": "std::comp_ellint_3, std::comp_ellint_3f, std::comp_ellint_3l",
            "path": "en.cppreference.com/w/cpp/experimental/special_functions/comp_ellint_3.html",
            "wgPageName": "cpp/experimental/special_functions/comp_ellint_3",
            "sample_declaration": "double comp_ellint_3(double k, double nu);\nfloat comp_ellint_3(float k, float nu);\nlong double comp_ellint_3(\n    long double k,\n    long double nu);\nfloat comp_ellint_3f(float k, float nu);\nlong double comp_ellint_3l(\n    long double k,\n    long double nu);",
            "other_declarations": 1
        },
        {
            "title": "std::expint, std::expintf, std::expintl",
            "path": "en.cppreference.com/w/cpp/experimental/special_functions/expint.html",
            "wgPageName": "cpp/experimental/special_functions/expint",
            "sample_declaration": "double expint(double arg);\ndouble expint(float arg);\ndouble expint(long double arg);\nfloat expintf(float arg);\nlong double expintl(long double arg);",
            "other_declarations": 1
        },
        {
            "title": "std::hermite, std::hermitef, std::hermitel",
            "path": "en.cppreference.com/w/cpp/experimental/special_functions/hermite.html",
            "wgPageName": "cpp/experimental/special_functions/hermite",
            "sample_declaration": "double hermite(unsigned int n, double x);\ndouble hermite(unsigned int n, float x);\ndouble hermite(unsigned int n, long double x);\nfloat hermitef(unsigned int n, float x);\nlong double hermitel(\n    unsigned int n,\n    long double x);",
            "other_declarations": 1
        },
        {
            "title": "std::laguerre, std::laguerref, std::laguerrel",
            "path": "en.cppreference.com/w/cpp/experimental/special_functions/laguerre.html",
            "wgPageName": "cpp/experimental/special_functions/laguerre",
            "sample_declaration": "double laguerre(unsigned int n, double x);\ndouble laguerre(unsigned int n, float x);\ndouble laguerre(unsigned int n, long double x);\nfloat laguerref(unsigned int n, float x);\nlong double laguerrel(\n    unsigned int n,\n    long double x);",
            "other_declarations": 1
        },
        {
            "title": "std::legendre, std::legendref, std::legendrel",
            "path": "en.cppreference.com/w/cpp/experimental/special_functions/legendre.html",
            "wgPageName": "cpp/experimental/special_functions/legendre",
            "sample_declaration": "double legendre(unsigned int n, double x);\ndouble legendre(unsigned int n, float x);\ndouble legendre(unsigned int n, long double x);\nfloat legendref(unsigned int n, float x);\nlong double legendrel(\n    unsigned int n,\n    long double x);",
            "other_declarations": 1
        },
        {
            "title": "std::riemann_zeta, std::riemann_zetaf, std::riemann_zetal",
            "path": "en.cppreference.com/w/cpp/experimental/special_functions/riemann_zeta.html",
            "wgPageName": "cpp/experimental/special_functions/riemann_zeta",
            "sample_declaration": "double riemann_zeta(double arg);\ndouble riemann_zeta(float arg);\ndouble riemann_zeta(long double arg);\nfloat riemann_zetaf(float arg);\nlong double riemann_zetal(long double arg);",
            "other_declarations": 1
        },
        {
            "title": "Mathematical special functions",
            "path": "en.cppreference.com/w/cpp/experimental/special_math.html",
            "wgPageName": "cpp/experimental/special_functions"
        },
        {
            "title": "std::experimental::pmr::synchronized_pool_resource",
            "path": "en.cppreference.com/w/cpp/experimental/synchronized_pool_resource.html",
            "wgPageName": "cpp/experimental/synchronized_pool_resource",
            "headers": [
                "<experimental/memory_resource>"
            ],
            "sample_declaration": "class synchronized_pool_resource\n    : public memory_resource;"
        },
        {
            "title": "std::experimental::pmr::synchronized_pool_resource::~synchronized_pool_resource",
            "path": "en.cppreference.com/w/cpp/experimental/synchronized_pool_resource/~synchronized_pool_resource.html",
            "wgPageName": "cpp/experimental/synchronized_pool_resource/~synchronized_pool_resource",
            "sample_declaration": "virtual ~synchronized_pool_resource();"
        },
        {
            "title": "std::experimental::pmr::synchronized_pool_resource::do_allocate",
            "path": "en.cppreference.com/w/cpp/experimental/synchronized_pool_resource/do_allocate.html",
            "wgPageName": "cpp/experimental/synchronized_pool_resource/do_allocate",
            "sample_declaration": "virtual void* do_allocate(\n    std::size_t bytes,\n    std::size_t alignment);"
        },
        {
            "title": "std::experimental::pmr::synchronized_pool_resource::do_deallocate",
            "path": "en.cppreference.com/w/cpp/experimental/synchronized_pool_resource/do_deallocate.html",
            "wgPageName": "cpp/experimental/synchronized_pool_resource/do_deallocate",
            "sample_declaration": "virtual void do_deallocate(\n    void* p,\n    std::size_t bytes,\n    std::size_t alignment);"
        },
        {
            "title": "std::experimental::pmr::synchronized_pool_resource::do_is_equal",
            "path": "en.cppreference.com/w/cpp/experimental/synchronized_pool_resource/do_is_equal.html",
            "wgPageName": "cpp/experimental/synchronized_pool_resource/do_is_equal",
            "sample_declaration": "virtual bool do_is_equal(\n    const memory_resource& other)\n    const noexcept;"
        },
        {
            "title": "std::experimental::pmr::synchronized_pool_resource::options",
            "path": "en.cppreference.com/w/cpp/experimental/synchronized_pool_resource/options.html",
            "wgPageName": "cpp/experimental/synchronized_pool_resource/options",
            "sample_declaration": "pool_options options() const;"
        },
        {
            "title": "std::experimental::pmr::synchronized_pool_resource::release",
            "path": "en.cppreference.com/w/cpp/experimental/synchronized_pool_resource/release.html",
            "wgPageName": "cpp/experimental/synchronized_pool_resource/release",
            "sample_declaration": "void release();"
        },
        {
            "title": "std::experimental::pmr::synchronized_pool_resource::synchronized_pool_resource",
            "path": "en.cppreference.com/w/cpp/experimental/synchronized_pool_resource/synchronized_pool_resource.html",
            "wgPageName": "cpp/experimental/synchronized_pool_resource/synchronized_pool_resource",
            "sample_declaration": "synchronized_pool_resource();",
            "other_declarations": 4
        },
        {
            "title": "std::experimental::pmr::synchronized_pool_resource::upstream_resource",
            "path": "en.cppreference.com/w/cpp/experimental/synchronized_pool_resource/upstream_resource.html",
            "wgPageName": "cpp/experimental/synchronized_pool_resource/upstream_resource",
            "sample_declaration": "memory_resource* upstream_resource() const;"
        },
        {
            "title": "std::experimental::to_array",
            "path": "en.cppreference.com/w/cpp/experimental/to_array.html",
            "wgPageName": "cpp/experimental/to_array",
            "headers": [
                "<experimental/array>"
            ],
            "sample_declaration": "template<class T, std::size_t N>\nconstexpr std::array<std::remove_cv_t<T>, N>\n    to_array(T (&a)[N]);"
        },
        {
            "title": "std::experimental::parallel::transform_reduce",
            "path": "en.cppreference.com/w/cpp/experimental/transform_reduce.html",
            "wgPageName": "cpp/experimental/transform_reduce",
            "headers": [
                "<experimental/numeric>"
            ],
            "sample_declaration": "template<\n    class InputIt,\n    class UnaryOp,\n    class T,\n    class BinaryOp>\nT transform_reduce(\n    InputIt first,\n    InputIt last,\n    UnaryOp unary_op,\n    T init,\n    BinaryOp binary_op);",
            "other_declarations": 1
        },
        {
            "title": "Variable templates for type traits (library fundamentals TS)",
            "path": "en.cppreference.com/w/cpp/experimental/type_trait_variable_templates.html",
            "wgPageName": "cpp/experimental/type_trait_variable_templates"
        },
        {
            "title": "std::experimental::unique_resource",
            "path": "en.cppreference.com/w/cpp/experimental/unique_resource.html",
            "wgPageName": "cpp/experimental/unique_resource",
            "headers": [
                "<experimental/scope>"
            ],
            "sample_declaration": "template<class R, class D>\nclass unique_resource;"
        },
        {
            "title": "std::experimental::unique_resource<R, D>::~unique_resource",
            "path": "en.cppreference.com/w/cpp/experimental/unique_resource/~unique_resource.html",
            "wgPageName": "cpp/experimental/unique_resource/~unique_resource",
            "sample_declaration": "~unique_resource();"
        },
        {
            "title": "deduction guides for std::experimental::unique_resource",
            "path": "en.cppreference.com/w/cpp/experimental/unique_resource/deduction_guides.html",
            "wgPageName": "cpp/experimental/unique_resource/deduction_guides",
            "headers": [
                "<experimental/scope>"
            ],
            "sample_declaration": "template<class R, class D>\nunique_resource(R, D) -> unique_resource<R, D>;"
        },
        {
            "title": "std::experimental::unique_resource<R, D>::get_deleter",
            "path": "en.cppreference.com/w/cpp/experimental/unique_resource/get_deleter.html",
            "wgPageName": "cpp/experimental/unique_resource/get_deleter",
            "sample_declaration": "const D& get_deleter() const noexcept;"
        },
        {
            "title": "std::experimental::unique_resource<R, D>::get",
            "path": "en.cppreference.com/w/cpp/experimental/unique_resource/get.html",
            "wgPageName": "cpp/experimental/unique_resource/get",
            "sample_declaration": "const R& get() const noexcept;"
        },
        {
            "title": "std::experimental::make_unique_resource_checked",
            "path": "en.cppreference.com/w/cpp/experimental/unique_resource/make_unique_resource_checked.html",
            "wgPageName": "cpp/experimental/unique_resource/make_unique_resource_checked",
            "headers": [
                "<experimental/scope>"
            ],
            "sample_declaration": "template<\n    class R,\n    class D,\n    class S = std::decay_t<R>>\nstd::experimental::unique_resource<\n    std::decay_t<R>,\n    std::decay_t<D>>\nmake_unique_resource_checked(\n    R&& r,\n    const S& invalid,\n    D&& d) noexcept(/*see below*/);"
        },
        {
            "title": "std::experimental::unique_resource<R, D>::operator*, std::experimental::unique_resource<R, D>::operator->",
            "path": "en.cppreference.com/w/cpp/experimental/unique_resource/operator*.html",
            "wgPageName": "cpp/experimental/unique_resource/operator*",
            "sample_declaration": "std::add_lvalue_reference_t<\n    std::remove_pointer_t<R>>\noperator*() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::unique_resource<R, D>::operator=",
            "path": "en.cppreference.com/w/cpp/experimental/unique_resource/operator=.html",
            "wgPageName": "cpp/experimental/unique_resource/operator=",
            "sample_declaration": "unique_resource&\noperator=(unique_resource&& other) noexcept(\n    /*see below*/);"
        },
        {
            "title": "std::experimental::unique_resource<R, D>::release",
            "path": "en.cppreference.com/w/cpp/experimental/unique_resource/release.html",
            "wgPageName": "cpp/experimental/unique_resource/release",
            "sample_declaration": "void release() noexcept;"
        },
        {
            "title": "std::experimental::unique_resource<R, D>::reset",
            "path": "en.cppreference.com/w/cpp/experimental/unique_resource/reset.html",
            "wgPageName": "cpp/experimental/unique_resource/reset",
            "sample_declaration": "void reset() noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::unique_resource<R, D>::unique_resource",
            "path": "en.cppreference.com/w/cpp/experimental/unique_resource/unique_resource.html",
            "wgPageName": "cpp/experimental/unique_resource/unique_resource",
            "sample_declaration": "unique_resource();",
            "other_declarations": 2
        },
        {
            "title": "std::experimental::erase_if (std::unordered_map)",
            "path": "en.cppreference.com/w/cpp/experimental/unordered_map/erase_if.html",
            "wgPageName": "cpp/experimental/unordered_map/erase_if",
            "headers": [
                "<experimental/unordered_map>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class T,\n    class Hash,\n    class KeyEqual,\n    class Alloc,\n    class Pred>\nvoid erase_if(\n    std::unordered_map<\n        Key,\n        T,\n        Hash,\n        KeyEqual,\n        Alloc>& c,\n    Pred pred);"
        },
        {
            "title": "std::experimental::erase_if (std::unordered_multimap)",
            "path": "en.cppreference.com/w/cpp/experimental/unordered_multimap/erase_if.html",
            "wgPageName": "cpp/experimental/unordered_multimap/erase_if",
            "headers": [
                "<experimental/unordered_map>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class T,\n    class Hash,\n    class KeyEqual,\n    class Alloc,\n    class Pred>\nvoid erase_if(\n    std::unordered_multimap<\n        Key,\n        T,\n        Hash,\n        KeyEqual,\n        Alloc>& c,\n    Pred pred);"
        },
        {
            "title": "std::experimental::erase_if (std::unordered_multiset)",
            "path": "en.cppreference.com/w/cpp/experimental/unordered_multiset/erase_if.html",
            "wgPageName": "cpp/experimental/unordered_multiset/erase_if",
            "headers": [
                "<experimental/unordered_set>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class Hash,\n    class KeyEqual,\n    class Alloc,\n    class Pred>\nvoid erase_if(\n    std::unordered_multiset<\n        Key,\n        Hash,\n        KeyEqual,\n        Alloc>& c,\n    Pred pred);"
        },
        {
            "title": "std::experimental::erase_if (std::unordered_set)",
            "path": "en.cppreference.com/w/cpp/experimental/unordered_set/erase_if.html",
            "wgPageName": "cpp/experimental/unordered_set/erase_if",
            "headers": [
                "<experimental/unordered_set>"
            ],
            "sample_declaration": "template<\n    class Key,\n    class Hash,\n    class KeyEqual,\n    class Alloc,\n    class Pred>\nvoid erase_if(\n    std::unordered_set<\n        Key,\n        Hash,\n        KeyEqual,\n        Alloc>& c,\n    Pred pred);"
        },
        {
            "title": "std::experimental::pmr::unsynchronized_pool_resource",
            "path": "en.cppreference.com/w/cpp/experimental/unsynchronized_pool_resource.html",
            "wgPageName": "cpp/experimental/unsynchronized_pool_resource",
            "headers": [
                "<experimental/memory_resource>"
            ],
            "sample_declaration": "class unsynchronized_pool_resource\n    : public memory_resource;"
        },
        {
            "title": "std::experimental::pmr::unsynchronized_pool_resource::~unsynchronized_pool_resource",
            "path": "en.cppreference.com/w/cpp/experimental/unsynchronized_pool_resource/~unsynchronized_pool_resource.html",
            "wgPageName": "cpp/experimental/unsynchronized_pool_resource/~unsynchronized_pool_resource",
            "sample_declaration": "virtual ~unsynchronized_pool_resource();"
        },
        {
            "title": "std::experimental::pmr::unsynchronized_pool_resource::do_allocate",
            "path": "en.cppreference.com/w/cpp/experimental/unsynchronized_pool_resource/do_allocate.html",
            "wgPageName": "cpp/experimental/unsynchronized_pool_resource/do_allocate",
            "sample_declaration": "virtual void* do_allocate(\n    std::size_t bytes,\n    std::size_t alignment);"
        },
        {
            "title": "std::experimental::pmr::unsynchronized_pool_resource::do_deallocate",
            "path": "en.cppreference.com/w/cpp/experimental/unsynchronized_pool_resource/do_deallocate.html",
            "wgPageName": "cpp/experimental/unsynchronized_pool_resource/do_deallocate",
            "sample_declaration": "virtual void do_deallocate(\n    void* p,\n    std::size_t bytes,\n    std::size_t alignment);"
        },
        {
            "title": "std::experimental::pmr::unsynchronized_pool_resource::do_is_equal",
            "path": "en.cppreference.com/w/cpp/experimental/unsynchronized_pool_resource/do_is_equal.html",
            "wgPageName": "cpp/experimental/unsynchronized_pool_resource/do_is_equal",
            "sample_declaration": "virtual bool do_is_equal(\n    const memory_resource& other)\n    const noexcept;"
        },
        {
            "title": "std::experimental::pmr::unsynchronized_pool_resource::options",
            "path": "en.cppreference.com/w/cpp/experimental/unsynchronized_pool_resource/options.html",
            "wgPageName": "cpp/experimental/unsynchronized_pool_resource/options",
            "sample_declaration": "pool_options options() const;"
        },
        {
            "title": "std::experimental::pmr::unsynchronized_pool_resource::release",
            "path": "en.cppreference.com/w/cpp/experimental/unsynchronized_pool_resource/release.html",
            "wgPageName": "cpp/experimental/unsynchronized_pool_resource/release",
            "sample_declaration": "void release();"
        },
        {
            "title": "std::experimental::pmr::unsynchronized_pool_resource::unsynchronized_pool_resource",
            "path": "en.cppreference.com/w/cpp/experimental/unsynchronized_pool_resource/unsynchronized_pool_resource.html",
            "wgPageName": "cpp/experimental/unsynchronized_pool_resource/unsynchronized_pool_resource",
            "sample_declaration": "unsynchronized_pool_resource();",
            "other_declarations": 4
        },
        {
            "title": "std::experimental::pmr::unsynchronized_pool_resource::upstream_resource",
            "path": "en.cppreference.com/w/cpp/experimental/unsynchronized_pool_resource/upstream_resource.html",
            "wgPageName": "cpp/experimental/unsynchronized_pool_resource/upstream_resource",
            "sample_declaration": "memory_resource* upstream_resource() const;"
        },
        {
            "title": "std::experimental::erase_if (std::vector)",
            "path": "en.cppreference.com/w/cpp/experimental/vector/erase_if.html",
            "wgPageName": "cpp/experimental/vector/erase_if",
            "headers": [
                "<experimental/vector>"
            ],
            "sample_declaration": "template<class T, class Alloc, class Pred>\nvoid erase_if(\n    std::vector<T, Alloc>& c,\n    Pred pred);"
        },
        {
            "title": "std::experimental::erase (std::vector)",
            "path": "en.cppreference.com/w/cpp/experimental/vector/erase.html",
            "wgPageName": "cpp/experimental/vector/erase",
            "headers": [
                "<experimental/vector>"
            ],
            "sample_declaration": "template<class T, class A, class U>\nvoid erase(\n    std::vector<T, A>& c,\n    const U& value);"
        },
        {
            "title": "std::experimental::void_t",
            "path": "en.cppreference.com/w/cpp/experimental/void_t.html",
            "wgPageName": "cpp/experimental/void_t",
            "headers": [
                "<experimental/type_traits>"
            ],
            "sample_declaration": "template<class...>\nusing void_t = void;"
        },
        {
            "title": "std::experimental::weak_ptr",
            "path": "en.cppreference.com/w/cpp/experimental/weak_ptr.html",
            "wgPageName": "cpp/experimental/weak_ptr",
            "headers": [
                "<experimental/memory>"
            ],
            "sample_declaration": "template<class T>\nclass weak_ptr;"
        },
        {
            "title": "std::experimental::weak_ptr<T>::weak_ptr",
            "path": "en.cppreference.com/w/cpp/experimental/weak_ptr/weak_ptr.html",
            "wgPageName": "cpp/experimental/weak_ptr/weak_ptr",
            "sample_declaration": "constexpr weak_ptr() noexcept;",
            "other_declarations": 5
        },
        {
            "title": "std::experimental::when_all",
            "path": "en.cppreference.com/w/cpp/experimental/when_all.html",
            "wgPageName": "cpp/experimental/when_all",
            "headers": [
                "<experimental/future>"
            ],
            "sample_declaration": "template<class InputIt>\nauto when_all(InputIt first, InputIt last)\n    -> future<std::vector<\n        typename std::iterator_traits<\n            InputIt>::value_type>>;",
            "other_declarations": 1
        },
        {
            "title": "std::experimental::when_any",
            "path": "en.cppreference.com/w/cpp/experimental/when_any.html",
            "wgPageName": "cpp/experimental/when_any",
            "headers": [
                "<experimental/future>"
            ],
            "sample_declaration": "template<class Sequence>\nstruct when_any_result {\n  std::size_t index;\n  Sequence futures;\n};",
            "other_declarations": 2
        },
        {
            "title": "Feature testing (since C++20)",
            "path": "en.cppreference.com/w/cpp/feature_test.html",
            "wgPageName": "cpp/feature_test"
        },
        {
            "title": "Filesystem library (since C++17)",
            "path": "en.cppreference.com/w/cpp/filesystem.html",
            "wgPageName": "cpp/filesystem"
        },
        {
            "title": "std::filesystem::absolute",
            "path": "en.cppreference.com/w/cpp/filesystem/absolute.html",
            "wgPageName": "cpp/filesystem/absolute",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "path absolute(const std::filesystem::path& p);\npath absolute(\n    const std::filesystem::path& p,\n    std::error_code& ec);"
        },
        {
            "title": "std::filesystem::canonical, std::filesystem::weakly_canonical",
            "path": "en.cppreference.com/w/cpp/filesystem/canonical.html",
            "wgPageName": "cpp/filesystem/canonical",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "path canonical(const std::filesystem::path& p);",
            "other_declarations": 3
        },
        {
            "title": "std::filesystem::copy_file",
            "path": "en.cppreference.com/w/cpp/filesystem/copy_file.html",
            "wgPageName": "cpp/filesystem/copy_file",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "bool copy_file(\n    const std::filesystem::path& from,\n    const std::filesystem::path& to);\nbool copy_file(\n    const std::filesystem::path& from,\n    const std::filesystem::path& to,\n    std::error_code& ec);",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::copy_options",
            "path": "en.cppreference.com/w/cpp/filesystem/copy_options.html",
            "wgPageName": "cpp/filesystem/copy_options",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "enum class copy_options {\n  none = /* unspecified */,\n  skip_existing = /* unspecified */,\n  overwrite_existing = /* unspecified */,\n  update_existing = /* unspecified */,\n  recursive = /* unspecified */,\n  copy_symlinks = /* unspecified */,\n  skip_symlinks = /* unspecified */,\n  directories_only = /* unspecified */,\n  create_symlinks = /* unspecified */,\n  create_hard_links = /* unspecified */\n};"
        },
        {
            "title": "std::filesystem::copy_symlink",
            "path": "en.cppreference.com/w/cpp/filesystem/copy_symlink.html",
            "wgPageName": "cpp/filesystem/copy_symlink",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "void copy_symlink(\n    const std::filesystem::path& from,\n    const std::filesystem::path& to);",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::copy",
            "path": "en.cppreference.com/w/cpp/filesystem/copy.html",
            "wgPageName": "cpp/filesystem/copy",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "void copy(\n    const std::filesystem::path& from,\n    const std::filesystem::path& to);\nvoid copy(\n    const std::filesystem::path& from,\n    const std::filesystem::path& to,\n    std::error_code& ec);",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::create_directory, std::filesystem::create_directories",
            "path": "en.cppreference.com/w/cpp/filesystem/create_directory.html",
            "wgPageName": "cpp/filesystem/create_directory",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "bool create_directory(\n    const std::filesystem::path& p);\nbool create_directory(\n    const std::filesystem::path& p,\n    std::error_code& ec) noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::filesystem::create_hard_link",
            "path": "en.cppreference.com/w/cpp/filesystem/create_hard_link.html",
            "wgPageName": "cpp/filesystem/create_hard_link",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "void create_hard_link(\n    const std::filesystem::path& target,\n    const std::filesystem::path& link);\nvoid create_hard_link(\n    const std::filesystem::path& target,\n    const std::filesystem::path& link,\n    std::error_code& ec) noexcept;"
        },
        {
            "title": "std::filesystem::create_symlink, std::filesystem::create_directory_symlink",
            "path": "en.cppreference.com/w/cpp/filesystem/create_symlink.html",
            "wgPageName": "cpp/filesystem/create_symlink",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "void create_symlink(\n    const std::filesystem::path& target,\n    const std::filesystem::path& link);\nvoid create_symlink(\n    const std::filesystem::path& target,\n    const std::filesystem::path& link,\n    std::error_code& ec) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::current_path",
            "path": "en.cppreference.com/w/cpp/filesystem/current_path.html",
            "wgPageName": "cpp/filesystem/current_path",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "path current_path();",
            "other_declarations": 3
        },
        {
            "title": "std::filesystem::directory_entry",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_entry.html",
            "wgPageName": "cpp/filesystem/directory_entry",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "class directory_entry;"
        },
        {
            "title": "std::filesystem::directory_entry::assign",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_entry/assign.html",
            "wgPageName": "cpp/filesystem/directory_entry/assign",
            "sample_declaration": "void assign(const std::filesystem::path& p);\nvoid assign(\n    const std::filesystem::path& p,\n    std::error_code& ec);"
        },
        {
            "title": "std::filesystem::directory_entry::directory_entry",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_entry/directory_entry.html",
            "wgPageName": "cpp/filesystem/directory_entry/directory_entry",
            "sample_declaration": "directory_entry() noexcept = default;",
            "other_declarations": 3
        },
        {
            "title": "std::filesystem::directory_entry::exists",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_entry/exists.html",
            "wgPageName": "cpp/filesystem/directory_entry/exists",
            "sample_declaration": "bool exists() const;\nbool exists(std::error_code& ec) const noexcept;"
        },
        {
            "title": "std::filesystem::directory_entry::file_size",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_entry/file_size.html",
            "wgPageName": "cpp/filesystem/directory_entry/file_size",
            "sample_declaration": "std::uintmax_t file_size() const;\nstd::uintmax_t file_size(\n    std::error_code& ec) const noexcept;"
        },
        {
            "title": "std::filesystem::directory_entry::hard_link_count",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_entry/hard_link_count.html",
            "wgPageName": "cpp/filesystem/directory_entry/hard_link_count",
            "sample_declaration": "std::uintmax_t hard_link_count() const;\nstd::uintmax_t hard_link_count(\n    std::error_code& ec) const noexcept;"
        },
        {
            "title": "std::filesystem::directory_entry::is_block_file",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_entry/is_block_file.html",
            "wgPageName": "cpp/filesystem/directory_entry/is_block_file",
            "sample_declaration": "bool is_block_file() const;\nbool is_block_file(\n    std::error_code& ec) const noexcept;"
        },
        {
            "title": "std::filesystem::directory_entry::is_character_file",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_entry/is_character_file.html",
            "wgPageName": "cpp/filesystem/directory_entry/is_character_file",
            "sample_declaration": "bool is_character_file() const;\nbool is_character_file(\n    std::error_code& ec) const noexcept;"
        },
        {
            "title": "std::filesystem::directory_entry::is_directory",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_entry/is_directory.html",
            "wgPageName": "cpp/filesystem/directory_entry/is_directory",
            "sample_declaration": "bool is_directory() const;\nbool is_directory(\n    std::error_code& ec) const noexcept;"
        },
        {
            "title": "std::filesystem::directory_entry::is_fifo",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_entry/is_fifo.html",
            "wgPageName": "cpp/filesystem/directory_entry/is_fifo",
            "sample_declaration": "bool is_fifo() const;\nbool is_fifo(\n    std::error_code& ec) const noexcept;"
        },
        {
            "title": "std::filesystem::directory_entry::is_other",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_entry/is_other.html",
            "wgPageName": "cpp/filesystem/directory_entry/is_other",
            "sample_declaration": "bool is_other() const;\nbool is_other(\n    std::error_code& ec) const noexcept;"
        },
        {
            "title": "std::filesystem::directory_entry::is_regular_file",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_entry/is_regular_file.html",
            "wgPageName": "cpp/filesystem/directory_entry/is_regular_file",
            "sample_declaration": "bool is_regular_file() const;\nbool is_regular_file(\n    std::error_code& ec) const noexcept;"
        },
        {
            "title": "std::filesystem::directory_entry::is_socket",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_entry/is_socket.html",
            "wgPageName": "cpp/filesystem/directory_entry/is_socket",
            "sample_declaration": "bool is_socket() const;\nbool is_socket(\n    std::error_code& ec) const noexcept;"
        },
        {
            "title": "std::filesystem::directory_entry::is_symlink",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_entry/is_symlink.html",
            "wgPageName": "cpp/filesystem/directory_entry/is_symlink",
            "sample_declaration": "bool is_symlink() const;\nbool is_symlink(\n    std::error_code& ec) const noexcept;"
        },
        {
            "title": "std::filesystem::directory_entry::last_write_time",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_entry/last_write_time.html",
            "wgPageName": "cpp/filesystem/directory_entry/last_write_time",
            "sample_declaration": "std::filesystem::file_time_type\nlast_write_time() const;\nstd::filesystem::file_time_type last_write_time(\n    std::error_code& ec) const noexcept;"
        },
        {
            "title": "std::filesystem::directory_entry::operator==,!=,<,<=,>,>=,<=>",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_entry/operator_cmp.html",
            "wgPageName": "cpp/filesystem/directory_entry/operator_cmp",
            "sample_declaration": "bool operator==(\n    const directory_entry& rhs) const noexcept;",
            "other_declarations": 6
        },
        {
            "title": "operator<<(std::filesystem::directory_entry)",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_entry/operator_ltlt.html",
            "wgPageName": "cpp/filesystem/directory_entry/operator_ltlt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const directory_entry& d);"
        },
        {
            "title": "std::filesystem::directory_entry::operator=",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_entry/operator=.html",
            "wgPageName": "cpp/filesystem/directory_entry/operator=",
            "sample_declaration": "directory_entry& operator=(\n    const directory_entry& other) = default;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::directory_entry::path",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_entry/path.html",
            "wgPageName": "cpp/filesystem/directory_entry/path",
            "sample_declaration": "const std::filesystem::path& path()\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::directory_entry::refresh",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_entry/refresh.html",
            "wgPageName": "cpp/filesystem/directory_entry/refresh",
            "sample_declaration": "void refresh();\nvoid refresh(std::error_code& ec) noexcept;"
        },
        {
            "title": "std::filesystem::directory_entry::replace_filename",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_entry/replace_filename.html",
            "wgPageName": "cpp/filesystem/directory_entry/replace_filename",
            "sample_declaration": "void replace_filename(\n    const std::filesystem::path& p);\nvoid replace_filename(\n    const std::filesystem::path& p,\n    std::error_code& ec);"
        },
        {
            "title": "std::filesystem::directory_entry::status, std::filesystem::directory_entry::symlink_status",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_entry/status.html",
            "wgPageName": "cpp/filesystem/directory_entry/status",
            "sample_declaration": "std::filesystem::file_status status() const;\nstd::filesystem::file_status status(\n    std::error_code& ec) const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::directory_iterator",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_iterator.html",
            "wgPageName": "cpp/filesystem/directory_iterator",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "class directory_iterator;"
        },
        {
            "title": "std::filesystem::begin(directory_iterator), std::filesystem::end(directory_iterator)",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_iterator/begin.html",
            "wgPageName": "cpp/filesystem/directory_iterator/begin",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "directory_iterator begin(\n    directory_iterator iter) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::directory_iterator::directory_iterator",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_iterator/directory_iterator.html",
            "wgPageName": "cpp/filesystem/directory_iterator/directory_iterator",
            "sample_declaration": "directory_iterator() noexcept;",
            "other_declarations": 6
        },
        {
            "title": "std::filesystem::directory_iterator::operator++, std::filesystem::directory_iterator::increment",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_iterator/increment.html",
            "wgPageName": "cpp/filesystem/directory_iterator/increment",
            "sample_declaration": "directory_iterator& operator++();\ndirectory_iterator& increment(\n    std::error_code& ec);"
        },
        {
            "title": "std::filesystem::directory_iterator::operator*, std::filesystem::directory_iterator::operator->",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_iterator/operator*.html",
            "wgPageName": "cpp/filesystem/directory_iterator/operator*",
            "sample_declaration": "const std::filesystem::directory_entry&\noperator*() const;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::directory_iterator::operator=",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_iterator/operator=.html",
            "wgPageName": "cpp/filesystem/directory_iterator/operator=",
            "sample_declaration": "directory_iterator& operator=(\n    const directory_iterator&) = default;\ndirectory_iterator& operator=(\n    directory_iterator&&) = default;"
        },
        {
            "title": "std::filesystem::directory_options",
            "path": "en.cppreference.com/w/cpp/filesystem/directory_options.html",
            "wgPageName": "cpp/filesystem/directory_options",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "enum class directory_options {\n  none = /* unspecified */,\n  follow_directory_symlink = /* unspecified */,\n  skip_permission_denied = /* unspecified */\n};"
        },
        {
            "title": "std::filesystem::equivalent",
            "path": "en.cppreference.com/w/cpp/filesystem/equivalent.html",
            "wgPageName": "cpp/filesystem/equivalent",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "bool equivalent(\n    const std::filesystem::path& p1,\n    const std::filesystem::path& p2);\nbool equivalent(\n    const std::filesystem::path& p1,\n    const std::filesystem::path& p2,\n    std::error_code& ec) noexcept;"
        },
        {
            "title": "std::filesystem::exists",
            "path": "en.cppreference.com/w/cpp/filesystem/exists.html",
            "wgPageName": "cpp/filesystem/exists",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "bool exists(\n    std::filesystem::file_status s) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::file_size",
            "path": "en.cppreference.com/w/cpp/filesystem/file_size.html",
            "wgPageName": "cpp/filesystem/file_size",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "std::uintmax_t file_size(\n    const std::filesystem::path& p);\nstd::uintmax_t file_size(\n    const std::filesystem::path& p,\n    std::error_code& ec) noexcept;"
        },
        {
            "title": "std::filesystem::file_status",
            "path": "en.cppreference.com/w/cpp/filesystem/file_status.html",
            "wgPageName": "cpp/filesystem/file_status",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "class file_status;"
        },
        {
            "title": "std::filesystem::file_status::file_status",
            "path": "en.cppreference.com/w/cpp/filesystem/file_status/file_status.html",
            "wgPageName": "cpp/filesystem/file_status/file_status",
            "sample_declaration": "file_status() noexcept\n    : file_status(\n          std::filesystem::file_type::none) {}",
            "other_declarations": 3
        },
        {
            "title": "std::filesystem::file_status::operator=",
            "path": "en.cppreference.com/w/cpp/filesystem/file_status/operator=.html",
            "wgPageName": "cpp/filesystem/file_status/operator=",
            "sample_declaration": "file_status& operator=(\n    const file_status& other) noexcept =\n    default;",
            "other_declarations": 1
        },
        {
            "title": "operator==(std::filesystem::file_status)",
            "path": "en.cppreference.com/w/cpp/filesystem/file_status/operator==.html",
            "wgPageName": "cpp/filesystem/file_status/operator==",
            "sample_declaration": "friend bool operator==(\n    const file_status& lhs,\n    const file_status& rhs) noexcept;"
        },
        {
            "title": "std::filesystem::file_status::permissions",
            "path": "en.cppreference.com/w/cpp/filesystem/file_status/permissions.html",
            "wgPageName": "cpp/filesystem/file_status/permissions",
            "sample_declaration": "std::filesystem::perms permissions()\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::file_status::type",
            "path": "en.cppreference.com/w/cpp/filesystem/file_status/type.html",
            "wgPageName": "cpp/filesystem/file_status/type",
            "sample_declaration": "std::filesystem::file_type type()\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::file_time_type",
            "path": "en.cppreference.com/w/cpp/filesystem/file_time_type.html",
            "wgPageName": "cpp/filesystem/file_time_type",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "using file_time_type =\n    std::chrono::time_point</*trivial-clock*/>;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::file_type",
            "path": "en.cppreference.com/w/cpp/filesystem/file_type.html",
            "wgPageName": "cpp/filesystem/file_type",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "enum class file_type {\n  none = /* unspecified */,\n  not_found = /* unspecified */,\n  regular = /* unspecified */,\n  directory = /* unspecified */,\n  symlink = /* unspecified */,\n  block = /* unspecified */,\n  character = /* unspecified */,\n  fifo = /* unspecified */,\n  socket = /* unspecified */,\n  unknown = /* unspecified */,\n  /* implementation-defined */\n};"
        },
        {
            "title": "std::filesystem::filesystem_error",
            "path": "en.cppreference.com/w/cpp/filesystem/filesystem_error.html",
            "wgPageName": "cpp/filesystem/filesystem_error",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "class filesystem_error;"
        },
        {
            "title": "std::filesystem::filesystem_error::filesystem_error",
            "path": "en.cppreference.com/w/cpp/filesystem/filesystem_error/filesystem_error.html",
            "wgPageName": "cpp/filesystem/filesystem_error/filesystem_error",
            "sample_declaration": "filesystem_error(\n    const std::string& what_arg,\n    std::error_code ec);",
            "other_declarations": 3
        },
        {
            "title": "std::filesystem::filesystem_error::operator=",
            "path": "en.cppreference.com/w/cpp/filesystem/filesystem_error/operator=.html",
            "wgPageName": "cpp/filesystem/filesystem_error/operator=",
            "sample_declaration": "filesystem_error& operator=(\n    const filesystem_error& other) noexcept;"
        },
        {
            "title": "std::filesystem::filesystem_error::path1, std::filesystem::filesystem_error::path2",
            "path": "en.cppreference.com/w/cpp/filesystem/filesystem_error/path.html",
            "wgPageName": "cpp/filesystem/filesystem_error/path",
            "sample_declaration": "const std::filesystem::path& path1()\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::filesystem_error::what",
            "path": "en.cppreference.com/w/cpp/filesystem/filesystem_error/what.html",
            "wgPageName": "cpp/filesystem/filesystem_error/what",
            "sample_declaration": "const char* what() const noexcept override;"
        },
        {
            "title": "std::filesystem::hard_link_count",
            "path": "en.cppreference.com/w/cpp/filesystem/hard_link_count.html",
            "wgPageName": "cpp/filesystem/hard_link_count",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "std::uintmax_t hard_link_count(\n    const std::filesystem::path& p);\nstd::uintmax_t hard_link_count(\n    const std::filesystem::path& p,\n    std::error_code& ec) noexcept;"
        },
        {
            "title": "std::filesystem::is_block_file",
            "path": "en.cppreference.com/w/cpp/filesystem/is_block_file.html",
            "wgPageName": "cpp/filesystem/is_block_file",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "bool is_block_file(\n    std::filesystem::file_status s) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::is_character_file",
            "path": "en.cppreference.com/w/cpp/filesystem/is_character_file.html",
            "wgPageName": "cpp/filesystem/is_character_file",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "bool is_character_file(\n    std::filesystem::file_status s) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::is_directory",
            "path": "en.cppreference.com/w/cpp/filesystem/is_directory.html",
            "wgPageName": "cpp/filesystem/is_directory",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "bool is_directory(\n    std::filesystem::file_status s) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::is_empty",
            "path": "en.cppreference.com/w/cpp/filesystem/is_empty.html",
            "wgPageName": "cpp/filesystem/is_empty",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "bool is_empty(const std::filesystem::path& p);\nbool is_empty(\n    const std::filesystem::path& p,\n    std::error_code& ec);"
        },
        {
            "title": "std::filesystem::is_fifo",
            "path": "en.cppreference.com/w/cpp/filesystem/is_fifo.html",
            "wgPageName": "cpp/filesystem/is_fifo",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "bool is_fifo(\n    std::filesystem::file_status s) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::is_other",
            "path": "en.cppreference.com/w/cpp/filesystem/is_other.html",
            "wgPageName": "cpp/filesystem/is_other",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "bool is_other(\n    std::filesystem::file_status s) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::is_regular_file",
            "path": "en.cppreference.com/w/cpp/filesystem/is_regular_file.html",
            "wgPageName": "cpp/filesystem/is_regular_file",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "bool is_regular_file(\n    std::filesystem::file_status s) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::is_socket",
            "path": "en.cppreference.com/w/cpp/filesystem/is_socket.html",
            "wgPageName": "cpp/filesystem/is_socket",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "bool is_socket(\n    std::filesystem::file_status s) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::is_symlink",
            "path": "en.cppreference.com/w/cpp/filesystem/is_symlink.html",
            "wgPageName": "cpp/filesystem/is_symlink",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "bool is_symlink(\n    std::filesystem::file_status s) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::last_write_time",
            "path": "en.cppreference.com/w/cpp/filesystem/last_write_time.html",
            "wgPageName": "cpp/filesystem/last_write_time",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "std::filesystem::file_time_type last_write_time(\n    const std::filesystem::path& p);\nstd::filesystem::file_time_type last_write_time(\n    const std::filesystem::path& p,\n    std::error_code& ec) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::path",
            "path": "en.cppreference.com/w/cpp/filesystem/path.html",
            "wgPageName": "cpp/filesystem/path",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "class path;"
        },
        {
            "title": "std::filesystem::path::~path",
            "path": "en.cppreference.com/w/cpp/filesystem/path/~path.html",
            "wgPageName": "cpp/filesystem/path/~path",
            "sample_declaration": "~path();"
        },
        {
            "title": "std::filesystem::path::append, std::filesystem::path::operator/=",
            "path": "en.cppreference.com/w/cpp/filesystem/path/append.html",
            "wgPageName": "cpp/filesystem/path/append",
            "sample_declaration": "path& operator/=(const path& p);",
            "other_declarations": 3
        },
        {
            "title": "std::filesystem::path::assign",
            "path": "en.cppreference.com/w/cpp/filesystem/path/assign.html",
            "wgPageName": "cpp/filesystem/path/assign",
            "sample_declaration": "path& assign(string_type&& source);",
            "other_declarations": 2
        },
        {
            "title": "std::filesystem::path::begin, std::filesystem::path::end",
            "path": "en.cppreference.com/w/cpp/filesystem/path/begin.html",
            "wgPageName": "cpp/filesystem/path/begin",
            "sample_declaration": "iterator begin() const;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::path::clear",
            "path": "en.cppreference.com/w/cpp/filesystem/path/clear.html",
            "wgPageName": "cpp/filesystem/path/clear",
            "sample_declaration": "void clear() noexcept;"
        },
        {
            "title": "std::filesystem::path::compare",
            "path": "en.cppreference.com/w/cpp/filesystem/path/compare.html",
            "wgPageName": "cpp/filesystem/path/compare",
            "sample_declaration": "int compare(const path& p) const noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::filesystem::path::concat, std::filesystem::path::operator+=",
            "path": "en.cppreference.com/w/cpp/filesystem/path/concat.html",
            "wgPageName": "cpp/filesystem/path/concat",
            "sample_declaration": "path& operator+=(const path& p);",
            "other_declarations": 7
        },
        {
            "title": "std::filesystem::path::empty",
            "path": "en.cppreference.com/w/cpp/filesystem/path/empty.html",
            "wgPageName": "cpp/filesystem/path/empty",
            "sample_declaration": "bool empty() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::path::extension",
            "path": "en.cppreference.com/w/cpp/filesystem/path/extension.html",
            "wgPageName": "cpp/filesystem/path/extension",
            "sample_declaration": "path extension() const;"
        },
        {
            "title": "std::filesystem::path::filename",
            "path": "en.cppreference.com/w/cpp/filesystem/path/filename.html",
            "wgPageName": "cpp/filesystem/path/filename",
            "sample_declaration": "path filename() const;"
        },
        {
            "title": "std::filesystem::path::format",
            "path": "en.cppreference.com/w/cpp/filesystem/path/format.html",
            "wgPageName": "cpp/filesystem/path/format",
            "sample_declaration": "enum format {\n  native_format,\n  generic_format,\n  auto_format\n};"
        },
        {
            "title": "std::filesystem::path::generic_string, std::filesystem::path::generic_wstring, std::filesystem::path::generic_u8string, std::filesystem::path::generic_u16string, std::filesystem::path::generic_u32string",
            "path": "en.cppreference.com/w/cpp/filesystem/path/generic_string.html",
            "wgPageName": "cpp/filesystem/path/generic_string",
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT>,\n    class Alloc = std::allocator<CharT> >\nstd::basic_string<CharT, Traits, Alloc>\ngeneric_string(const Alloc& a = Alloc()) const;",
            "other_declarations": 6
        },
        {
            "title": "std::filesystem::path::has_root_path, std::filesystem::path::has_root_name, std::filesystem::path::has_root_directory, std::filesystem::path::has_relative_path, std::filesystem::path::has_parent_path, std::filesystem::path::has_filename, std::filesystem::path::has_stem, std::filesystem::path::has_extension",
            "path": "en.cppreference.com/w/cpp/filesystem/path/has_path.html",
            "wgPageName": "cpp/filesystem/path/has_path",
            "sample_declaration": "bool has_root_path() const;",
            "other_declarations": 7
        },
        {
            "title": "std::filesystem::hash_value",
            "path": "en.cppreference.com/w/cpp/filesystem/path/hash_value.html",
            "wgPageName": "cpp/filesystem/path/hash_value",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "std::size_t hash_value(\n    const std::filesystem::path& p) noexcept;"
        },
        {
            "title": "std::hash<std::filesystem::path>",
            "path": "en.cppreference.com/w/cpp/filesystem/path/hash.html",
            "wgPageName": "cpp/filesystem/path/hash",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "template<>\nstruct hash<std::filesystem::path>;"
        },
        {
            "title": "std::filesystem::path::is_absolute,is_relative",
            "path": "en.cppreference.com/w/cpp/filesystem/path/is_absrel.html",
            "wgPageName": "cpp/filesystem/path/is_absrel",
            "sample_declaration": "bool is_absolute() const;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::path::lexically_normal, std::filesystem::path::lexically_relative, std::filesystem::path::lexically_proximate",
            "path": "en.cppreference.com/w/cpp/filesystem/path/lexically_normal.html",
            "wgPageName": "cpp/filesystem/path/lexically_normal",
            "sample_declaration": "path lexically_normal() const;",
            "other_declarations": 2
        },
        {
            "title": "std::filesystem::path::make_preferred",
            "path": "en.cppreference.com/w/cpp/filesystem/path/make_preferred.html",
            "wgPageName": "cpp/filesystem/path/make_preferred",
            "sample_declaration": "path& make_preferred();"
        },
        {
            "title": "std::filesystem::path::c_str, std::filesystem::path::native, std::filesystem::path::operator string_type()",
            "path": "en.cppreference.com/w/cpp/filesystem/path/native.html",
            "wgPageName": "cpp/filesystem/path/native",
            "sample_declaration": "const value_type* c_str() const noexcept;",
            "other_declarations": 2
        },
        {
            "title": "operator==,!=,<,<=,>,>=,<=>(std::filesystem::path)",
            "path": "en.cppreference.com/w/cpp/filesystem/path/operator_cmp.html",
            "wgPageName": "cpp/filesystem/path/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const path& lhs,\n    const path& rhs) noexcept;",
            "other_declarations": 6
        },
        {
            "title": "operator<<,>>(std::filesystem::path)",
            "path": "en.cppreference.com/w/cpp/filesystem/path/operator_ltltgtgt.html",
            "wgPageName": "cpp/filesystem/path/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const path& p);",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::operator/(std::filesystem::path)",
            "path": "en.cppreference.com/w/cpp/filesystem/path/operator_slash.html",
            "wgPageName": "cpp/filesystem/path/operator_slash",
            "sample_declaration": "friend path operator/(\n    const path& lhs,\n    const path& rhs);"
        },
        {
            "title": "std::filesystem::path::operator=",
            "path": "en.cppreference.com/w/cpp/filesystem/path/operator=.html",
            "wgPageName": "cpp/filesystem/path/operator=",
            "sample_declaration": "path& operator=(const path& p);",
            "other_declarations": 3
        },
        {
            "title": "std::filesystem::path::parent_path",
            "path": "en.cppreference.com/w/cpp/filesystem/path/parent_path.html",
            "wgPageName": "cpp/filesystem/path/parent_path",
            "sample_declaration": "path parent_path() const;"
        },
        {
            "title": "std::filesystem::path::path",
            "path": "en.cppreference.com/w/cpp/filesystem/path/path.html",
            "wgPageName": "cpp/filesystem/path/path",
            "sample_declaration": "path() noexcept;",
            "other_declarations": 7
        },
        {
            "title": "std::filesystem::path::relative_path",
            "path": "en.cppreference.com/w/cpp/filesystem/path/relative_path.html",
            "wgPageName": "cpp/filesystem/path/relative_path",
            "sample_declaration": "path relative_path() const;"
        },
        {
            "title": "std::filesystem::path::remove_filename",
            "path": "en.cppreference.com/w/cpp/filesystem/path/remove_filename.html",
            "wgPageName": "cpp/filesystem/path/remove_filename",
            "sample_declaration": "path& remove_filename();"
        },
        {
            "title": "std::filesystem::path::replace_extension",
            "path": "en.cppreference.com/w/cpp/filesystem/path/replace_extension.html",
            "wgPageName": "cpp/filesystem/path/replace_extension",
            "sample_declaration": "path& replace_extension(\n    const path& replacement = path());"
        },
        {
            "title": "std::filesystem::path::replace_filename",
            "path": "en.cppreference.com/w/cpp/filesystem/path/replace_filename.html",
            "wgPageName": "cpp/filesystem/path/replace_filename",
            "sample_declaration": "path& replace_filename(const path& replacement);"
        },
        {
            "title": "std::filesystem::path::root_directory",
            "path": "en.cppreference.com/w/cpp/filesystem/path/root_directory.html",
            "wgPageName": "cpp/filesystem/path/root_directory",
            "sample_declaration": "path root_directory() const;"
        },
        {
            "title": "std::filesystem::path::root_name",
            "path": "en.cppreference.com/w/cpp/filesystem/path/root_name.html",
            "wgPageName": "cpp/filesystem/path/root_name",
            "sample_declaration": "path root_name() const;"
        },
        {
            "title": "std::filesystem::path::root_path",
            "path": "en.cppreference.com/w/cpp/filesystem/path/root_path.html",
            "wgPageName": "cpp/filesystem/path/root_path",
            "sample_declaration": "path root_path() const;"
        },
        {
            "title": "std::filesystem::path::stem",
            "path": "en.cppreference.com/w/cpp/filesystem/path/stem.html",
            "wgPageName": "cpp/filesystem/path/stem",
            "sample_declaration": "path stem() const;"
        },
        {
            "title": "std::filesystem::path::string, std::filesystem::path::wstring, std::filesystem::path::u8string, std::filesystem::path::u16string, std::filesystem::path::u32string",
            "path": "en.cppreference.com/w/cpp/filesystem/path/string.html",
            "wgPageName": "cpp/filesystem/path/string",
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT>,\n    class Alloc = std::allocator<CharT> >\nstd::basic_string<CharT, Traits, Alloc> string(\n    const Alloc& a = Alloc()) const;",
            "other_declarations": 6
        },
        {
            "title": "std::filesystem::path::swap",
            "path": "en.cppreference.com/w/cpp/filesystem/path/swap.html",
            "wgPageName": "cpp/filesystem/path/swap",
            "sample_declaration": "void swap(path& other) noexcept;"
        },
        {
            "title": "std::filesystem::swap(std::filesystem::path)",
            "path": "en.cppreference.com/w/cpp/filesystem/path/swap2.html",
            "wgPageName": "cpp/filesystem/path/swap2",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "void swap(\n    std::filesystem::path& lhs,\n    std::filesystem::path& rhs) noexcept;"
        },
        {
            "title": "std::filesystem::u8path",
            "path": "en.cppreference.com/w/cpp/filesystem/path/u8path.html",
            "wgPageName": "cpp/filesystem/path/u8path",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "template<class Source>\nstd::filesystem::path u8path(\n    const Source& source);",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::perm_options",
            "path": "en.cppreference.com/w/cpp/filesystem/perm_options.html",
            "wgPageName": "cpp/filesystem/perm_options",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "enum class perm_options {\n  replace = /* unspecified */,\n  add = /* unspecified */,\n  remove = /* unspecified */,\n  nofollow = /* unspecified */\n};"
        },
        {
            "title": "std::filesystem::permissions",
            "path": "en.cppreference.com/w/cpp/filesystem/permissions.html",
            "wgPageName": "cpp/filesystem/permissions",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "void permissions(\n    const std::filesystem::path& p,\n    std::filesystem::perms prms,\n    std::filesystem::perm_options opts =\n        perm_options::replace);\nvoid permissions(\n    const std::filesystem::path& p,\n    std::filesystem::perms prms,\n    std::error_code& ec) noexcept;\nvoid permissions(\n    const std::filesystem::path& p,\n    std::filesystem::perms prms,\n    std::filesystem::perm_options opts,\n    std::error_code& ec);"
        },
        {
            "title": "std::filesystem::perms",
            "path": "en.cppreference.com/w/cpp/filesystem/perms.html",
            "wgPageName": "cpp/filesystem/perms",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "enum class perms;"
        },
        {
            "title": "std::filesystem::read_symlink",
            "path": "en.cppreference.com/w/cpp/filesystem/read_symlink.html",
            "wgPageName": "cpp/filesystem/read_symlink",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "std::filesystem::path read_symlink(\n    const std::filesystem::path& p);\nstd::filesystem::path read_symlink(\n    const std::filesystem::path& p,\n    std::error_code& ec);"
        },
        {
            "title": "std::filesystem::recursive_directory_iterator",
            "path": "en.cppreference.com/w/cpp/filesystem/recursive_directory_iterator.html",
            "wgPageName": "cpp/filesystem/recursive_directory_iterator",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "class recursive_directory_iterator;"
        },
        {
            "title": "std::filesystem::begin(recursive_directory_iterator), std::filesystem::end(recursive_directory_iterator)",
            "path": "en.cppreference.com/w/cpp/filesystem/recursive_directory_iterator/begin.html",
            "wgPageName": "cpp/filesystem/recursive_directory_iterator/begin",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "recursive_directory_iterator begin(\n    recursive_directory_iterator iter) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::recursive_directory_iterator::depth",
            "path": "en.cppreference.com/w/cpp/filesystem/recursive_directory_iterator/depth.html",
            "wgPageName": "cpp/filesystem/recursive_directory_iterator/depth",
            "sample_declaration": "int depth() const;"
        },
        {
            "title": "std::filesystem::recursive_directory_iterator::disable_recursion_pending",
            "path": "en.cppreference.com/w/cpp/filesystem/recursive_directory_iterator/disable_recursion_pending.html",
            "wgPageName": "cpp/filesystem/recursive_directory_iterator/disable_recursion_pending",
            "sample_declaration": "void disable_recursion_pending();"
        },
        {
            "title": "std::filesystem::recursive_directory_iterator::operator++, std::filesystem::recursive_directory_iterator::increment",
            "path": "en.cppreference.com/w/cpp/filesystem/recursive_directory_iterator/increment.html",
            "wgPageName": "cpp/filesystem/recursive_directory_iterator/increment",
            "sample_declaration": "recursive_directory_iterator& operator++();",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::recursive_directory_iterator::operator*, std::filesystem::recursive_directory_iterator::operator->",
            "path": "en.cppreference.com/w/cpp/filesystem/recursive_directory_iterator/operator*.html",
            "wgPageName": "cpp/filesystem/recursive_directory_iterator/operator*",
            "sample_declaration": "const std::filesystem::directory_entry&\noperator*() const;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::recursive_directory_iterator::operator=",
            "path": "en.cppreference.com/w/cpp/filesystem/recursive_directory_iterator/operator=.html",
            "wgPageName": "cpp/filesystem/recursive_directory_iterator/operator=",
            "sample_declaration": "recursive_directory_iterator& operator=(\n    const recursive_directory_iterator& other) =\n    default;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::recursive_directory_iterator::options",
            "path": "en.cppreference.com/w/cpp/filesystem/recursive_directory_iterator/options.html",
            "wgPageName": "cpp/filesystem/recursive_directory_iterator/options",
            "sample_declaration": "std::filesystem::directory_options options()\n    const;"
        },
        {
            "title": "std::filesystem::recursive_directory_iterator::pop",
            "path": "en.cppreference.com/w/cpp/filesystem/recursive_directory_iterator/pop.html",
            "wgPageName": "cpp/filesystem/recursive_directory_iterator/pop",
            "sample_declaration": "void pop();",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::recursive_directory_iterator::recursion_pending",
            "path": "en.cppreference.com/w/cpp/filesystem/recursive_directory_iterator/recursion_pending.html",
            "wgPageName": "cpp/filesystem/recursive_directory_iterator/recursion_pending",
            "sample_declaration": "bool recursion_pending() const;"
        },
        {
            "title": "std::filesystem::recursive_directory_iterator::recursive_directory_iterator",
            "path": "en.cppreference.com/w/cpp/filesystem/recursive_directory_iterator/recursive_directory_iterator.html",
            "wgPageName": "cpp/filesystem/recursive_directory_iterator/recursive_directory_iterator",
            "sample_declaration": "recursive_directory_iterator() noexcept;",
            "other_declarations": 6
        },
        {
            "title": "std::filesystem::relative, std::filesystem::proximate",
            "path": "en.cppreference.com/w/cpp/filesystem/relative.html",
            "wgPageName": "cpp/filesystem/relative",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "path relative(\n    const std::filesystem::path& p,\n    std::error_code& ec);",
            "other_declarations": 3
        },
        {
            "title": "std::filesystem::remove, std::filesystem::remove_all",
            "path": "en.cppreference.com/w/cpp/filesystem/remove.html",
            "wgPageName": "cpp/filesystem/remove",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "bool remove(const std::filesystem::path& p);\nbool remove(\n    const std::filesystem::path& p,\n    std::error_code& ec) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::rename",
            "path": "en.cppreference.com/w/cpp/filesystem/rename.html",
            "wgPageName": "cpp/filesystem/rename",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "void rename(\n    const std::filesystem::path& old_p,\n    const std::filesystem::path& new_p);\nvoid rename(\n    const std::filesystem::path& old_p,\n    const std::filesystem::path& new_p,\n    std::error_code& ec) noexcept;"
        },
        {
            "title": "std::filesystem::resize_file",
            "path": "en.cppreference.com/w/cpp/filesystem/resize_file.html",
            "wgPageName": "cpp/filesystem/resize_file",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "void resize_file(\n    const std::filesystem::path& p,\n    std::uintmax_t new_size);\nvoid resize_file(\n    const std::filesystem::path& p,\n    std::uintmax_t new_size,\n    std::error_code& ec) noexcept;"
        },
        {
            "title": "std::filesystem::space_info",
            "path": "en.cppreference.com/w/cpp/filesystem/space_info.html",
            "wgPageName": "cpp/filesystem/space_info",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "struct space_info {\n  std::uintmax_t capacity;\n  std::uintmax_t free;\n  std::uintmax_t available;\n};"
        },
        {
            "title": "std::filesystem::space",
            "path": "en.cppreference.com/w/cpp/filesystem/space.html",
            "wgPageName": "cpp/filesystem/space",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "std::filesystem::space_info space(\n    const std::filesystem::path& p);\nstd::filesystem::space_info space(\n    const std::filesystem::path& p,\n    std::error_code& ec) noexcept;"
        },
        {
            "title": "std::filesystem::status_known",
            "path": "en.cppreference.com/w/cpp/filesystem/status_known.html",
            "wgPageName": "cpp/filesystem/status_known",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "bool status_known(\n    std::filesystem::file_status s) noexcept;"
        },
        {
            "title": "std::filesystem::status, std::filesystem::symlink_status",
            "path": "en.cppreference.com/w/cpp/filesystem/status.html",
            "wgPageName": "cpp/filesystem/status",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "std::filesystem::file_status status(\n    const std::filesystem::path& p);\nstd::filesystem::file_status status(\n    const std::filesystem::path& p,\n    std::error_code& ec) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::filesystem::temp_directory_path",
            "path": "en.cppreference.com/w/cpp/filesystem/temp_directory_path.html",
            "wgPageName": "cpp/filesystem/temp_directory_path",
            "headers": [
                "<filesystem>"
            ],
            "sample_declaration": "path temp_directory_path();\npath temp_directory_path(std::error_code& ec);"
        },
        {
            "title": "Freestanding and hosted implementations",
            "path": "en.cppreference.com/w/cpp/freestanding.html",
            "wgPageName": "cpp/freestanding"
        },
        {
            "title": "C++ Standard Library headers",
            "path": "en.cppreference.com/w/cpp/header.html",
            "wgPageName": "cpp/header"
        },
        {
            "title": "Standard library header <algorithm>",
            "path": "en.cppreference.com/w/cpp/header/algorithm.html",
            "wgPageName": "cpp/header/algorithm"
        },
        {
            "title": "Standard library header <any> (C++17)",
            "path": "en.cppreference.com/w/cpp/header/any.html",
            "wgPageName": "cpp/header/any"
        },
        {
            "title": "Standard library header <array> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/array.html",
            "wgPageName": "cpp/header/array"
        },
        {
            "title": "Standard library header <atomic> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/atomic.html",
            "wgPageName": "cpp/header/atomic"
        },
        {
            "title": "Standard library header <barrier> (C++20)",
            "path": "en.cppreference.com/w/cpp/header/barrier.html",
            "wgPageName": "cpp/header/barrier"
        },
        {
            "title": "Standard library header <bit> (C++20)",
            "path": "en.cppreference.com/w/cpp/header/bit.html",
            "wgPageName": "cpp/header/bit"
        },
        {
            "title": "Standard library header <bitset>",
            "path": "en.cppreference.com/w/cpp/header/bitset.html",
            "wgPageName": "cpp/header/bitset"
        },
        {
            "title": "Standard library header <cassert>",
            "path": "en.cppreference.com/w/cpp/header/cassert.html",
            "wgPageName": "cpp/header/cassert"
        },
        {
            "title": "Standard library header <ccomplex> (C++11)(until C++20), <complex.h> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/ccomplex.html",
            "wgPageName": "cpp/header/ccomplex"
        },
        {
            "title": "Standard library header <cctype>",
            "path": "en.cppreference.com/w/cpp/header/cctype.html",
            "wgPageName": "cpp/header/cctype"
        },
        {
            "title": "Standard library header <cerrno>",
            "path": "en.cppreference.com/w/cpp/header/cerrno.html",
            "wgPageName": "cpp/header/cerrno"
        },
        {
            "title": "Standard library header <cfenv> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/cfenv.html",
            "wgPageName": "cpp/header/cfenv"
        },
        {
            "title": "Standard library header <cfloat>",
            "path": "en.cppreference.com/w/cpp/header/cfloat.html",
            "wgPageName": "cpp/header/cfloat"
        },
        {
            "title": "Standard library header <charconv> (C++17)",
            "path": "en.cppreference.com/w/cpp/header/charconv.html",
            "wgPageName": "cpp/header/charconv"
        },
        {
            "title": "Standard library header <chrono> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/chrono.html",
            "wgPageName": "cpp/header/chrono"
        },
        {
            "title": "Standard library header <cinttypes> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/cinttypes.html",
            "wgPageName": "cpp/header/cinttypes"
        },
        {
            "title": "Standard library header <ciso646> (until C++20), <iso646.h>",
            "path": "en.cppreference.com/w/cpp/header/ciso646.html",
            "wgPageName": "cpp/header/ciso646"
        },
        {
            "title": "Standard library header <climits>",
            "path": "en.cppreference.com/w/cpp/header/climits.html",
            "wgPageName": "cpp/header/climits"
        },
        {
            "title": "Standard library header <clocale>",
            "path": "en.cppreference.com/w/cpp/header/clocale.html",
            "wgPageName": "cpp/header/clocale"
        },
        {
            "title": "Standard library header <cmath>",
            "path": "en.cppreference.com/w/cpp/header/cmath.html",
            "wgPageName": "cpp/header/cmath"
        },
        {
            "title": "Standard library header <codecvt> (C++11)(deprecated in C++17)",
            "path": "en.cppreference.com/w/cpp/header/codecvt.html",
            "wgPageName": "cpp/header/codecvt"
        },
        {
            "title": "Standard library header <compare> (C++20)",
            "path": "en.cppreference.com/w/cpp/header/compare.html",
            "wgPageName": "cpp/header/compare"
        },
        {
            "title": "Standard library header <complex>",
            "path": "en.cppreference.com/w/cpp/header/complex.html",
            "wgPageName": "cpp/header/complex"
        },
        {
            "title": "Standard library header <concepts> (C++20)",
            "path": "en.cppreference.com/w/cpp/header/concepts.html",
            "wgPageName": "cpp/header/concepts"
        },
        {
            "title": "Standard library header <condition_variable> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/condition_variable.html",
            "wgPageName": "cpp/header/condition_variable"
        },
        {
            "title": "Standard library header <coroutine> (C++20)",
            "path": "en.cppreference.com/w/cpp/header/coroutine.html",
            "wgPageName": "cpp/header/coroutine"
        },
        {
            "title": "Standard library header <csetjmp>",
            "path": "en.cppreference.com/w/cpp/header/csetjmp.html",
            "wgPageName": "cpp/header/csetjmp"
        },
        {
            "title": "Standard library header <csignal>",
            "path": "en.cppreference.com/w/cpp/header/csignal.html",
            "wgPageName": "cpp/header/csignal"
        },
        {
            "title": "Standard library header <cstdalign> (C++11)(until C++20), <stdalign.h> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/cstdalign.html",
            "wgPageName": "cpp/header/cstdalign"
        },
        {
            "title": "Standard library header <cstdarg>",
            "path": "en.cppreference.com/w/cpp/header/cstdarg.html",
            "wgPageName": "cpp/header/cstdarg"
        },
        {
            "title": "Standard library header <cstdbool> (C++11)(until C++20), <stdbool.h> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/cstdbool.html",
            "wgPageName": "cpp/header/cstdbool"
        },
        {
            "title": "Standard library header <cstddef>",
            "path": "en.cppreference.com/w/cpp/header/cstddef.html",
            "wgPageName": "cpp/header/cstddef"
        },
        {
            "title": "Standard library header <cstdint> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/cstdint.html",
            "wgPageName": "cpp/header/cstdint"
        },
        {
            "title": "Standard library header <cstdio>",
            "path": "en.cppreference.com/w/cpp/header/cstdio.html",
            "wgPageName": "cpp/header/cstdio"
        },
        {
            "title": "Standard library header <cstdlib>",
            "path": "en.cppreference.com/w/cpp/header/cstdlib.html",
            "wgPageName": "cpp/header/cstdlib"
        },
        {
            "title": "Standard library header <cstring>",
            "path": "en.cppreference.com/w/cpp/header/cstring.html",
            "wgPageName": "cpp/header/cstring"
        },
        {
            "title": "Standard library header <ctgmath> (C++11)(until C++20), <tgmath.h> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/ctgmath.html",
            "wgPageName": "cpp/header/ctgmath"
        },
        {
            "title": "Standard library header <ctime>",
            "path": "en.cppreference.com/w/cpp/header/ctime.html",
            "wgPageName": "cpp/header/ctime"
        },
        {
            "title": "Standard library header <cuchar> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/cuchar.html",
            "wgPageName": "cpp/header/cuchar"
        },
        {
            "title": "Standard library header <cwchar>",
            "path": "en.cppreference.com/w/cpp/header/cwchar.html",
            "wgPageName": "cpp/header/cwchar"
        },
        {
            "title": "Standard library header <cwctype>",
            "path": "en.cppreference.com/w/cpp/header/cwctype.html",
            "wgPageName": "cpp/header/cwctype"
        },
        {
            "title": "Standard library header <deque>",
            "path": "en.cppreference.com/w/cpp/header/deque.html",
            "wgPageName": "cpp/header/deque"
        },
        {
            "title": "Standard library header <exception>",
            "path": "en.cppreference.com/w/cpp/header/exception.html",
            "wgPageName": "cpp/header/exception"
        },
        {
            "title": "Standard library header <execution> (C++17)",
            "path": "en.cppreference.com/w/cpp/header/execution.html",
            "wgPageName": "cpp/header/execution"
        },
        {
            "title": "Standard library header <expected> (C++23)",
            "path": "en.cppreference.com/w/cpp/header/expected.html",
            "wgPageName": "cpp/header/expected"
        },
        {
            "title": "Experimental C++ Standard Library headers",
            "path": "en.cppreference.com/w/cpp/header/experimental.html",
            "wgPageName": "cpp/header/experimental"
        },
        {
            "title": "Experimental library header <experimental/any>",
            "path": "en.cppreference.com/w/cpp/header/experimental/any.html",
            "wgPageName": "cpp/header/experimental/any"
        },
        {
            "title": "Experimental library header <experimental/filesystem>",
            "path": "en.cppreference.com/w/cpp/header/experimental/filesystem.html",
            "wgPageName": "cpp/header/experimental/filesystem"
        },
        {
            "title": "cpp/header/experimental/functional",
            "path": "en.cppreference.com/w/cpp/header/experimental/functional.html",
            "wgPageName": "cpp/header/experimental/functional"
        },
        {
            "title": "Experimental library header <experimental/memory_resource>",
            "path": "en.cppreference.com/w/cpp/header/experimental/memory_resource.html",
            "wgPageName": "cpp/header/experimental/memory_resource"
        },
        {
            "title": "cpp/header/experimental/net",
            "path": "en.cppreference.com/w/cpp/header/experimental/net.html",
            "wgPageName": "cpp/header/experimental/net"
        },
        {
            "title": "Experimental library header <experimental/optional>",
            "path": "en.cppreference.com/w/cpp/header/experimental/optional.html",
            "wgPageName": "cpp/header/experimental/optional"
        },
        {
            "title": "Experimental library header <experimental/ranges/algorithm>",
            "path": "en.cppreference.com/w/cpp/header/experimental/ranges/algorithm.html",
            "wgPageName": "cpp/header/experimental/ranges/algorithm"
        },
        {
            "title": "Experimental library header <experimental/ranges/concepts>",
            "path": "en.cppreference.com/w/cpp/header/experimental/ranges/concepts.html",
            "wgPageName": "cpp/header/experimental/ranges/concepts"
        },
        {
            "title": "Experimental library header <experimental/ranges/functional>",
            "path": "en.cppreference.com/w/cpp/header/experimental/ranges/functional.html",
            "wgPageName": "cpp/header/experimental/ranges/functional"
        },
        {
            "title": "Experimental library header <experimental/ranges/iterator>",
            "path": "en.cppreference.com/w/cpp/header/experimental/ranges/iterator.html",
            "wgPageName": "cpp/header/experimental/ranges/iterator"
        },
        {
            "title": "Experimental library header <experimental/ranges/random>",
            "path": "en.cppreference.com/w/cpp/header/experimental/ranges/random.html",
            "wgPageName": "cpp/header/experimental/ranges/random"
        },
        {
            "title": "Standard library header <experimental/ranges/range>",
            "path": "en.cppreference.com/w/cpp/header/experimental/ranges/range.html",
            "wgPageName": "cpp/header/experimental/ranges/range"
        },
        {
            "title": "Experimental library header <experimental/ranges/tuple>",
            "path": "en.cppreference.com/w/cpp/header/experimental/ranges/tuple.html",
            "wgPageName": "cpp/header/experimental/ranges/tuple"
        },
        {
            "title": "Experimental library header <experimental/ranges/type_traits>",
            "path": "en.cppreference.com/w/cpp/header/experimental/ranges/type_traits.html",
            "wgPageName": "cpp/header/experimental/ranges/type_traits"
        },
        {
            "title": "Experimental library header <experimental/ranges/utility>",
            "path": "en.cppreference.com/w/cpp/header/experimental/ranges/utility.html",
            "wgPageName": "cpp/header/experimental/ranges/utility"
        },
        {
            "title": "Experimental library header <experimental/reflect>",
            "path": "en.cppreference.com/w/cpp/header/experimental/reflect.html",
            "wgPageName": "cpp/header/experimental/reflect"
        },
        {
            "title": "Experimental library header <experimental/simd>",
            "path": "en.cppreference.com/w/cpp/header/experimental/simd.html",
            "wgPageName": "cpp/header/experimental/simd"
        },
        {
            "title": "Experimental library header <experimental/string_view>",
            "path": "en.cppreference.com/w/cpp/header/experimental/string_view.html",
            "wgPageName": "cpp/header/experimental/string_view"
        },
        {
            "title": "Standard library header <filesystem> (C++17)",
            "path": "en.cppreference.com/w/cpp/header/filesystem.html",
            "wgPageName": "cpp/header/filesystem"
        },
        {
            "title": "Standard library header <flat_map> (C++23)",
            "path": "en.cppreference.com/w/cpp/header/flat_map.html",
            "wgPageName": "cpp/header/flat_map"
        },
        {
            "title": "Standard library header <flat_set> (C++23)",
            "path": "en.cppreference.com/w/cpp/header/flat_set.html",
            "wgPageName": "cpp/header/flat_set"
        },
        {
            "title": "Standard library header <format> (C++20)",
            "path": "en.cppreference.com/w/cpp/header/format.html",
            "wgPageName": "cpp/header/format"
        },
        {
            "title": "Standard library header <forward_list> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/forward_list.html",
            "wgPageName": "cpp/header/forward_list"
        },
        {
            "title": "Standard library header <fstream>",
            "path": "en.cppreference.com/w/cpp/header/fstream.html",
            "wgPageName": "cpp/header/fstream"
        },
        {
            "title": "Standard library header <functional>",
            "path": "en.cppreference.com/w/cpp/header/functional.html",
            "wgPageName": "cpp/header/functional"
        },
        {
            "title": "Standard library header <future> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/future.html",
            "wgPageName": "cpp/header/future"
        },
        {
            "title": "Standard library header <generator> (C++23)",
            "path": "en.cppreference.com/w/cpp/header/generator.html",
            "wgPageName": "cpp/header/generator"
        },
        {
            "title": "Standard library header <initializer_list> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/initializer_list.html",
            "wgPageName": "cpp/header/initializer_list"
        },
        {
            "title": "Standard library header <iomanip>",
            "path": "en.cppreference.com/w/cpp/header/iomanip.html",
            "wgPageName": "cpp/header/iomanip"
        },
        {
            "title": "Standard library header <ios>",
            "path": "en.cppreference.com/w/cpp/header/ios.html",
            "wgPageName": "cpp/header/ios"
        },
        {
            "title": "Standard library header <iosfwd>",
            "path": "en.cppreference.com/w/cpp/header/iosfwd.html",
            "wgPageName": "cpp/header/iosfwd"
        },
        {
            "title": "Standard library header <iostream>",
            "path": "en.cppreference.com/w/cpp/header/iostream.html",
            "wgPageName": "cpp/header/iostream"
        },
        {
            "title": "Standard library header <istream>",
            "path": "en.cppreference.com/w/cpp/header/istream.html",
            "wgPageName": "cpp/header/istream"
        },
        {
            "title": "Standard library header <iterator>",
            "path": "en.cppreference.com/w/cpp/header/iterator.html",
            "wgPageName": "cpp/header/iterator"
        },
        {
            "title": "Standard library header <latch> (C++20)",
            "path": "en.cppreference.com/w/cpp/header/latch.html",
            "wgPageName": "cpp/header/latch"
        },
        {
            "title": "Standard library header <limits>",
            "path": "en.cppreference.com/w/cpp/header/limits.html",
            "wgPageName": "cpp/header/limits"
        },
        {
            "title": "Standard library header <list>",
            "path": "en.cppreference.com/w/cpp/header/list.html",
            "wgPageName": "cpp/header/list"
        },
        {
            "title": "Standard library header <locale>",
            "path": "en.cppreference.com/w/cpp/header/locale.html",
            "wgPageName": "cpp/header/locale"
        },
        {
            "title": "Standard library header <map>",
            "path": "en.cppreference.com/w/cpp/header/map.html",
            "wgPageName": "cpp/header/map"
        },
        {
            "title": "Standard library header <mdspan> (C++23)",
            "path": "en.cppreference.com/w/cpp/header/mdspan.html",
            "wgPageName": "cpp/header/mdspan"
        },
        {
            "title": "Standard library header <memory_resource> (C++17)",
            "path": "en.cppreference.com/w/cpp/header/memory_resource.html",
            "wgPageName": "cpp/header/memory_resource"
        },
        {
            "title": "Standard library header <memory>",
            "path": "en.cppreference.com/w/cpp/header/memory.html",
            "wgPageName": "cpp/header/memory"
        },
        {
            "title": "Standard library header <mutex> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/mutex.html",
            "wgPageName": "cpp/header/mutex"
        },
        {
            "title": "Standard library header <new>",
            "path": "en.cppreference.com/w/cpp/header/new.html",
            "wgPageName": "cpp/header/new"
        },
        {
            "title": "Standard library header <numbers> (C++20)",
            "path": "en.cppreference.com/w/cpp/header/numbers.html",
            "wgPageName": "cpp/header/numbers"
        },
        {
            "title": "Standard library header <numeric>",
            "path": "en.cppreference.com/w/cpp/header/numeric.html",
            "wgPageName": "cpp/header/numeric"
        },
        {
            "title": "Standard library header <optional> (C++17)",
            "path": "en.cppreference.com/w/cpp/header/optional.html",
            "wgPageName": "cpp/header/optional"
        },
        {
            "title": "Standard library header <ostream>",
            "path": "en.cppreference.com/w/cpp/header/ostream.html",
            "wgPageName": "cpp/header/ostream"
        },
        {
            "title": "Standard library header <print> (C++23)",
            "path": "en.cppreference.com/w/cpp/header/print.html",
            "wgPageName": "cpp/header/print"
        },
        {
            "title": "Standard library header <queue>",
            "path": "en.cppreference.com/w/cpp/header/queue.html",
            "wgPageName": "cpp/header/queue"
        },
        {
            "title": "Standard library header <random> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/random.html",
            "wgPageName": "cpp/header/random"
        },
        {
            "title": "Standard library header <ranges> (C++20)",
            "path": "en.cppreference.com/w/cpp/header/ranges.html",
            "wgPageName": "cpp/header/ranges",
            "sample_declaration": "namespace std {\nnamespace views = ranges::views;\n}"
        },
        {
            "title": "Standard library header <ratio> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/ratio.html",
            "wgPageName": "cpp/header/ratio"
        },
        {
            "title": "Standard library header <regex> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/regex.html",
            "wgPageName": "cpp/header/regex"
        },
        {
            "title": "Standard library header <scoped_allocator> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/scoped_allocator.html",
            "wgPageName": "cpp/header/scoped_allocator"
        },
        {
            "title": "Standard library header <semaphore> (C++20)",
            "path": "en.cppreference.com/w/cpp/header/semaphore.html",
            "wgPageName": "cpp/header/semaphore"
        },
        {
            "title": "Standard library header <set>",
            "path": "en.cppreference.com/w/cpp/header/set.html",
            "wgPageName": "cpp/header/set"
        },
        {
            "title": "Standard library header <shared_mutex> (C++14)",
            "path": "en.cppreference.com/w/cpp/header/shared_mutex.html",
            "wgPageName": "cpp/header/shared_mutex"
        },
        {
            "title": "Standard library header <source_location> (C++20)",
            "path": "en.cppreference.com/w/cpp/header/source_location.html",
            "wgPageName": "cpp/header/source_location"
        },
        {
            "title": "Standard library header <span> (C++20)",
            "path": "en.cppreference.com/w/cpp/header/span.html",
            "wgPageName": "cpp/header/span"
        },
        {
            "title": "Standard library header <spanstream> (C++23)",
            "path": "en.cppreference.com/w/cpp/header/spanstream.html",
            "wgPageName": "cpp/header/spanstream"
        },
        {
            "title": "Standard library header <sstream>",
            "path": "en.cppreference.com/w/cpp/header/sstream.html",
            "wgPageName": "cpp/header/sstream"
        },
        {
            "title": "Standard library header <stack>",
            "path": "en.cppreference.com/w/cpp/header/stack.html",
            "wgPageName": "cpp/header/stack"
        },
        {
            "title": "Standard library header <stacktrace> (C++23)",
            "path": "en.cppreference.com/w/cpp/header/stacktrace.html",
            "wgPageName": "cpp/header/stacktrace"
        },
        {
            "title": "Standard library header <stdatomic.h>",
            "path": "en.cppreference.com/w/cpp/header/stdatomic.h.html",
            "wgPageName": "cpp/header/stdatomic.h"
        },
        {
            "title": "Standard library header <stdexcept>",
            "path": "en.cppreference.com/w/cpp/header/stdexcept.html",
            "wgPageName": "cpp/header/stdexcept"
        },
        {
            "title": "Standard library header <stdfloat> (C++23)",
            "path": "en.cppreference.com/w/cpp/header/stdfloat.html",
            "wgPageName": "cpp/header/stdfloat"
        },
        {
            "title": "Standard library header <stop_token> (C++20)",
            "path": "en.cppreference.com/w/cpp/header/stop_token.html",
            "wgPageName": "cpp/header/stop_token"
        },
        {
            "title": "Standard library header <streambuf>",
            "path": "en.cppreference.com/w/cpp/header/streambuf.html",
            "wgPageName": "cpp/header/streambuf"
        },
        {
            "title": "Standard library header <string_view> (C++17)",
            "path": "en.cppreference.com/w/cpp/header/string_view.html",
            "wgPageName": "cpp/header/string_view"
        },
        {
            "title": "Standard library header <string>",
            "path": "en.cppreference.com/w/cpp/header/string.html",
            "wgPageName": "cpp/header/string"
        },
        {
            "title": "Standard library header <strstream> (deprecated in C++98)",
            "path": "en.cppreference.com/w/cpp/header/strstream.html",
            "wgPageName": "cpp/header/strstream"
        },
        {
            "title": "Standard library header <syncstream> (C++20)",
            "path": "en.cppreference.com/w/cpp/header/syncstream.html",
            "wgPageName": "cpp/header/syncstream"
        },
        {
            "title": "Standard library header <system_error> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/system_error.html",
            "wgPageName": "cpp/header/system_error"
        },
        {
            "title": "Standard library header <thread> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/thread.html",
            "wgPageName": "cpp/header/thread"
        },
        {
            "title": "Standard library header <tuple> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/tuple.html",
            "wgPageName": "cpp/header/tuple"
        },
        {
            "title": "Standard library header <type_traits> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/type_traits.html",
            "wgPageName": "cpp/header/type_traits"
        },
        {
            "title": "Standard library header <typeindex> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/typeindex.html",
            "wgPageName": "cpp/header/typeindex"
        },
        {
            "title": "Standard library header <typeinfo>",
            "path": "en.cppreference.com/w/cpp/header/typeinfo.html",
            "wgPageName": "cpp/header/typeinfo"
        },
        {
            "title": "Standard library header <unordered_map> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/unordered_map.html",
            "wgPageName": "cpp/header/unordered_map"
        },
        {
            "title": "Standard library header <unordered_set> (C++11)",
            "path": "en.cppreference.com/w/cpp/header/unordered_set.html",
            "wgPageName": "cpp/header/unordered_set"
        },
        {
            "title": "Standard library header <utility>",
            "path": "en.cppreference.com/w/cpp/header/utility.html",
            "wgPageName": "cpp/header/utility"
        },
        {
            "title": "Standard library header <valarray>",
            "path": "en.cppreference.com/w/cpp/header/valarray.html",
            "wgPageName": "cpp/header/valarray"
        },
        {
            "title": "Standard library header <variant> (C++17)",
            "path": "en.cppreference.com/w/cpp/header/variant.html",
            "wgPageName": "cpp/header/variant"
        },
        {
            "title": "Standard library header <vector>",
            "path": "en.cppreference.com/w/cpp/header/vector.html",
            "wgPageName": "cpp/header/vector"
        },
        {
            "title": "Standard library header <version> (C++20)",
            "path": "en.cppreference.com/w/cpp/header/version.html",
            "wgPageName": "cpp/header/version"
        },
        {
            "title": "C++ Standard Library headers",
            "path": "en.cppreference.com/w/cpp/headers.html",
            "wgPageName": "cpp/header"
        },
        {
            "title": "Index",
            "path": "en.cppreference.com/w/cpp/index.html",
            "wgPageName": "cpp/index"
        },
        {
            "title": "Input/output library",
            "path": "en.cppreference.com/w/cpp/io.html",
            "wgPageName": "cpp/io"
        },
        {
            "title": "std::basic_filebuf",
            "path": "en.cppreference.com/w/cpp/io/basic_filebuf.html",
            "wgPageName": "cpp/io/basic_filebuf",
            "headers": [
                "<fstream>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT> >\nclass basic_filebuf\n    : public std::basic_streambuf<CharT, Traits>"
        },
        {
            "title": "std::basic_filebuf<CharT,Traits>::~basic_filebuf",
            "path": "en.cppreference.com/w/cpp/io/basic_filebuf/~basic_filebuf.html",
            "wgPageName": "cpp/io/basic_filebuf/~basic_filebuf",
            "sample_declaration": "virtual ~basic_filebuf();"
        },
        {
            "title": "std::basic_filebuf<CharT,Traits>::basic_filebuf",
            "path": "en.cppreference.com/w/cpp/io/basic_filebuf/basic_filebuf.html",
            "wgPageName": "cpp/io/basic_filebuf/basic_filebuf",
            "sample_declaration": "basic_filebuf();",
            "other_declarations": 2
        },
        {
            "title": "std::basic_filebuf<CharT,Traits>::close",
            "path": "en.cppreference.com/w/cpp/io/basic_filebuf/close.html",
            "wgPageName": "cpp/io/basic_filebuf/close",
            "sample_declaration": "std::basic_filebuf<CharT, Traits>* close();"
        },
        {
            "title": "std::basic_filebuf<CharT,Traits>::imbue",
            "path": "en.cppreference.com/w/cpp/io/basic_filebuf/imbue.html",
            "wgPageName": "cpp/io/basic_filebuf/imbue",
            "sample_declaration": "protected:\nvirtual void imbue(const std::locale& loc)"
        },
        {
            "title": "std::basic_filebuf<CharT,Traits>::is_open",
            "path": "en.cppreference.com/w/cpp/io/basic_filebuf/is_open.html",
            "wgPageName": "cpp/io/basic_filebuf/is_open",
            "sample_declaration": "bool is_open() const;"
        },
        {
            "title": "std::basic_filebuf<CharT,Traits>::open",
            "path": "en.cppreference.com/w/cpp/io/basic_filebuf/open.html",
            "wgPageName": "cpp/io/basic_filebuf/open",
            "sample_declaration": "std::basic_filebuf<CharT, Traits>* open(\n    const char* s,\n    std::ios_base::openmode mode)",
            "other_declarations": 3
        },
        {
            "title": "std::basic_filebuf<CharT,Traits>::operator=",
            "path": "en.cppreference.com/w/cpp/io/basic_filebuf/operator=.html",
            "wgPageName": "cpp/io/basic_filebuf/operator=",
            "sample_declaration": "std::basic_filebuf& operator=(\n    std::basic_filebuf&& rhs);",
            "other_declarations": 1
        },
        {
            "title": "std::basic_filebuf<CharT,Traits>::overflow",
            "path": "en.cppreference.com/w/cpp/io/basic_filebuf/overflow.html",
            "wgPageName": "cpp/io/basic_filebuf/overflow",
            "sample_declaration": "protected:\nvirtual int_type overflow(\n    int_type c = Traits::eof());"
        },
        {
            "title": "std::basic_filebuf<CharT,Traits>::pbackfail",
            "path": "en.cppreference.com/w/cpp/io/basic_filebuf/pbackfail.html",
            "wgPageName": "cpp/io/basic_filebuf/pbackfail",
            "sample_declaration": "protected:\nvirtual int_type pbackfail(\n    int_type c = Traits::eof())"
        },
        {
            "title": "std::basic_filebuf<CharT,Traits>::seekoff",
            "path": "en.cppreference.com/w/cpp/io/basic_filebuf/seekoff.html",
            "wgPageName": "cpp/io/basic_filebuf/seekoff",
            "sample_declaration": "protected:\nvirtual pos_type seekoff(\n    off_type off,\n    std::ios_base::seekdir dir,\n    std::ios_base::openmode which =\n        std::ios_base::in | std::ios_base::out);"
        },
        {
            "title": "std::basic_filebuf<CharT,Traits>::seekpos",
            "path": "en.cppreference.com/w/cpp/io/basic_filebuf/seekpos.html",
            "wgPageName": "cpp/io/basic_filebuf/seekpos",
            "sample_declaration": "protected:\nvirtual pos_type seekpos(\n    pos_type sp,\n    std::ios_base::openmode which =\n        std::ios_base::in | std::ios_base::out);"
        },
        {
            "title": "std::basic_filebuf<CharT,Traits>::setbuf",
            "path": "en.cppreference.com/w/cpp/io/basic_filebuf/setbuf.html",
            "wgPageName": "cpp/io/basic_filebuf/setbuf",
            "sample_declaration": "protected:\nvirtual std::basic_streambuf<CharT, Traits>*\nsetbuf(char_type* s, std::streamsize n)"
        },
        {
            "title": "std::basic_filebuf<CharT,Traits>::showmanyc",
            "path": "en.cppreference.com/w/cpp/io/basic_filebuf/showmanyc.html",
            "wgPageName": "cpp/io/basic_filebuf/showmanyc",
            "sample_declaration": "protected:\nvirtual std::streamsize showmanyc()"
        },
        {
            "title": "std::basic_filebuf<CharT,Traits>::swap",
            "path": "en.cppreference.com/w/cpp/io/basic_filebuf/swap.html",
            "wgPageName": "cpp/io/basic_filebuf/swap",
            "sample_declaration": "void swap(std::basic_filebuf& rhs);"
        },
        {
            "title": "std::swap(std::basic_filebuf)",
            "path": "en.cppreference.com/w/cpp/io/basic_filebuf/swap2.html",
            "wgPageName": "cpp/io/basic_filebuf/swap2",
            "sample_declaration": "template<class CharT, class Traits>\nvoid swap(\n    std::basic_filebuf<CharT, Traits>& lhs,\n    std::basic_filebuf<CharT, Traits>& rhs);"
        },
        {
            "title": "std::basic_filebuf<CharT,Traits>::sync",
            "path": "en.cppreference.com/w/cpp/io/basic_filebuf/sync.html",
            "wgPageName": "cpp/io/basic_filebuf/sync",
            "sample_declaration": "protected:\nvirtual int sync()"
        },
        {
            "title": "std::basic_filebuf<CharT,Traits>::uflow",
            "path": "en.cppreference.com/w/cpp/io/basic_filebuf/uflow.html",
            "wgPageName": "cpp/io/basic_filebuf/uflow",
            "sample_declaration": "protected:\nvirtual int_type uflow()"
        },
        {
            "title": "std::basic_filebuf<CharT,Traits>::underflow",
            "path": "en.cppreference.com/w/cpp/io/basic_filebuf/underflow.html",
            "wgPageName": "cpp/io/basic_filebuf/underflow",
            "sample_declaration": "protected:\nvirtual int_type underflow()"
        },
        {
            "title": "std::basic_fstream",
            "path": "en.cppreference.com/w/cpp/io/basic_fstream.html",
            "wgPageName": "cpp/io/basic_fstream",
            "headers": [
                "<fstream>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT> >\nclass basic_fstream\n    : public std::basic_iostream<CharT, Traits>"
        },
        {
            "title": "std::basic_fstream<CharT,Traits>::basic_fstream",
            "path": "en.cppreference.com/w/cpp/io/basic_fstream/basic_fstream.html",
            "wgPageName": "cpp/io/basic_fstream/basic_fstream",
            "sample_declaration": "basic_fstream();",
            "other_declarations": 6
        },
        {
            "title": "std::basic_fstream<CharT,Traits>::close",
            "path": "en.cppreference.com/w/cpp/io/basic_fstream/close.html",
            "wgPageName": "cpp/io/basic_fstream/close",
            "sample_declaration": "void close();"
        },
        {
            "title": "std::basic_fstream<CharT,Traits>::is_open",
            "path": "en.cppreference.com/w/cpp/io/basic_fstream/is_open.html",
            "wgPageName": "cpp/io/basic_fstream/is_open",
            "sample_declaration": "bool is_open();",
            "other_declarations": 1
        },
        {
            "title": "std::basic_fstream<CharT,Traits>::open",
            "path": "en.cppreference.com/w/cpp/io/basic_fstream/open.html",
            "wgPageName": "cpp/io/basic_fstream/open",
            "sample_declaration": "void open(\n    const char* filename,\n    ios_base::openmode mode = ios_base::in |\n                              ios_base::out);",
            "other_declarations": 3
        },
        {
            "title": "std::basic_fstream<CharT,Traits>::operator=",
            "path": "en.cppreference.com/w/cpp/io/basic_fstream/operator=.html",
            "wgPageName": "cpp/io/basic_fstream/operator=",
            "sample_declaration": "basic_fstream& operator=(basic_fstream&& other);"
        },
        {
            "title": "std::basic_fstream<CharT,Traits>::rdbuf",
            "path": "en.cppreference.com/w/cpp/io/basic_fstream/rdbuf.html",
            "wgPageName": "cpp/io/basic_fstream/rdbuf",
            "sample_declaration": "std::basic_filebuf<CharT, Traits>* rdbuf()\n    const;"
        },
        {
            "title": "std::basic_fstream<CharT,Traits>::swap",
            "path": "en.cppreference.com/w/cpp/io/basic_fstream/swap.html",
            "wgPageName": "cpp/io/basic_fstream/swap",
            "sample_declaration": "void swap(basic_fstream& other);"
        },
        {
            "title": "std::swap(std::basic_fstream)",
            "path": "en.cppreference.com/w/cpp/io/basic_fstream/swap2.html",
            "wgPageName": "cpp/io/basic_fstream/swap2",
            "sample_declaration": "template<class CharT, class Traits>\nvoid swap(\n    basic_fstream<CharT, Traits>& lhs,\n    basic_fstream<CharT, Traits>& rhs);"
        },
        {
            "title": "std::basic_ifstream",
            "path": "en.cppreference.com/w/cpp/io/basic_ifstream.html",
            "wgPageName": "cpp/io/basic_ifstream",
            "headers": [
                "<fstream>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT> >\nclass basic_ifstream\n    : public std::basic_istream<CharT, Traits>"
        },
        {
            "title": "std::basic_ifstream<CharT,Traits>::basic_ifstream",
            "path": "en.cppreference.com/w/cpp/io/basic_ifstream/basic_ifstream.html",
            "wgPageName": "cpp/io/basic_ifstream/basic_ifstream",
            "sample_declaration": "basic_ifstream();",
            "other_declarations": 6
        },
        {
            "title": "std::basic_ifstream<CharT,Traits>::close",
            "path": "en.cppreference.com/w/cpp/io/basic_ifstream/close.html",
            "wgPageName": "cpp/io/basic_ifstream/close",
            "sample_declaration": "void close();"
        },
        {
            "title": "std::basic_ifstream<CharT,Traits>::is_open",
            "path": "en.cppreference.com/w/cpp/io/basic_ifstream/is_open.html",
            "wgPageName": "cpp/io/basic_ifstream/is_open",
            "sample_declaration": "bool is_open();",
            "other_declarations": 1
        },
        {
            "title": "std::basic_ifstream<CharT,Traits>::open",
            "path": "en.cppreference.com/w/cpp/io/basic_ifstream/open.html",
            "wgPageName": "cpp/io/basic_ifstream/open",
            "sample_declaration": "void open(\n    const char* filename,\n    ios_base::openmode mode = ios_base::in);",
            "other_declarations": 3
        },
        {
            "title": "std::basic_ifstream<CharT,Traits>::operator=",
            "path": "en.cppreference.com/w/cpp/io/basic_ifstream/operator=.html",
            "wgPageName": "cpp/io/basic_ifstream/operator=",
            "sample_declaration": "basic_ifstream& operator=(\n    basic_ifstream&& other);"
        },
        {
            "title": "std::basic_ifstream<CharT,Traits>::rdbuf",
            "path": "en.cppreference.com/w/cpp/io/basic_ifstream/rdbuf.html",
            "wgPageName": "cpp/io/basic_ifstream/rdbuf",
            "sample_declaration": "std::basic_filebuf<CharT, Traits>* rdbuf()\n    const;"
        },
        {
            "title": "std::basic_ifstream<CharT,Traits>::swap",
            "path": "en.cppreference.com/w/cpp/io/basic_ifstream/swap.html",
            "wgPageName": "cpp/io/basic_ifstream/swap",
            "sample_declaration": "void swap(basic_ifstream& other);"
        },
        {
            "title": "std::swap(std::basic_ifstream)",
            "path": "en.cppreference.com/w/cpp/io/basic_ifstream/swap2.html",
            "wgPageName": "cpp/io/basic_ifstream/swap2",
            "sample_declaration": "template<class CharT, class Traits>\nvoid swap(\n    basic_ifstream<CharT, Traits>& lhs,\n    basic_ifstream<CharT, Traits>& rhs);"
        },
        {
            "title": "std::basic_ios",
            "path": "en.cppreference.com/w/cpp/io/basic_ios.html",
            "wgPageName": "cpp/io/basic_ios",
            "headers": [
                "<ios>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT> >\nclass basic_ios : public std::ios_base"
        },
        {
            "title": "std::basic_ios<CharT,Traits>::~basic_ios",
            "path": "en.cppreference.com/w/cpp/io/basic_ios/~basic_ios.html",
            "wgPageName": "cpp/io/basic_ios/~basic_ios",
            "sample_declaration": "virtual ~basic_ios();"
        },
        {
            "title": "std::basic_ios<CharT,Traits>::bad",
            "path": "en.cppreference.com/w/cpp/io/basic_ios/bad.html",
            "wgPageName": "cpp/io/basic_ios/bad",
            "sample_declaration": "bool bad() const;"
        },
        {
            "title": "std::basic_ios<CharT,Traits>::basic_ios",
            "path": "en.cppreference.com/w/cpp/io/basic_ios/basic_ios.html",
            "wgPageName": "cpp/io/basic_ios/basic_ios",
            "sample_declaration": "protected:\nbasic_ios();",
            "other_declarations": 3
        },
        {
            "title": "std::basic_ios<CharT,Traits>::clear",
            "path": "en.cppreference.com/w/cpp/io/basic_ios/clear.html",
            "wgPageName": "cpp/io/basic_ios/clear",
            "sample_declaration": "void clear(\n    std::ios_base::iostate state =\n        std::ios_base::goodbit);"
        },
        {
            "title": "std::basic_ios<CharT,Traits>::copyfmt",
            "path": "en.cppreference.com/w/cpp/io/basic_ios/copyfmt.html",
            "wgPageName": "cpp/io/basic_ios/copyfmt",
            "sample_declaration": "basic_ios& copyfmt(const basic_ios& other);"
        },
        {
            "title": "std::basic_ios<CharT,Traits>::eof",
            "path": "en.cppreference.com/w/cpp/io/basic_ios/eof.html",
            "wgPageName": "cpp/io/basic_ios/eof",
            "sample_declaration": "bool eof() const;"
        },
        {
            "title": "std::basic_ios<CharT,Traits>::exceptions",
            "path": "en.cppreference.com/w/cpp/io/basic_ios/exceptions.html",
            "wgPageName": "cpp/io/basic_ios/exceptions",
            "sample_declaration": "std::ios_base::iostate exceptions() const;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_ios<CharT,Traits>::fail",
            "path": "en.cppreference.com/w/cpp/io/basic_ios/fail.html",
            "wgPageName": "cpp/io/basic_ios/fail",
            "sample_declaration": "bool fail() const;"
        },
        {
            "title": "std::basic_ios<CharT,Traits>::fill",
            "path": "en.cppreference.com/w/cpp/io/basic_ios/fill.html",
            "wgPageName": "cpp/io/basic_ios/fill",
            "sample_declaration": "CharT fill() const;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_ios<CharT,Traits>::good",
            "path": "en.cppreference.com/w/cpp/io/basic_ios/good.html",
            "wgPageName": "cpp/io/basic_ios/good",
            "sample_declaration": "bool good() const;"
        },
        {
            "title": "std::basic_ios<CharT,Traits>::imbue",
            "path": "en.cppreference.com/w/cpp/io/basic_ios/imbue.html",
            "wgPageName": "cpp/io/basic_ios/imbue",
            "sample_declaration": "std::locale imbue(const std::locale& loc);"
        },
        {
            "title": "std::basic_ios<CharT,Traits>::init",
            "path": "en.cppreference.com/w/cpp/io/basic_ios/init.html",
            "wgPageName": "cpp/io/basic_ios/init",
            "sample_declaration": "protected:\nvoid init(\n    std::basic_streambuf<CharT, Traits>* sb);"
        },
        {
            "title": "std::basic_ios<CharT,Traits>::move",
            "path": "en.cppreference.com/w/cpp/io/basic_ios/move.html",
            "wgPageName": "cpp/io/basic_ios/move",
            "sample_declaration": "protected:\nvoid move(basic_ios& other);",
            "other_declarations": 1
        },
        {
            "title": "std::basic_ios<CharT,Traits>::narrow",
            "path": "en.cppreference.com/w/cpp/io/basic_ios/narrow.html",
            "wgPageName": "cpp/io/basic_ios/narrow",
            "sample_declaration": "char narrow(char_type c, char dfault) const;"
        },
        {
            "title": "std::basic_ios<CharT,Traits>::operator bool",
            "path": "en.cppreference.com/w/cpp/io/basic_ios/operator_bool.html",
            "wgPageName": "cpp/io/basic_ios/operator_bool",
            "sample_declaration": "operator void*() const;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_ios<CharT,Traits>::operator!",
            "path": "en.cppreference.com/w/cpp/io/basic_ios/operator!.html",
            "wgPageName": "cpp/io/basic_ios/operator!",
            "sample_declaration": "bool operator!() const;"
        },
        {
            "title": "std::basic_ios<CharT,Traits>::rdbuf",
            "path": "en.cppreference.com/w/cpp/io/basic_ios/rdbuf.html",
            "wgPageName": "cpp/io/basic_ios/rdbuf",
            "sample_declaration": "std::basic_streambuf<CharT, Traits>* rdbuf()\n    const;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_ios<CharT,Traits>::rdstate",
            "path": "en.cppreference.com/w/cpp/io/basic_ios/rdstate.html",
            "wgPageName": "cpp/io/basic_ios/rdstate",
            "sample_declaration": "iostate rdstate() const;"
        },
        {
            "title": "std::basic_ios<CharT,Traits>::set_rdbuf",
            "path": "en.cppreference.com/w/cpp/io/basic_ios/set_rdbuf.html",
            "wgPageName": "cpp/io/basic_ios/set_rdbuf",
            "sample_declaration": "protected:\nvoid set_rdbuf(\n    std::basic_streambuf<CharT, Traits>* sb);"
        },
        {
            "title": "std::basic_ios<CharT,Traits>::setstate",
            "path": "en.cppreference.com/w/cpp/io/basic_ios/setstate.html",
            "wgPageName": "cpp/io/basic_ios/setstate",
            "sample_declaration": "void setstate(iostate state);"
        },
        {
            "title": "std::basic_ios<CharT,Traits>::swap",
            "path": "en.cppreference.com/w/cpp/io/basic_ios/swap.html",
            "wgPageName": "cpp/io/basic_ios/swap",
            "sample_declaration": "protected:\nvoid swap(basic_ios& other) noexcept;"
        },
        {
            "title": "std::basic_ios<CharT,Traits>::tie",
            "path": "en.cppreference.com/w/cpp/io/basic_ios/tie.html",
            "wgPageName": "cpp/io/basic_ios/tie",
            "sample_declaration": "std::basic_ostream<CharT, Traits>* tie() const;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_ios<CharT,Traits>::widen",
            "path": "en.cppreference.com/w/cpp/io/basic_ios/widen.html",
            "wgPageName": "cpp/io/basic_ios/widen",
            "sample_declaration": "char_type widen(char c) const;"
        },
        {
            "title": "std::basic_iostream",
            "path": "en.cppreference.com/w/cpp/io/basic_iostream.html",
            "wgPageName": "cpp/io/basic_iostream",
            "headers": [
                "<istream>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT> >\nclass basic_iostream\n    : public basic_istream<CharT, Traits>,\n      public basic_ostream<CharT, Traits>"
        },
        {
            "title": "std::basic_iostream<CharT,Traits>::~basic_iostream",
            "path": "en.cppreference.com/w/cpp/io/basic_iostream/~basic_iostream.html",
            "wgPageName": "cpp/io/basic_iostream/~basic_iostream",
            "sample_declaration": "virtual ~basic_iostream();"
        },
        {
            "title": "std::basic_iostream<CharT,Traits>::basic_iostream",
            "path": "en.cppreference.com/w/cpp/io/basic_iostream/basic_iostream.html",
            "wgPageName": "cpp/io/basic_iostream/basic_iostream",
            "sample_declaration": "explicit basic_iostream(\n    std::basic_streambuf<CharT, Traits>* sb);",
            "other_declarations": 2
        },
        {
            "title": "std::basic_iostream<CharT,Traits>::operator=",
            "path": "en.cppreference.com/w/cpp/io/basic_iostream/operator=.html",
            "wgPageName": "cpp/io/basic_iostream/operator=",
            "sample_declaration": "basic_iostream& operator=(\n    const basic_iostream& other) = delete;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_iostream<CharT,Traits>::swap",
            "path": "en.cppreference.com/w/cpp/io/basic_iostream/swap.html",
            "wgPageName": "cpp/io/basic_iostream/swap",
            "sample_declaration": "protected:\nvoid swap(basic_iostream& other);"
        },
        {
            "title": "std::basic_ispanstream",
            "path": "en.cppreference.com/w/cpp/io/basic_ispanstream.html",
            "wgPageName": "cpp/io/basic_ispanstream",
            "headers": [
                "<spanstream>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT> >\nclass basic_ispanstream;"
        },
        {
            "title": "std::basic_ispanstream<CharT,Traits>::basic_ispanstream",
            "path": "en.cppreference.com/w/cpp/io/basic_ispanstream/basic_ispanstream.html",
            "wgPageName": "cpp/io/basic_ispanstream/basic_ispanstream",
            "sample_declaration": "explicit basic_ispanstream(\n    std::span<CharT> s,\n    std::ios_base::openmode mode =\n        std::ios_base::in);",
            "other_declarations": 3
        },
        {
            "title": "std::basic_ispanstream<CharT,Traits>::operator=",
            "path": "en.cppreference.com/w/cpp/io/basic_ispanstream/operator=.html",
            "wgPageName": "cpp/io/basic_ispanstream/operator=",
            "sample_declaration": "basic_ispanstream& operator=(\n    basic_ispanstream&& other);",
            "other_declarations": 1
        },
        {
            "title": "std::basic_ispanstream<CharT,Traits>::rdbuf",
            "path": "en.cppreference.com/w/cpp/io/basic_ispanstream/rdbuf.html",
            "wgPageName": "cpp/io/basic_ispanstream/rdbuf",
            "sample_declaration": "std::basic_spanbuf<CharT, Traits>* rdbuf()\n    const noexcept;"
        },
        {
            "title": "std::basic_ispanstream<CharT,Traits>::span",
            "path": "en.cppreference.com/w/cpp/io/basic_ispanstream/span.html",
            "wgPageName": "cpp/io/basic_ispanstream/span",
            "sample_declaration": "std::span<const CharT> span() const noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::basic_ispanstream<CharT,Traits>::swap",
            "path": "en.cppreference.com/w/cpp/io/basic_ispanstream/swap.html",
            "wgPageName": "cpp/io/basic_ispanstream/swap",
            "sample_declaration": "void swap(basic_ispanstream& other);"
        },
        {
            "title": "std::swap(std::basic_ispanstream)",
            "path": "en.cppreference.com/w/cpp/io/basic_ispanstream/swap2.html",
            "wgPageName": "cpp/io/basic_ispanstream/swap2",
            "headers": [
                "<spanstream>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nvoid swap(\n    std::basic_ispanstream<CharT, Traits>& lhs,\n    std::basic_ispanstream<CharT, Traits>& rhs);"
        },
        {
            "title": "std::basic_istream",
            "path": "en.cppreference.com/w/cpp/io/basic_istream.html",
            "wgPageName": "cpp/io/basic_istream",
            "headers": [
                "<istream>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT> >\nclass basic_istream\n    : virtual public std::\n          basic_ios<CharT, Traits>"
        },
        {
            "title": "std::basic_istream<CharT,Traits>::~basic_istream",
            "path": "en.cppreference.com/w/cpp/io/basic_istream/~basic_istream.html",
            "wgPageName": "cpp/io/basic_istream/~basic_istream",
            "sample_declaration": "virtual ~basic_istream();"
        },
        {
            "title": "std::basic_istream<CharT,Traits>::basic_istream",
            "path": "en.cppreference.com/w/cpp/io/basic_istream/basic_istream.html",
            "wgPageName": "cpp/io/basic_istream/basic_istream",
            "sample_declaration": "explicit basic_istream(\n    std::basic_streambuf<CharT, Traits>* sb);",
            "other_declarations": 2
        },
        {
            "title": "std::basic_istream<CharT,Traits>::gcount",
            "path": "en.cppreference.com/w/cpp/io/basic_istream/gcount.html",
            "wgPageName": "cpp/io/basic_istream/gcount",
            "sample_declaration": "std::streamsize gcount() const;"
        },
        {
            "title": "std::basic_istream<CharT,Traits>::get",
            "path": "en.cppreference.com/w/cpp/io/basic_istream/get.html",
            "wgPageName": "cpp/io/basic_istream/get",
            "sample_declaration": "int_type get();",
            "other_declarations": 5
        },
        {
            "title": "std::basic_istream<CharT,Traits>::getline",
            "path": "en.cppreference.com/w/cpp/io/basic_istream/getline.html",
            "wgPageName": "cpp/io/basic_istream/getline",
            "sample_declaration": "basic_istream& getline(\n    char_type* s,\n    std::streamsize count);",
            "other_declarations": 1
        },
        {
            "title": "std::basic_istream<CharT,Traits>::ignore",
            "path": "en.cppreference.com/w/cpp/io/basic_istream/ignore.html",
            "wgPageName": "cpp/io/basic_istream/ignore",
            "sample_declaration": "basic_istream& ignore(\n    std::streamsize count = 1,\n    int_type delim = Traits::eof());"
        },
        {
            "title": "std::basic_istream<CharT,Traits>::operator>>",
            "path": "en.cppreference.com/w/cpp/io/basic_istream/operator_gtgt.html",
            "wgPageName": "cpp/io/basic_istream/operator_gtgt",
            "sample_declaration": "basic_istream& operator>>(short& value);\nbasic_istream& operator>>(\n    unsigned short& value);",
            "other_declarations": 10
        },
        {
            "title": "operator>>(std::basic_istream)",
            "path": "en.cppreference.com/w/cpp/io/basic_istream/operator_gtgt2.html",
            "wgPageName": "cpp/io/basic_istream/operator_gtgt2",
            "headers": [
                "<istream>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nbasic_istream<CharT, Traits>& operator>>(\n    basic_istream<CharT, Traits>& st,\n    CharT& ch);\ntemplate<class Traits>\nbasic_istream<char, Traits>& operator>>(\n    basic_istream<char, Traits>& st,\n    signed char& ch);\ntemplate<class Traits>\nbasic_istream<char, Traits>& operator>>(\n    basic_istream<char, Traits>& st,\n    unsigned char& ch);",
            "other_declarations": 3
        },
        {
            "title": "std::basic_istream<CharT,Traits>::operator=",
            "path": "en.cppreference.com/w/cpp/io/basic_istream/operator=.html",
            "wgPageName": "cpp/io/basic_istream/operator=",
            "sample_declaration": "protected:\nbasic_istream& operator=(\n    const basic_istream& rhs) = delete;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_istream<CharT,Traits>::peek",
            "path": "en.cppreference.com/w/cpp/io/basic_istream/peek.html",
            "wgPageName": "cpp/io/basic_istream/peek",
            "sample_declaration": "int_type peek();"
        },
        {
            "title": "std::basic_istream<CharT,Traits>::putback",
            "path": "en.cppreference.com/w/cpp/io/basic_istream/putback.html",
            "wgPageName": "cpp/io/basic_istream/putback",
            "sample_declaration": "basic_istream& putback(char_type ch);"
        },
        {
            "title": "std::basic_istream<CharT,Traits>::read",
            "path": "en.cppreference.com/w/cpp/io/basic_istream/read.html",
            "wgPageName": "cpp/io/basic_istream/read",
            "sample_declaration": "basic_istream& read(\n    char_type* s,\n    std::streamsize count);"
        },
        {
            "title": "std::basic_istream<CharT,Traits>::readsome",
            "path": "en.cppreference.com/w/cpp/io/basic_istream/readsome.html",
            "wgPageName": "cpp/io/basic_istream/readsome",
            "sample_declaration": "std::streamsize readsome(\n    char_type* s,\n    std::streamsize count);"
        },
        {
            "title": "std::basic_istream<CharT,Traits>::seekg",
            "path": "en.cppreference.com/w/cpp/io/basic_istream/seekg.html",
            "wgPageName": "cpp/io/basic_istream/seekg",
            "sample_declaration": "basic_istream& seekg(pos_type pos);",
            "other_declarations": 1
        },
        {
            "title": "std::basic_istream<CharT,Traits>::sentry",
            "path": "en.cppreference.com/w/cpp/io/basic_istream/sentry.html",
            "wgPageName": "cpp/io/basic_istream/sentry",
            "sample_declaration": "class sentry;"
        },
        {
            "title": "std::basic_istream<CharT,Traits>::swap",
            "path": "en.cppreference.com/w/cpp/io/basic_istream/swap.html",
            "wgPageName": "cpp/io/basic_istream/swap",
            "sample_declaration": "protected:\nvoid swap(basic_istream& rhs);"
        },
        {
            "title": "std::basic_istream<CharT,Traits>::sync",
            "path": "en.cppreference.com/w/cpp/io/basic_istream/sync.html",
            "wgPageName": "cpp/io/basic_istream/sync",
            "sample_declaration": "int sync();"
        },
        {
            "title": "std::basic_istream<CharT,Traits>::tellg",
            "path": "en.cppreference.com/w/cpp/io/basic_istream/tellg.html",
            "wgPageName": "cpp/io/basic_istream/tellg",
            "sample_declaration": "pos_type tellg();"
        },
        {
            "title": "std::basic_istream<CharT,Traits>::unget",
            "path": "en.cppreference.com/w/cpp/io/basic_istream/unget.html",
            "wgPageName": "cpp/io/basic_istream/unget",
            "sample_declaration": "basic_istream& unget();"
        },
        {
            "title": "std::basic_istringstream",
            "path": "en.cppreference.com/w/cpp/io/basic_istringstream.html",
            "wgPageName": "cpp/io/basic_istringstream",
            "headers": [
                "<sstream>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT>,\n    class Allocator = std::allocator<CharT> >\nclass basic_istringstream;"
        },
        {
            "title": "std::basic_istringstream<CharT,Traits,Allocator>::basic_istringstream",
            "path": "en.cppreference.com/w/cpp/io/basic_istringstream/basic_istringstream.html",
            "wgPageName": "cpp/io/basic_istringstream/basic_istringstream",
            "sample_declaration": "basic_istringstream()\n    : basic_istringstream(std::ios_base::in) {}",
            "other_declarations": 9
        },
        {
            "title": "std::basic_istringstream::operator=",
            "path": "en.cppreference.com/w/cpp/io/basic_istringstream/operator=.html",
            "wgPageName": "cpp/io/basic_istringstream/operator=",
            "sample_declaration": "basic_istringstream& operator=(\n    basic_istringstream&& other);"
        },
        {
            "title": "std::basic_istringstream::rdbuf",
            "path": "en.cppreference.com/w/cpp/io/basic_istringstream/rdbuf.html",
            "wgPageName": "cpp/io/basic_istringstream/rdbuf",
            "sample_declaration": "std::basic_stringbuf<CharT, Traits, Allocator>*\nrdbuf() const;"
        },
        {
            "title": "std::basic_istringstream<CharT,Traits,Allocator>::str",
            "path": "en.cppreference.com/w/cpp/io/basic_istringstream/str.html",
            "wgPageName": "cpp/io/basic_istringstream/str",
            "sample_declaration": "std::basic_string<CharT, Traits, Allocator>\nstr() const;",
            "other_declarations": 6
        },
        {
            "title": "std::basic_istringstream::swap",
            "path": "en.cppreference.com/w/cpp/io/basic_istringstream/swap.html",
            "wgPageName": "cpp/io/basic_istringstream/swap",
            "sample_declaration": "void swap(basic_istringstream& other);"
        },
        {
            "title": "std::swap(std::basic_istringstream)",
            "path": "en.cppreference.com/w/cpp/io/basic_istringstream/swap2.html",
            "wgPageName": "cpp/io/basic_istringstream/swap2",
            "headers": [
                "<sstream>"
            ],
            "sample_declaration": "template<class CharT, class Traits, class Alloc>\nvoid swap(\n    std::basic_istringstream<\n        CharT,\n        Traits,\n        Alloc>& lhs,\n    std::basic_istringstream<\n        CharT,\n        Traits,\n        Alloc>& rhs);"
        },
        {
            "title": "std::basic_istringstream<CharT,Traits,Allocator>::view",
            "path": "en.cppreference.com/w/cpp/io/basic_istringstream/view.html",
            "wgPageName": "cpp/io/basic_istringstream/view",
            "sample_declaration": "std::basic_string_view<CharT, Traits> view()\n    const noexcept;"
        },
        {
            "title": "std::basic_ofstream",
            "path": "en.cppreference.com/w/cpp/io/basic_ofstream.html",
            "wgPageName": "cpp/io/basic_ofstream",
            "headers": [
                "<fstream>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT> >\nclass basic_ofstream\n    : public std::basic_ostream<CharT, Traits>"
        },
        {
            "title": "std::basic_ofstream<CharT,Traits>::basic_ofstream",
            "path": "en.cppreference.com/w/cpp/io/basic_ofstream/basic_ofstream.html",
            "wgPageName": "cpp/io/basic_ofstream/basic_ofstream",
            "sample_declaration": "basic_ofstream();",
            "other_declarations": 6
        },
        {
            "title": "std::basic_ofstream<CharT,Traits>::close",
            "path": "en.cppreference.com/w/cpp/io/basic_ofstream/close.html",
            "wgPageName": "cpp/io/basic_ofstream/close",
            "sample_declaration": "void close();"
        },
        {
            "title": "std::basic_ofstream<CharT,Traits>::is_open",
            "path": "en.cppreference.com/w/cpp/io/basic_ofstream/is_open.html",
            "wgPageName": "cpp/io/basic_ofstream/is_open",
            "sample_declaration": "bool is_open();",
            "other_declarations": 1
        },
        {
            "title": "std::basic_ofstream<CharT,Traits>::open",
            "path": "en.cppreference.com/w/cpp/io/basic_ofstream/open.html",
            "wgPageName": "cpp/io/basic_ofstream/open",
            "sample_declaration": "void open(\n    const char* filename,\n    ios_base::openmode mode = ios_base::out);",
            "other_declarations": 3
        },
        {
            "title": "std::basic_ofstream<CharT,Traits>::operator=",
            "path": "en.cppreference.com/w/cpp/io/basic_ofstream/operator=.html",
            "wgPageName": "cpp/io/basic_ofstream/operator=",
            "sample_declaration": "basic_ofstream& operator=(\n    basic_ofstream&& other);"
        },
        {
            "title": "std::basic_ofstream<CharT,Traits>::rdbuf",
            "path": "en.cppreference.com/w/cpp/io/basic_ofstream/rdbuf.html",
            "wgPageName": "cpp/io/basic_ofstream/rdbuf",
            "sample_declaration": "std::basic_filebuf<CharT, Traits>* rdbuf()\n    const;"
        },
        {
            "title": "std::basic_ofstream<CharT,Traits>::swap",
            "path": "en.cppreference.com/w/cpp/io/basic_ofstream/swap.html",
            "wgPageName": "cpp/io/basic_ofstream/swap",
            "sample_declaration": "void swap(basic_ofstream& other);"
        },
        {
            "title": "std::swap(std::basic_ofstream)",
            "path": "en.cppreference.com/w/cpp/io/basic_ofstream/swap2.html",
            "wgPageName": "cpp/io/basic_ofstream/swap2",
            "sample_declaration": "template<class CharT, class Traits>\nvoid swap(\n    basic_ofstream<CharT, Traits>& lhs,\n    basic_ofstream<CharT, Traits>& rhs);"
        },
        {
            "title": "std::basic_ospanstream",
            "path": "en.cppreference.com/w/cpp/io/basic_ospanstream.html",
            "wgPageName": "cpp/io/basic_ospanstream",
            "headers": [
                "<spanstream>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT> >\nclass basic_ospanstream;"
        },
        {
            "title": "std::basic_ospanstream<CharT,Traits>::basic_ospanstream",
            "path": "en.cppreference.com/w/cpp/io/basic_ospanstream/basic_ospanstream.html",
            "wgPageName": "cpp/io/basic_ospanstream/basic_ospanstream",
            "sample_declaration": "explicit basic_ospanstream(\n    std::span<CharT> s,\n    std::ios_base::openmode mode =\n        std::ios_base::out);",
            "other_declarations": 2
        },
        {
            "title": "std::basic_ospanstream<CharT,Traits>::operator=",
            "path": "en.cppreference.com/w/cpp/io/basic_ospanstream/operator=.html",
            "wgPageName": "cpp/io/basic_ospanstream/operator=",
            "sample_declaration": "basic_ospanstream& operator=(\n    basic_ospanstream&& other);",
            "other_declarations": 1
        },
        {
            "title": "std::basic_ospanstream<CharT,Traits>::rdbuf",
            "path": "en.cppreference.com/w/cpp/io/basic_ospanstream/rdbuf.html",
            "wgPageName": "cpp/io/basic_ospanstream/rdbuf",
            "sample_declaration": "std::basic_spanbuf<CharT, Traits>* rdbuf()\n    const noexcept;"
        },
        {
            "title": "std::basic_ospanstream<CharT,Traits>::span",
            "path": "en.cppreference.com/w/cpp/io/basic_ospanstream/span.html",
            "wgPageName": "cpp/io/basic_ospanstream/span",
            "sample_declaration": "std::span<CharT> span() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_ospanstream<CharT,Traits>::swap",
            "path": "en.cppreference.com/w/cpp/io/basic_ospanstream/swap.html",
            "wgPageName": "cpp/io/basic_ospanstream/swap",
            "sample_declaration": "void swap(basic_ospanstream& other);"
        },
        {
            "title": "std::swap(std::basic_ospanstream)",
            "path": "en.cppreference.com/w/cpp/io/basic_ospanstream/swap2.html",
            "wgPageName": "cpp/io/basic_ospanstream/swap2",
            "headers": [
                "<spanstream>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nvoid swap(\n    std::basic_ospanstream<CharT, Traits>& lhs,\n    std::basic_ospanstream<CharT, Traits>& rhs);"
        },
        {
            "title": "std::basic_ostream",
            "path": "en.cppreference.com/w/cpp/io/basic_ostream.html",
            "wgPageName": "cpp/io/basic_ostream",
            "headers": [
                "<ostream>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT> >\nclass basic_ostream\n    : virtual public std::\n          basic_ios<CharT, Traits>"
        },
        {
            "title": "std::basic_ostream<CharT,Traits>::~basic_ostream",
            "path": "en.cppreference.com/w/cpp/io/basic_ostream/~basic_ostream.html",
            "wgPageName": "cpp/io/basic_ostream/~basic_ostream",
            "sample_declaration": "virtual ~basic_ostream();"
        },
        {
            "title": "std::basic_ostream<CharT,Traits>::basic_ostream",
            "path": "en.cppreference.com/w/cpp/io/basic_ostream/basic_ostream.html",
            "wgPageName": "cpp/io/basic_ostream/basic_ostream",
            "sample_declaration": "explicit basic_ostream(\n    std::basic_streambuf<CharT, Traits>* sb);",
            "other_declarations": 2
        },
        {
            "title": "std::basic_ostream<CharT,Traits>::flush",
            "path": "en.cppreference.com/w/cpp/io/basic_ostream/flush.html",
            "wgPageName": "cpp/io/basic_ostream/flush",
            "sample_declaration": "basic_ostream& flush();"
        },
        {
            "title": "std::basic_ostream<CharT,Traits>::operator<<",
            "path": "en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt.html",
            "wgPageName": "cpp/io/basic_ostream/operator_ltlt",
            "sample_declaration": "basic_ostream& operator<<(short value);\nbasic_ostream& operator<<(unsigned short value);",
            "other_declarations": 12
        },
        {
            "title": "operator<<(std::basic_ostream)",
            "path": "en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt2.html",
            "wgPageName": "cpp/io/basic_ostream/operator_ltlt2",
            "headers": [
                "<ostream>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nbasic_ostream<CharT, Traits>& operator<<(\n    basic_ostream<CharT, Traits>& os,\n    CharT ch);",
            "other_declarations": 24
        },
        {
            "title": "std::basic_ostream<CharT,Traits>::operator=",
            "path": "en.cppreference.com/w/cpp/io/basic_ostream/operator=.html",
            "wgPageName": "cpp/io/basic_ostream/operator=",
            "sample_declaration": "protected:\nbasic_ostream& operator=(\n    const basic_ostream& rhs) = delete;",
            "other_declarations": 1
        },
        {
            "title": "print(std::ostream)",
            "path": "en.cppreference.com/w/cpp/io/basic_ostream/print.html",
            "wgPageName": "cpp/io/basic_ostream/print",
            "headers": [
                "<ostream>"
            ],
            "sample_declaration": "template<class... Args>\nvoid print(\n    std::ostream& os,\n    std::format_string<Args...> fmt,\n    Args&&... args);"
        },
        {
            "title": "println(std::ostream)",
            "path": "en.cppreference.com/w/cpp/io/basic_ostream/println.html",
            "wgPageName": "cpp/io/basic_ostream/println",
            "headers": [
                "<ostream>"
            ],
            "sample_declaration": "template<class... Args>\nvoid println(\n    std::ostream& os,\n    std::format_string<Args...> fmt,\n    Args&&... args);"
        },
        {
            "title": "std::basic_ostream<CharT,Traits>::put",
            "path": "en.cppreference.com/w/cpp/io/basic_ostream/put.html",
            "wgPageName": "cpp/io/basic_ostream/put",
            "sample_declaration": "basic_ostream& put(char_type ch);"
        },
        {
            "title": "std::basic_ostream<CharT,Traits>::seekp",
            "path": "en.cppreference.com/w/cpp/io/basic_ostream/seekp.html",
            "wgPageName": "cpp/io/basic_ostream/seekp",
            "sample_declaration": "basic_ostream& seekp(pos_type pos);",
            "other_declarations": 1
        },
        {
            "title": "std::basic_ostream<CharT,Traits>::sentry",
            "path": "en.cppreference.com/w/cpp/io/basic_ostream/sentry.html",
            "wgPageName": "cpp/io/basic_ostream/sentry",
            "sample_declaration": "class sentry;"
        },
        {
            "title": "std::basic_ostream<CharT,Traits>::swap",
            "path": "en.cppreference.com/w/cpp/io/basic_ostream/swap.html",
            "wgPageName": "cpp/io/basic_ostream/swap",
            "sample_declaration": "protected:\nvoid swap(basic_ostream& rhs);"
        },
        {
            "title": "std::basic_ostream<CharT,Traits>::tellp",
            "path": "en.cppreference.com/w/cpp/io/basic_ostream/tellp.html",
            "wgPageName": "cpp/io/basic_ostream/tellp",
            "sample_declaration": "pos_type tellp();"
        },
        {
            "title": "vprint_nonunicode(std::ostream)",
            "path": "en.cppreference.com/w/cpp/io/basic_ostream/vprint_nonunicode.html",
            "wgPageName": "cpp/io/basic_ostream/vprint_nonunicode",
            "headers": [
                "<ostream>"
            ],
            "sample_declaration": "void vprint_nonunicode(\n    std::ostream& os,\n    std::string_view fmt,\n    std::format_args args);"
        },
        {
            "title": "vprint_unicode(std::ostream)",
            "path": "en.cppreference.com/w/cpp/io/basic_ostream/vprint_unicode.html",
            "wgPageName": "cpp/io/basic_ostream/vprint_unicode",
            "headers": [
                "<ostream>"
            ],
            "sample_declaration": "void vprint_unicode(\n    std::ostream& os,\n    std::string_view fmt,\n    std::format_args args);"
        },
        {
            "title": "std::basic_ostream<CharT,Traits>::write",
            "path": "en.cppreference.com/w/cpp/io/basic_ostream/write.html",
            "wgPageName": "cpp/io/basic_ostream/write",
            "sample_declaration": "basic_ostream& write(\n    const char_type* s,\n    std::streamsize count);"
        },
        {
            "title": "std::basic_ostringstream",
            "path": "en.cppreference.com/w/cpp/io/basic_ostringstream.html",
            "wgPageName": "cpp/io/basic_ostringstream",
            "headers": [
                "<sstream>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT>,\n    class Allocator = std::allocator<CharT> >\nclass basic_ostringstream;"
        },
        {
            "title": "std::basic_ostringstream<CharT,Traits,Allocator>::basic_ostringstream",
            "path": "en.cppreference.com/w/cpp/io/basic_ostringstream/basic_ostringstream.html",
            "wgPageName": "cpp/io/basic_ostringstream/basic_ostringstream",
            "sample_declaration": "basic_ostringstream()\n    : basic_ostringstream(std::ios_base::out) {}",
            "other_declarations": 9
        },
        {
            "title": "std::basic_ostringstream::operator=",
            "path": "en.cppreference.com/w/cpp/io/basic_ostringstream/operator=.html",
            "wgPageName": "cpp/io/basic_ostringstream/operator=",
            "sample_declaration": "basic_ostringstream& operator=(\n    basic_ostringstream&& other);"
        },
        {
            "title": "std::basic_ostringstream::rdbuf",
            "path": "en.cppreference.com/w/cpp/io/basic_ostringstream/rdbuf.html",
            "wgPageName": "cpp/io/basic_ostringstream/rdbuf",
            "sample_declaration": "std::basic_stringbuf<CharT, Traits, Allocator>*\nrdbuf() const;"
        },
        {
            "title": "std::basic_ostringstream<CharT,Traits,Allocator>::str",
            "path": "en.cppreference.com/w/cpp/io/basic_ostringstream/str.html",
            "wgPageName": "cpp/io/basic_ostringstream/str",
            "sample_declaration": "std::basic_string<CharT, Traits, Allocator>\nstr() const;",
            "other_declarations": 6
        },
        {
            "title": "std::basic_ostringstream::swap",
            "path": "en.cppreference.com/w/cpp/io/basic_ostringstream/swap.html",
            "wgPageName": "cpp/io/basic_ostringstream/swap",
            "sample_declaration": "void swap(basic_ostringstream& other);"
        },
        {
            "title": "std::swap(std::basic_ostringstream)",
            "path": "en.cppreference.com/w/cpp/io/basic_ostringstream/swap2.html",
            "wgPageName": "cpp/io/basic_ostringstream/swap2",
            "headers": [
                "<sstream>"
            ],
            "sample_declaration": "template<class CharT, class Traits, class Alloc>\nvoid swap(\n    std::basic_ostringstream<\n        CharT,\n        Traits,\n        Alloc>& lhs,\n    std::basic_ostringstream<\n        CharT,\n        Traits,\n        Alloc>& rhs);"
        },
        {
            "title": "std::basic_ostringstream<CharT,Traits,Allocator>::view",
            "path": "en.cppreference.com/w/cpp/io/basic_ostringstream/view.html",
            "wgPageName": "cpp/io/basic_ostringstream/view",
            "sample_declaration": "std::basic_string_view<CharT, Traits> view()\n    const noexcept;"
        },
        {
            "title": "std::basic_osyncstream",
            "path": "en.cppreference.com/w/cpp/io/basic_osyncstream.html",
            "wgPageName": "cpp/io/basic_osyncstream",
            "headers": [
                "<syncstream>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT>,\n    class Allocator = std::allocator<CharT> >\nclass basic_osyncstream\n    : public std::basic_ostream<CharT, Traits>"
        },
        {
            "title": "std::basic_osyncstream<CharT,Traits,Allocator>::~basic_osyncstream",
            "path": "en.cppreference.com/w/cpp/io/basic_osyncstream/~basic_osyncstream.html",
            "wgPageName": "cpp/io/basic_osyncstream/~basic_osyncstream",
            "sample_declaration": "~basic_osyncstream();"
        },
        {
            "title": "std::basic_osyncstream<CharT,Traits,Allocator>::basic_osyncstream",
            "path": "en.cppreference.com/w/cpp/io/basic_osyncstream/basic_osyncstream.html",
            "wgPageName": "cpp/io/basic_osyncstream/basic_osyncstream",
            "sample_declaration": "basic_osyncstream(\n    streambuf_type* buf,\n    const Allocator& a);",
            "other_declarations": 4
        },
        {
            "title": "std::basic_osyncstream<CharT,Traits,Allocator>::emit",
            "path": "en.cppreference.com/w/cpp/io/basic_osyncstream/emit.html",
            "wgPageName": "cpp/io/basic_osyncstream/emit",
            "sample_declaration": "void emit();"
        },
        {
            "title": "std::basic_osyncstream<CharT,Traits,Allocator>::get_wrapped",
            "path": "en.cppreference.com/w/cpp/io/basic_osyncstream/get_wrapped.html",
            "wgPageName": "cpp/io/basic_osyncstream/get_wrapped",
            "sample_declaration": "streambuf_type* get_wrapped() const noexcept;"
        },
        {
            "title": "std::basic_osyncstream<CharT,Traits,Allocator>::operator=",
            "path": "en.cppreference.com/w/cpp/io/basic_osyncstream/operator=.html",
            "wgPageName": "cpp/io/basic_osyncstream/operator=",
            "sample_declaration": "basic_osyncstream& operator=(\n    std::basic_osyncstream&& other) noexcept;"
        },
        {
            "title": "std::basic_osyncstream<CharT,Traits,Allocator>::rdbuf",
            "path": "en.cppreference.com/w/cpp/io/basic_osyncstream/rdbuf.html",
            "wgPageName": "cpp/io/basic_osyncstream/rdbuf",
            "sample_declaration": "syncbuf_type* rdbuf() const noexcept;"
        },
        {
            "title": "std::basic_spanbuf",
            "path": "en.cppreference.com/w/cpp/io/basic_spanbuf.html",
            "wgPageName": "cpp/io/basic_spanbuf",
            "headers": [
                "<spanstream>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT> >\nclass basic_spanbuf\n    : public std::basic_streambuf<CharT, Traits>"
        },
        {
            "title": "std::basic_spanbuf<CharT,Traits>::basic_spanbuf",
            "path": "en.cppreference.com/w/cpp/io/basic_spanbuf/basic_spanbuf.html",
            "wgPageName": "cpp/io/basic_spanbuf/basic_spanbuf",
            "sample_declaration": "basic_spanbuf()\n    : basic_spanbuf(\n          std::ios_base::in |\n          std::ios_base::out) {}",
            "other_declarations": 4
        },
        {
            "title": "std::basic_spanbuf<CharT,Traits>::operator=",
            "path": "en.cppreference.com/w/cpp/io/basic_spanbuf/operator=.html",
            "wgPageName": "cpp/io/basic_spanbuf/operator=",
            "sample_declaration": "basic_spanbuf& operator=(basic_spanbuf&& rhs);",
            "other_declarations": 1
        },
        {
            "title": "std::basic_spanbuf<CharT,Traits>::seekoff",
            "path": "en.cppreference.com/w/cpp/io/basic_spanbuf/seekoff.html",
            "wgPageName": "cpp/io/basic_spanbuf/seekoff",
            "sample_declaration": "protected:\npos_type seekoff(\n    off_type off,\n    std::ios_base::seekdir dir,\n    std::ios_base::openmode which =\n        std::ios_base::in |\n        std::ios_base::out) override;"
        },
        {
            "title": "std::basic_spanbuf<CharT,Traits>::seekpos",
            "path": "en.cppreference.com/w/cpp/io/basic_spanbuf/seekpos.html",
            "wgPageName": "cpp/io/basic_spanbuf/seekpos",
            "sample_declaration": "protected:\npos_type seekpos(\n    pos_type sp,\n    std::ios_base::openmode which =\n        std::ios_base::in |\n        std::ios_base::out) override;"
        },
        {
            "title": "std::basic_spanbuf<CharT,Traits>::setbuf",
            "path": "en.cppreference.com/w/cpp/io/basic_spanbuf/setbuf.html",
            "wgPageName": "cpp/io/basic_spanbuf/setbuf",
            "sample_declaration": "protected:\nstd::basic_streambuf<CharT, Traits>* setbuf(\n    CharT* s,\n    std::streamsize n) override;"
        },
        {
            "title": "std::basic_spanbuf<CharT,Traits>::span",
            "path": "en.cppreference.com/w/cpp/io/basic_spanbuf/span.html",
            "wgPageName": "cpp/io/basic_spanbuf/span",
            "sample_declaration": "std::span<CharT> span() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_spanbuf<CharT,Traits>::swap",
            "path": "en.cppreference.com/w/cpp/io/basic_spanbuf/swap.html",
            "wgPageName": "cpp/io/basic_spanbuf/swap",
            "sample_declaration": "void swap(basic_spanbuf& rhs);"
        },
        {
            "title": "std::swap(std::basic_spanbuf)",
            "path": "en.cppreference.com/w/cpp/io/basic_spanbuf/swap2.html",
            "wgPageName": "cpp/io/basic_spanbuf/swap2",
            "headers": [
                "<spanstream>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nvoid swap(\n    std::basic_spanbuf<CharT, Traits>& lhs,\n    std::basic_spanbuf<CharT, Traits>& rhs);"
        },
        {
            "title": "std::basic_spanstream",
            "path": "en.cppreference.com/w/cpp/io/basic_spanstream.html",
            "wgPageName": "cpp/io/basic_spanstream",
            "headers": [
                "<spanstream>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT> >\nclass basic_spanstream;"
        },
        {
            "title": "std::basic_spanstream<CharT,Traits>::basic_spanstream",
            "path": "en.cppreference.com/w/cpp/io/basic_spanstream/basic_spanstream.html",
            "wgPageName": "cpp/io/basic_spanstream/basic_spanstream",
            "sample_declaration": "explicit basic_spanstream(\n    std::span<CharT> s,\n    std::ios_base::openmode mode =\n        std::ios_base::in | std::ios_base::out);",
            "other_declarations": 2
        },
        {
            "title": "std::basic_spanstream<CharT,Traits>::operator=",
            "path": "en.cppreference.com/w/cpp/io/basic_spanstream/operator=.html",
            "wgPageName": "cpp/io/basic_spanstream/operator=",
            "sample_declaration": "basic_spanstream& operator=(\n    basic_spanstream&& other);",
            "other_declarations": 1
        },
        {
            "title": "std::basic_spanstream<CharT,Traits>::rdbuf",
            "path": "en.cppreference.com/w/cpp/io/basic_spanstream/rdbuf.html",
            "wgPageName": "cpp/io/basic_spanstream/rdbuf",
            "sample_declaration": "std::basic_spanbuf<CharT, Traits>* rdbuf()\n    const noexcept;"
        },
        {
            "title": "std::basic_spanstream<CharT,Traits>::span",
            "path": "en.cppreference.com/w/cpp/io/basic_spanstream/span.html",
            "wgPageName": "cpp/io/basic_spanstream/span",
            "sample_declaration": "std::span<CharT> span() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_spanstream<CharT,Traits>::swap",
            "path": "en.cppreference.com/w/cpp/io/basic_spanstream/swap.html",
            "wgPageName": "cpp/io/basic_spanstream/swap",
            "sample_declaration": "void swap(basic_spanstream& other);"
        },
        {
            "title": "std::swap(std::basic_spanstream)",
            "path": "en.cppreference.com/w/cpp/io/basic_spanstream/swap2.html",
            "wgPageName": "cpp/io/basic_spanstream/swap2",
            "headers": [
                "<spanstream>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nvoid swap(\n    std::basic_spanstream<CharT, Traits>& lhs,\n    std::basic_spanstream<CharT, Traits>& rhs);"
        },
        {
            "title": "std::basic_streambuf",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf.html",
            "wgPageName": "cpp/io/basic_streambuf",
            "headers": [
                "<streambuf>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT> >\nclass basic_streambuf;"
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::~basic_streambuf",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/~basic_streambuf.html",
            "wgPageName": "cpp/io/basic_streambuf/~basic_streambuf",
            "sample_declaration": "virtual ~basic_streambuf();"
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::basic_streambuf",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/basic_streambuf.html",
            "wgPageName": "cpp/io/basic_streambuf/basic_streambuf",
            "sample_declaration": "protected:\nbasic_streambuf();",
            "other_declarations": 1
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::gbump",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/gbump.html",
            "wgPageName": "cpp/io/basic_streambuf/gbump",
            "sample_declaration": "protected:\nvoid gbump(int count);"
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::getloc",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/getloc.html",
            "wgPageName": "cpp/io/basic_streambuf/getloc",
            "sample_declaration": "std::locale getloc() const;"
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::eback, gptr, egptr",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/gptr.html",
            "wgPageName": "cpp/io/basic_streambuf/gptr",
            "sample_declaration": "char_type* eback() const;",
            "other_declarations": 2
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::in_avail",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/in_avail.html",
            "wgPageName": "cpp/io/basic_streambuf/in_avail",
            "sample_declaration": "std::streamsize in_avail();"
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::operator=",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/operator=.html",
            "wgPageName": "cpp/io/basic_streambuf/operator=",
            "sample_declaration": "basic_streambuf& operator=(\n    const basic_streambuf& other);"
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::overflow",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/overflow.html",
            "wgPageName": "cpp/io/basic_streambuf/overflow",
            "sample_declaration": "protected:\nvirtual int_type overflow(\n    int_type ch = Traits::eof());"
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::pbackfail",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/pbackfail.html",
            "wgPageName": "cpp/io/basic_streambuf/pbackfail",
            "sample_declaration": "protected:\nvirtual int_type pbackfail(\n    int_type c = Traits::eof());"
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::pbump",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/pbump.html",
            "wgPageName": "cpp/io/basic_streambuf/pbump",
            "sample_declaration": "protected:\nvoid pbump(int count);"
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::pbase, std::basic_streambuf<CharT,Traits>::pptr, std::basic_streambuf<CharT,Traits>::epptr",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/pptr.html",
            "wgPageName": "cpp/io/basic_streambuf/pptr",
            "sample_declaration": "char_type* pbase() const;",
            "other_declarations": 2
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::pubimbue, std::basic_streambuf<CharT,Traits>::imbue",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/pubimbue.html",
            "wgPageName": "cpp/io/basic_streambuf/pubimbue",
            "sample_declaration": "std::locale pubimbue(const std::locale& loc);",
            "other_declarations": 1
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::pubseekoff, std::basic_streambuf<CharT,Traits>::seekoff",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/pubseekoff.html",
            "wgPageName": "cpp/io/basic_streambuf/pubseekoff",
            "sample_declaration": "pos_type pubseekoff(\n    off_type off,\n    std::ios_base::seekdir dir,\n    std::ios_base::openmode which =\n        ios_base::in | ios_base::out);",
            "other_declarations": 1
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::pubseekpos, std::basic_streambuf<CharT,Traits>::seekpos",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/pubseekpos.html",
            "wgPageName": "cpp/io/basic_streambuf/pubseekpos",
            "sample_declaration": "pos_type pubseekpos(\n    pos_type pos,\n    std::ios_base::openmode which =\n        std::ios_base::in | std::ios_base::out);",
            "other_declarations": 1
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::pubsetbuf, std::basic_streambuf<CharT,Traits>::setbuf",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/pubsetbuf.html",
            "wgPageName": "cpp/io/basic_streambuf/pubsetbuf",
            "sample_declaration": "public:\nbasic_streambuf<CharT, Traits>* pubsetbuf(\n    char_type* s,\n    std::streamsize n)",
            "other_declarations": 1
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::pubsync, std::basic_streambuf<CharT,Traits>::sync",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/pubsync.html",
            "wgPageName": "cpp/io/basic_streambuf/pubsync",
            "sample_declaration": "int pubsync();",
            "other_declarations": 1
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::sbumpc, std::basic_streambuf<CharT,Traits>::stossc",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/sbumpc.html",
            "wgPageName": "cpp/io/basic_streambuf/sbumpc",
            "sample_declaration": "int_type sbumpc();",
            "other_declarations": 1
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::setg",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/setg.html",
            "wgPageName": "cpp/io/basic_streambuf/setg",
            "sample_declaration": "protected:\nvoid setg(\n    char_type* gbeg,\n    char_type* gcurr,\n    char_type* gend);"
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::setp",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/setp.html",
            "wgPageName": "cpp/io/basic_streambuf/setp",
            "sample_declaration": "protected:\nvoid setp(char_type* pbeg, char_type* pend);"
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::sgetc",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/sgetc.html",
            "wgPageName": "cpp/io/basic_streambuf/sgetc",
            "sample_declaration": "int_type sgetc();"
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::sgetn, std::basic_streambuf<CharT,Traits>::xsgetn",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/sgetn.html",
            "wgPageName": "cpp/io/basic_streambuf/sgetn",
            "sample_declaration": "std::streamsize sgetn(\n    char_type* s,\n    std::streamsize count);",
            "other_declarations": 1
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::showmanyc",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/showmanyc.html",
            "wgPageName": "cpp/io/basic_streambuf/showmanyc",
            "sample_declaration": "protected:\nvirtual std::streamsize showmanyc();"
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::snextc",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/snextc.html",
            "wgPageName": "cpp/io/basic_streambuf/snextc",
            "sample_declaration": "int_type snextc();"
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::sputbackc",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/sputbackc.html",
            "wgPageName": "cpp/io/basic_streambuf/sputbackc",
            "sample_declaration": "int_type sputbackc(char_type c);"
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::sputc",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/sputc.html",
            "wgPageName": "cpp/io/basic_streambuf/sputc",
            "sample_declaration": "int_type sputc(char_type ch);"
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::sputn, std::basic_streambuf<CharT,Traits>::xsputn",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/sputn.html",
            "wgPageName": "cpp/io/basic_streambuf/sputn",
            "sample_declaration": "std::streamsize sputn(\n    const char_type* s,\n    std::streamsize count);",
            "other_declarations": 1
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::sungetc",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/sungetc.html",
            "wgPageName": "cpp/io/basic_streambuf/sungetc",
            "sample_declaration": "int_type sungetc();"
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::swap",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/swap.html",
            "wgPageName": "cpp/io/basic_streambuf/swap",
            "sample_declaration": "void swap(basic_streambuf& other);"
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::uflow",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/uflow.html",
            "wgPageName": "cpp/io/basic_streambuf/uflow",
            "sample_declaration": "protected:\nvirtual int_type uflow();"
        },
        {
            "title": "std::basic_streambuf<CharT,Traits>::underflow",
            "path": "en.cppreference.com/w/cpp/io/basic_streambuf/underflow.html",
            "wgPageName": "cpp/io/basic_streambuf/underflow",
            "sample_declaration": "protected:\nvirtual int_type underflow();"
        },
        {
            "title": "std::basic_stringbuf",
            "path": "en.cppreference.com/w/cpp/io/basic_stringbuf.html",
            "wgPageName": "cpp/io/basic_stringbuf",
            "headers": [
                "<sstream>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT>,\n    class Allocator = std::allocator<CharT> >\nclass basic_stringbuf\n    : public std::basic_streambuf<CharT, Traits>"
        },
        {
            "title": "std::basic_stringbuf<CharT,Traits,Allocator>::basic_stringbuf",
            "path": "en.cppreference.com/w/cpp/io/basic_stringbuf/basic_stringbuf.html",
            "wgPageName": "cpp/io/basic_stringbuf/basic_stringbuf",
            "sample_declaration": "basic_stringbuf()\n    : basic_stringbuf(\n          std::ios_base::in |\n          std::ios_base::out) {}",
            "other_declarations": 12
        },
        {
            "title": "std::basic_stringbuf<CharT,Traits,Allocator>::get_allocator",
            "path": "en.cppreference.com/w/cpp/io/basic_stringbuf/get_allocator.html",
            "wgPageName": "cpp/io/basic_stringbuf/get_allocator",
            "sample_declaration": "allocator_type get_allocator() const noexcept;"
        },
        {
            "title": "std::basic_stringbuf<CharT,Traits,Allocator>::operator=",
            "path": "en.cppreference.com/w/cpp/io/basic_stringbuf/operator=.html",
            "wgPageName": "cpp/io/basic_stringbuf/operator=",
            "sample_declaration": "std::basic_stringbuf& operator=(\n    std::basic_stringbuf&& rhs);",
            "other_declarations": 1
        },
        {
            "title": "std::basic_stringbuf<CharT,Traits,Allocator>::overflow",
            "path": "en.cppreference.com/w/cpp/io/basic_stringbuf/overflow.html",
            "wgPageName": "cpp/io/basic_stringbuf/overflow",
            "sample_declaration": "protected:\nvirtual int_type overflow(\n    int_type c = Traits::eof());"
        },
        {
            "title": "std::basic_stringbuf<CharT,Traits,Allocator>::pbackfail",
            "path": "en.cppreference.com/w/cpp/io/basic_stringbuf/pbackfail.html",
            "wgPageName": "cpp/io/basic_stringbuf/pbackfail",
            "sample_declaration": "protected:\nvirtual int_type pbackfail(\n    int_type c = Traits::eof())"
        },
        {
            "title": "std::basic_stringbuf<CharT,Traits,Allocator>::seekoff",
            "path": "en.cppreference.com/w/cpp/io/basic_stringbuf/seekoff.html",
            "wgPageName": "cpp/io/basic_stringbuf/seekoff",
            "sample_declaration": "protected:\nvirtual pos_type seekoff(\n    off_type off,\n    ios_base::seekdir dir,\n    ios_base::openmode which = ios_base::in |\n                               ios_base::out);"
        },
        {
            "title": "std::basic_stringbuf<CharT,Traits,Allocator>::seekpos",
            "path": "en.cppreference.com/w/cpp/io/basic_stringbuf/seekpos.html",
            "wgPageName": "cpp/io/basic_stringbuf/seekpos",
            "sample_declaration": "protected:\nvirtual pos_type seekpos(\n    pos_type sp,\n    std::ios_base::openmode which =\n        std::ios_base::in | std::ios_base::out);"
        },
        {
            "title": "std::basic_stringbuf<CharT,Traits,Allocator>::setbuf",
            "path": "en.cppreference.com/w/cpp/io/basic_stringbuf/setbuf.html",
            "wgPageName": "cpp/io/basic_stringbuf/setbuf",
            "sample_declaration": "protected:\nvirtual std::basic_streambuf<CharT, Traits>*\nsetbuf(char_type* s, std::streamsize n)"
        },
        {
            "title": "std::basic_stringbuf<CharT,Traits,Allocator>::str",
            "path": "en.cppreference.com/w/cpp/io/basic_stringbuf/str.html",
            "wgPageName": "cpp/io/basic_stringbuf/str",
            "sample_declaration": "std::basic_string<CharT, Traits, Allocator>\nstr() const;",
            "other_declarations": 6
        },
        {
            "title": "std::basic_stringbuf<CharT,Traits,Allocator>::swap",
            "path": "en.cppreference.com/w/cpp/io/basic_stringbuf/swap.html",
            "wgPageName": "cpp/io/basic_stringbuf/swap",
            "sample_declaration": "void swap(basic_stringbuf& rhs);",
            "other_declarations": 1
        },
        {
            "title": "std::swap(std::basic_stringbuf)",
            "path": "en.cppreference.com/w/cpp/io/basic_stringbuf/swap2.html",
            "wgPageName": "cpp/io/basic_stringbuf/swap2",
            "headers": [
                "<sstream>"
            ],
            "sample_declaration": "template<class CharT, class Traits, class Alloc>\nvoid swap(\n    std::basic_stringbuf<CharT, Traits, Alloc>&\n        lhs,\n    std::basic_stringbuf<CharT, Traits, Alloc>&\n        rhs);",
            "other_declarations": 1
        },
        {
            "title": "std::basic_stringbuf<CharT,Traits,Allocator>::underflow",
            "path": "en.cppreference.com/w/cpp/io/basic_stringbuf/underflow.html",
            "wgPageName": "cpp/io/basic_stringbuf/underflow",
            "sample_declaration": "protected:\nvirtual int_type underflow()"
        },
        {
            "title": "std::basic_stringbuf<CharT,Traits,Allocator>::view",
            "path": "en.cppreference.com/w/cpp/io/basic_stringbuf/view.html",
            "wgPageName": "cpp/io/basic_stringbuf/view",
            "sample_declaration": "std::basic_string_view<CharT, Traits> view()\n    const noexcept;"
        },
        {
            "title": "std::basic_stringstream",
            "path": "en.cppreference.com/w/cpp/io/basic_stringstream.html",
            "wgPageName": "cpp/io/basic_stringstream",
            "headers": [
                "<sstream>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT>,\n    class Allocator = std::allocator<CharT> >\nclass basic_stringstream;"
        },
        {
            "title": "std::basic_stringstream<CharT,Traits,Allocator>::basic_stringstream",
            "path": "en.cppreference.com/w/cpp/io/basic_stringstream/basic_stringstream.html",
            "wgPageName": "cpp/io/basic_stringstream/basic_stringstream",
            "sample_declaration": "basic_stringstream()\n    : basic_stringstream(\n          std::ios_base::in |\n          std::ios_base::out) {}",
            "other_declarations": 9
        },
        {
            "title": "std::basic_stringstream::operator=",
            "path": "en.cppreference.com/w/cpp/io/basic_stringstream/operator=.html",
            "wgPageName": "cpp/io/basic_stringstream/operator=",
            "sample_declaration": "basic_stringstream& operator=(\n    basic_stringstream&& other);"
        },
        {
            "title": "std::basic_stringstream::rdbuf",
            "path": "en.cppreference.com/w/cpp/io/basic_stringstream/rdbuf.html",
            "wgPageName": "cpp/io/basic_stringstream/rdbuf",
            "sample_declaration": "std::basic_stringbuf<CharT, Traits, Allocator>*\nrdbuf() const;"
        },
        {
            "title": "std::basic_stringstream<CharT,Traits,Allocator>::str",
            "path": "en.cppreference.com/w/cpp/io/basic_stringstream/str.html",
            "wgPageName": "cpp/io/basic_stringstream/str",
            "sample_declaration": "std::basic_string<CharT, Traits, Allocator>\nstr() const;",
            "other_declarations": 6
        },
        {
            "title": "std::basic_stringstream::swap",
            "path": "en.cppreference.com/w/cpp/io/basic_stringstream/swap.html",
            "wgPageName": "cpp/io/basic_stringstream/swap",
            "sample_declaration": "void swap(basic_stringstream& other);"
        },
        {
            "title": "std::swap(std::basic_stringstream)",
            "path": "en.cppreference.com/w/cpp/io/basic_stringstream/swap2.html",
            "wgPageName": "cpp/io/basic_stringstream/swap2",
            "headers": [
                "<sstream>"
            ],
            "sample_declaration": "template<class CharT, class Traits, class Alloc>\nvoid swap(\n    std::basic_stringstream<\n        CharT,\n        Traits,\n        Alloc>& lhs,\n    std::basic_stringstream<\n        CharT,\n        Traits,\n        Alloc>& rhs);"
        },
        {
            "title": "std::basic_stringstream<CharT,Traits,Allocator>::view",
            "path": "en.cppreference.com/w/cpp/io/basic_stringstream/view.html",
            "wgPageName": "cpp/io/basic_stringstream/view",
            "sample_declaration": "std::basic_string_view<CharT, Traits> view()\n    const noexcept;"
        },
        {
            "title": "std::basic_syncbuf",
            "path": "en.cppreference.com/w/cpp/io/basic_syncbuf.html",
            "wgPageName": "cpp/io/basic_syncbuf",
            "headers": [
                "<syncstream>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT>,\n    class Allocator = std::allocator<CharT> >\nclass basic_syncbuf\n    : public std::basic_streambuf<CharT, Traits>"
        },
        {
            "title": "std::basic_syncbuf<CharT,Traits,Allocator>::~basic_syncbuf",
            "path": "en.cppreference.com/w/cpp/io/basic_syncbuf/~basic_syncbuf.html",
            "wgPageName": "cpp/io/basic_syncbuf/~basic_syncbuf",
            "sample_declaration": "~basic_syncbuf();"
        },
        {
            "title": "std::basic_syncbuf<CharT,Traits,Allocator>::basic_syncbuf",
            "path": "en.cppreference.com/w/cpp/io/basic_syncbuf/basic_syncbuf.html",
            "wgPageName": "cpp/io/basic_syncbuf/basic_syncbuf",
            "sample_declaration": "basic_syncbuf() : basic_syncbuf(nullptr)",
            "other_declarations": 3
        },
        {
            "title": "std::basic_syncbuf<CharT,Traits,Allocator>::emit",
            "path": "en.cppreference.com/w/cpp/io/basic_syncbuf/emit.html",
            "wgPageName": "cpp/io/basic_syncbuf/emit",
            "sample_declaration": "bool emit();"
        },
        {
            "title": "std::basic_syncbuf<CharT,Traits,Allocator>::get_allocator",
            "path": "en.cppreference.com/w/cpp/io/basic_syncbuf/get_allocator.html",
            "wgPageName": "cpp/io/basic_syncbuf/get_allocator",
            "sample_declaration": "allocator_type get_allocator() const noexcept;"
        },
        {
            "title": "std::basic_syncbuf<CharT,Traits,Allocator>::get_wrapped",
            "path": "en.cppreference.com/w/cpp/io/basic_syncbuf/get_wrapped.html",
            "wgPageName": "cpp/io/basic_syncbuf/get_wrapped",
            "sample_declaration": "streambuf_type* get_wrapped() const noexcept;"
        },
        {
            "title": "std::basic_syncbuf<CharT,Traits,Allocator>::operator=",
            "path": "en.cppreference.com/w/cpp/io/basic_syncbuf/operator=.html",
            "wgPageName": "cpp/io/basic_syncbuf/operator=",
            "sample_declaration": "basic_syncbuf& operator=(basic_syncbuf&& other);"
        },
        {
            "title": "std::basic_syncbuf<CharT,Traits,Allocator>::set_emit_on_sync",
            "path": "en.cppreference.com/w/cpp/io/basic_syncbuf/set_emit_on_sync.html",
            "wgPageName": "cpp/io/basic_syncbuf/set_emit_on_sync",
            "sample_declaration": "void set_emit_on_sync(bool b) noexcept;"
        },
        {
            "title": "std::basic_syncbuf<CharT,Traits,Allocator>::swap",
            "path": "en.cppreference.com/w/cpp/io/basic_syncbuf/swap.html",
            "wgPageName": "cpp/io/basic_syncbuf/swap",
            "sample_declaration": "void swap(basic_syncbuf& other);"
        },
        {
            "title": "std::swap(std::basic_syncbuf)",
            "path": "en.cppreference.com/w/cpp/io/basic_syncbuf/swap2.html",
            "wgPageName": "cpp/io/basic_syncbuf/swap2",
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Allocator>\nvoid swap(\n    std::\n        basic_syncbuf<CharT, Traits, Allocator>&\n            lhs,\n    std::\n        basic_syncbuf<CharT, Traits, Allocator>&\n            rhs);"
        },
        {
            "title": "std::basic_syncbuf<CharT,Traits,Allocator>::sync",
            "path": "en.cppreference.com/w/cpp/io/basic_syncbuf/sync.html",
            "wgPageName": "cpp/io/basic_syncbuf/sync",
            "sample_declaration": "protected:\nint sync() override;"
        },
        {
            "title": "C-style file input/output",
            "path": "en.cppreference.com/w/cpp/io/c.html",
            "wgPageName": "cpp/io/c"
        },
        {
            "title": "std::clearerr",
            "path": "en.cppreference.com/w/cpp/io/c/clearerr.html",
            "wgPageName": "cpp/io/c/clearerr",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "void clearerr(std::FILE* stream);"
        },
        {
            "title": "std::fclose",
            "path": "en.cppreference.com/w/cpp/io/c/fclose.html",
            "wgPageName": "cpp/io/c/fclose",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "int fclose(std::FILE* stream);"
        },
        {
            "title": "std::feof",
            "path": "en.cppreference.com/w/cpp/io/c/feof.html",
            "wgPageName": "cpp/io/c/feof",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "int feof(std::FILE* stream);"
        },
        {
            "title": "std::ferror",
            "path": "en.cppreference.com/w/cpp/io/c/ferror.html",
            "wgPageName": "cpp/io/c/ferror",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "int ferror(std::FILE* stream);"
        },
        {
            "title": "std::fflush",
            "path": "en.cppreference.com/w/cpp/io/c/fflush.html",
            "wgPageName": "cpp/io/c/fflush",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "int fflush(std::FILE* stream);"
        },
        {
            "title": "std::fgetc, std::getc",
            "path": "en.cppreference.com/w/cpp/io/c/fgetc.html",
            "wgPageName": "cpp/io/c/fgetc",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "int fgetc(std::FILE* stream);\nint getc(std::FILE* stream);"
        },
        {
            "title": "std::fgetpos",
            "path": "en.cppreference.com/w/cpp/io/c/fgetpos.html",
            "wgPageName": "cpp/io/c/fgetpos",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "int fgetpos(\n    std::FILE* stream,\n    std::fpos_t* pos);"
        },
        {
            "title": "std::fgets",
            "path": "en.cppreference.com/w/cpp/io/c/fgets.html",
            "wgPageName": "cpp/io/c/fgets",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "char* fgets(\n    char* str,\n    int count,\n    std::FILE* stream);"
        },
        {
            "title": "std::fgetwc",
            "path": "en.cppreference.com/w/cpp/io/c/fgetwc.html",
            "wgPageName": "cpp/io/c/fgetwc",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "wint_t fgetwc(std::FILE* stream);",
            "other_declarations": 1
        },
        {
            "title": "std::fgetws",
            "path": "en.cppreference.com/w/cpp/io/c/fgetws.html",
            "wgPageName": "cpp/io/c/fgetws",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "wchar_t* fgetws(\n    wchar_t* str,\n    int count,\n    std::FILE* stream);"
        },
        {
            "title": "std::FILE",
            "path": "en.cppreference.com/w/cpp/io/c/FILE.html",
            "wgPageName": "cpp/io/c/FILE",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "typedef /* unspecified */ FILE;"
        },
        {
            "title": "std::fopen",
            "path": "en.cppreference.com/w/cpp/io/c/fopen.html",
            "wgPageName": "cpp/io/c/fopen",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "std::FILE* fopen(\n    const char* filename,\n    const char* mode);"
        },
        {
            "title": "std::fpos_t",
            "path": "en.cppreference.com/w/cpp/io/c/fpos_t.html",
            "wgPageName": "cpp/io/c/fpos_t",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "typedef /* implementation-defined */ fpos_t;"
        },
        {
            "title": "std::printf, std::fprintf, std::sprintf, std::snprintf",
            "path": "en.cppreference.com/w/cpp/io/c/fprintf.html",
            "wgPageName": "cpp/io/c/fprintf",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "int printf(const char* format, ...);",
            "other_declarations": 3
        },
        {
            "title": "std::fputc, std::putc",
            "path": "en.cppreference.com/w/cpp/io/c/fputc.html",
            "wgPageName": "cpp/io/c/fputc",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "int fputc(int ch, std::FILE* stream);\nint putc(int ch, std::FILE* stream);"
        },
        {
            "title": "std::fputs",
            "path": "en.cppreference.com/w/cpp/io/c/fputs.html",
            "wgPageName": "cpp/io/c/fputs",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "int fputs(const char* str, std::FILE* stream);"
        },
        {
            "title": "std::fputwc",
            "path": "en.cppreference.com/w/cpp/io/c/fputwc.html",
            "wgPageName": "cpp/io/c/fputwc",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "wint_t fputwc(wchar_t ch, std::FILE* stream);",
            "other_declarations": 1
        },
        {
            "title": "std::fputws",
            "path": "en.cppreference.com/w/cpp/io/c/fputws.html",
            "wgPageName": "cpp/io/c/fputws",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "int fputws(\n    const wchar_t* str,\n    std::FILE* stream);"
        },
        {
            "title": "std::fread",
            "path": "en.cppreference.com/w/cpp/io/c/fread.html",
            "wgPageName": "cpp/io/c/fread",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "std::size_t fread(\n    void* buffer,\n    std::size_t size,\n    std::size_t count,\n    std::FILE* stream);"
        },
        {
            "title": "std::freopen",
            "path": "en.cppreference.com/w/cpp/io/c/freopen.html",
            "wgPageName": "cpp/io/c/freopen",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "std::FILE* freopen(\n    const char* filename,\n    const char* mode,\n    std::FILE* stream);"
        },
        {
            "title": "std::scanf, std::fscanf, std::sscanf",
            "path": "en.cppreference.com/w/cpp/io/c/fscanf.html",
            "wgPageName": "cpp/io/c/fscanf",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "int scanf(const char* format, ...);",
            "other_declarations": 2
        },
        {
            "title": "std::fseek",
            "path": "en.cppreference.com/w/cpp/io/c/fseek.html",
            "wgPageName": "cpp/io/c/fseek",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "int fseek(\n    std::FILE* stream,\n    long offset,\n    int origin);"
        },
        {
            "title": "std::fsetpos",
            "path": "en.cppreference.com/w/cpp/io/c/fsetpos.html",
            "wgPageName": "cpp/io/c/fsetpos",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "int fsetpos(\n    std::FILE* stream,\n    const std::fpos_t* pos);"
        },
        {
            "title": "std::ftell",
            "path": "en.cppreference.com/w/cpp/io/c/ftell.html",
            "wgPageName": "cpp/io/c/ftell",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "long ftell(std::FILE* stream);"
        },
        {
            "title": "std::fwide",
            "path": "en.cppreference.com/w/cpp/io/c/fwide.html",
            "wgPageName": "cpp/io/c/fwide",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "int fwide(std::FILE* stream, int mode);"
        },
        {
            "title": "std::wprintf, std::fwprintf, std::swprintf",
            "path": "en.cppreference.com/w/cpp/io/c/fwprintf.html",
            "wgPageName": "cpp/io/c/fwprintf",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "int wprintf(const wchar_t* format, ...);",
            "other_declarations": 2
        },
        {
            "title": "std::fwrite",
            "path": "en.cppreference.com/w/cpp/io/c/fwrite.html",
            "wgPageName": "cpp/io/c/fwrite",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "std::size_t fwrite(\n    const void* buffer,\n    std::size_t size,\n    std::size_t count,\n    std::FILE* stream);"
        },
        {
            "title": "std::wscanf, std::fwscanf, std::swscanf",
            "path": "en.cppreference.com/w/cpp/io/c/fwscanf.html",
            "wgPageName": "cpp/io/c/fwscanf",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "int wscanf(const wchar_t* format, ...);",
            "other_declarations": 2
        },
        {
            "title": "std::getchar",
            "path": "en.cppreference.com/w/cpp/io/c/getchar.html",
            "wgPageName": "cpp/io/c/getchar",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "int getchar();"
        },
        {
            "title": "std::gets",
            "path": "en.cppreference.com/w/cpp/io/c/gets.html",
            "wgPageName": "cpp/io/c/gets",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "char* gets(char* str);"
        },
        {
            "title": "std::getwchar",
            "path": "en.cppreference.com/w/cpp/io/c/getwchar.html",
            "wgPageName": "cpp/io/c/getwchar",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "wint_t getwchar();"
        },
        {
            "title": "std::perror",
            "path": "en.cppreference.com/w/cpp/io/c/perror.html",
            "wgPageName": "cpp/io/c/perror",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "void perror(const char* s);"
        },
        {
            "title": "std::printf, std::fprintf, std::sprintf, std::snprintf",
            "path": "en.cppreference.com/w/cpp/io/c/printf.html",
            "wgPageName": "cpp/io/c/fprintf",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "int printf(const char* format, ...);",
            "other_declarations": 3
        },
        {
            "title": "std::putchar",
            "path": "en.cppreference.com/w/cpp/io/c/putchar.html",
            "wgPageName": "cpp/io/c/putchar",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "int putchar(int ch);"
        },
        {
            "title": "std::puts",
            "path": "en.cppreference.com/w/cpp/io/c/puts.html",
            "wgPageName": "cpp/io/c/puts",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "int puts(const char* str);"
        },
        {
            "title": "std::putwchar",
            "path": "en.cppreference.com/w/cpp/io/c/putwchar.html",
            "wgPageName": "cpp/io/c/putwchar",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "wint_t putwchar(wchar_t ch);"
        },
        {
            "title": "std::remove",
            "path": "en.cppreference.com/w/cpp/io/c/remove.html",
            "wgPageName": "cpp/io/c/remove",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "int remove(const char* fname);"
        },
        {
            "title": "std::rename",
            "path": "en.cppreference.com/w/cpp/io/c/rename.html",
            "wgPageName": "cpp/io/c/rename",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "int rename(\n    const char* old_filename,\n    const char* new_filename);"
        },
        {
            "title": "std::rewind",
            "path": "en.cppreference.com/w/cpp/io/c/rewind.html",
            "wgPageName": "cpp/io/c/rewind",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "void rewind(std::FILE* stream);"
        },
        {
            "title": "std::scanf, std::fscanf, std::sscanf",
            "path": "en.cppreference.com/w/cpp/io/c/scanf.html",
            "wgPageName": "cpp/io/c/fscanf",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "int scanf(const char* format, ...);",
            "other_declarations": 2
        },
        {
            "title": "std::setbuf",
            "path": "en.cppreference.com/w/cpp/io/c/setbuf.html",
            "wgPageName": "cpp/io/c/setbuf",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "void setbuf(std::FILE* stream, char* buffer);"
        },
        {
            "title": "std::setvbuf",
            "path": "en.cppreference.com/w/cpp/io/c/setvbuf.html",
            "wgPageName": "cpp/io/c/setvbuf",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "int setvbuf(\n    std::FILE* stream,\n    char* buffer,\n    int mode,\n    std::size_t size);"
        },
        {
            "title": "std::printf, std::fprintf, std::sprintf, std::snprintf",
            "path": "en.cppreference.com/w/cpp/io/c/snprintf.html",
            "wgPageName": "cpp/io/c/fprintf",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "int printf(const char* format, ...);",
            "other_declarations": 3
        },
        {
            "title": "stdin, stdout, stderr",
            "path": "en.cppreference.com/w/cpp/io/c/std_streams.html",
            "wgPageName": "cpp/io/c/std_streams",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "#define stdin /* implementation-defined */",
            "other_declarations": 2
        },
        {
            "title": "std::tmpfile",
            "path": "en.cppreference.com/w/cpp/io/c/tmpfile.html",
            "wgPageName": "cpp/io/c/tmpfile",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "std::FILE* tmpfile();"
        },
        {
            "title": "std::tmpnam",
            "path": "en.cppreference.com/w/cpp/io/c/tmpnam.html",
            "wgPageName": "cpp/io/c/tmpnam",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "char* tmpnam(char* filename);"
        },
        {
            "title": "std::ungetc",
            "path": "en.cppreference.com/w/cpp/io/c/ungetc.html",
            "wgPageName": "cpp/io/c/ungetc",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "int ungetc(int ch, std::FILE* stream);"
        },
        {
            "title": "std::ungetwc",
            "path": "en.cppreference.com/w/cpp/io/c/ungetwc.html",
            "wgPageName": "cpp/io/c/ungetwc",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "wint_t ungetwc(wint_t ch, std::FILE* stream);"
        },
        {
            "title": "std::vprintf, std::vfprintf, std::vsprintf, std::vsnprintf",
            "path": "en.cppreference.com/w/cpp/io/c/vfprintf.html",
            "wgPageName": "cpp/io/c/vfprintf",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "int vprintf(const char* format, va_list vlist);",
            "other_declarations": 3
        },
        {
            "title": "std::vscanf, std::vfscanf, std::vsscanf",
            "path": "en.cppreference.com/w/cpp/io/c/vfscanf.html",
            "wgPageName": "cpp/io/c/vfscanf",
            "headers": [
                "<cstdio>"
            ],
            "sample_declaration": "int vscanf(const char* format, va_list vlist);",
            "other_declarations": 2
        },
        {
            "title": "std::vwprintf, std::vfwprintf, std::vswprintf",
            "path": "en.cppreference.com/w/cpp/io/c/vfwprintf.html",
            "wgPageName": "cpp/io/c/vfwprintf",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "int vwprintf(\n    const wchar_t* format,\n    va_list vlist);",
            "other_declarations": 2
        },
        {
            "title": "std::vwscanf, std::vfwscanf, std::vswscanf",
            "path": "en.cppreference.com/w/cpp/io/c/vfwscanf.html",
            "wgPageName": "cpp/io/c/vfwscanf",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "int vwscanf(\n    const wchar_t* format,\n    va_list vlist);",
            "other_declarations": 2
        },
        {
            "title": "std::cerr, std::wcerr",
            "path": "en.cppreference.com/w/cpp/io/cerr.html",
            "wgPageName": "cpp/io/cerr",
            "headers": [
                "<iostream>"
            ],
            "sample_declaration": "extern std::ostream cerr;",
            "other_declarations": 1
        },
        {
            "title": "std::cin, std::wcin",
            "path": "en.cppreference.com/w/cpp/io/cin.html",
            "wgPageName": "cpp/io/cin",
            "headers": [
                "<iostream>"
            ],
            "sample_declaration": "extern std::istream cin;",
            "other_declarations": 1
        },
        {
            "title": "std::clog, std::wclog",
            "path": "en.cppreference.com/w/cpp/io/clog.html",
            "wgPageName": "cpp/io/clog",
            "headers": [
                "<iostream>"
            ],
            "sample_declaration": "extern std::ostream clog;",
            "other_declarations": 1
        },
        {
            "title": "std::cout, std::wcout",
            "path": "en.cppreference.com/w/cpp/io/cout.html",
            "wgPageName": "cpp/io/cout",
            "headers": [
                "<iostream>"
            ],
            "sample_declaration": "extern std::ostream cout;",
            "other_declarations": 1
        },
        {
            "title": "std::fpos",
            "path": "en.cppreference.com/w/cpp/io/fpos.html",
            "wgPageName": "cpp/io/fpos",
            "headers": [
                "<ios>"
            ],
            "sample_declaration": "template<class State>\nclass fpos;"
        },
        {
            "title": "std::fpos<State>::state",
            "path": "en.cppreference.com/w/cpp/io/fpos/state.html",
            "wgPageName": "cpp/io/fpos/state",
            "sample_declaration": "State state() const;",
            "other_declarations": 1
        },
        {
            "title": "std::io_errc",
            "path": "en.cppreference.com/w/cpp/io/io_errc.html",
            "wgPageName": "cpp/io/io_errc",
            "headers": [
                "<ios>"
            ],
            "sample_declaration": "enum class io_errc {\n  stream = 1,\n};"
        },
        {
            "title": "std::is_error_code_enum<std::io_errc>",
            "path": "en.cppreference.com/w/cpp/io/io_errc/is_error_code_enum.html",
            "wgPageName": "cpp/io/io_errc/is_error_code_enum",
            "headers": [
                "<ios>"
            ],
            "sample_declaration": "template<>\nstruct is_error_code_enum<std::io_errc>\n    : public std::true_type {};"
        },
        {
            "title": "std::make_error_code(std::io_errc)",
            "path": "en.cppreference.com/w/cpp/io/io_errc/make_error_code.html",
            "wgPageName": "cpp/io/io_errc/make_error_code",
            "headers": [
                "<ios>"
            ],
            "sample_declaration": "std::error_code make_error_code(\n    std::io_errc e) noexcept;"
        },
        {
            "title": "std::make_error_condition(std::io_errc)",
            "path": "en.cppreference.com/w/cpp/io/io_errc/make_error_condition.html",
            "wgPageName": "cpp/io/io_errc/make_error_condition",
            "headers": [
                "<ios>"
            ],
            "sample_declaration": "std::error_condition make_error_condition(\n    std::io_errc e) noexcept;"
        },
        {
            "title": "std::ios_base",
            "path": "en.cppreference.com/w/cpp/io/ios_base.html",
            "wgPageName": "cpp/io/ios_base",
            "headers": [
                "<ios>"
            ],
            "sample_declaration": "class ios_base;"
        },
        {
            "title": "std::ios_base::~ios_base",
            "path": "en.cppreference.com/w/cpp/io/ios_base/~ios_base.html",
            "wgPageName": "cpp/io/ios_base/~ios_base",
            "sample_declaration": "virtual ~ios_base();"
        },
        {
            "title": "std::ios_base::event_callback",
            "path": "en.cppreference.com/w/cpp/io/ios_base/event_callback.html",
            "wgPageName": "cpp/io/ios_base/event_callback",
            "sample_declaration": "typedef void (*event_callback)(\n    event type,\n    ios_base& ios,\n    int index);"
        },
        {
            "title": "std::ios_base::event",
            "path": "en.cppreference.com/w/cpp/io/ios_base/event.html",
            "wgPageName": "cpp/io/ios_base/event",
            "sample_declaration": "enum event {\n  erase_event,\n  imbue_event,\n  copyfmt_event\n};"
        },
        {
            "title": "std::ios_base::failure",
            "path": "en.cppreference.com/w/cpp/io/ios_base/failure.html",
            "wgPageName": "cpp/io/ios_base/failure",
            "headers": [
                "<ios>"
            ],
            "sample_declaration": "class failure;"
        },
        {
            "title": "std::ios_base::flags",
            "path": "en.cppreference.com/w/cpp/io/ios_base/flags.html",
            "wgPageName": "cpp/io/ios_base/flags",
            "sample_declaration": "fmtflags flags() const;",
            "other_declarations": 1
        },
        {
            "title": "std::ios_base::fmtflags",
            "path": "en.cppreference.com/w/cpp/io/ios_base/fmtflags.html",
            "wgPageName": "cpp/io/ios_base/fmtflags",
            "sample_declaration": "typedef /*implementation defined*/ fmtflags;",
            "other_declarations": 4
        },
        {
            "title": "std::ios_base::getloc",
            "path": "en.cppreference.com/w/cpp/io/ios_base/getloc.html",
            "wgPageName": "cpp/io/ios_base/getloc",
            "sample_declaration": "std::locale getloc() const;"
        },
        {
            "title": "std::ios_base::imbue",
            "path": "en.cppreference.com/w/cpp/io/ios_base/imbue.html",
            "wgPageName": "cpp/io/ios_base/imbue",
            "sample_declaration": "std::locale imbue(const std::locale& loc);"
        },
        {
            "title": "std::ios_base::Init",
            "path": "en.cppreference.com/w/cpp/io/ios_base/Init.html",
            "wgPageName": "cpp/io/ios_base/Init",
            "sample_declaration": "class Init;"
        },
        {
            "title": "std::ios_base::ios_base",
            "path": "en.cppreference.com/w/cpp/io/ios_base/ios_base.html",
            "wgPageName": "cpp/io/ios_base/ios_base",
            "sample_declaration": "private:\nios_base(const ios_base&);",
            "other_declarations": 2
        },
        {
            "title": "std::ios_base::iostate",
            "path": "en.cppreference.com/w/cpp/io/ios_base/iostate.html",
            "wgPageName": "cpp/io/ios_base/iostate",
            "sample_declaration": "typedef /*implementation defined*/ iostate;",
            "other_declarations": 2
        },
        {
            "title": "std::ios_base::iword",
            "path": "en.cppreference.com/w/cpp/io/ios_base/iword.html",
            "wgPageName": "cpp/io/ios_base/iword",
            "sample_declaration": "long& iword(int index);"
        },
        {
            "title": "std::ios_base::openmode",
            "path": "en.cppreference.com/w/cpp/io/ios_base/openmode.html",
            "wgPageName": "cpp/io/ios_base/openmode",
            "sample_declaration": "typedef /*implementation defined*/ openmode;",
            "other_declarations": 1
        },
        {
            "title": "std::ios_base::operator=",
            "path": "en.cppreference.com/w/cpp/io/ios_base/operator=.html",
            "wgPageName": "cpp/io/ios_base/operator=",
            "sample_declaration": "private:\nios_base& operator=(const ios_base&);",
            "other_declarations": 1
        },
        {
            "title": "std::ios_base::precision",
            "path": "en.cppreference.com/w/cpp/io/ios_base/precision.html",
            "wgPageName": "cpp/io/ios_base/precision",
            "sample_declaration": "streamsize precision() const;",
            "other_declarations": 1
        },
        {
            "title": "std::ios_base::pword",
            "path": "en.cppreference.com/w/cpp/io/ios_base/pword.html",
            "wgPageName": "cpp/io/ios_base/pword",
            "sample_declaration": "void*& pword(int index);"
        },
        {
            "title": "std::ios_base::register_callback",
            "path": "en.cppreference.com/w/cpp/io/ios_base/register_callback.html",
            "wgPageName": "cpp/io/ios_base/register_callback",
            "sample_declaration": "void register_callback(\n    event_callback function,\n    int index);"
        },
        {
            "title": "std::ios_base::seekdir",
            "path": "en.cppreference.com/w/cpp/io/ios_base/seekdir.html",
            "wgPageName": "cpp/io/ios_base/seekdir",
            "sample_declaration": "typedef /*implementation defined*/ seekdir;",
            "other_declarations": 1
        },
        {
            "title": "std::ios_base::setf",
            "path": "en.cppreference.com/w/cpp/io/ios_base/setf.html",
            "wgPageName": "cpp/io/ios_base/setf",
            "sample_declaration": "fmtflags setf(fmtflags flags);",
            "other_declarations": 1
        },
        {
            "title": "std::ios_base::sync_with_stdio",
            "path": "en.cppreference.com/w/cpp/io/ios_base/sync_with_stdio.html",
            "wgPageName": "cpp/io/ios_base/sync_with_stdio",
            "sample_declaration": "static bool sync_with_stdio(bool sync = true);"
        },
        {
            "title": "std::ios_base::unsetf",
            "path": "en.cppreference.com/w/cpp/io/ios_base/unsetf.html",
            "wgPageName": "cpp/io/ios_base/unsetf",
            "sample_declaration": "void unsetf(fmtflags flags);"
        },
        {
            "title": "std::ios_base::width",
            "path": "en.cppreference.com/w/cpp/io/ios_base/width.html",
            "wgPageName": "cpp/io/ios_base/width",
            "sample_declaration": "streamsize width() const;",
            "other_declarations": 1
        },
        {
            "title": "std::ios_base::xalloc",
            "path": "en.cppreference.com/w/cpp/io/ios_base/xalloc.html",
            "wgPageName": "cpp/io/ios_base/xalloc",
            "sample_declaration": "static int xalloc();"
        },
        {
            "title": "std::iostream_category",
            "path": "en.cppreference.com/w/cpp/io/iostream_category.html",
            "wgPageName": "cpp/io/iostream_category",
            "headers": [
                "<ios>"
            ],
            "sample_declaration": "const std::error_category&\niostream_category() noexcept;"
        },
        {
            "title": "std::istrstream",
            "path": "en.cppreference.com/w/cpp/io/istrstream.html",
            "wgPageName": "cpp/io/istrstream",
            "headers": [
                "<strstream>"
            ],
            "sample_declaration": "class istrstream : public std::istream"
        },
        {
            "title": "std::istrstream::~istrstream",
            "path": "en.cppreference.com/w/cpp/io/istrstream/~istrstream.html",
            "wgPageName": "cpp/io/istrstream/~istrstream",
            "sample_declaration": "virtual ~istrstream();"
        },
        {
            "title": "std::istrstream::istrstream",
            "path": "en.cppreference.com/w/cpp/io/istrstream/istrstream.html",
            "wgPageName": "cpp/io/istrstream/istrstream",
            "sample_declaration": "explicit istrstream(const char* s);",
            "other_declarations": 3
        },
        {
            "title": "std::istrstream::rdbuf",
            "path": "en.cppreference.com/w/cpp/io/istrstream/rdbuf.html",
            "wgPageName": "cpp/io/istrstream/rdbuf",
            "sample_declaration": "strstreambuf* rdbuf() const;"
        },
        {
            "title": "std::istrstream::str",
            "path": "en.cppreference.com/w/cpp/io/istrstream/str.html",
            "wgPageName": "cpp/io/istrstream/str",
            "sample_declaration": "char* str();"
        },
        {
            "title": "Input/output manipulators",
            "path": "en.cppreference.com/w/cpp/io/manip.html",
            "wgPageName": "cpp/io/manip"
        },
        {
            "title": "std::boolalpha, std::noboolalpha",
            "path": "en.cppreference.com/w/cpp/io/manip/boolalpha.html",
            "wgPageName": "cpp/io/manip/boolalpha",
            "headers": [
                "<ios>"
            ],
            "sample_declaration": "std::ios_base& boolalpha(std::ios_base& str);",
            "other_declarations": 1
        },
        {
            "title": "std::emit_on_flush, std::noemit_on_flush",
            "path": "en.cppreference.com/w/cpp/io/manip/emit_on_flush.html",
            "wgPageName": "cpp/io/manip/emit_on_flush",
            "headers": [
                "<ostream>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>&\nemit_on_flush(\n    std::basic_ostream<CharT, Traits>& os);",
            "other_declarations": 1
        },
        {
            "title": "std::endl",
            "path": "en.cppreference.com/w/cpp/io/manip/endl.html",
            "wgPageName": "cpp/io/manip/endl",
            "headers": [
                "<ostream>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& endl(\n    std::basic_ostream<CharT, Traits>& os);"
        },
        {
            "title": "std::ends",
            "path": "en.cppreference.com/w/cpp/io/manip/ends.html",
            "wgPageName": "cpp/io/manip/ends",
            "headers": [
                "<ostream>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& ends(\n    std::basic_ostream<CharT, Traits>& os);"
        },
        {
            "title": "std::fixed, std::scientific, std::hexfloat, std::defaultfloat",
            "path": "en.cppreference.com/w/cpp/io/manip/fixed.html",
            "wgPageName": "cpp/io/manip/fixed",
            "headers": [
                "<ios>"
            ],
            "sample_declaration": "std::ios_base& fixed(std::ios_base& str);",
            "other_declarations": 3
        },
        {
            "title": "std::flush_emit",
            "path": "en.cppreference.com/w/cpp/io/manip/flush_emit.html",
            "wgPageName": "cpp/io/manip/flush_emit",
            "headers": [
                "<ostream>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& flush_emit(\n    std::basic_ostream<CharT, Traits>& os);"
        },
        {
            "title": "std::flush",
            "path": "en.cppreference.com/w/cpp/io/manip/flush.html",
            "wgPageName": "cpp/io/manip/flush",
            "headers": [
                "<ostream>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& flush(\n    std::basic_ostream<CharT, Traits>& os);"
        },
        {
            "title": "std::get_money",
            "path": "en.cppreference.com/w/cpp/io/manip/get_money.html",
            "wgPageName": "cpp/io/manip/get_money",
            "headers": [
                "<iomanip>"
            ],
            "sample_declaration": "template<class MoneyT>\n/*unspecified*/ get_money(\n    MoneyT& mon,\n    bool intl = false);"
        },
        {
            "title": "std::get_time",
            "path": "en.cppreference.com/w/cpp/io/manip/get_time.html",
            "wgPageName": "cpp/io/manip/get_time",
            "headers": [
                "<iomanip>"
            ],
            "sample_declaration": "template<class CharT>\n/*unspecified*/ get_time(\n    std::tm* tmb,\n    const CharT* fmt);"
        },
        {
            "title": "std::dec, std::hex, std::oct",
            "path": "en.cppreference.com/w/cpp/io/manip/hex.html",
            "wgPageName": "cpp/io/manip/hex",
            "headers": [
                "<ios>"
            ],
            "sample_declaration": "std::ios_base& dec(std::ios_base& str);",
            "other_declarations": 2
        },
        {
            "title": "std::left, std::right, std::internal",
            "path": "en.cppreference.com/w/cpp/io/manip/left.html",
            "wgPageName": "cpp/io/manip/left",
            "headers": [
                "<ios>"
            ],
            "sample_declaration": "std::ios_base& left(std::ios_base& str);",
            "other_declarations": 2
        },
        {
            "title": "std::put_money",
            "path": "en.cppreference.com/w/cpp/io/manip/put_money.html",
            "wgPageName": "cpp/io/manip/put_money",
            "headers": [
                "<iomanip>"
            ],
            "sample_declaration": "template<class MoneyT>\n/*unspecified*/ put_money(\n    const MoneyT& mon,\n    bool intl = false);"
        },
        {
            "title": "std::put_time",
            "path": "en.cppreference.com/w/cpp/io/manip/put_time.html",
            "wgPageName": "cpp/io/manip/put_time",
            "headers": [
                "<iomanip>"
            ],
            "sample_declaration": "template<class CharT>\n/*unspecified*/ put_time(\n    const std::tm* tmb,\n    const CharT* fmt);"
        },
        {
            "title": "std::quoted",
            "path": "en.cppreference.com/w/cpp/io/manip/quoted.html",
            "wgPageName": "cpp/io/manip/quoted",
            "headers": [
                "<iomanip>"
            ],
            "sample_declaration": "template<class CharT>\n/*unspecified*/ quoted(\n    const CharT* s,\n    CharT delim = CharT('\"'),\n    CharT escape = CharT('\\\\'));",
            "other_declarations": 3
        },
        {
            "title": "std::resetiosflags",
            "path": "en.cppreference.com/w/cpp/io/manip/resetiosflags.html",
            "wgPageName": "cpp/io/manip/resetiosflags",
            "headers": [
                "<iomanip>"
            ],
            "sample_declaration": "/*unspecified*/ resetiosflags(\n    std::ios_base::fmtflags mask);"
        },
        {
            "title": "std::setbase",
            "path": "en.cppreference.com/w/cpp/io/manip/setbase.html",
            "wgPageName": "cpp/io/manip/setbase",
            "headers": [
                "<iomanip>"
            ],
            "sample_declaration": "/*unspecified*/ setbase(int base);"
        },
        {
            "title": "std::setfill",
            "path": "en.cppreference.com/w/cpp/io/manip/setfill.html",
            "wgPageName": "cpp/io/manip/setfill",
            "headers": [
                "<iomanip>"
            ],
            "sample_declaration": "template<class CharT>\n/*unspecified*/ setfill(CharT c);"
        },
        {
            "title": "std::setiosflags",
            "path": "en.cppreference.com/w/cpp/io/manip/setiosflags.html",
            "wgPageName": "cpp/io/manip/setiosflags",
            "headers": [
                "<iomanip>"
            ],
            "sample_declaration": "/*unspecified*/ setiosflags(\n    std::ios_base::fmtflags mask);"
        },
        {
            "title": "std::setprecision",
            "path": "en.cppreference.com/w/cpp/io/manip/setprecision.html",
            "wgPageName": "cpp/io/manip/setprecision",
            "headers": [
                "<iomanip>"
            ],
            "sample_declaration": "/*unspecified*/ setprecision(int n);"
        },
        {
            "title": "std::setw",
            "path": "en.cppreference.com/w/cpp/io/manip/setw.html",
            "wgPageName": "cpp/io/manip/setw",
            "headers": [
                "<iomanip>"
            ],
            "sample_declaration": "/*unspecified*/ setw(int n);"
        },
        {
            "title": "std::showbase, std::noshowbase",
            "path": "en.cppreference.com/w/cpp/io/manip/showbase.html",
            "wgPageName": "cpp/io/manip/showbase",
            "headers": [
                "<ios>"
            ],
            "sample_declaration": "std::ios_base& showbase(std::ios_base& str);",
            "other_declarations": 1
        },
        {
            "title": "std::showpoint, std::noshowpoint",
            "path": "en.cppreference.com/w/cpp/io/manip/showpoint.html",
            "wgPageName": "cpp/io/manip/showpoint",
            "headers": [
                "<ios>"
            ],
            "sample_declaration": "std::ios_base& showpoint(std::ios_base& str);",
            "other_declarations": 1
        },
        {
            "title": "std::showpos, std::noshowpos",
            "path": "en.cppreference.com/w/cpp/io/manip/showpos.html",
            "wgPageName": "cpp/io/manip/showpos",
            "headers": [
                "<ios>"
            ],
            "sample_declaration": "std::ios_base& showpos(std::ios_base& str);",
            "other_declarations": 1
        },
        {
            "title": "std::skipws, std::noskipws",
            "path": "en.cppreference.com/w/cpp/io/manip/skipws.html",
            "wgPageName": "cpp/io/manip/skipws",
            "headers": [
                "<ios>"
            ],
            "sample_declaration": "std::ios_base& skipws(std::ios_base& str);",
            "other_declarations": 1
        },
        {
            "title": "std::unitbuf, std::nounitbuf",
            "path": "en.cppreference.com/w/cpp/io/manip/unitbuf.html",
            "wgPageName": "cpp/io/manip/unitbuf",
            "headers": [
                "<ios>"
            ],
            "sample_declaration": "std::ios_base& unitbuf(std::ios_base& str);",
            "other_declarations": 1
        },
        {
            "title": "std::uppercase, std::nouppercase",
            "path": "en.cppreference.com/w/cpp/io/manip/uppercase.html",
            "wgPageName": "cpp/io/manip/uppercase",
            "headers": [
                "<ios>"
            ],
            "sample_declaration": "std::ios_base& uppercase(std::ios_base& str);",
            "other_declarations": 1
        },
        {
            "title": "std::ws",
            "path": "en.cppreference.com/w/cpp/io/manip/ws.html",
            "wgPageName": "cpp/io/manip/ws",
            "headers": [
                "<istream>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_istream<CharT, Traits>& ws(\n    std::basic_istream<CharT, Traits>& is);"
        },
        {
            "title": "std::ostrstream",
            "path": "en.cppreference.com/w/cpp/io/ostrstream.html",
            "wgPageName": "cpp/io/ostrstream",
            "headers": [
                "<strstream>"
            ],
            "sample_declaration": "class ostrstream : public std::ostream"
        },
        {
            "title": "std::ostrstream::~ostrstream",
            "path": "en.cppreference.com/w/cpp/io/ostrstream/~ostrstream.html",
            "wgPageName": "cpp/io/ostrstream/~ostrstream",
            "sample_declaration": "virtual ~ostrstream();"
        },
        {
            "title": "std::ostrstream::freeze",
            "path": "en.cppreference.com/w/cpp/io/ostrstream/freeze.html",
            "wgPageName": "cpp/io/ostrstream/freeze",
            "sample_declaration": "void freeze(bool flag = true);"
        },
        {
            "title": "std::ostrstream::ostrstream",
            "path": "en.cppreference.com/w/cpp/io/ostrstream/ostrstream.html",
            "wgPageName": "cpp/io/ostrstream/ostrstream",
            "sample_declaration": "ostrstream();",
            "other_declarations": 1
        },
        {
            "title": "std::ostrstream::pcount",
            "path": "en.cppreference.com/w/cpp/io/ostrstream/pcount.html",
            "wgPageName": "cpp/io/ostrstream/pcount",
            "sample_declaration": "int pcount() const;"
        },
        {
            "title": "std::ostrstream::rdbuf",
            "path": "en.cppreference.com/w/cpp/io/ostrstream/rdbuf.html",
            "wgPageName": "cpp/io/ostrstream/rdbuf",
            "sample_declaration": "strstreambuf* rdbuf() const;"
        },
        {
            "title": "std::ostrstream::str",
            "path": "en.cppreference.com/w/cpp/io/ostrstream/str.html",
            "wgPageName": "cpp/io/ostrstream/str",
            "sample_declaration": "char* str();"
        },
        {
            "title": "std::print",
            "path": "en.cppreference.com/w/cpp/io/print.html",
            "wgPageName": "cpp/io/print",
            "headers": [
                "<print>"
            ],
            "sample_declaration": "template<class... Args>\nvoid print(\n    std::FILE* stream,\n    std::format_string<Args...> fmt,\n    Args&&... args);",
            "other_declarations": 1
        },
        {
            "title": "std::println",
            "path": "en.cppreference.com/w/cpp/io/println.html",
            "wgPageName": "cpp/io/println",
            "headers": [
                "<print>"
            ],
            "sample_declaration": "template<class... Args>\nvoid println(\n    std::FILE* stream,\n    std::format_string<Args...> fmt,\n    Args&&... args);",
            "other_declarations": 1
        },
        {
            "title": "std::streamoff",
            "path": "en.cppreference.com/w/cpp/io/streamoff.html",
            "wgPageName": "cpp/io/streamoff",
            "headers": [
                "<ios>"
            ],
            "sample_declaration": "typedef /*implementation-defined*/ streamoff;"
        },
        {
            "title": "std::streamsize",
            "path": "en.cppreference.com/w/cpp/io/streamsize.html",
            "wgPageName": "cpp/io/streamsize",
            "headers": [
                "<ios>"
            ],
            "sample_declaration": "typedef /*implementation-defined*/ streamsize;"
        },
        {
            "title": "std::strstream",
            "path": "en.cppreference.com/w/cpp/io/strstream.html",
            "wgPageName": "cpp/io/strstream",
            "headers": [
                "<strstream>"
            ],
            "sample_declaration": "class strstream : public std::iostream"
        },
        {
            "title": "std::strstream::~strstream",
            "path": "en.cppreference.com/w/cpp/io/strstream/~strstream.html",
            "wgPageName": "cpp/io/strstream/~strstream",
            "sample_declaration": "virtual ~strstream();"
        },
        {
            "title": "std::strstream::freeze",
            "path": "en.cppreference.com/w/cpp/io/strstream/freeze.html",
            "wgPageName": "cpp/io/strstream/freeze",
            "sample_declaration": "void freeze(bool flag = true);"
        },
        {
            "title": "std::strstream::pcount",
            "path": "en.cppreference.com/w/cpp/io/strstream/pcount.html",
            "wgPageName": "cpp/io/strstream/pcount",
            "sample_declaration": "int pcount() const;"
        },
        {
            "title": "std::strstream::rdbuf",
            "path": "en.cppreference.com/w/cpp/io/strstream/rdbuf.html",
            "wgPageName": "cpp/io/strstream/rdbuf",
            "sample_declaration": "strstreambuf* rdbuf() const;"
        },
        {
            "title": "std::strstream::str",
            "path": "en.cppreference.com/w/cpp/io/strstream/str.html",
            "wgPageName": "cpp/io/strstream/str",
            "sample_declaration": "char* str();"
        },
        {
            "title": "std::strstream::strstream",
            "path": "en.cppreference.com/w/cpp/io/strstream/strstream.html",
            "wgPageName": "cpp/io/strstream/strstream",
            "sample_declaration": "strstream();",
            "other_declarations": 1
        },
        {
            "title": "std::strstreambuf",
            "path": "en.cppreference.com/w/cpp/io/strstreambuf.html",
            "wgPageName": "cpp/io/strstreambuf",
            "headers": [
                "<strstream>"
            ],
            "sample_declaration": "class strstreambuf\n    : public std::basic_streambuf<char>"
        },
        {
            "title": "std::strstreambuf::~strstreambuf",
            "path": "en.cppreference.com/w/cpp/io/strstreambuf/~strstreambuf.html",
            "wgPageName": "cpp/io/strstreambuf/~strstreambuf",
            "sample_declaration": "virtual ~strstreambuf();"
        },
        {
            "title": "std::strstreambuf::freeze",
            "path": "en.cppreference.com/w/cpp/io/strstreambuf/freeze.html",
            "wgPageName": "cpp/io/strstreambuf/freeze",
            "sample_declaration": "void freeze(bool freezefl = true);"
        },
        {
            "title": "std::strstreambuf::overflow",
            "path": "en.cppreference.com/w/cpp/io/strstreambuf/overflow.html",
            "wgPageName": "cpp/io/strstreambuf/overflow",
            "sample_declaration": "protected:\nvirtual int_type overflow(int_type c = EOF);"
        },
        {
            "title": "std::strstreambuf::pbackfail",
            "path": "en.cppreference.com/w/cpp/io/strstreambuf/pbackfail.html",
            "wgPageName": "cpp/io/strstreambuf/pbackfail",
            "sample_declaration": "protected:\nvirtual int_type pbackfail(int_type c = EOF);"
        },
        {
            "title": "std::strstreambuf::pcount",
            "path": "en.cppreference.com/w/cpp/io/strstreambuf/pcount.html",
            "wgPageName": "cpp/io/strstreambuf/pcount",
            "sample_declaration": "int pcount() const;"
        },
        {
            "title": "std::strstreambuf::seekoff",
            "path": "en.cppreference.com/w/cpp/io/strstreambuf/seekoff.html",
            "wgPageName": "cpp/io/strstreambuf/seekoff",
            "sample_declaration": "protected:\nvirtual pos_type seekoff(\n    off_type off,\n    ios_base::seekdir way,\n    ios_base::openmode which = ios_base::in |\n                               ios_base::out);"
        },
        {
            "title": "std::strstreambuf::seekpos",
            "path": "en.cppreference.com/w/cpp/io/strstreambuf/seekpos.html",
            "wgPageName": "cpp/io/strstreambuf/seekpos",
            "sample_declaration": "protected:\nvirtual pos_type seekpos(\n    pos_type sp,\n    std::ios_base::openmode which =\n        std::ios_base::in | std::ios_base::out);"
        },
        {
            "title": "std::strstreambuf::setbuf",
            "path": "en.cppreference.com/w/cpp/io/strstreambuf/setbuf.html",
            "wgPageName": "cpp/io/strstreambuf/setbuf",
            "sample_declaration": "protected:\nvirtual streambuf<char>* setbuf(\n    char* s,\n    std::streamsize n);"
        },
        {
            "title": "std::strstreambuf::str",
            "path": "en.cppreference.com/w/cpp/io/strstreambuf/str.html",
            "wgPageName": "cpp/io/strstreambuf/str",
            "sample_declaration": "char* str() const;"
        },
        {
            "title": "std::strstreambuf::strstreambuf",
            "path": "en.cppreference.com/w/cpp/io/strstreambuf/strstreambuf.html",
            "wgPageName": "cpp/io/strstreambuf/strstreambuf",
            "sample_declaration": "explicit strstreambuf(\n    std::streamsize alsize = 0);",
            "other_declarations": 8
        },
        {
            "title": "std::strstreambuf::underflow",
            "path": "en.cppreference.com/w/cpp/io/strstreambuf/underflow.html",
            "wgPageName": "cpp/io/strstreambuf/underflow",
            "sample_declaration": "protected:\nvirtual int_type underflow();"
        },
        {
            "title": "std::vprint_nonunicode",
            "path": "en.cppreference.com/w/cpp/io/vprint_nonunicode.html",
            "wgPageName": "cpp/io/vprint_nonunicode",
            "headers": [
                "<print>"
            ],
            "sample_declaration": "void vprint_nonunicode(\n    std::FILE* stream,\n    std::string_view fmt,\n    std::format_args args);",
            "other_declarations": 1
        },
        {
            "title": "std::vprint_unicode",
            "path": "en.cppreference.com/w/cpp/io/vprint_unicode.html",
            "wgPageName": "cpp/io/vprint_unicode",
            "headers": [
                "<print>"
            ],
            "sample_declaration": "void vprint_unicode(\n    std::FILE* stream,\n    std::string_view fmt,\n    std::format_args args);",
            "other_declarations": 1
        },
        {
            "title": "Iterator library",
            "path": "en.cppreference.com/w/cpp/iterator.html",
            "wgPageName": "cpp/iterator"
        },
        {
            "title": "std::advance",
            "path": "en.cppreference.com/w/cpp/iterator/advance.html",
            "wgPageName": "cpp/iterator/advance",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class InputIt, class Distance>\nvoid advance(InputIt& it, Distance n);",
            "other_declarations": 1
        },
        {
            "title": "std::back_insert_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/back_insert_iterator.html",
            "wgPageName": "cpp/iterator/back_insert_iterator",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class Container>\nclass back_insert_iterator\n    : public std::iterator<\n          std::output_iterator_tag,\n          void,\n          void,\n          void,\n          void>",
            "other_declarations": 1
        },
        {
            "title": "std::back_insert_iterator<Container>::back_insert_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/back_insert_iterator/back_insert_iterator.html",
            "wgPageName": "cpp/iterator/back_insert_iterator/back_insert_iterator",
            "sample_declaration": "explicit back_insert_iterator(Container& c);",
            "other_declarations": 1
        },
        {
            "title": "std::back_insert_iterator<Container>::operator*",
            "path": "en.cppreference.com/w/cpp/iterator/back_insert_iterator/operator*.html",
            "wgPageName": "cpp/iterator/back_insert_iterator/operator*",
            "sample_declaration": "back_insert_iterator& operator*();",
            "other_declarations": 1
        },
        {
            "title": "std::back_insert_iterator<Container>::operator++",
            "path": "en.cppreference.com/w/cpp/iterator/back_insert_iterator/operator++.html",
            "wgPageName": "cpp/iterator/back_insert_iterator/operator++",
            "sample_declaration": "back_insert_iterator& operator++();",
            "other_declarations": 3
        },
        {
            "title": "std::back_insert_iterator<Container>::operator=",
            "path": "en.cppreference.com/w/cpp/iterator/back_insert_iterator/operator=.html",
            "wgPageName": "cpp/iterator/back_insert_iterator/operator=",
            "sample_declaration": "back_insert_iterator<Container>& operator=(\n    typename Container::const_reference value);",
            "other_declarations": 4
        },
        {
            "title": "std::back_inserter",
            "path": "en.cppreference.com/w/cpp/iterator/back_inserter.html",
            "wgPageName": "cpp/iterator/back_inserter",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class Container>\nstd::back_insert_iterator<Container>\nback_inserter(Container& c);",
            "other_declarations": 1
        },
        {
            "title": "std::begin, std::cbegin",
            "path": "en.cppreference.com/w/cpp/iterator/begin.html",
            "wgPageName": "cpp/iterator/begin",
            "headers": [
                "<array>",
                "<deque>",
                "<forward_list>",
                "<iterator>",
                "<list>",
                "<map>",
                "<regex>",
                "<set>",
                "<span>",
                "<string>",
                "<string_view>",
                "<unordered_map>",
                "<unordered_set>",
                "<vector>"
            ],
            "sample_declaration": "template<class C>\nauto begin(C& c) -> decltype(c.begin());",
            "other_declarations": 6
        },
        {
            "title": "std::bidirectional_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/bidirectional_iterator.html",
            "wgPageName": "cpp/iterator/bidirectional_iterator",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class I>\nconcept bidirectional_iterator =\n    std::forward_iterator<I> &&\n    std::derived_from<\n        /*ITER_CONCEPT*/<I>,\n        std::bidirectional_iterator_tag> &&\n    requires(I i) {\n  { --i } -> std::same_as<I&>;\n  { i-- } -> std::same_as<I>;\n};"
        },
        {
            "title": "std::common_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/common_iterator.html",
            "wgPageName": "cpp/iterator/common_iterator",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<\n    std::input_or_output_iterator I,\n    std::sentinel_for<I> S>\nrequires(\n    !std::same_as<I, S> &&\n    std::copyable<I>) class common_iterator;"
        },
        {
            "title": "std::common_iterator<I,S>::common_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/common_iterator/common_iterator.html",
            "wgPageName": "cpp/iterator/common_iterator/common_iterator",
            "sample_declaration": "constexpr common_iterator() requires\n    std::default_initializable<I>\n= default;",
            "other_declarations": 3
        },
        {
            "title": "std::incrementable_traits<std::common_iterator>",
            "path": "en.cppreference.com/w/cpp/iterator/common_iterator/incrementable_traits.html",
            "wgPageName": "cpp/iterator/common_iterator/incrementable_traits",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class I, class S>\nstruct incrementable_traits<\n    std::common_iterator<I, S>> {\n  using difference_type =\n      std::iter_difference_t<I>;\n};"
        },
        {
            "title": "iter_move(std::common_iterator)",
            "path": "en.cppreference.com/w/cpp/iterator/common_iterator/iter_move.html",
            "wgPageName": "cpp/iterator/common_iterator/iter_move",
            "sample_declaration": "friend std::iter_rvalue_reference_t<I> iter_move( const std::common_iterator& i ) noexcept(noexcept(ranges::iter_move(std::declval<const I&>())) requires std::input_iterator<I>;"
        },
        {
            "title": "iter_swap(std::common_iterator)",
            "path": "en.cppreference.com/w/cpp/iterator/common_iterator/iter_swap.html",
            "wgPageName": "cpp/iterator/common_iterator/iter_swap",
            "sample_declaration": "template<\n    std::indirectly_swappable<I> I2,\n    class S2>\nfriend constexpr void iter_swap(\n    const common_iterator& x,\n    const std::common_iterator<I2, S2>&\n        y) noexcept(/*see below*/);"
        },
        {
            "title": "std::iterator_traits<std::common_iterator>",
            "path": "en.cppreference.com/w/cpp/iterator/common_iterator/iterator_traits.html",
            "wgPageName": "cpp/iterator/common_iterator/iterator_traits",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<std::input_iterator I, class S>\nstruct iterator_traits<\n    std::common_iterator<I, S>>;"
        },
        {
            "title": "std::common_iterator<I,S>::operator++",
            "path": "en.cppreference.com/w/cpp/iterator/common_iterator/operator_arith.html",
            "wgPageName": "cpp/iterator/common_iterator/operator_arith",
            "sample_declaration": "constexpr common_iterator& operator++();",
            "other_declarations": 2
        },
        {
            "title": "operator==(std::common_iterator)",
            "path": "en.cppreference.com/w/cpp/iterator/common_iterator/operator_cmp.html",
            "wgPageName": "cpp/iterator/common_iterator/operator_cmp",
            "sample_declaration": "template<class I2, std::sentinel_for<I> S2>\nrequires std::sentinel_for<S, I2>\nfriend constexpr bool operator==(\n    const common_iterator& x,\n    const std::common_iterator<I2, S2>& y);",
            "other_declarations": 1
        },
        {
            "title": "operator-(std::common_iterator)",
            "path": "en.cppreference.com/w/cpp/iterator/common_iterator/operator-.html",
            "wgPageName": "cpp/iterator/common_iterator/operator-",
            "sample_declaration": "template<\n    std::sized_sentinel_for<I> I2,\n    std::sized_sentinel_for<I> S2>\nrequires std::sized_sentinel_for<S, I2>\nfriend constexpr std::iter_difference_t<I2>\noperator-(\n    const common_iterator& x,\n    const std::common_iterator<I2, S2>& y);"
        },
        {
            "title": "std::common_iterator<I,S>::operator*,->",
            "path": "en.cppreference.com/w/cpp/iterator/common_iterator/operator*.html",
            "wgPageName": "cpp/iterator/common_iterator/operator*",
            "sample_declaration": "constexpr decltype(auto) operator*();",
            "other_declarations": 3
        },
        {
            "title": "std::common_iterator<I,S>::operator=",
            "path": "en.cppreference.com/w/cpp/iterator/common_iterator/operator=.html",
            "wgPageName": "cpp/iterator/common_iterator/operator=",
            "sample_declaration": "template<class I2, class S2>\nrequires std::convertible_to<const I2&, I> &&\n    std::convertible_to<const S2&, S> &&\n    std::assignable_from<I&, const I2&> &&\n    std::assignable_from<S&, const S2&>\nconstexpr common_iterator& operator=(\n    const common_iterator<I2, S2>& x);"
        },
        {
            "title": "std::contiguous_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/contiguous_iterator.html",
            "wgPageName": "cpp/iterator/contiguous_iterator",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class I>\nconcept contiguous_iterator =\n    std::random_access_iterator<I> &&\n    std::derived_from<\n        /*ITER_CONCEPT*/<I>,\n        std::contiguous_iterator_tag> &&\n    std::is_lvalue_reference_v<\n        std::iter_reference_t<I>> &&\n    std::same_as<\n        std::iter_value_t<I>,\n        std::remove_cvref_t<\n            std::iter_reference_t<I>>> &&\n    requires(const I& i) {\n  {\n    std::to_address(i)\n    } -> std::same_as<std::add_pointer_t<\n        std::iter_reference_t<I>>>;\n};"
        },
        {
            "title": "std::counted_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/counted_iterator.html",
            "wgPageName": "cpp/iterator/counted_iterator",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<std::input_or_output_iterator I>\nclass counted_iterator;"
        },
        {
            "title": "std::counted_iterator<I>::base",
            "path": "en.cppreference.com/w/cpp/iterator/counted_iterator/base.html",
            "wgPageName": "cpp/iterator/counted_iterator/base",
            "sample_declaration": "constexpr const I& base() const& noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::counted_iterator<I>::count",
            "path": "en.cppreference.com/w/cpp/iterator/counted_iterator/count.html",
            "wgPageName": "cpp/iterator/counted_iterator/count",
            "sample_declaration": "constexpr std::iter_difference_t<I> count()\n    const noexcept;"
        },
        {
            "title": "std::counted_iterator<I>::counted_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/counted_iterator/counted_iterator.html",
            "wgPageName": "cpp/iterator/counted_iterator/counted_iterator",
            "sample_declaration": "constexpr counted_iterator() requires\n    std::default_initializable<I>\n= default;",
            "other_declarations": 2
        },
        {
            "title": "iter_move(std::counted_iterator)",
            "path": "en.cppreference.com/w/cpp/iterator/counted_iterator/iter_move.html",
            "wgPageName": "cpp/iterator/counted_iterator/iter_move",
            "sample_declaration": "friend constexpr std::iter_rvalue_reference_t<I>\niter_move(const std::counted_iterator& i) noexcept(\n    noexcept(\n        ranges::iter_move(i.base()))) requires\n    std::input_iterator<I>;"
        },
        {
            "title": "iter_swap(std::counted_iterator)",
            "path": "en.cppreference.com/w/cpp/iterator/counted_iterator/iter_swap.html",
            "wgPageName": "cpp/iterator/counted_iterator/iter_swap",
            "sample_declaration": "template<std::indirectly_swappable<I> I2>\nfriend constexpr void iter_swap(\n    const counted_iterator& x,\n    const std::counted_iterator<I2>&\n        y) noexcept(noexcept(ranges::\n                                 iter_swap(\n                                     x.base(),\n                                     y.base())));"
        },
        {
            "title": "std::iterator_traits<std::counted_iterator>",
            "path": "en.cppreference.com/w/cpp/iterator/counted_iterator/iterator_traits.html",
            "wgPageName": "cpp/iterator/counted_iterator/iterator_traits",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<std::input_iterator I>\nrequires /* see below */ struct iterator_traits<\n    std::counted_iterator<I>>\n    : std::iterator_traits<I> {\n  using pointer = std::conditional_t<\n      std::contiguous_iterator<I>,\n      std::add_pointer_t<\n          std::iter_reference_t<I>>,\n      void>;\n};"
        },
        {
            "title": "std::counted_iterator<I>::operator++,+,+=,--,-,-=",
            "path": "en.cppreference.com/w/cpp/iterator/counted_iterator/operator_arith.html",
            "wgPageName": "cpp/iterator/counted_iterator/operator_arith",
            "sample_declaration": "constexpr counted_iterator& operator++();",
            "other_declarations": 8
        },
        {
            "title": "std::counted_iterator<I>::operator[]",
            "path": "en.cppreference.com/w/cpp/iterator/counted_iterator/operator_at.html",
            "wgPageName": "cpp/iterator/counted_iterator/operator_at",
            "sample_declaration": "constexpr decltype(auto) operator[](\n    std::iter_difference_t<I> n) const requires\n    std::random_access_iterator<I>;"
        },
        {
            "title": "operator==,<=>(std::counted_iterator)",
            "path": "en.cppreference.com/w/cpp/iterator/counted_iterator/operator_cmp.html",
            "wgPageName": "cpp/iterator/counted_iterator/operator_cmp",
            "sample_declaration": "template<std::common_with<I> I2>\nfriend constexpr bool operator==(\n    const counted_iterator& x,\n    const counted_iterator<I2>& y);",
            "other_declarations": 1
        },
        {
            "title": "operator==(std::counted_iterator<I>, std::default_sentinel_t)",
            "path": "en.cppreference.com/w/cpp/iterator/counted_iterator/operator_cmp2.html",
            "wgPageName": "cpp/iterator/counted_iterator/operator_cmp2",
            "sample_declaration": "friend constexpr bool operator==(\n    const counted_iterator& x,\n    std::default_sentinel_t);"
        },
        {
            "title": "operator-(std::counted_iterator)",
            "path": "en.cppreference.com/w/cpp/iterator/counted_iterator/operator-.html",
            "wgPageName": "cpp/iterator/counted_iterator/operator-",
            "sample_declaration": "template<std::common_with<I> I2>\nfriend constexpr std::iter_difference_t<I2>\noperator-(\n    const counted_iterator& x,\n    const counted_iterator<I2>& y);"
        },
        {
            "title": "operator-(std::counted_iterator<I>, std::default_sentinel_t)",
            "path": "en.cppreference.com/w/cpp/iterator/counted_iterator/operator-2.html",
            "wgPageName": "cpp/iterator/counted_iterator/operator-2",
            "sample_declaration": "friend constexpr std::iter_difference_t<I>\noperator-(\n    const counted_iterator& x,\n    std::default_sentinel_t);",
            "other_declarations": 1
        },
        {
            "title": "std::counted_iterator<I>::operator*,->",
            "path": "en.cppreference.com/w/cpp/iterator/counted_iterator/operator*.html",
            "wgPageName": "cpp/iterator/counted_iterator/operator*",
            "sample_declaration": "constexpr decltype(auto) operator*();",
            "other_declarations": 2
        },
        {
            "title": "operator+(std::counted_iterator)",
            "path": "en.cppreference.com/w/cpp/iterator/counted_iterator/operator+.html",
            "wgPageName": "cpp/iterator/counted_iterator/operator+",
            "sample_declaration": "friend constexpr counted_iterator operator+(\n    std::iter_difference_t<I> n,\n    const counted_iterator& x) requires\n    std::random_access_iterator<I>;"
        },
        {
            "title": "std::counted_iterator<I>::operator=",
            "path": "en.cppreference.com/w/cpp/iterator/counted_iterator/operator=.html",
            "wgPageName": "cpp/iterator/counted_iterator/operator=",
            "sample_declaration": "template<class I2>\nrequires std::assignable_from<I&, const I2&>\nconstexpr counted_iterator& operator=(\n    const counted_iterator<I2>& other);"
        },
        {
            "title": "std::data",
            "path": "en.cppreference.com/w/cpp/iterator/data.html",
            "wgPageName": "cpp/iterator/data",
            "headers": [
                "<array>",
                "<deque>",
                "<forward_list>",
                "<iterator>",
                "<list>",
                "<map>",
                "<regex>",
                "<set>",
                "<span>",
                "<string>",
                "<string_view>",
                "<unordered_map>",
                "<unordered_set>",
                "<vector>"
            ],
            "sample_declaration": "template<class C>\nconstexpr auto data(C& c) -> decltype(c.data());",
            "other_declarations": 3
        },
        {
            "title": "std::default_sentinel_t, std::default_sentinel",
            "path": "en.cppreference.com/w/cpp/iterator/default_sentinel_t.html",
            "wgPageName": "cpp/iterator/default_sentinel_t",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "struct default_sentinel_t {};",
            "other_declarations": 1
        },
        {
            "title": "std::default_sentinel_t, std::default_sentinel",
            "path": "en.cppreference.com/w/cpp/iterator/default_sentinel.html",
            "wgPageName": "cpp/iterator/default_sentinel_t",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "struct default_sentinel_t {};",
            "other_declarations": 1
        },
        {
            "title": "std::distance",
            "path": "en.cppreference.com/w/cpp/iterator/distance.html",
            "wgPageName": "cpp/iterator/distance",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class InputIt>\ntypename std::iterator_traits<\n    InputIt>::difference_type\ndistance(InputIt first, InputIt last);"
        },
        {
            "title": "std::empty",
            "path": "en.cppreference.com/w/cpp/iterator/empty.html",
            "wgPageName": "cpp/iterator/empty",
            "headers": [
                "<array>",
                "<deque>",
                "<forward_list>",
                "<iterator>",
                "<list>",
                "<map>",
                "<regex>",
                "<set>",
                "<span>",
                "<string>",
                "<string_view>",
                "<unordered_map>",
                "<unordered_set>",
                "<vector>"
            ],
            "sample_declaration": "template<class C>\nconstexpr auto empty(const C& c)\n    -> decltype(c.empty());",
            "other_declarations": 5
        },
        {
            "title": "std::end, std::cend",
            "path": "en.cppreference.com/w/cpp/iterator/end.html",
            "wgPageName": "cpp/iterator/end",
            "headers": [
                "<array>",
                "<deque>",
                "<forward_list>",
                "<iterator>",
                "<list>",
                "<map>",
                "<regex>",
                "<set>",
                "<span>",
                "<string>",
                "<string_view>",
                "<unordered_map>",
                "<unordered_set>",
                "<vector>"
            ],
            "sample_declaration": "template<class C>\nauto end(C& c) -> decltype(c.end());",
            "other_declarations": 6
        },
        {
            "title": "std::forward_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/forward_iterator.html",
            "wgPageName": "cpp/iterator/forward_iterator",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class I>\nconcept forward_iterator =\n    std::input_iterator<I> && std::derived_from<\n        /*ITER_CONCEPT*/<I>,\n        std::forward_iterator_tag> &&\n    std::incrementable<I> &&\n    std::sentinel_for<I, I>;"
        },
        {
            "title": "std::front_insert_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/front_insert_iterator.html",
            "wgPageName": "cpp/iterator/front_insert_iterator",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class Container>\nclass front_insert_iterator\n    : public std::iterator<\n          std::output_iterator_tag,\n          void,\n          void,\n          void,\n          void>",
            "other_declarations": 1
        },
        {
            "title": "std::front_insert_iterator<Container>::front_insert_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/front_insert_iterator/front_insert_iterator.html",
            "wgPageName": "cpp/iterator/front_insert_iterator/front_insert_iterator",
            "sample_declaration": "explicit front_insert_iterator(Container& c);",
            "other_declarations": 1
        },
        {
            "title": "std::front_insert_iterator<Container>::operator*",
            "path": "en.cppreference.com/w/cpp/iterator/front_insert_iterator/operator*.html",
            "wgPageName": "cpp/iterator/front_insert_iterator/operator*",
            "sample_declaration": "front_insert_iterator& operator*();",
            "other_declarations": 1
        },
        {
            "title": "std::front_insert_iterator<Container>::operator++",
            "path": "en.cppreference.com/w/cpp/iterator/front_insert_iterator/operator++.html",
            "wgPageName": "cpp/iterator/front_insert_iterator/operator++",
            "sample_declaration": "front_insert_iterator& operator++();",
            "other_declarations": 3
        },
        {
            "title": "std::front_insert_iterator<Container>::operator=",
            "path": "en.cppreference.com/w/cpp/iterator/front_insert_iterator/operator=.html",
            "wgPageName": "cpp/iterator/front_insert_iterator/operator=",
            "sample_declaration": "front_insert_iterator<Container>& operator=(\n    typename Container::const_reference value);",
            "other_declarations": 4
        },
        {
            "title": "std::front_inserter",
            "path": "en.cppreference.com/w/cpp/iterator/front_inserter.html",
            "wgPageName": "cpp/iterator/front_inserter",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class Container>\nstd::front_insert_iterator<Container>\nfront_inserter(Container& c);",
            "other_declarations": 1
        },
        {
            "title": "std::incrementable_traits",
            "path": "en.cppreference.com/w/cpp/iterator/incrementable_traits.html",
            "wgPageName": "cpp/iterator/incrementable_traits",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class I>\nstruct incrementable_traits {};",
            "other_declarations": 4
        },
        {
            "title": "std::incrementable",
            "path": "en.cppreference.com/w/cpp/iterator/incrementable.html",
            "wgPageName": "cpp/iterator/incrementable",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class I>\nconcept incrementable = std::regular<I> &&\n    std::weakly_incrementable<I> &&\n    requires(I i) {\n  { i++ } -> std::same_as<I>;\n};"
        },
        {
            "title": "std::indirect_binary_predicate",
            "path": "en.cppreference.com/w/cpp/iterator/indirect_binary_predicate.html",
            "wgPageName": "cpp/iterator/indirect_binary_predicate",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class F, class I1, class I2>\nconcept indirect_binary_predicate =\n    std::indirectly_readable<I1> &&\n    std::indirectly_readable<I2> &&\n    std::copy_constructible<F> &&\n    std::predicate < F&,\n        std::iter_value_t<I1>\n&, std::iter_value_t<I2>& >\n       &&std::predicate<\n           F&,\n           std::iter_value_t<I1>&,\n           std::iter_reference_t<I2>>&&\n           std::predicate<\n               F&,\n               std::iter_reference_t<I1>,\n               std::iter_value_t<I2>&>&&\n               std::predicate<\n                   F&,\n                   std::iter_reference_t<I1>,\n                   std::iter_reference_t<I2>>&&\n                   std::predicate<\n                       F&,\n                       std::\n                           iter_common_reference_t<\n                               I1>,\n                       std::\n                           iter_common_reference_t<\n                               I2>>;"
        },
        {
            "title": "std::indirect_equivalence_relation",
            "path": "en.cppreference.com/w/cpp/iterator/indirect_equivalence_relation.html",
            "wgPageName": "cpp/iterator/indirect_equivalence_relation",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class F, class I1, class I2 = I1>\nconcept indirect_equivalence_relation =\n    std::indirectly_readable<I1> &&\n    std::indirectly_readable<I2> &&\n    std::copy_constructible<F> &&\n    std::equivalence_relation < F&,\n        std::iter_value_t<I1>\n&, std::iter_value_t<I2>& >\n       &&std::equivalence_relation<\n           F&,\n           std::iter_value_t<I1>&,\n           std::iter_reference_t<I2>>&&\n           std::equivalence_relation<\n               F&,\n               std::iter_reference_t<I1>,\n               std::iter_value_t<I2>&>&&\n               std::equivalence_relation<\n                   F&,\n                   std::iter_reference_t<I1>,\n                   std::iter_reference_t<I2>>&&\n                   std::equivalence_relation<\n                       F&,\n                       std::\n                           iter_common_reference_t<\n                               I1>,\n                       std::\n                           iter_common_reference_t<\n                               I2>>;"
        },
        {
            "title": "std::indirect_result_t",
            "path": "en.cppreference.com/w/cpp/iterator/indirect_result_t.html",
            "wgPageName": "cpp/iterator/indirect_result_t",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class F, class... Is>\nrequires(std::indirectly_readable<Is>&&...) &&\n    std::invocable<\n        F,\n        std::iter_reference_t<\n            Is>...> using indirect_result_t =\n    std::invoke_result_t<\n        F,\n        std::iter_reference_t<Is>...>;"
        },
        {
            "title": "std::indirect_strict_weak_order",
            "path": "en.cppreference.com/w/cpp/iterator/indirect_strict_weak_order.html",
            "wgPageName": "cpp/iterator/indirect_strict_weak_order",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class F, class I1, class I2 = I1>\nconcept indirect_strict_weak_order =\n    std::indirectly_readable<I1> &&\n    std::indirectly_readable<I2> &&\n    std::copy_constructible<F> &&\n    std::strict_weak_order < F&,\n        std::iter_value_t<I1>\n&, std::iter_value_t<I2>& >\n       &&std::strict_weak_order<\n           F&,\n           std::iter_value_t<I1>&,\n           std::iter_reference_t<I2>>&&\n           std::strict_weak_order<\n               F&,\n               std::iter_reference_t<I1>,\n               std::iter_value_t<I2>&>&&\n               std::strict_weak_order<\n                   F&,\n                   std::iter_reference_t<I1>,\n                   std::iter_reference_t<I2>>&&\n                   std::strict_weak_order<\n                       F&,\n                       std::\n                           iter_common_reference_t<\n                               I1>,\n                       std::\n                           iter_common_reference_t<\n                               I2>>;"
        },
        {
            "title": "std::indirect_unary_predicate",
            "path": "en.cppreference.com/w/cpp/iterator/indirect_unary_predicate.html",
            "wgPageName": "cpp/iterator/indirect_unary_predicate",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class F, class I>\nconcept indirect_unary_predicate =\n    std::indirectly_readable<I> &&\n    std::copy_constructible<F> &&\n    std::predicate < F&,\n        std::iter_value_t<I>\n& > &&std::predicate<\n        F&,\n        std::iter_reference_t<I>>&&\n        std::predicate<\n            F&,\n            std::iter_common_reference_t<I>>;"
        },
        {
            "title": "std::indirectly_comparable",
            "path": "en.cppreference.com/w/cpp/iterator/indirectly_comparable.html",
            "wgPageName": "cpp/iterator/indirectly_comparable",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<\n    class I1,\n    class I2,\n    class Comp,\n    class Proj1 = std::identity,\n    class Proj2 = std::identity>\nconcept indirectly_comparable =\n    std::indirect_binary_predicate<\n        Comp,\n        std::projected<I1, Proj1>,\n        std::projected<I2, Proj2>>;"
        },
        {
            "title": "std::indirectly_copyable_storable",
            "path": "en.cppreference.com/w/cpp/iterator/indirectly_copyable_storable.html",
            "wgPageName": "cpp/iterator/indirectly_copyable_storable",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class In, class Out>\nconcept indirectly_copyable_storable =\n    std::indirectly_copyable<In, Out> &&\n    std::indirectly_writable < Out,\n        std::iter_value_t<In>\n& > &&std::indirectly_writable<\n        Out,\n        const std::iter_value_t<In>&>&&\n        std::indirectly_writable<\n            Out,\n            std::iter_value_t<In>&&>&&\n            std::indirectly_writable<\n                Out,\n                const std::iter_value_t<In>&&>&&\n                std::copyable<\n                    std::iter_value_t<In>>&&\n                    std::constructible_from<\n                        std::iter_value_t<In>,\n                        std::iter_reference_t<\n                            In>>&&\n                        std::assignable_from<\n                            std::iter_value_t<\n                                In>&,\n                            std::\n                                iter_reference_t<\n                                    In>>;"
        },
        {
            "title": "std::indirectly_copyable",
            "path": "en.cppreference.com/w/cpp/iterator/indirectly_copyable.html",
            "wgPageName": "cpp/iterator/indirectly_copyable",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class In, class Out>\nconcept indirectly_copyable =\n    std::indirectly_readable<In> &&\n    std::indirectly_writable<\n        Out,\n        std::iter_reference_t<In>>;"
        },
        {
            "title": "std::indirectly_movable_storable",
            "path": "en.cppreference.com/w/cpp/iterator/indirectly_movable_storable.html",
            "wgPageName": "cpp/iterator/indirectly_movable_storable",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class In, class Out>\nconcept indirectly_movable_storable =\n    std::indirectly_movable<In, Out> &&\n    std::indirectly_writable<\n        Out,\n        std::iter_value_t<In>> &&\n    std::movable<std::iter_value_t<In>> &&\n    std::constructible_from<\n        std::iter_value_t<In>,\n        std::iter_rvalue_reference_t<In>> &&\n    std::assignable_from < std::iter_value_t<In>\n&, std::iter_rvalue_reference_t < In >> ;"
        },
        {
            "title": "std::indirectly_movable",
            "path": "en.cppreference.com/w/cpp/iterator/indirectly_movable.html",
            "wgPageName": "cpp/iterator/indirectly_movable",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class In, class Out>\nconcept indirectly_movable =\n    std::indirectly_readable<In> &&\n    std::indirectly_writable<\n        Out,\n        std::iter_rvalue_reference_t<In>>;"
        },
        {
            "title": "std::indirectly_readable_traits",
            "path": "en.cppreference.com/w/cpp/iterator/indirectly_readable_traits.html",
            "wgPageName": "cpp/iterator/indirectly_readable_traits",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class I>\nstruct indirectly_readable_traits {};",
            "other_declarations": 7
        },
        {
            "title": "std::indirectly_readable",
            "path": "en.cppreference.com/w/cpp/iterator/indirectly_readable.html",
            "wgPageName": "cpp/iterator/indirectly_readable",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class In>\nconcept __IndirectlyReadableImpl =  // exposition\n                                    // only\n                                    // requires(const\n                                    // In in) {\n                                    // typename\n                                    // std::iter_value_t<In>;\n                                    // typename\n                                    // std::iter_reference_t<In>;\n                                    // typename\n                                    // std::iter_rvalue_reference_t<In>;\n                                    // { *in }\n                                    // ->\n                                    // std::same_as<std::iter_reference_t<In>>;\n                                    // {\n                                    // ranges::iter_move(in)\n                                    // } ->\n                                    // std::same_as<std::iter_rvalue_reference_t<In>>;\n                                    // } &&\n                                    // std::common_reference_with<\n                                    // std::iter_reference_t<In>&&,\n                                    // std::iter_value_t<In>&\n                                    // > &&\n                                    // std::common_reference_with<\n                                    // std::iter_reference_t<In>&&,\n                                    // std::iter_rvalue_reference_t<In>&&\n                                    // > &&\n                                    // std::common_reference_with<\n                                    // std::iter_rvalue_reference_t<In>&&,\n                                    // const\n                                    // std::iter_value_t<In>&\n                                    // >;",
            "other_declarations": 1
        },
        {
            "title": "std::indirectly_swappable",
            "path": "en.cppreference.com/w/cpp/iterator/indirectly_swappable.html",
            "wgPageName": "cpp/iterator/indirectly_swappable",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class I1, class I2>\nconcept indirectly_swappable =\n    std::indirectly_readable<I1> &&\n    std::indirectly_readable<I2> &&\n    requires(const I1 i1, const I2 i2) {\n  ranges::iter_swap(i1, i1);\n  ranges::iter_swap(i1, i2);\n  ranges::iter_swap(i2, i1);\n  ranges::iter_swap(i2, i2);\n};"
        },
        {
            "title": "std::indirectly_unary_invocable, std::indirectly_regular_unary_invocable",
            "path": "en.cppreference.com/w/cpp/iterator/indirectly_unary_invocable.html",
            "wgPageName": "cpp/iterator/indirectly_unary_invocable",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class F, class I>\nconcept indirectly_unary_invocable =\n    std::indirectly_readable<I> &&\n    std::copy_constructible<F> &&\n    std::invocable < F&,\n        std::iter_value_t<I>\n& > &&std::invocable<\n        F&,\n        std::iter_reference_t<I>>&&\n        std::invocable<\n            F&,\n            std::iter_common_reference_t<I>>&&\n            std::common_reference_with<\n                std::invoke_result_t<\n                    F&,\n                    std::iter_value_t<I>&>,\n                std::invoke_result_t<\n                    F&,\n                    std::iter_reference_t<I>>>;",
            "other_declarations": 1
        },
        {
            "title": "std::indirectly_writable",
            "path": "en.cppreference.com/w/cpp/iterator/indirectly_writable.html",
            "wgPageName": "cpp/iterator/indirectly_writable",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class Out, class T>\nconcept indirectly_writable =\n    requires(Out&& o, T&& t) {\n  *o = std::forward<T>(t);\n  *std::forward<Out>(o) = std::forward<T>(t);\n  const_cast<\n      const std::iter_reference_t<Out>&&>(*o) =\n      std::forward<T>(t);\n  const_cast<\n      const std::iter_reference_t<Out>&&>(\n      *std::forward<Out>(o)) =\n      std::forward<T>(t);\n};  // none of the four expressions above are\n    // required to be equality-preserving"
        },
        {
            "title": "std::input_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/input_iterator.html",
            "wgPageName": "cpp/iterator/input_iterator",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class I>\nconcept input_iterator =\n    std::input_or_output_iterator<I> &&\n    std::indirectly_readable<I> && requires {\n  typename /*ITER_CONCEPT*/<I>;\n} && std::derived_from<\n    /*ITER_CONCEPT*/<I>,\n    std::input_iterator_tag>;"
        },
        {
            "title": "std::input_or_output_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/input_or_output_iterator.html",
            "wgPageName": "cpp/iterator/input_or_output_iterator",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class I>\nconcept input_or_output_iterator =\n    requires(I i) {\n  { *i } -> /*can-reference*/;\n}\n&&std::weakly_incrementable<I>;"
        },
        {
            "title": "std::insert_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/insert_iterator.html",
            "wgPageName": "cpp/iterator/insert_iterator",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class Container>\nclass insert_iterator\n    : public std::iterator<\n          std::output_iterator_tag,\n          void,\n          void,\n          void,\n          void>",
            "other_declarations": 1
        },
        {
            "title": "std::insert_iterator<Container>::insert_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/insert_iterator/insert_iterator.html",
            "wgPageName": "cpp/iterator/insert_iterator/insert_iterator",
            "sample_declaration": "insert_iterator(\n    Container& c,\n    typename Container::iterator i);",
            "other_declarations": 1
        },
        {
            "title": "std::insert_iterator<Container>::operator*",
            "path": "en.cppreference.com/w/cpp/iterator/insert_iterator/operator*.html",
            "wgPageName": "cpp/iterator/insert_iterator/operator*",
            "sample_declaration": "insert_iterator& operator*();",
            "other_declarations": 1
        },
        {
            "title": "std::insert_iterator<Container>::operator++",
            "path": "en.cppreference.com/w/cpp/iterator/insert_iterator/operator++.html",
            "wgPageName": "cpp/iterator/insert_iterator/operator++",
            "sample_declaration": "insert_iterator& operator++();",
            "other_declarations": 3
        },
        {
            "title": "std::insert_iterator<Container>::operator=",
            "path": "en.cppreference.com/w/cpp/iterator/insert_iterator/operator=.html",
            "wgPageName": "cpp/iterator/insert_iterator/operator=",
            "sample_declaration": "insert_iterator<Container>& operator=(\n    typename Container::const_reference value);",
            "other_declarations": 4
        },
        {
            "title": "std::inserter",
            "path": "en.cppreference.com/w/cpp/iterator/inserter.html",
            "wgPageName": "cpp/iterator/inserter",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class Container>\nstd::insert_iterator<Container> inserter(\n    Container& c,\n    typename Container::iterator i);",
            "other_declarations": 1
        },
        {
            "title": "std::istream_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/istream_iterator.html",
            "wgPageName": "cpp/iterator/istream_iterator",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<\n    class T,\n    class CharT = char,\n    class Traits = std::char_traits<CharT>,\n    class Distance = std::ptrdiff_t>\nclass istream_iterator\n    : public std::iterator<\n          std::input_iterator_tag,\n          T,\n          Distance,\n          const T*,\n          const T&>",
            "other_declarations": 1
        },
        {
            "title": "std::istream_iterator<T,CharT,Traits,Distance>::~istream_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/istream_iterator/~istream_iterator.html",
            "wgPageName": "cpp/iterator/istream_iterator/~istream_iterator",
            "sample_declaration": "~istream_iterator();",
            "other_declarations": 1
        },
        {
            "title": "std::istream_iterator<T,CharT,Traits,Distance>::istream_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/istream_iterator/istream_iterator.html",
            "wgPageName": "cpp/iterator/istream_iterator/istream_iterator",
            "sample_declaration": "istream_iterator();",
            "other_declarations": 5
        },
        {
            "title": "std::istream_iterator<T,CharT,Traits,Distance>::operator++, operator++(int)",
            "path": "en.cppreference.com/w/cpp/iterator/istream_iterator/operator_arith.html",
            "wgPageName": "cpp/iterator/istream_iterator/operator_arith",
            "sample_declaration": "istream_iterator& operator++();",
            "other_declarations": 1
        },
        {
            "title": "operator==,!=(std::istream_iterator<T,CharT,Traits,Dist>)",
            "path": "en.cppreference.com/w/cpp/iterator/istream_iterator/operator_cmp.html",
            "wgPageName": "cpp/iterator/istream_iterator/operator_cmp",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<\n    class T,\n    class CharT,\n    class Traits,\n    class Dist>\nbool operator==(\n    const std::istream_iterator<\n        T,\n        CharT,\n        Traits,\n        Dist>& lhs,\n    const std::istream_iterator<\n        T,\n        CharT,\n        Traits,\n        Dist>& rhs);",
            "other_declarations": 2
        },
        {
            "title": "std::istream_iterator<T,CharT,Traits,Distance>::operator*, operator->",
            "path": "en.cppreference.com/w/cpp/iterator/istream_iterator/operator*.html",
            "wgPageName": "cpp/iterator/istream_iterator/operator*",
            "sample_declaration": "const T& operator*() const;",
            "other_declarations": 1
        },
        {
            "title": "std::istreambuf_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/istreambuf_iterator.html",
            "wgPageName": "cpp/iterator/istreambuf_iterator",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT> >\nclass istreambuf_iterator\n    : public std::iterator<\n          std::input_iterator_tag,\n          CharT,\n          typename Traits::off_type,\n          /* unspecified, usually CharT* */,\n          CharT>",
            "other_declarations": 1
        },
        {
            "title": "std::istreambuf_iterator<CharT,Traits>::equal",
            "path": "en.cppreference.com/w/cpp/iterator/istreambuf_iterator/equal.html",
            "wgPageName": "cpp/iterator/istreambuf_iterator/equal",
            "sample_declaration": "bool equal(const istreambuf_iterator& it) const;"
        },
        {
            "title": "std::istreambuf_iterator<CharT,Traits>::istreambuf_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/istreambuf_iterator/istreambuf_iterator.html",
            "wgPageName": "cpp/iterator/istreambuf_iterator/istreambuf_iterator",
            "sample_declaration": "istreambuf_iterator() throw();",
            "other_declarations": 9
        },
        {
            "title": "std::istreambuf_iterator<CharT,Traits>::operator++, operator++(int)",
            "path": "en.cppreference.com/w/cpp/iterator/istreambuf_iterator/operator_arith.html",
            "wgPageName": "cpp/iterator/istreambuf_iterator/operator_arith",
            "sample_declaration": "istreambuf_iterator& operator++();",
            "other_declarations": 1
        },
        {
            "title": "operator==,!=(std::istreambuf_iterator<CharT,Traits>)",
            "path": "en.cppreference.com/w/cpp/iterator/istreambuf_iterator/operator_cmp.html",
            "wgPageName": "cpp/iterator/istreambuf_iterator/operator_cmp",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nbool operator==(\n    const std::\n        istreambuf_iterator<CharT, Traits>& lhs,\n    const std::istreambuf_iterator<\n        CharT,\n        Traits>& rhs);",
            "other_declarations": 2
        },
        {
            "title": "std::istreambuf_iterator<CharT,Traits>::operator*, operator->",
            "path": "en.cppreference.com/w/cpp/iterator/istreambuf_iterator/operator*.html",
            "wgPageName": "cpp/iterator/istreambuf_iterator/operator*",
            "sample_declaration": "CharT operator*() const;",
            "other_declarations": 1
        },
        {
            "title": "std::iter_value_t, std::iter_reference_t, std::iter_const_reference_t, std::iter_difference_t, std::iter_rvalue_reference_t, std::iter_common_reference_t",
            "path": "en.cppreference.com/w/cpp/iterator/iter_t.html",
            "wgPageName": "cpp/iterator/iter_t",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class T>\nconcept /*dereferenceable*/ =\n    /* see below */;  // exposition only",
            "other_declarations": 6
        },
        {
            "title": "std::input_iterator_tag, std::output_iterator_tag, std::forward_iterator_tag, std::bidirectional_iterator_tag, std::random_access_iterator_tag, std::contiguous_iterator_tag",
            "path": "en.cppreference.com/w/cpp/iterator/iterator_tags.html",
            "wgPageName": "cpp/iterator/iterator_tags",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "struct input_iterator_tag {};",
            "other_declarations": 5
        },
        {
            "title": "std::iterator_traits",
            "path": "en.cppreference.com/w/cpp/iterator/iterator_traits.html",
            "wgPageName": "cpp/iterator/iterator_traits",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class Iter>\nstruct iterator_traits;",
            "other_declarations": 2
        },
        {
            "title": "std::iterator",
            "path": "en.cppreference.com/w/cpp/iterator/iterator.html",
            "wgPageName": "cpp/iterator/iterator",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<\n    class Category,\n    class T,\n    class Distance = std::ptrdiff_t,\n    class Pointer = T*,\n    class Reference = T&>\nstruct iterator;"
        },
        {
            "title": "std::make_move_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/make_move_iterator.html",
            "wgPageName": "cpp/iterator/make_move_iterator",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class Iter>\nstd::move_iterator<Iter> make_move_iterator(\n    Iter i);",
            "other_declarations": 1
        },
        {
            "title": "std::make_reverse_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/make_reverse_iterator.html",
            "wgPageName": "cpp/iterator/make_reverse_iterator",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class Iter>\nstd::reverse_iterator<Iter>\nmake_reverse_iterator(Iter i);",
            "other_declarations": 1
        },
        {
            "title": "std::mergeable",
            "path": "en.cppreference.com/w/cpp/iterator/mergeable.html",
            "wgPageName": "cpp/iterator/mergeable",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<\n    class I1,\n    class I2,\n    class Out,\n    class Comp = ranges::less,\n    class Proj1 = std::identity,\n    class Proj2 = std::identity>\nconcept mergeable = std::input_iterator<I1> &&\n    std::input_iterator<I2> &&\n    std::weakly_incrementable<Out> &&\n    std::indirectly_copyable<I1, Out> &&\n    std::indirectly_copyable<I2, Out> &&\n    std::indirect_strict_weak_order<\n        Comp,\n        std::projected<I1, Proj1>,\n        std::projected<I2, Proj2>>;"
        },
        {
            "title": "std::move_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/move_iterator.html",
            "wgPageName": "cpp/iterator/move_iterator",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class Iter>\nclass move_iterator;"
        },
        {
            "title": "std::move_iterator<Iter>::base",
            "path": "en.cppreference.com/w/cpp/iterator/move_iterator/base.html",
            "wgPageName": "cpp/iterator/move_iterator/base",
            "sample_declaration": "iterator_type base() const;",
            "other_declarations": 3
        },
        {
            "title": "iter_move(std::move_iterator)",
            "path": "en.cppreference.com/w/cpp/iterator/move_iterator/iter_move.html",
            "wgPageName": "cpp/iterator/move_iterator/iter_move",
            "sample_declaration": "friend constexpr std::iter_rvalue_reference_t<\n    Iter>\niter_move(const std::move_iterator& i) noexcept(\n    /* see below */);"
        },
        {
            "title": "iter_swap(std::move_iterator)",
            "path": "en.cppreference.com/w/cpp/iterator/move_iterator/iter_swap.html",
            "wgPageName": "cpp/iterator/move_iterator/iter_swap",
            "sample_declaration": "template<std::indirectly_swappable<Iter> Iter2>\nfriend constexpr void iter_swap(\n    const move_iterator& x,\n    const std::move_iterator<Iter2>&\n        y) noexcept(/*see below*/);"
        },
        {
            "title": "std::move_iterator<Iter>::move_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/move_iterator/move_iterator.html",
            "wgPageName": "cpp/iterator/move_iterator/move_iterator",
            "sample_declaration": "move_iterator();",
            "other_declarations": 5
        },
        {
            "title": "std::move_iterator<Iter>::operator++,+,+=,--,-,-=",
            "path": "en.cppreference.com/w/cpp/iterator/move_iterator/operator_arith.html",
            "wgPageName": "cpp/iterator/move_iterator/operator_arith",
            "sample_declaration": "move_iterator& operator++();",
            "other_declarations": 16
        },
        {
            "title": "std::move_iterator<Iter>::operator[]",
            "path": "en.cppreference.com/w/cpp/iterator/move_iterator/operator_at.html",
            "wgPageName": "cpp/iterator/move_iterator/operator_at",
            "sample_declaration": "/*unspecified*/ operator[](\n    difference_type n) const;",
            "other_declarations": 1
        },
        {
            "title": "operator==,!=,<,<=,>,>=,<=>(std::move_iterator)",
            "path": "en.cppreference.com/w/cpp/iterator/move_iterator/operator_cmp.html",
            "wgPageName": "cpp/iterator/move_iterator/operator_cmp",
            "sample_declaration": "template<class Iterator1, class Iterator2>\nbool operator==(\n    const std::move_iterator<Iterator1>& lhs,\n    const std::move_iterator<Iterator2>& rhs);",
            "other_declarations": 12
        },
        {
            "title": "operator==(std::move_iterator<Iter>, std::move_sentinel)",
            "path": "en.cppreference.com/w/cpp/iterator/move_iterator/operator_cmp2.html",
            "wgPageName": "cpp/iterator/move_iterator/operator_cmp2",
            "sample_declaration": "template<std::sentinel_for<Iter> S>\nfriend constexpr bool operator==(\n    const move_iterator& i,\n    const std::move_sentinel<S>& s);"
        },
        {
            "title": "operator-(std::move_iterator)",
            "path": "en.cppreference.com/w/cpp/iterator/move_iterator/operator-.html",
            "wgPageName": "cpp/iterator/move_iterator/operator-",
            "sample_declaration": "template<class Iterator1, class Iterator2>\nauto operator-(\n    const move_iterator<Iterator1>& lhs,\n    const move_iterator<Iterator2>& rhs)\n    -> decltype(lhs.base() - rhs.base());",
            "other_declarations": 1
        },
        {
            "title": "operator-(std::move_iterator<Iter>, std::move_sentinel)",
            "path": "en.cppreference.com/w/cpp/iterator/move_iterator/operator-2.html",
            "wgPageName": "cpp/iterator/move_iterator/operator-2",
            "sample_declaration": "template<std::sized_sentinel_for<Iter> S>\nfriend constexpr std::iter_difference_t<Iter>\noperator-(\n    const std::move_sentinel<S>& s,\n    const move_iterator& i);",
            "other_declarations": 1
        },
        {
            "title": "std::move_iterator<Iter>::operator*,->",
            "path": "en.cppreference.com/w/cpp/iterator/move_iterator/operator*.html",
            "wgPageName": "cpp/iterator/move_iterator/operator*",
            "sample_declaration": "reference operator*() const;",
            "other_declarations": 3
        },
        {
            "title": "operator+(std::move_iterator)",
            "path": "en.cppreference.com/w/cpp/iterator/move_iterator/operator+.html",
            "wgPageName": "cpp/iterator/move_iterator/operator+",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class Iter>\nmove_iterator<Iter> operator+(\n    typename move_iterator<\n        Iter>::difference_type n,\n    const move_iterator<Iter>& it);",
            "other_declarations": 1
        },
        {
            "title": "std::move_iterator<Iter>::operator=",
            "path": "en.cppreference.com/w/cpp/iterator/move_iterator/operator=.html",
            "wgPageName": "cpp/iterator/move_iterator/operator=",
            "sample_declaration": "template<class U>\nmove_iterator& operator=(\n    const move_iterator<U>& other);",
            "other_declarations": 1
        },
        {
            "title": "std::move_sentinel",
            "path": "en.cppreference.com/w/cpp/iterator/move_sentinel.html",
            "wgPageName": "cpp/iterator/move_sentinel",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<std::semiregular S>\nclass move_sentinel;"
        },
        {
            "title": "std::move_sentinel<S>::base",
            "path": "en.cppreference.com/w/cpp/iterator/move_sentinel/base.html",
            "wgPageName": "cpp/iterator/move_sentinel/base",
            "sample_declaration": "constexpr S base() const;"
        },
        {
            "title": "std::move_sentinel<S>::move_sentinel",
            "path": "en.cppreference.com/w/cpp/iterator/move_sentinel/move_sentinel.html",
            "wgPageName": "cpp/iterator/move_sentinel/move_sentinel",
            "sample_declaration": "constexpr move_sentinel();",
            "other_declarations": 2
        },
        {
            "title": "std::move_sentinel<S>::operator=",
            "path": "en.cppreference.com/w/cpp/iterator/move_sentinel/operator=.html",
            "wgPageName": "cpp/iterator/move_sentinel/operator=",
            "sample_declaration": "template<class S2>\nrequires std::assignable_from<S&, const S2&>\nconstexpr move_sentinel& operator=(\n    const std::move_sentinel<S2>& other);"
        },
        {
            "title": "std::next",
            "path": "en.cppreference.com/w/cpp/iterator/next.html",
            "wgPageName": "cpp/iterator/next",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class InputIt>\nInputIt next(\n    InputIt it,\n    typename std::iterator_traits<\n        InputIt>::difference_type n = 1);",
            "other_declarations": 1
        },
        {
            "title": "std::ostream_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/ostream_iterator.html",
            "wgPageName": "cpp/iterator/ostream_iterator",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<\n    class T,\n    class CharT = char,\n    class Traits = std::char_traits<CharT> >\nclass ostream_iterator\n    : public std::iterator<\n          std::output_iterator_tag,\n          void,\n          void,\n          void,\n          void>",
            "other_declarations": 1
        },
        {
            "title": "std::ostream_iterator<T,CharT,Traits>::~ostream_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/ostream_iterator/~ostream_iterator.html",
            "wgPageName": "cpp/iterator/ostream_iterator/~ostream_iterator",
            "sample_declaration": "~ostream_iterator()"
        },
        {
            "title": "std::ostream_iterator<T,CharT,Traits>::operator++",
            "path": "en.cppreference.com/w/cpp/iterator/ostream_iterator/operator_arith.html",
            "wgPageName": "cpp/iterator/ostream_iterator/operator_arith",
            "sample_declaration": "ostream_iterator& operator++();",
            "other_declarations": 1
        },
        {
            "title": "std::ostream_iterator<T,CharT,Traits>::operator*",
            "path": "en.cppreference.com/w/cpp/iterator/ostream_iterator/operator*.html",
            "wgPageName": "cpp/iterator/ostream_iterator/operator*",
            "sample_declaration": "ostream_iterator& operator*();"
        },
        {
            "title": "std::ostream_iterator<T,CharT,Traits>::operator=",
            "path": "en.cppreference.com/w/cpp/iterator/ostream_iterator/operator=.html",
            "wgPageName": "cpp/iterator/ostream_iterator/operator=",
            "sample_declaration": "ostream_iterator& operator=(const T& value);"
        },
        {
            "title": "std::ostream_iterator<T,CharT,Traits>::ostream_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/ostream_iterator/ostream_iterator.html",
            "wgPageName": "cpp/iterator/ostream_iterator/ostream_iterator",
            "sample_declaration": "ostream_iterator(\n    ostream_type& stream,\n    const CharT* delim);",
            "other_declarations": 1
        },
        {
            "title": "std::ostreambuf_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/ostreambuf_iterator.html",
            "wgPageName": "cpp/iterator/ostreambuf_iterator",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT> >\nclass ostreambuf_iterator\n    : public std::iterator<\n          std::output_iterator_tag,\n          void,\n          void,\n          void,\n          void>",
            "other_declarations": 1
        },
        {
            "title": "std::ostreambuf_iterator<CharT,Traits>::failed",
            "path": "en.cppreference.com/w/cpp/iterator/ostreambuf_iterator/failed.html",
            "wgPageName": "cpp/iterator/ostreambuf_iterator/failed",
            "sample_declaration": "bool failed() const throw();",
            "other_declarations": 1
        },
        {
            "title": "std::ostreambuf_iterator<CharT,Traits>::operator++",
            "path": "en.cppreference.com/w/cpp/iterator/ostreambuf_iterator/operator_arith.html",
            "wgPageName": "cpp/iterator/ostreambuf_iterator/operator_arith",
            "sample_declaration": "ostreambuf_iterator& operator++();",
            "other_declarations": 1
        },
        {
            "title": "std::ostreambuf_iterator<CharT,Traits>::operator*",
            "path": "en.cppreference.com/w/cpp/iterator/ostreambuf_iterator/operator*.html",
            "wgPageName": "cpp/iterator/ostreambuf_iterator/operator*",
            "sample_declaration": "ostreambuf_iterator& operator*();"
        },
        {
            "title": "std::ostreambuf_iterator<CharT,Traits>::operator=",
            "path": "en.cppreference.com/w/cpp/iterator/ostreambuf_iterator/operator=.html",
            "wgPageName": "cpp/iterator/ostreambuf_iterator/operator=",
            "sample_declaration": "ostreambuf_iterator& operator=(CharT c);"
        },
        {
            "title": "std::ostreambuf_iterator<CharT,Traits>::ostreambuf_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/ostreambuf_iterator/ostreambuf_iterator.html",
            "wgPageName": "cpp/iterator/ostreambuf_iterator/ostreambuf_iterator",
            "sample_declaration": "ostreambuf_iterator(\n    streambuf_type* buffer) throw();",
            "other_declarations": 3
        },
        {
            "title": "std::output_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/output_iterator.html",
            "wgPageName": "cpp/iterator/output_iterator",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class I, class T>\nconcept output_iterator =\n    std::input_or_output_iterator<I> &&\n    std::indirectly_writable<I, T> &&\n    requires(I i, T&& t) {\n  *i++ = std::forward<T>(\n      t);  // not required to be\n           // equality-preserving };"
        },
        {
            "title": "std::permutable",
            "path": "en.cppreference.com/w/cpp/iterator/permutable.html",
            "wgPageName": "cpp/iterator/permutable",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class I>\nconcept permutable = std::forward_iterator<I> &&\n    std::indirectly_movable_storable<I, I> &&\n    std::indirectly_swappable<I, I>;"
        },
        {
            "title": "std::prev",
            "path": "en.cppreference.com/w/cpp/iterator/prev.html",
            "wgPageName": "cpp/iterator/prev",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class BidirIt>\nBidirIt prev(\n    BidirIt it,\n    typename std::iterator_traits<\n        BidirIt>::difference_type n = 1);",
            "other_declarations": 1
        },
        {
            "title": "std::projected",
            "path": "en.cppreference.com/w/cpp/iterator/projected.html",
            "wgPageName": "cpp/iterator/projected",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<\n    std::indirectly_readable I,\n    std::indirectly_regular_unary_invocable<I>\n        Proj>\nstruct projected {\n  using value_type = std::remove_cvref_t<\n      std::indirect_result_t<Proj&, I>>;\n  std::indirect_result_t<Proj&, I> operator*()\n      const;  // not defined };",
            "other_declarations": 1
        },
        {
            "title": "std::random_access_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/random_access_iterator.html",
            "wgPageName": "cpp/iterator/random_access_iterator",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class I>\nconcept random_access_iterator =\n    std::bidirectional_iterator<I> &&\n    std::derived_from<\n        /*ITER_CONCEPT*/<I>,\n        std::random_access_iterator_tag> &&\n    std::totally_ordered<I> &&\n    std::sized_sentinel_for<I, I> && requires(\n        I i,\n        const I j,\n        const std::iter_difference_t<I> n) {\n  { i += n } -> std::same_as<I&>;\n  { j + n } -> std::same_as<I>;\n  { n + j } -> std::same_as<I>;\n  { i -= n } -> std::same_as<I&>;\n  { j - n } -> std::same_as<I>;\n  {\n    j[n]\n    } -> std::same_as<std::iter_reference_t<I>>;\n};"
        },
        {
            "title": "std::ranges::advance",
            "path": "en.cppreference.com/w/cpp/iterator/ranges/advance.html",
            "wgPageName": "cpp/iterator/ranges/advance",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<std::input_or_output_iterator I>\nconstexpr void advance(\n    I& i,\n    std::iter_difference_t<I> n);",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::distance",
            "path": "en.cppreference.com/w/cpp/iterator/ranges/distance.html",
            "wgPageName": "cpp/iterator/ranges/distance",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<\n    std::input_or_output_iterator I,\n    std::sentinel_for<I> S>\nrequires(!std::sized_sentinel_for<\n         S,\n         I>) constexpr std::\n    iter_difference_t<I> distance(\n        I first,\n        S last);",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::iter_move",
            "path": "en.cppreference.com/w/cpp/iterator/ranges/iter_move.html",
            "wgPageName": "cpp/iterator/ranges/iter_move",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "inline namespace /*unspecified*/ {\ninline constexpr /*unspecified*/ iter_move =\n    /*unspecified*/;\n}",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::iter_swap",
            "path": "en.cppreference.com/w/cpp/iterator/ranges/iter_swap.html",
            "wgPageName": "cpp/iterator/ranges/iter_swap",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "namespace ranges {\ninline namespace /*unspecified*/ {\ninline constexpr /*unspecified*/ iter_swap =\n    /*unspecified*/;\n}\n}  // namespace ranges",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::next",
            "path": "en.cppreference.com/w/cpp/iterator/ranges/next.html",
            "wgPageName": "cpp/iterator/ranges/next",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<std::input_or_output_iterator I>\nconstexpr I next(I i);",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::prev",
            "path": "en.cppreference.com/w/cpp/iterator/ranges/prev.html",
            "wgPageName": "cpp/iterator/ranges/prev",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<std::bidirectional_iterator I>\nconstexpr I prev(I i);",
            "other_declarations": 2
        },
        {
            "title": "std::rbegin, std::crbegin",
            "path": "en.cppreference.com/w/cpp/iterator/rbegin.html",
            "wgPageName": "cpp/iterator/rbegin",
            "headers": [
                "<array>",
                "<deque>",
                "<forward_list>",
                "<iterator>",
                "<list>",
                "<map>",
                "<regex>",
                "<set>",
                "<span>",
                "<string>",
                "<string_view>",
                "<unordered_map>",
                "<unordered_set>",
                "<vector>"
            ],
            "sample_declaration": "template<class C>\nauto rbegin(C& c) -> decltype(c.rbegin());",
            "other_declarations": 9
        },
        {
            "title": "std::rend, std::crend",
            "path": "en.cppreference.com/w/cpp/iterator/rend.html",
            "wgPageName": "cpp/iterator/rend",
            "headers": [
                "<array>",
                "<deque>",
                "<forward_list>",
                "<iterator>",
                "<list>",
                "<map>",
                "<regex>",
                "<set>",
                "<span>",
                "<string>",
                "<string_view>",
                "<unordered_map>",
                "<unordered_set>",
                "<vector>"
            ],
            "sample_declaration": "template<class C>\nauto rend(C& c) -> decltype(c.rend());",
            "other_declarations": 9
        },
        {
            "title": "std::reverse_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/reverse_iterator.html",
            "wgPageName": "cpp/iterator/reverse_iterator",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class Iter>\nclass reverse_iterator;"
        },
        {
            "title": "std::reverse_iterator<Iter>::base",
            "path": "en.cppreference.com/w/cpp/iterator/reverse_iterator/base.html",
            "wgPageName": "cpp/iterator/reverse_iterator/base",
            "sample_declaration": "iterator_type base() const;",
            "other_declarations": 1
        },
        {
            "title": "std::iter_move(std::reverse_iterator)",
            "path": "en.cppreference.com/w/cpp/iterator/reverse_iterator/iter_move.html",
            "wgPageName": "cpp/iterator/reverse_iterator/iter_move",
            "sample_declaration": "friend constexpr std::iter_rvalue_reference_t<\n    Iter>\niter_move(const std::reverse_iterator&\n              i) noexcept(/* see below */);"
        },
        {
            "title": "std::iter_swap(std::reverse_iterator)",
            "path": "en.cppreference.com/w/cpp/iterator/reverse_iterator/iter_swap.html",
            "wgPageName": "cpp/iterator/reverse_iterator/iter_swap",
            "sample_declaration": "template<std::indirectly_swappable<Iter> Iter2>\nfriend constexpr void iter_swap(\n    const reverse_iterator& x,\n    const std::reverse_iterator<Iter2>&\n        y) noexcept(/*see below*/);"
        },
        {
            "title": "std::reverse_iterator<Iter>::operator++,+,+=,--,-,-=",
            "path": "en.cppreference.com/w/cpp/iterator/reverse_iterator/operator_arith.html",
            "wgPageName": "cpp/iterator/reverse_iterator/operator_arith",
            "sample_declaration": "reverse_iterator& operator++();",
            "other_declarations": 15
        },
        {
            "title": "std::reverse_iterator<Iter>::operator[]",
            "path": "en.cppreference.com/w/cpp/iterator/reverse_iterator/operator_at.html",
            "wgPageName": "cpp/iterator/reverse_iterator/operator_at",
            "sample_declaration": "/*unspecified*/ operator[](\n    difference_type n) const;",
            "other_declarations": 1
        },
        {
            "title": "operator==,!=,<,<=,>,>=,<=>(std::reverse_iterator)",
            "path": "en.cppreference.com/w/cpp/iterator/reverse_iterator/operator_cmp.html",
            "wgPageName": "cpp/iterator/reverse_iterator/operator_cmp",
            "sample_declaration": "template<class Iterator1, class Iterator2>\nbool operator==(\n    const std::reverse_iterator<Iterator1>& lhs,\n    const std::reverse_iterator<Iterator2>&\n        rhs);",
            "other_declarations": 12
        },
        {
            "title": "operator-(std::reverse_iterator)",
            "path": "en.cppreference.com/w/cpp/iterator/reverse_iterator/operator-.html",
            "wgPageName": "cpp/iterator/reverse_iterator/operator-",
            "sample_declaration": "template<class Iterator>\ntypename reverse_iterator<\n    Iterator>::difference_type\noperator-(\n    const reverse_iterator<Iterator>& lhs,\n    const reverse_iterator<Iterator>& rhs);",
            "other_declarations": 2
        },
        {
            "title": "std::reverse_iterator<Iter>::operator*,->",
            "path": "en.cppreference.com/w/cpp/iterator/reverse_iterator/operator*.html",
            "wgPageName": "cpp/iterator/reverse_iterator/operator*",
            "sample_declaration": "reference operator*() const;",
            "other_declarations": 4
        },
        {
            "title": "operator+(std::reverse_iterator)",
            "path": "en.cppreference.com/w/cpp/iterator/reverse_iterator/operator+.html",
            "wgPageName": "cpp/iterator/reverse_iterator/operator+",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class Iter>\nreverse_iterator<Iter> operator+(\n    typename reverse_iterator<\n        Iter>::difference_type n,\n    const reverse_iterator<Iter>& it);",
            "other_declarations": 1
        },
        {
            "title": "std::reverse_iterator<Iter>::operator=",
            "path": "en.cppreference.com/w/cpp/iterator/reverse_iterator/operator=.html",
            "wgPageName": "cpp/iterator/reverse_iterator/operator=",
            "sample_declaration": "template<class U>\nreverse_iterator& operator=(\n    const reverse_iterator<U>& other);",
            "other_declarations": 1
        },
        {
            "title": "std::reverse_iterator<Iter>::reverse_iterator",
            "path": "en.cppreference.com/w/cpp/iterator/reverse_iterator/reverse_iterator.html",
            "wgPageName": "cpp/iterator/reverse_iterator/reverse_iterator",
            "sample_declaration": "reverse_iterator();",
            "other_declarations": 5
        },
        {
            "title": "std::sentinel_for",
            "path": "en.cppreference.com/w/cpp/iterator/sentinel_for.html",
            "wgPageName": "cpp/iterator/sentinel_for",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class S, class I>\nconcept sentinel_for = std::semiregular<S> &&\n    std::input_or_output_iterator<I> &&\n    __WeaklyEqualityComparableWith<S, I>;"
        },
        {
            "title": "std::size, std::ssize",
            "path": "en.cppreference.com/w/cpp/iterator/size.html",
            "wgPageName": "cpp/iterator/size",
            "headers": [
                "<array>",
                "<deque>",
                "<forward_list>",
                "<iterator>",
                "<list>",
                "<map>",
                "<regex>",
                "<set>",
                "<span>",
                "<string>",
                "<string_view>",
                "<unordered_map>",
                "<unordered_set>",
                "<vector>"
            ],
            "sample_declaration": "template<class C>\nconstexpr auto size(const C& c)\n    -> decltype(c.size());",
            "other_declarations": 3
        },
        {
            "title": "std::sized_sentinel_for, std::disable_sized_sentinel_for",
            "path": "en.cppreference.com/w/cpp/iterator/sized_sentinel_for.html",
            "wgPageName": "cpp/iterator/sized_sentinel_for",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class S, class I>\nconcept sized_sentinel_for =\n    std::sentinel_for<S, I> &&\n    !std::disable_sized_sentinel_for<\n        std::remove_cv_t<S>,\n        std::remove_cv_t<I>> &&\n    requires(const I& i, const S& s) {\n  {\n    s - i\n    }\n    -> std::same_as<std::iter_difference_t<I>>;\n  {\n    i - s\n    }\n    -> std::same_as<std::iter_difference_t<I>>;\n};",
            "other_declarations": 1
        },
        {
            "title": "std::sortable",
            "path": "en.cppreference.com/w/cpp/iterator/sortable.html",
            "wgPageName": "cpp/iterator/sortable",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<\n    class I,\n    class Comp = ranges::less,\n    class Proj = std::identity>\nconcept sortable = std::permutable<I> &&\n    std::indirect_strict_weak_order<\n        Comp,\n        std::projected<I, Proj>>;"
        },
        {
            "title": "std::unreachable_sentinel_t, std::unreachable_sentinel",
            "path": "en.cppreference.com/w/cpp/iterator/unreachable_sentinel_t.html",
            "wgPageName": "cpp/iterator/unreachable_sentinel_t",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "struct unreachable_sentinel_t;",
            "other_declarations": 1
        },
        {
            "title": "std::weakly_incrementable",
            "path": "en.cppreference.com/w/cpp/iterator/weakly_incrementable.html",
            "wgPageName": "cpp/iterator/weakly_incrementable",
            "headers": [
                "<iterator>"
            ],
            "sample_declaration": "template<class I>\nconcept weakly_incrementable =\n    std::movable<I> && requires(I i) {\n  typename std::iter_difference_t<I>;\n  requires /*is-signed-integer-like*/<\n      std::iter_difference_t<I>>;\n  {\n    ++i\n    } -> std::same_as<\n        I&>;  // not required to be\n              // equality-preserving i++; // not\n              // required to be\n              // equality-preserving };"
        },
        {
            "title": "C++ keywords",
            "path": "en.cppreference.com/w/cpp/keyword.html",
            "wgPageName": "cpp/keyword"
        },
        {
            "title": "C++ keywords: alignas (since C++11)",
            "path": "en.cppreference.com/w/cpp/keyword/alignas.html",
            "wgPageName": "cpp/keyword/alignas"
        },
        {
            "title": "C++ keywords: alignof (since C++11)",
            "path": "en.cppreference.com/w/cpp/keyword/alignof.html",
            "wgPageName": "cpp/keyword/alignof"
        },
        {
            "title": "C++ keywords: and_eq",
            "path": "en.cppreference.com/w/cpp/keyword/and_eq.html",
            "wgPageName": "cpp/keyword/and_eq"
        },
        {
            "title": "C++ keywords: and",
            "path": "en.cppreference.com/w/cpp/keyword/and.html",
            "wgPageName": "cpp/keyword/and"
        },
        {
            "title": "C++ keywords: asm",
            "path": "en.cppreference.com/w/cpp/keyword/asm.html",
            "wgPageName": "cpp/keyword/asm"
        },
        {
            "title": "C++ keywords: auto",
            "path": "en.cppreference.com/w/cpp/keyword/auto.html",
            "wgPageName": "cpp/keyword/auto"
        },
        {
            "title": "C++ keywords: bitand",
            "path": "en.cppreference.com/w/cpp/keyword/bitand.html",
            "wgPageName": "cpp/keyword/bitand"
        },
        {
            "title": "C++ keywords: bitor",
            "path": "en.cppreference.com/w/cpp/keyword/bitor.html",
            "wgPageName": "cpp/keyword/bitor"
        },
        {
            "title": "C++ keywords: bool",
            "path": "en.cppreference.com/w/cpp/keyword/bool.html",
            "wgPageName": "cpp/keyword/bool"
        },
        {
            "title": "C++ keywords:  break",
            "path": "en.cppreference.com/w/cpp/keyword/break.html",
            "wgPageName": "cpp/keyword/break"
        },
        {
            "title": "C++ keywords: case",
            "path": "en.cppreference.com/w/cpp/keyword/case.html",
            "wgPageName": "cpp/keyword/case"
        },
        {
            "title": "C++ keywords: catch",
            "path": "en.cppreference.com/w/cpp/keyword/catch.html",
            "wgPageName": "cpp/keyword/catch"
        },
        {
            "title": "C++ keywords: char",
            "path": "en.cppreference.com/w/cpp/keyword/char.html",
            "wgPageName": "cpp/keyword/char"
        },
        {
            "title": "C++ keywords: char16_t (since C++11)",
            "path": "en.cppreference.com/w/cpp/keyword/char16_t.html",
            "wgPageName": "cpp/keyword/char16_t"
        },
        {
            "title": "C++ keywords: char32_t (since C++11)",
            "path": "en.cppreference.com/w/cpp/keyword/char32_t.html",
            "wgPageName": "cpp/keyword/char32_t"
        },
        {
            "title": "C++ keywords: char8_t (since C++20)",
            "path": "en.cppreference.com/w/cpp/keyword/char8_t.html",
            "wgPageName": "cpp/keyword/char8_t"
        },
        {
            "title": "C++ keywords: class",
            "path": "en.cppreference.com/w/cpp/keyword/class.html",
            "wgPageName": "cpp/keyword/class"
        },
        {
            "title": "C++ keywords: co_await (since C++20)",
            "path": "en.cppreference.com/w/cpp/keyword/co_await.html",
            "wgPageName": "cpp/keyword/co_await"
        },
        {
            "title": "C++ keywords: co_return (since C++20)",
            "path": "en.cppreference.com/w/cpp/keyword/co_return.html",
            "wgPageName": "cpp/keyword/co_return"
        },
        {
            "title": "C++ keywords: co_yield (since C++20)",
            "path": "en.cppreference.com/w/cpp/keyword/co_yield.html",
            "wgPageName": "cpp/keyword/co_yield"
        },
        {
            "title": "C++ keywords: compl",
            "path": "en.cppreference.com/w/cpp/keyword/compl.html",
            "wgPageName": "cpp/keyword/compl"
        },
        {
            "title": "C++ keywords: concept (since C++20)",
            "path": "en.cppreference.com/w/cpp/keyword/concept.html",
            "wgPageName": "cpp/keyword/concept"
        },
        {
            "title": "C++ keywords: const_cast",
            "path": "en.cppreference.com/w/cpp/keyword/const_cast.html",
            "wgPageName": "cpp/keyword/const_cast"
        },
        {
            "title": "C++ keywords: const",
            "path": "en.cppreference.com/w/cpp/keyword/const.html",
            "wgPageName": "cpp/keyword/const"
        },
        {
            "title": "C++ keywords: consteval (since C++20)",
            "path": "en.cppreference.com/w/cpp/keyword/consteval.html",
            "wgPageName": "cpp/keyword/consteval"
        },
        {
            "title": "C++ keywords: constexpr (since C++11)",
            "path": "en.cppreference.com/w/cpp/keyword/constexpr.html",
            "wgPageName": "cpp/keyword/constexpr"
        },
        {
            "title": "C++ keywords: constinit (since C++20)",
            "path": "en.cppreference.com/w/cpp/keyword/constinit.html",
            "wgPageName": "cpp/keyword/constinit"
        },
        {
            "title": "C++ keywords: continue",
            "path": "en.cppreference.com/w/cpp/keyword/continue.html",
            "wgPageName": "cpp/keyword/continue"
        },
        {
            "title": "C++ keywords: decltype (since C++11)",
            "path": "en.cppreference.com/w/cpp/keyword/decltype.html",
            "wgPageName": "cpp/keyword/decltype"
        },
        {
            "title": "C++ keywords: default",
            "path": "en.cppreference.com/w/cpp/keyword/default.html",
            "wgPageName": "cpp/keyword/default"
        },
        {
            "title": "C++ keywords: delete",
            "path": "en.cppreference.com/w/cpp/keyword/delete.html",
            "wgPageName": "cpp/keyword/delete"
        },
        {
            "title": "C++ keywords: do",
            "path": "en.cppreference.com/w/cpp/keyword/do.html",
            "wgPageName": "cpp/keyword/do"
        },
        {
            "title": "C++ keywords: double",
            "path": "en.cppreference.com/w/cpp/keyword/double.html",
            "wgPageName": "cpp/keyword/double"
        },
        {
            "title": "C++ keywords: dynamic_cast",
            "path": "en.cppreference.com/w/cpp/keyword/dynamic_cast.html",
            "wgPageName": "cpp/keyword/dynamic_cast"
        },
        {
            "title": "C++ keywords: else",
            "path": "en.cppreference.com/w/cpp/keyword/else.html",
            "wgPageName": "cpp/keyword/else"
        },
        {
            "title": "C++ keywords: enum",
            "path": "en.cppreference.com/w/cpp/keyword/enum.html",
            "wgPageName": "cpp/keyword/enum"
        },
        {
            "title": "C++ keywords: explicit",
            "path": "en.cppreference.com/w/cpp/keyword/explicit.html",
            "wgPageName": "cpp/keyword/explicit"
        },
        {
            "title": "C++ keywords: export",
            "path": "en.cppreference.com/w/cpp/keyword/export.html",
            "wgPageName": "cpp/keyword/export"
        },
        {
            "title": "C++ keywords: extern",
            "path": "en.cppreference.com/w/cpp/keyword/extern.html",
            "wgPageName": "cpp/keyword/extern"
        },
        {
            "title": "C++ keywords: false",
            "path": "en.cppreference.com/w/cpp/keyword/false.html",
            "wgPageName": "cpp/keyword/false"
        },
        {
            "title": "C++ keywords: final (since C++11)",
            "path": "en.cppreference.com/w/cpp/keyword/final.html",
            "wgPageName": "cpp/keyword/final"
        },
        {
            "title": "C++ keywords: float",
            "path": "en.cppreference.com/w/cpp/keyword/float.html",
            "wgPageName": "cpp/keyword/float"
        },
        {
            "title": "C++ keywords: for",
            "path": "en.cppreference.com/w/cpp/keyword/for.html",
            "wgPageName": "cpp/keyword/for"
        },
        {
            "title": "C++ keywords: friend",
            "path": "en.cppreference.com/w/cpp/keyword/friend.html",
            "wgPageName": "cpp/keyword/friend"
        },
        {
            "title": "C++ keywords: goto",
            "path": "en.cppreference.com/w/cpp/keyword/goto.html",
            "wgPageName": "cpp/keyword/goto"
        },
        {
            "title": "C++ keywords: if",
            "path": "en.cppreference.com/w/cpp/keyword/if.html",
            "wgPageName": "cpp/keyword/if"
        },
        {
            "title": "C++ keywords: import (since C++20)",
            "path": "en.cppreference.com/w/cpp/keyword/import.html",
            "wgPageName": "cpp/keyword/import"
        },
        {
            "title": "C++ keywords: inline",
            "path": "en.cppreference.com/w/cpp/keyword/inline.html",
            "wgPageName": "cpp/keyword/inline"
        },
        {
            "title": "C++ keywords: int",
            "path": "en.cppreference.com/w/cpp/keyword/int.html",
            "wgPageName": "cpp/keyword/int"
        },
        {
            "title": "C++ keywords: long",
            "path": "en.cppreference.com/w/cpp/keyword/long.html",
            "wgPageName": "cpp/keyword/long"
        },
        {
            "title": "C++ keywords: module (since C++20)",
            "path": "en.cppreference.com/w/cpp/keyword/module.html",
            "wgPageName": "cpp/keyword/module"
        },
        {
            "title": "C++ keywords: mutable",
            "path": "en.cppreference.com/w/cpp/keyword/mutable.html",
            "wgPageName": "cpp/keyword/mutable"
        },
        {
            "title": "C++ keywords: namespace",
            "path": "en.cppreference.com/w/cpp/keyword/namespace.html",
            "wgPageName": "cpp/keyword/namespace"
        },
        {
            "title": "C++ keywords: new",
            "path": "en.cppreference.com/w/cpp/keyword/new.html",
            "wgPageName": "cpp/keyword/new"
        },
        {
            "title": "C++ keywords: noexcept (since C++11)",
            "path": "en.cppreference.com/w/cpp/keyword/noexcept.html",
            "wgPageName": "cpp/keyword/noexcept"
        },
        {
            "title": "C++ keywords: not_eq",
            "path": "en.cppreference.com/w/cpp/keyword/not_eq.html",
            "wgPageName": "cpp/keyword/not_eq"
        },
        {
            "title": "C++ keywords: not",
            "path": "en.cppreference.com/w/cpp/keyword/not.html",
            "wgPageName": "cpp/keyword/not"
        },
        {
            "title": "C++ keywords: nullptr (since C++11)",
            "path": "en.cppreference.com/w/cpp/keyword/nullptr.html",
            "wgPageName": "cpp/keyword/nullptr"
        },
        {
            "title": "C++ keywords: operator",
            "path": "en.cppreference.com/w/cpp/keyword/operator.html",
            "wgPageName": "cpp/keyword/operator"
        },
        {
            "title": "C++ keywords: or_eq",
            "path": "en.cppreference.com/w/cpp/keyword/or_eq.html",
            "wgPageName": "cpp/keyword/or_eq"
        },
        {
            "title": "C++ keywords: or",
            "path": "en.cppreference.com/w/cpp/keyword/or.html",
            "wgPageName": "cpp/keyword/or"
        },
        {
            "title": "C++ keywords: override (since C++11)",
            "path": "en.cppreference.com/w/cpp/keyword/override.html",
            "wgPageName": "cpp/keyword/override"
        },
        {
            "title": "C++ keywords: private",
            "path": "en.cppreference.com/w/cpp/keyword/private.html",
            "wgPageName": "cpp/keyword/private"
        },
        {
            "title": "C++ keywords: protected",
            "path": "en.cppreference.com/w/cpp/keyword/protected.html",
            "wgPageName": "cpp/keyword/protected"
        },
        {
            "title": "C++ keywords: public",
            "path": "en.cppreference.com/w/cpp/keyword/public.html",
            "wgPageName": "cpp/keyword/public"
        },
        {
            "title": "C++ keywords: reflexpr (reflection TS)",
            "path": "en.cppreference.com/w/cpp/keyword/reflexpr.html",
            "wgPageName": "cpp/keyword/reflexpr"
        },
        {
            "title": "C++ keywords: register",
            "path": "en.cppreference.com/w/cpp/keyword/register.html",
            "wgPageName": "cpp/keyword/register"
        },
        {
            "title": "C++ keywords: reinterpret_cast",
            "path": "en.cppreference.com/w/cpp/keyword/reinterpret_cast.html",
            "wgPageName": "cpp/keyword/reinterpret_cast"
        },
        {
            "title": "C++ keywords: requires (since C++20)",
            "path": "en.cppreference.com/w/cpp/keyword/requires.html",
            "wgPageName": "cpp/keyword/requires"
        },
        {
            "title": "C++ keywords: return",
            "path": "en.cppreference.com/w/cpp/keyword/return.html",
            "wgPageName": "cpp/keyword/return"
        },
        {
            "title": "C++ keywords: short",
            "path": "en.cppreference.com/w/cpp/keyword/short.html",
            "wgPageName": "cpp/keyword/short"
        },
        {
            "title": "C++ keywords: signed",
            "path": "en.cppreference.com/w/cpp/keyword/signed.html",
            "wgPageName": "cpp/keyword/signed"
        },
        {
            "title": "C++ keywords: sizeof",
            "path": "en.cppreference.com/w/cpp/keyword/sizeof.html",
            "wgPageName": "cpp/keyword/sizeof"
        },
        {
            "title": "C++ keywords: static_assert (since C++11)",
            "path": "en.cppreference.com/w/cpp/keyword/static_assert.html",
            "wgPageName": "cpp/keyword/static_assert"
        },
        {
            "title": "C++ keywords: static_cast",
            "path": "en.cppreference.com/w/cpp/keyword/static_cast.html",
            "wgPageName": "cpp/keyword/static_cast"
        },
        {
            "title": "C++ keywords: static",
            "path": "en.cppreference.com/w/cpp/keyword/static.html",
            "wgPageName": "cpp/keyword/static"
        },
        {
            "title": "C++ keywords: struct",
            "path": "en.cppreference.com/w/cpp/keyword/struct.html",
            "wgPageName": "cpp/keyword/struct"
        },
        {
            "title": "C++ keywords: switch",
            "path": "en.cppreference.com/w/cpp/keyword/switch.html",
            "wgPageName": "cpp/keyword/switch"
        },
        {
            "title": "C++ keywords: template",
            "path": "en.cppreference.com/w/cpp/keyword/template.html",
            "wgPageName": "cpp/keyword/template"
        },
        {
            "title": "C++ keywords: this",
            "path": "en.cppreference.com/w/cpp/keyword/this.html",
            "wgPageName": "cpp/keyword/this"
        },
        {
            "title": "C++ keywords: thread_local (since C++11)",
            "path": "en.cppreference.com/w/cpp/keyword/thread_local.html",
            "wgPageName": "cpp/keyword/thread_local"
        },
        {
            "title": "C++ keywords: throw",
            "path": "en.cppreference.com/w/cpp/keyword/throw.html",
            "wgPageName": "cpp/keyword/throw"
        },
        {
            "title": "C++ keywords: true",
            "path": "en.cppreference.com/w/cpp/keyword/true.html",
            "wgPageName": "cpp/keyword/true"
        },
        {
            "title": "C++ keywords: try",
            "path": "en.cppreference.com/w/cpp/keyword/try.html",
            "wgPageName": "cpp/keyword/try"
        },
        {
            "title": "C++ keywords: typedef",
            "path": "en.cppreference.com/w/cpp/keyword/typedef.html",
            "wgPageName": "cpp/keyword/typedef"
        },
        {
            "title": "C++ keywords: typeid",
            "path": "en.cppreference.com/w/cpp/keyword/typeid.html",
            "wgPageName": "cpp/keyword/typeid"
        },
        {
            "title": "C++ keywords: union",
            "path": "en.cppreference.com/w/cpp/keyword/union.html",
            "wgPageName": "cpp/keyword/union"
        },
        {
            "title": "C++ keywords: unsigned",
            "path": "en.cppreference.com/w/cpp/keyword/unsigned.html",
            "wgPageName": "cpp/keyword/unsigned"
        },
        {
            "title": "C++ keywords: using",
            "path": "en.cppreference.com/w/cpp/keyword/using.html",
            "wgPageName": "cpp/keyword/using"
        },
        {
            "title": "C++ keywords: virtual",
            "path": "en.cppreference.com/w/cpp/keyword/virtual.html",
            "wgPageName": "cpp/keyword/virtual"
        },
        {
            "title": "C++ keywords: void",
            "path": "en.cppreference.com/w/cpp/keyword/void.html",
            "wgPageName": "cpp/keyword/void"
        },
        {
            "title": "C++ keywords: volatile",
            "path": "en.cppreference.com/w/cpp/keyword/volatile.html",
            "wgPageName": "cpp/keyword/volatile"
        },
        {
            "title": "C++ keywords: wchar_t",
            "path": "en.cppreference.com/w/cpp/keyword/wchar_t.html",
            "wgPageName": "cpp/keyword/wchar_t"
        },
        {
            "title": "C++ keywords: while",
            "path": "en.cppreference.com/w/cpp/keyword/while.html",
            "wgPageName": "cpp/keyword/while"
        },
        {
            "title": "C++ keywords: xor_eq",
            "path": "en.cppreference.com/w/cpp/keyword/xor_eq.html",
            "wgPageName": "cpp/keyword/xor_eq"
        },
        {
            "title": "C++ keywords: xor",
            "path": "en.cppreference.com/w/cpp/keyword/xor.html",
            "wgPageName": "cpp/keyword/xor"
        },
        {
            "title": "C++ keywords",
            "path": "en.cppreference.com/w/cpp/keywords.html",
            "wgPageName": "cpp/keyword"
        },
        {
            "title": "C++ keywords: if",
            "path": "en.cppreference.com/w/cpp/keywords/if.html",
            "wgPageName": "cpp/keyword/if"
        },
        {
            "title": "C++ keywords: static",
            "path": "en.cppreference.com/w/cpp/keywords/static.html",
            "wgPageName": "cpp/keyword/static"
        },
        {
            "title": "C++ keywords: typename",
            "path": "en.cppreference.com/w/cpp/keywords/typename.html",
            "wgPageName": "cpp/keyword/typename"
        },
        {
            "title": "C++ language",
            "path": "en.cppreference.com/w/cpp/language.html",
            "wgPageName": "cpp/language"
        },
        {
            "title": "Abstract class",
            "path": "en.cppreference.com/w/cpp/language/abstract_class.html",
            "wgPageName": "cpp/language/abstract_class"
        },
        {
            "title": "Access specifiers",
            "path": "en.cppreference.com/w/cpp/language/access.html",
            "wgPageName": "cpp/language/access"
        },
        {
            "title": "Acronyms",
            "path": "en.cppreference.com/w/cpp/language/acronyms.html",
            "wgPageName": "cpp/language/acronyms"
        },
        {
            "title": "Argument-dependent lookup",
            "path": "en.cppreference.com/w/cpp/language/adl.html",
            "wgPageName": "cpp/language/adl"
        },
        {
            "title": "Aggregate initialization",
            "path": "en.cppreference.com/w/cpp/language/aggregate_initialization.html",
            "wgPageName": "cpp/language/aggregate_initialization"
        },
        {
            "title": "alignas specifier (since C++11)",
            "path": "en.cppreference.com/w/cpp/language/alignas.html",
            "wgPageName": "cpp/language/alignas"
        },
        {
            "title": "alignof operator (since C++11)",
            "path": "en.cppreference.com/w/cpp/language/alignof.html",
            "wgPageName": "cpp/language/alignof"
        },
        {
            "title": "Array declaration",
            "path": "en.cppreference.com/w/cpp/language/array.html",
            "wgPageName": "cpp/language/array"
        },
        {
            "title": "The as-if rule",
            "path": "en.cppreference.com/w/cpp/language/as_if.html",
            "wgPageName": "cpp/language/as_if"
        },
        {
            "title": "Copy assignment operator",
            "path": "en.cppreference.com/w/cpp/language/as_operator.html",
            "wgPageName": "cpp/language/copy_assignment"
        },
        {
            "title": "ASCII Chart",
            "path": "en.cppreference.com/w/cpp/language/ascii.html",
            "wgPageName": "cpp/language/ascii"
        },
        {
            "title": "asm declaration",
            "path": "en.cppreference.com/w/cpp/language/asm.html",
            "wgPageName": "cpp/language/asm"
        },
        {
            "title": "Attribute specifier sequence(since C++11)",
            "path": "en.cppreference.com/w/cpp/language/attributes.html",
            "wgPageName": "cpp/language/attributes"
        },
        {
            "title": "C++ attribute: assume (since C++23)",
            "path": "en.cppreference.com/w/cpp/language/attributes/assume.html",
            "wgPageName": "cpp/language/attributes/assume"
        },
        {
            "title": "C++ attribute: carries_dependency (since C++11)",
            "path": "en.cppreference.com/w/cpp/language/attributes/carries_dependency.html",
            "wgPageName": "cpp/language/attributes/carries_dependency"
        },
        {
            "title": "C++ attribute: deprecated (since C++14)",
            "path": "en.cppreference.com/w/cpp/language/attributes/deprecated.html",
            "wgPageName": "cpp/language/attributes/deprecated"
        },
        {
            "title": "C++ attribute: fallthrough (since C++17)",
            "path": "en.cppreference.com/w/cpp/language/attributes/fallthrough.html",
            "wgPageName": "cpp/language/attributes/fallthrough"
        },
        {
            "title": "C++ attribute: likely, unlikely (since C++20)",
            "path": "en.cppreference.com/w/cpp/language/attributes/likely.html",
            "wgPageName": "cpp/language/attributes/likely"
        },
        {
            "title": "C++ attribute: maybe_unused (since C++17)",
            "path": "en.cppreference.com/w/cpp/language/attributes/maybe_unused.html",
            "wgPageName": "cpp/language/attributes/maybe_unused"
        },
        {
            "title": "C++ attribute: no_unique_address (since C++20)",
            "path": "en.cppreference.com/w/cpp/language/attributes/no_unique_address.html",
            "wgPageName": "cpp/language/attributes/no_unique_address"
        },
        {
            "title": "C++ attribute: nodiscard (since C++17)",
            "path": "en.cppreference.com/w/cpp/language/attributes/nodiscard.html",
            "wgPageName": "cpp/language/attributes/nodiscard"
        },
        {
            "title": "C++ attribute: noreturn (since C++11)",
            "path": "en.cppreference.com/w/cpp/language/attributes/noreturn.html",
            "wgPageName": "cpp/language/attributes/noreturn"
        },
        {
            "title": "C++ attribute: optimize_for_synchronized (TM TS)",
            "path": "en.cppreference.com/w/cpp/language/attributes/optimize_for_synchronized.html",
            "wgPageName": "cpp/language/attributes/optimize_for_synchronized"
        },
        {
            "title": "Placeholder type specifiers (since C++11)",
            "path": "en.cppreference.com/w/cpp/language/auto.html",
            "wgPageName": "cpp/language/auto"
        },
        {
            "title": "Basic concepts",
            "path": "en.cppreference.com/w/cpp/language/basic_concepts.html",
            "wgPageName": "cpp/language/basic_concepts"
        },
        {
            "title": "Bit-field",
            "path": "en.cppreference.com/w/cpp/language/bit_field.html",
            "wgPageName": "cpp/language/bit_field"
        },
        {
            "title": "Bit-field",
            "path": "en.cppreference.com/w/cpp/language/bitfield.html",
            "wgPageName": "cpp/language/bit_field"
        },
        {
            "title": "Boolean literals",
            "path": "en.cppreference.com/w/cpp/language/bool_literal.html",
            "wgPageName": "cpp/language/bool_literal"
        },
        {
            "title": "break statement",
            "path": "en.cppreference.com/w/cpp/language/break.html",
            "wgPageName": "cpp/language/break"
        },
        {
            "title": "user-defined conversion function",
            "path": "en.cppreference.com/w/cpp/language/cast_operator.html",
            "wgPageName": "cpp/language/cast_operator"
        },
        {
            "title": "Character literal",
            "path": "en.cppreference.com/w/cpp/language/character_literal.html",
            "wgPageName": "cpp/language/character_literal"
        },
        {
            "title": "Character sets and encodings",
            "path": "en.cppreference.com/w/cpp/language/charset.html",
            "wgPageName": "cpp/language/charset"
        },
        {
            "title": "Class template argument deduction (CTAD) (since C++17)",
            "path": "en.cppreference.com/w/cpp/language/class_template_argument_deduction.html",
            "wgPageName": "cpp/language/class_template_argument_deduction"
        },
        {
            "title": "Class template",
            "path": "en.cppreference.com/w/cpp/language/class_template.html",
            "wgPageName": "cpp/language/class_template"
        },
        {
            "title": "Class declaration",
            "path": "en.cppreference.com/w/cpp/language/class.html",
            "wgPageName": "cpp/language/class"
        },
        {
            "title": "Classes",
            "path": "en.cppreference.com/w/cpp/language/classes.html",
            "wgPageName": "cpp/language/classes"
        },
        {
            "title": "const_cast conversion",
            "path": "en.cppreference.com/w/cpp/language/const_cast.html",
            "wgPageName": "cpp/language/const_cast"
        },
        {
            "title": "Constant expressions",
            "path": "en.cppreference.com/w/cpp/language/constant_expression.html",
            "wgPageName": "cpp/language/constant_expression"
        },
        {
            "title": "Constant initialization",
            "path": "en.cppreference.com/w/cpp/language/constant_initialization.html",
            "wgPageName": "cpp/language/constant_initialization"
        },
        {
            "title": "consteval specifier (since C++20)",
            "path": "en.cppreference.com/w/cpp/language/consteval.html",
            "wgPageName": "cpp/language/consteval"
        },
        {
            "title": "constexpr specifier (since C++11)",
            "path": "en.cppreference.com/w/cpp/language/constexpr.html",
            "wgPageName": "cpp/language/constexpr"
        },
        {
            "title": "constinit specifier (since C++20)",
            "path": "en.cppreference.com/w/cpp/language/constinit.html",
            "wgPageName": "cpp/language/constinit"
        },
        {
            "title": "Constraints and concepts (since C++20)",
            "path": "en.cppreference.com/w/cpp/language/constraints.html",
            "wgPageName": "cpp/language/constraints"
        },
        {
            "title": "continue statement",
            "path": "en.cppreference.com/w/cpp/language/continue.html",
            "wgPageName": "cpp/language/continue"
        },
        {
            "title": "Converting constructor",
            "path": "en.cppreference.com/w/cpp/language/converting_constructor.html",
            "wgPageName": "cpp/language/converting_constructor"
        },
        {
            "title": "Copy constructors",
            "path": "en.cppreference.com/w/cpp/language/copy_constructor.html",
            "wgPageName": "cpp/language/copy_constructor"
        },
        {
            "title": "Copy elision",
            "path": "en.cppreference.com/w/cpp/language/copy_elision.html",
            "wgPageName": "cpp/language/copy_elision"
        },
        {
            "title": "Copy initialization",
            "path": "en.cppreference.com/w/cpp/language/copy_initialization.html",
            "wgPageName": "cpp/language/copy_initialization"
        },
        {
            "title": "Coroutines (C++20)",
            "path": "en.cppreference.com/w/cpp/language/coroutines.html",
            "wgPageName": "cpp/language/coroutines"
        },
        {
            "title": "Curiously Recurring Template Pattern",
            "path": "en.cppreference.com/w/cpp/language/crtp.html",
            "wgPageName": "cpp/language/crtp"
        },
        {
            "title": "Class template argument deduction (CTAD) (since C++17)",
            "path": "en.cppreference.com/w/cpp/language/ctad.html",
            "wgPageName": "cpp/language/class_template_argument_deduction"
        },
        {
            "title": "cv (const and volatile) type qualifiers",
            "path": "en.cppreference.com/w/cpp/language/cv.html",
            "wgPageName": "cpp/language/cv"
        },
        {
            "title": "Non-static data members",
            "path": "en.cppreference.com/w/cpp/language/data_members.html",
            "wgPageName": "cpp/language/data_members"
        },
        {
            "title": "Declarations",
            "path": "en.cppreference.com/w/cpp/language/declarations.html",
            "wgPageName": "cpp/language/declarations"
        },
        {
            "title": "decltype specifier",
            "path": "en.cppreference.com/w/cpp/language/decltype.html",
            "wgPageName": "cpp/language/decltype"
        },
        {
            "title": "Class template argument deduction (CTAD) (since C++17)",
            "path": "en.cppreference.com/w/cpp/language/deduction_guide.html",
            "wgPageName": "cpp/language/class_template_argument_deduction"
        },
        {
            "title": "Default arguments",
            "path": "en.cppreference.com/w/cpp/language/default_arguments.html",
            "wgPageName": "cpp/language/default_arguments"
        },
        {
            "title": "Default comparisons (since C++20)",
            "path": "en.cppreference.com/w/cpp/language/default_comparisons.html",
            "wgPageName": "cpp/language/default_comparisons"
        },
        {
            "title": "Default constructors",
            "path": "en.cppreference.com/w/cpp/language/default_constructor.html",
            "wgPageName": "cpp/language/default_constructor"
        },
        {
            "title": "Default initialization",
            "path": "en.cppreference.com/w/cpp/language/default_initialization.html",
            "wgPageName": "cpp/language/default_initialization"
        },
        {
            "title": "Definitions and ODR (One Definition Rule)",
            "path": "en.cppreference.com/w/cpp/language/definition.html",
            "wgPageName": "cpp/language/definition"
        },
        {
            "title": "delete expression",
            "path": "en.cppreference.com/w/cpp/language/delete.html",
            "wgPageName": "cpp/language/delete"
        },
        {
            "title": "Dependent names",
            "path": "en.cppreference.com/w/cpp/language/dependent_name.html",
            "wgPageName": "cpp/language/dependent_name"
        },
        {
            "title": "Derived classes",
            "path": "en.cppreference.com/w/cpp/language/derived_class.html",
            "wgPageName": "cpp/language/derived_class"
        },
        {
            "title": "Destructors",
            "path": "en.cppreference.com/w/cpp/language/destructor.html",
            "wgPageName": "cpp/language/destructor"
        },
        {
            "title": "Direct initialization",
            "path": "en.cppreference.com/w/cpp/language/direct_initialization.html",
            "wgPageName": "cpp/language/direct_initialization"
        },
        {
            "title": "do-while loop",
            "path": "en.cppreference.com/w/cpp/language/do.html",
            "wgPageName": "cpp/language/do"
        },
        {
            "title": "dynamic_cast conversion",
            "path": "en.cppreference.com/w/cpp/language/dynamic_cast.html",
            "wgPageName": "cpp/language/dynamic_cast"
        },
        {
            "title": "Empty base optimization",
            "path": "en.cppreference.com/w/cpp/language/ebo.html",
            "wgPageName": "cpp/language/ebo"
        },
        {
            "title": "Elaborated type specifier",
            "path": "en.cppreference.com/w/cpp/language/elaborated_type_specifier.html",
            "wgPageName": "cpp/language/elaborated_type_specifier"
        },
        {
            "title": "Enumeration declaration",
            "path": "en.cppreference.com/w/cpp/language/enum_class.html",
            "wgPageName": "cpp/language/enum"
        },
        {
            "title": "Enumeration declaration",
            "path": "en.cppreference.com/w/cpp/language/enum.html",
            "wgPageName": "cpp/language/enum"
        },
        {
            "title": "Escape sequences",
            "path": "en.cppreference.com/w/cpp/language/escape.html",
            "wgPageName": "cpp/language/escape"
        },
        {
            "title": "Order of evaluation",
            "path": "en.cppreference.com/w/cpp/language/eval_order.html",
            "wgPageName": "cpp/language/eval_order"
        },
        {
            "title": "Dynamic exception specification (until C++17)",
            "path": "en.cppreference.com/w/cpp/language/except_spec.html",
            "wgPageName": "cpp/language/except_spec"
        },
        {
            "title": "Exceptions",
            "path": "en.cppreference.com/w/cpp/language/exceptions.html",
            "wgPageName": "cpp/language/exceptions"
        },
        {
            "title": "Explicit type conversion",
            "path": "en.cppreference.com/w/cpp/language/explicit_cast.html",
            "wgPageName": "cpp/language/explicit_cast"
        },
        {
            "title": "explicit specifier",
            "path": "en.cppreference.com/w/cpp/language/explicit.html",
            "wgPageName": "cpp/language/explicit"
        },
        {
            "title": "Expressions",
            "path": "en.cppreference.com/w/cpp/language/expressions.html",
            "wgPageName": "cpp/language/expressions"
        },
        {
            "title": "Extending the namespace std",
            "path": "en.cppreference.com/w/cpp/language/extending_std.html",
            "wgPageName": "cpp/language/extending_std"
        },
        {
            "title": "final specifier (since C++11)",
            "path": "en.cppreference.com/w/cpp/language/final.html",
            "wgPageName": "cpp/language/final"
        },
        {
            "title": "Floating-point literal",
            "path": "en.cppreference.com/w/cpp/language/floating_literal.html",
            "wgPageName": "cpp/language/floating_literal"
        },
        {
            "title": "fold expression(since C++17)",
            "path": "en.cppreference.com/w/cpp/language/fold.html",
            "wgPageName": "cpp/language/fold"
        },
        {
            "title": "for loop",
            "path": "en.cppreference.com/w/cpp/language/for.html",
            "wgPageName": "cpp/language/for"
        },
        {
            "title": "Friend declaration",
            "path": "en.cppreference.com/w/cpp/language/friend.html",
            "wgPageName": "cpp/language/friend"
        },
        {
            "title": "Function template",
            "path": "en.cppreference.com/w/cpp/language/function_template.html",
            "wgPageName": "cpp/language/function_template"
        },
        {
            "title": "Function-try-block",
            "path": "en.cppreference.com/w/cpp/language/function-try-block.html",
            "wgPageName": "cpp/language/function-try-block"
        },
        {
            "title": "Function declaration",
            "path": "en.cppreference.com/w/cpp/language/function.html",
            "wgPageName": "cpp/language/function"
        },
        {
            "title": "Functions",
            "path": "en.cppreference.com/w/cpp/language/functions.html",
            "wgPageName": "cpp/language/functions"
        },
        {
            "title": "goto statement",
            "path": "en.cppreference.com/w/cpp/language/goto.html",
            "wgPageName": "cpp/language/goto"
        },
        {
            "title": "History of C++",
            "path": "en.cppreference.com/w/cpp/language/history.html",
            "wgPageName": "cpp/language/history"
        },
        {
            "title": "Identifiers",
            "path": "en.cppreference.com/w/cpp/language/identifiers.html",
            "wgPageName": "cpp/language/identifiers"
        },
        {
            "title": "if statement",
            "path": "en.cppreference.com/w/cpp/language/if.html",
            "wgPageName": "cpp/language/if"
        },
        {
            "title": "Implicit conversions",
            "path": "en.cppreference.com/w/cpp/language/implicit_cast.html",
            "wgPageName": "cpp/language/implicit_conversion"
        },
        {
            "title": "Implicit conversions",
            "path": "en.cppreference.com/w/cpp/language/implicit_conversion.html",
            "wgPageName": "cpp/language/implicit_conversion"
        },
        {
            "title": "Type",
            "path": "en.cppreference.com/w/cpp/language/incomplete_type.html",
            "wgPageName": "cpp/language/type"
        },
        {
            "title": "Initialization",
            "path": "en.cppreference.com/w/cpp/language/initialization.html",
            "wgPageName": "cpp/language/initialization"
        },
        {
            "title": "Constructors and member initializer lists",
            "path": "en.cppreference.com/w/cpp/language/initializer_list.html",
            "wgPageName": "cpp/language/constructor"
        },
        {
            "title": "Injected-class-name",
            "path": "en.cppreference.com/w/cpp/language/injected-class-name.html",
            "wgPageName": "cpp/language/injected-class-name"
        },
        {
            "title": "inline specifier",
            "path": "en.cppreference.com/w/cpp/language/inline.html",
            "wgPageName": "cpp/language/inline"
        },
        {
            "title": "Integer literal",
            "path": "en.cppreference.com/w/cpp/language/integer_literal.html",
            "wgPageName": "cpp/language/integer_literal"
        },
        {
            "title": "Lambda expressions (since C++11)",
            "path": "en.cppreference.com/w/cpp/language/lambda.html",
            "wgPageName": "cpp/language/lambda",
            "sample_declaration": "ret operator()(params) {\n  body\n}",
            "other_declarations": 1
        },
        {
            "title": "Language linkage",
            "path": "en.cppreference.com/w/cpp/language/language_linkage.html",
            "wgPageName": "cpp/language/language_linkage"
        },
        {
            "title": "Lifetime",
            "path": "en.cppreference.com/w/cpp/language/lifetime.html",
            "wgPageName": "cpp/language/lifetime"
        },
        {
            "title": "List-initialization (since C++11)",
            "path": "en.cppreference.com/w/cpp/language/list_initialization.html",
            "wgPageName": "cpp/language/list_initialization"
        },
        {
            "title": "Name lookup",
            "path": "en.cppreference.com/w/cpp/language/lookup.html",
            "wgPageName": "cpp/language/lookup"
        },
        {
            "title": "Main function",
            "path": "en.cppreference.com/w/cpp/language/main_function.html",
            "wgPageName": "cpp/language/main_function"
        },
        {
            "title": "Non-static member functions",
            "path": "en.cppreference.com/w/cpp/language/member_functions.html",
            "wgPageName": "cpp/language/member_functions"
        },
        {
            "title": "Member templates",
            "path": "en.cppreference.com/w/cpp/language/member_template.html",
            "wgPageName": "cpp/language/member_template"
        },
        {
            "title": "Memory model",
            "path": "en.cppreference.com/w/cpp/language/memory_model.html",
            "wgPageName": "cpp/language/memory_model"
        },
        {
            "title": "Modules (since C++20)",
            "path": "en.cppreference.com/w/cpp/language/modules.html",
            "wgPageName": "cpp/language/modules"
        },
        {
            "title": "Move assignment operator",
            "path": "en.cppreference.com/w/cpp/language/move_assignment.html",
            "wgPageName": "cpp/language/move_assignment"
        },
        {
            "title": "Move constructors",
            "path": "en.cppreference.com/w/cpp/language/move_constructor.html",
            "wgPageName": "cpp/language/move_constructor"
        },
        {
            "title": "Move assignment operator",
            "path": "en.cppreference.com/w/cpp/language/move_operator.html",
            "wgPageName": "cpp/language/move_assignment"
        },
        {
            "title": "Identifiers",
            "path": "en.cppreference.com/w/cpp/language/name.html",
            "wgPageName": "cpp/language/identifiers"
        },
        {
            "title": "Namespace aliases",
            "path": "en.cppreference.com/w/cpp/language/namespace_alias.html",
            "wgPageName": "cpp/language/namespace_alias"
        },
        {
            "title": "Namespaces",
            "path": "en.cppreference.com/w/cpp/language/namespace.html",
            "wgPageName": "cpp/language/namespace"
        },
        {
            "title": "No Diagnostic Required",
            "path": "en.cppreference.com/w/cpp/language/ndr.html",
            "wgPageName": "cpp/language/ndr"
        },
        {
            "title": "Nested classes",
            "path": "en.cppreference.com/w/cpp/language/nested_classes.html",
            "wgPageName": "cpp/language/nested_types"
        },
        {
            "title": "Nested classes",
            "path": "en.cppreference.com/w/cpp/language/nested_types.html",
            "wgPageName": "cpp/language/nested_types"
        },
        {
            "title": "new expression",
            "path": "en.cppreference.com/w/cpp/language/new.html",
            "wgPageName": "cpp/language/new"
        },
        {
            "title": "noexcept specifier  (since C++11)",
            "path": "en.cppreference.com/w/cpp/language/noexcept_spec.html",
            "wgPageName": "cpp/language/noexcept_spec"
        },
        {
            "title": "noexcept operator (since C++11)",
            "path": "en.cppreference.com/w/cpp/language/noexcept.html",
            "wgPageName": "cpp/language/noexcept"
        },
        {
            "title": "nullptr, the pointer literal",
            "path": "en.cppreference.com/w/cpp/language/nullptr.html",
            "wgPageName": "cpp/language/nullptr"
        },
        {
            "title": "Object",
            "path": "en.cppreference.com/w/cpp/language/object.html",
            "wgPageName": "cpp/language/object"
        },
        {
            "title": "Object",
            "path": "en.cppreference.com/w/cpp/language/objects.html",
            "wgPageName": "cpp/language/object"
        },
        {
            "title": "Alternative operator representations",
            "path": "en.cppreference.com/w/cpp/language/operator_alternative.html",
            "wgPageName": "cpp/language/operator_alternative"
        },
        {
            "title": "Arithmetic operators",
            "path": "en.cppreference.com/w/cpp/language/operator_arithmetic.html",
            "wgPageName": "cpp/language/operator_arithmetic",
            "sample_declaration": "A operator+(A)",
            "other_declarations": 2
        },
        {
            "title": "Assignment operators",
            "path": "en.cppreference.com/w/cpp/language/operator_assignment.html",
            "wgPageName": "cpp/language/operator_assignment",
            "sample_declaration": "T*& operator=(T*&, T*);",
            "other_declarations": 1
        },
        {
            "title": "Comparison operators",
            "path": "en.cppreference.com/w/cpp/language/operator_comparison.html",
            "wgPageName": "cpp/language/operator_comparison",
            "sample_declaration": "bool operator<(L, R);",
            "other_declarations": 5
        },
        {
            "title": "Increment/decrement operators",
            "path": "en.cppreference.com/w/cpp/language/operator_incdec.html",
            "wgPageName": "cpp/language/operator_incdec",
            "sample_declaration": "A& operator++(A&)",
            "other_declarations": 4
        },
        {
            "title": "Logical operators",
            "path": "en.cppreference.com/w/cpp/language/operator_logical.html",
            "wgPageName": "cpp/language/operator_logical",
            "sample_declaration": "bool operator!(bool)",
            "other_declarations": 2
        },
        {
            "title": "Member access operators",
            "path": "en.cppreference.com/w/cpp/language/operator_member_access.html",
            "wgPageName": "cpp/language/operator_member_access",
            "sample_declaration": "T& operator[](T*, std::ptrdiff_t);",
            "other_declarations": 1
        },
        {
            "title": "Other operators",
            "path": "en.cppreference.com/w/cpp/language/operator_other.html",
            "wgPageName": "cpp/language/operator_other",
            "sample_declaration": "LR operator?: (bool, L, R);",
            "other_declarations": 1
        },
        {
            "title": "C++ Operator Precedence",
            "path": "en.cppreference.com/w/cpp/language/operator_precedence.html",
            "wgPageName": "cpp/language/operator_precedence"
        },
        {
            "title": "operator overloading",
            "path": "en.cppreference.com/w/cpp/language/operators.html",
            "wgPageName": "cpp/language/operators"
        },
        {
            "title": "Overload resolution",
            "path": "en.cppreference.com/w/cpp/language/overload_resolution.html",
            "wgPageName": "cpp/language/overload_resolution"
        },
        {
            "title": "Address of an overloaded function",
            "path": "en.cppreference.com/w/cpp/language/overloaded_address.html",
            "wgPageName": "cpp/language/overloaded_address"
        },
        {
            "title": "override specifier (since C++11)",
            "path": "en.cppreference.com/w/cpp/language/override.html",
            "wgPageName": "cpp/language/override"
        },
        {
            "title": "Parameter pack(since C++11)",
            "path": "en.cppreference.com/w/cpp/language/parameter_pack.html",
            "wgPageName": "cpp/language/parameter_pack"
        },
        {
            "title": "Partial template specialization",
            "path": "en.cppreference.com/w/cpp/language/partial_specialization.html",
            "wgPageName": "cpp/language/partial_specialization"
        },
        {
            "title": "PImpl",
            "path": "en.cppreference.com/w/cpp/language/pimpl.html",
            "wgPageName": "cpp/language/pimpl"
        },
        {
            "title": "Pointer declaration",
            "path": "en.cppreference.com/w/cpp/language/pointer.html",
            "wgPageName": "cpp/language/pointer"
        },
        {
            "title": "Punctuation",
            "path": "en.cppreference.com/w/cpp/language/punctuators.html",
            "wgPageName": "cpp/language/punctuators"
        },
        {
            "title": "Qualified name lookup",
            "path": "en.cppreference.com/w/cpp/language/qualified_lookup.html",
            "wgPageName": "cpp/language/qualified_lookup"
        },
        {
            "title": "RAII",
            "path": "en.cppreference.com/w/cpp/language/raii.html",
            "wgPageName": "cpp/language/raii"
        },
        {
            "title": "Range-based for loop  (since C++11)",
            "path": "en.cppreference.com/w/cpp/language/range-for.html",
            "wgPageName": "cpp/language/range-for"
        },
        {
            "title": "Reference initialization",
            "path": "en.cppreference.com/w/cpp/language/reference_initialization.html",
            "wgPageName": "cpp/language/reference_initialization"
        },
        {
            "title": "Reference declaration",
            "path": "en.cppreference.com/w/cpp/language/reference.html",
            "wgPageName": "cpp/language/reference"
        },
        {
            "title": "reinterpret_cast conversion",
            "path": "en.cppreference.com/w/cpp/language/reinterpret_cast.html",
            "wgPageName": "cpp/language/reinterpret_cast"
        },
        {
            "title": "Requires expression (since C++20)",
            "path": "en.cppreference.com/w/cpp/language/requires.html",
            "wgPageName": "cpp/language/requires"
        },
        {
            "title": "return statement",
            "path": "en.cppreference.com/w/cpp/language/return.html",
            "wgPageName": "cpp/language/return"
        },
        {
            "title": "The rule of three/five/zero",
            "path": "en.cppreference.com/w/cpp/language/rule_of_three.html",
            "wgPageName": "cpp/language/rule_of_three"
        },
        {
            "title": "Scope",
            "path": "en.cppreference.com/w/cpp/language/scope.html",
            "wgPageName": "cpp/language/scope"
        },
        {
            "title": "SFINAE",
            "path": "en.cppreference.com/w/cpp/language/sfinae.html",
            "wgPageName": "cpp/language/sfinae"
        },
        {
            "title": "sizeof... operator (since C++11)",
            "path": "en.cppreference.com/w/cpp/language/sizeof....html",
            "wgPageName": "cpp/language/sizeof..."
        },
        {
            "title": "sizeof operator",
            "path": "en.cppreference.com/w/cpp/language/sizeof.html",
            "wgPageName": "cpp/language/sizeof"
        },
        {
            "title": "Statements",
            "path": "en.cppreference.com/w/cpp/language/statements.html",
            "wgPageName": "cpp/language/statements"
        },
        {
            "title": "static_assert declaration (since C++11)",
            "path": "en.cppreference.com/w/cpp/language/static_assert.html",
            "wgPageName": "cpp/language/static_assert"
        },
        {
            "title": "static_cast conversion",
            "path": "en.cppreference.com/w/cpp/language/static_cast.html",
            "wgPageName": "cpp/language/static_cast"
        },
        {
            "title": "static members",
            "path": "en.cppreference.com/w/cpp/language/static.html",
            "wgPageName": "cpp/language/static"
        },
        {
            "title": "Storage class specifiers",
            "path": "en.cppreference.com/w/cpp/language/storage_duration.html",
            "wgPageName": "cpp/language/storage_duration"
        },
        {
            "title": "String literal",
            "path": "en.cppreference.com/w/cpp/language/string_literal.html",
            "wgPageName": "cpp/language/string_literal"
        },
        {
            "title": "Structured binding declaration (since C++17)",
            "path": "en.cppreference.com/w/cpp/language/structured_binding.html",
            "wgPageName": "cpp/language/structured_binding"
        },
        {
            "title": "switch statement",
            "path": "en.cppreference.com/w/cpp/language/switch.html",
            "wgPageName": "cpp/language/switch"
        },
        {
            "title": "Template argument deduction",
            "path": "en.cppreference.com/w/cpp/language/template_argument_deduction.html",
            "wgPageName": "cpp/language/template_argument_deduction"
        },
        {
            "title": "Template Metaprogramming",
            "path": "en.cppreference.com/w/cpp/language/template_metaprogramming.html",
            "wgPageName": "cpp/language/template_metaprogramming"
        },
        {
            "title": "Template parameters and template arguments",
            "path": "en.cppreference.com/w/cpp/language/template_parameters.html",
            "wgPageName": "cpp/language/template_parameters"
        },
        {
            "title": "Explicit (full) template specialization",
            "path": "en.cppreference.com/w/cpp/language/template_specialization.html",
            "wgPageName": "cpp/language/template_specialization"
        },
        {
            "title": "Templates",
            "path": "en.cppreference.com/w/cpp/language/templates.html",
            "wgPageName": "cpp/language/templates"
        },
        {
            "title": "The this pointer",
            "path": "en.cppreference.com/w/cpp/language/this.html",
            "wgPageName": "cpp/language/this"
        },
        {
            "title": "throw expression",
            "path": "en.cppreference.com/w/cpp/language/throw.html",
            "wgPageName": "cpp/language/throw"
        },
        {
            "title": "Transactional memory",
            "path": "en.cppreference.com/w/cpp/language/transactional_memory.html",
            "wgPageName": "cpp/language/transactional_memory"
        },
        {
            "title": "Phases of translation",
            "path": "en.cppreference.com/w/cpp/language/translation_phases.html",
            "wgPageName": "cpp/language/translation_phases"
        },
        {
            "title": "try-block",
            "path": "en.cppreference.com/w/cpp/language/try_catch.html",
            "wgPageName": "cpp/language/try_catch"
        },
        {
            "title": "Translation-unit-local entities (since C++20)",
            "path": "en.cppreference.com/w/cpp/language/tu_local.html",
            "wgPageName": "cpp/language/tu_local"
        },
        {
            "title": "Type alias, alias template (since C++11)",
            "path": "en.cppreference.com/w/cpp/language/type_alias.html",
            "wgPageName": "cpp/language/type_alias"
        },
        {
            "title": "Type",
            "path": "en.cppreference.com/w/cpp/language/type-id.html",
            "wgPageName": "cpp/language/type"
        },
        {
            "title": "Type",
            "path": "en.cppreference.com/w/cpp/language/type.html",
            "wgPageName": "cpp/language/type"
        },
        {
            "title": "typedef specifier",
            "path": "en.cppreference.com/w/cpp/language/typedef.html",
            "wgPageName": "cpp/language/typedef"
        },
        {
            "title": "typeid operator",
            "path": "en.cppreference.com/w/cpp/language/typeid.html",
            "wgPageName": "cpp/language/typeid"
        },
        {
            "title": "Fundamental types",
            "path": "en.cppreference.com/w/cpp/language/types.html",
            "wgPageName": "cpp/language/types",
            "headers": [
                "<cstddef>"
            ],
            "sample_declaration": "typedef decltype(nullptr) nullptr_t;"
        },
        {
            "title": "Undefined behavior",
            "path": "en.cppreference.com/w/cpp/language/ub.html",
            "wgPageName": "cpp/language/ub"
        },
        {
            "title": "Union declaration",
            "path": "en.cppreference.com/w/cpp/language/union.html",
            "wgPageName": "cpp/language/union"
        },
        {
            "title": "Unqualified name lookup",
            "path": "en.cppreference.com/w/cpp/language/unqualified_lookup.html",
            "wgPageName": "cpp/language/unqualified_lookup"
        },
        {
            "title": "User-defined literals (since C++11)",
            "path": "en.cppreference.com/w/cpp/language/user_literal.html",
            "wgPageName": "cpp/language/user_literal"
        },
        {
            "title": "Using-declaration",
            "path": "en.cppreference.com/w/cpp/language/using_declaration.html",
            "wgPageName": "cpp/language/using_declaration"
        },
        {
            "title": "Value categories",
            "path": "en.cppreference.com/w/cpp/language/value_category.html",
            "wgPageName": "cpp/language/value_category"
        },
        {
            "title": "Value initialization",
            "path": "en.cppreference.com/w/cpp/language/value_initialization.html",
            "wgPageName": "cpp/language/value_initialization"
        },
        {
            "title": "Variable template (since C++14)",
            "path": "en.cppreference.com/w/cpp/language/variable_template.html",
            "wgPageName": "cpp/language/variable_template"
        },
        {
            "title": "Variadic arguments",
            "path": "en.cppreference.com/w/cpp/language/variadic_arguments.html",
            "wgPageName": "cpp/language/variadic_arguments"
        },
        {
            "title": "virtual function specifier",
            "path": "en.cppreference.com/w/cpp/language/virtual.html",
            "wgPageName": "cpp/language/virtual"
        },
        {
            "title": "while loop",
            "path": "en.cppreference.com/w/cpp/language/while.html",
            "wgPageName": "cpp/language/while"
        },
        {
            "title": "Zero-initialization",
            "path": "en.cppreference.com/w/cpp/language/zero_initialization.html",
            "wgPageName": "cpp/language/zero_initialization"
        },
        {
            "title": "Zero-overhead principle",
            "path": "en.cppreference.com/w/cpp/language/Zero-overhead_principle.html",
            "wgPageName": "cpp/language/Zero-overhead_principle"
        },
        {
            "title": "Useful resources",
            "path": "en.cppreference.com/w/cpp/links.html",
            "wgPageName": "cpp/links"
        },
        {
            "title": "A list of open source C++ libraries",
            "path": "en.cppreference.com/w/cpp/links/libs.html",
            "wgPageName": "cpp/links/libs"
        },
        {
            "title": "Localization library",
            "path": "en.cppreference.com/w/cpp/locale.html",
            "wgPageName": "cpp/locale"
        },
        {
            "title": "std::codecvt_base",
            "path": "en.cppreference.com/w/cpp/locale/codecvt_base.html",
            "wgPageName": "cpp/locale/codecvt_base",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "class codecvt_base;"
        },
        {
            "title": "std::codecvt_byname",
            "path": "en.cppreference.com/w/cpp/locale/codecvt_byname.html",
            "wgPageName": "cpp/locale/codecvt_byname",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<\n    class InternT,\n    class ExternT,\n    class State>\nclass codecvt_byname\n    : public std::\n          codecvt<InternT, ExternT, State>;"
        },
        {
            "title": "std::codecvt_mode",
            "path": "en.cppreference.com/w/cpp/locale/codecvt_mode.html",
            "wgPageName": "cpp/locale/codecvt_mode",
            "headers": [
                "<codecvt>"
            ],
            "sample_declaration": "enum codecvt_mode {\n  consume_header = 4,\n  generate_header = 2,\n  little_endian = 1\n};"
        },
        {
            "title": "std::codecvt_utf16",
            "path": "en.cppreference.com/w/cpp/locale/codecvt_utf16.html",
            "wgPageName": "cpp/locale/codecvt_utf16",
            "headers": [
                "<codecvt>"
            ],
            "sample_declaration": "template<\n    class Elem,\n    unsigned long Maxcode = 0x10ffff,\n    std::codecvt_mode Mode =\n        (std::codecvt_mode)0>\nclass codecvt_utf16\n    : public std::\n          codecvt<Elem, char, std::mbstate_t>;"
        },
        {
            "title": "std::codecvt_utf8_utf16",
            "path": "en.cppreference.com/w/cpp/locale/codecvt_utf8_utf16.html",
            "wgPageName": "cpp/locale/codecvt_utf8_utf16",
            "headers": [
                "<codecvt>"
            ],
            "sample_declaration": "template<\n    class Elem,\n    unsigned long Maxcode = 0x10ffff,\n    std::codecvt_mode Mode =\n        (std::codecvt_mode)0>\nclass codecvt_utf8_utf16\n    : public std::\n          codecvt<Elem, char, std::mbstate_t>;"
        },
        {
            "title": "std::codecvt_utf8",
            "path": "en.cppreference.com/w/cpp/locale/codecvt_utf8.html",
            "wgPageName": "cpp/locale/codecvt_utf8",
            "headers": [
                "<codecvt>"
            ],
            "sample_declaration": "template<\n    class Elem,\n    unsigned long Maxcode = 0x10ffff,\n    std::codecvt_mode Mode =\n        (std::codecvt_mode)0>\nclass codecvt_utf8\n    : public std::\n          codecvt<Elem, char, std::mbstate_t>;"
        },
        {
            "title": "std::codecvt",
            "path": "en.cppreference.com/w/cpp/locale/codecvt.html",
            "wgPageName": "cpp/locale/codecvt",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<\n    class InternT,\n    class ExternT,\n    class StateT>\nclass codecvt;"
        },
        {
            "title": "std::codecvt<InternT,ExternT,StateT>::~codecvt",
            "path": "en.cppreference.com/w/cpp/locale/codecvt/~codecvt.html",
            "wgPageName": "cpp/locale/codecvt/~codecvt",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "protected:\n~codecvt();"
        },
        {
            "title": "std::codecvt<InternT,ExternT,StateT>::always_noconv, do_always_noconv",
            "path": "en.cppreference.com/w/cpp/locale/codecvt/always_noconv.html",
            "wgPageName": "cpp/locale/codecvt/always_noconv",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nbool always_noconv() const throw();",
            "other_declarations": 3
        },
        {
            "title": "std::codecvt<InternT,ExternT,StateT>::codecvt",
            "path": "en.cppreference.com/w/cpp/locale/codecvt/codecvt.html",
            "wgPageName": "cpp/locale/codecvt/codecvt",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "explicit codecvt(std::size_t refs = 0);"
        },
        {
            "title": "std::codecvt<InternT,ExternT,StateT>::encoding, do_encoding",
            "path": "en.cppreference.com/w/cpp/locale/codecvt/encoding.html",
            "wgPageName": "cpp/locale/codecvt/encoding",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nint encoding() const throw();",
            "other_declarations": 3
        },
        {
            "title": "std::codecvt<InternT,ExternT,StateT>::in, std::codecvt<InternT,ExternT,StateT>::do_in",
            "path": "en.cppreference.com/w/cpp/locale/codecvt/in.html",
            "wgPageName": "cpp/locale/codecvt/in",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nresult in(\n    StateT& state,\n    const ExternT* from,\n    const ExternT* from_end,\n    const ExternT*& from_next,\n    InternT* to,\n    InternT* to_end,\n    InternT*& to_next) const;",
            "other_declarations": 1
        },
        {
            "title": "std::codecvt<InternT,ExternT,StateT>::length, do_length",
            "path": "en.cppreference.com/w/cpp/locale/codecvt/length.html",
            "wgPageName": "cpp/locale/codecvt/length",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nint length(\n    StateT& state,\n    const ExternT* from,\n    const ExternT* from_end,\n    std::size_t max) const;",
            "other_declarations": 1
        },
        {
            "title": "std::codecvt<InternT,ExternT,StateT>::max_length, do_max_length",
            "path": "en.cppreference.com/w/cpp/locale/codecvt/max_length.html",
            "wgPageName": "cpp/locale/codecvt/max_length",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nint max_length() const throw();",
            "other_declarations": 3
        },
        {
            "title": "std::codecvt<InternT,ExternT,StateT>::out, do_out",
            "path": "en.cppreference.com/w/cpp/locale/codecvt/out.html",
            "wgPageName": "cpp/locale/codecvt/out",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nresult out(\n    StateT& state,\n    const InternT* from,\n    const InternT* from_end,\n    const InternT*& from_next,\n    ExternT* to,\n    ExternT* to_end,\n    ExternT*& to_next) const;",
            "other_declarations": 1
        },
        {
            "title": "std::codecvt<InternT,ExternT,StateT>::unshift, do_unshift",
            "path": "en.cppreference.com/w/cpp/locale/codecvt/unshift.html",
            "wgPageName": "cpp/locale/codecvt/unshift",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nresult unshift(\n    StateT& state,\n    ExternT* to,\n    ExternT* to_end,\n    ExternT*& to_next) const;",
            "other_declarations": 1
        },
        {
            "title": "std::collate_byname",
            "path": "en.cppreference.com/w/cpp/locale/collate_byname.html",
            "wgPageName": "cpp/locale/collate_byname",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class CharT>\nclass collate_byname\n    : public std::collate<CharT>;"
        },
        {
            "title": "std::collate",
            "path": "en.cppreference.com/w/cpp/locale/collate.html",
            "wgPageName": "cpp/locale/collate",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class CharT>\nclass collate;"
        },
        {
            "title": "std::collate<CharT>::~collate",
            "path": "en.cppreference.com/w/cpp/locale/collate/~collate.html",
            "wgPageName": "cpp/locale/collate/~collate",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "protected:\n~collate();"
        },
        {
            "title": "std::collate<CharT>::collate",
            "path": "en.cppreference.com/w/cpp/locale/collate/collate.html",
            "wgPageName": "cpp/locale/collate/collate",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "explicit collate(std::size_t refs = 0);"
        },
        {
            "title": "std::collate<CharT>::compare, std::collate<CharT>::do_compare",
            "path": "en.cppreference.com/w/cpp/locale/collate/compare.html",
            "wgPageName": "cpp/locale/collate/compare",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nint compare(\n    const CharT* low1,\n    const CharT* high1,\n    const CharT* low2,\n    const CharT* high2) const;",
            "other_declarations": 1
        },
        {
            "title": "std::collate<CharT>::hash, std::collate<CharT>::do_hash",
            "path": "en.cppreference.com/w/cpp/locale/collate/hash.html",
            "wgPageName": "cpp/locale/collate/hash",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nlong hash(const CharT* beg, const CharT* end)\n    const;",
            "other_declarations": 1
        },
        {
            "title": "std::collate<CharT>::transform, do_transform",
            "path": "en.cppreference.com/w/cpp/locale/collate/transform.html",
            "wgPageName": "cpp/locale/collate/transform",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nstring_type transform(\n    const CharT* low,\n    const CharT* high) const;",
            "other_declarations": 1
        },
        {
            "title": "std::ctype_base",
            "path": "en.cppreference.com/w/cpp/locale/ctype_base.html",
            "wgPageName": "cpp/locale/ctype_base",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "class ctype_base;"
        },
        {
            "title": "std::ctype_byname<char>",
            "path": "en.cppreference.com/w/cpp/locale/ctype_byname_char.html",
            "wgPageName": "cpp/locale/ctype_byname_char",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<>\nclass ctype_byname : public std::ctype<char>;"
        },
        {
            "title": "std::ctype_byname",
            "path": "en.cppreference.com/w/cpp/locale/ctype_byname.html",
            "wgPageName": "cpp/locale/ctype_byname",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class CharT>\nclass ctype_byname : public std::ctype<CharT>;"
        },
        {
            "title": "std::ctype<char>",
            "path": "en.cppreference.com/w/cpp/locale/ctype_char.html",
            "wgPageName": "cpp/locale/ctype_char",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<>\nclass ctype<char>;"
        },
        {
            "title": "std::ctype<char>::~ctype",
            "path": "en.cppreference.com/w/cpp/locale/ctype_char/~ctype.html",
            "wgPageName": "cpp/locale/ctype_char/~ctype",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "protected:\n~ctype();"
        },
        {
            "title": "std::ctype<char>::classic_table",
            "path": "en.cppreference.com/w/cpp/locale/ctype_char/classic_table.html",
            "wgPageName": "cpp/locale/ctype_char/classic_table",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "static const mask* classic_table() throw();",
            "other_declarations": 1
        },
        {
            "title": "std::ctype<char>::ctype",
            "path": "en.cppreference.com/w/cpp/locale/ctype_char/ctype.html",
            "wgPageName": "cpp/locale/ctype_char/ctype",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "explicit ctype(\n    const mask* tbl = 0,\n    bool del = false,\n    std::size_t refs = 0);"
        },
        {
            "title": "std::ctype<char>::is",
            "path": "en.cppreference.com/w/cpp/locale/ctype_char/is.html",
            "wgPageName": "cpp/locale/ctype_char/is",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "bool is(mask m, char c) const;",
            "other_declarations": 1
        },
        {
            "title": "std::ctype<char>::scan_is",
            "path": "en.cppreference.com/w/cpp/locale/ctype_char/scan_is.html",
            "wgPageName": "cpp/locale/ctype_char/scan_is",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "const char* scan_is(\n    mask m,\n    const char* beg,\n    const char* end) const;"
        },
        {
            "title": "std::ctype<char>::scan_not",
            "path": "en.cppreference.com/w/cpp/locale/ctype_char/scan_not.html",
            "wgPageName": "cpp/locale/ctype_char/scan_not",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "const char* scan_not(\n    mask m,\n    const char* beg,\n    const char* end) const;"
        },
        {
            "title": "std::ctype<char>::table",
            "path": "en.cppreference.com/w/cpp/locale/ctype_char/table.html",
            "wgPageName": "cpp/locale/ctype_char/table",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "const mask* table() const throw();",
            "other_declarations": 1
        },
        {
            "title": "std::ctype",
            "path": "en.cppreference.com/w/cpp/locale/ctype.html",
            "wgPageName": "cpp/locale/ctype",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class CharT>\nclass ctype;"
        },
        {
            "title": "std::ctype<CharT>::~ctype",
            "path": "en.cppreference.com/w/cpp/locale/ctype/~ctype.html",
            "wgPageName": "cpp/locale/ctype/~ctype",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "protected:\n~ctype();"
        },
        {
            "title": "std::ctype<CharT>::ctype",
            "path": "en.cppreference.com/w/cpp/locale/ctype/ctype.html",
            "wgPageName": "cpp/locale/ctype/ctype",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "explicit ctype(std::size_t refs = 0);"
        },
        {
            "title": "std::ctype<CharT>::is, std::ctype<CharT>::do_is",
            "path": "en.cppreference.com/w/cpp/locale/ctype/is.html",
            "wgPageName": "cpp/locale/ctype/is",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nbool is(mask m, CharT c) const;",
            "other_declarations": 3
        },
        {
            "title": "std::ctype<CharT>::narrow, do_narrow",
            "path": "en.cppreference.com/w/cpp/locale/ctype/narrow.html",
            "wgPageName": "cpp/locale/ctype/narrow",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nchar narrow(CharT c, char dflt) const;",
            "other_declarations": 3
        },
        {
            "title": "std::ctype<CharT>::scan_is, std::ctype<CharT>::do_scan_is",
            "path": "en.cppreference.com/w/cpp/locale/ctype/scan_is.html",
            "wgPageName": "cpp/locale/ctype/scan_is",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nconst CharT* scan_is(\n    mask m,\n    const CharT* beg,\n    const CharT* end) const;",
            "other_declarations": 1
        },
        {
            "title": "std::ctype<CharT>::scan_not, std::ctype<CharT>::do_scan_not",
            "path": "en.cppreference.com/w/cpp/locale/ctype/scan_not.html",
            "wgPageName": "cpp/locale/ctype/scan_not",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nconst CharT* scan_not(\n    mask m,\n    const CharT* beg,\n    const CharT* end) const;",
            "other_declarations": 1
        },
        {
            "title": "std::ctype<CharT>::tolower, std::ctype<CharT>::do_tolower",
            "path": "en.cppreference.com/w/cpp/locale/ctype/tolower.html",
            "wgPageName": "cpp/locale/ctype/tolower",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nCharT tolower(CharT c) const;",
            "other_declarations": 3
        },
        {
            "title": "std::ctype<CharT>::toupper, std::ctype<CharT>::do_toupper",
            "path": "en.cppreference.com/w/cpp/locale/ctype/toupper.html",
            "wgPageName": "cpp/locale/ctype/toupper",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nCharT toupper(CharT c) const;",
            "other_declarations": 3
        },
        {
            "title": "std::ctype<CharT>::widen, do_widen",
            "path": "en.cppreference.com/w/cpp/locale/ctype/widen.html",
            "wgPageName": "cpp/locale/ctype/widen",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nCharT widen(char c) const;",
            "other_declarations": 3
        },
        {
            "title": "std::has_facet",
            "path": "en.cppreference.com/w/cpp/locale/has_facet.html",
            "wgPageName": "cpp/locale/has_facet",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class Facet>\nbool has_facet(const locale& loc) throw();",
            "other_declarations": 1
        },
        {
            "title": "std::isalnum(std::locale)",
            "path": "en.cppreference.com/w/cpp/locale/isalnum.html",
            "wgPageName": "cpp/locale/isalnum",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class charT>\nbool isalnum(charT ch, const locale& loc);"
        },
        {
            "title": "std::isalpha(std::locale)",
            "path": "en.cppreference.com/w/cpp/locale/isalpha.html",
            "wgPageName": "cpp/locale/isalpha",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class charT>\nbool isalpha(charT ch, const locale& loc);"
        },
        {
            "title": "std::isblank(std::locale)",
            "path": "en.cppreference.com/w/cpp/locale/isblank.html",
            "wgPageName": "cpp/locale/isblank",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class charT>\nbool isblank(charT ch, const locale& loc);"
        },
        {
            "title": "std::iscntrl(std::locale)",
            "path": "en.cppreference.com/w/cpp/locale/iscntrl.html",
            "wgPageName": "cpp/locale/iscntrl",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class charT>\nbool iscntrl(charT ch, const locale& loc);"
        },
        {
            "title": "std::isdigit(std::locale)",
            "path": "en.cppreference.com/w/cpp/locale/isdigit.html",
            "wgPageName": "cpp/locale/isdigit",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class charT>\nbool isdigit(charT ch, const locale& loc);"
        },
        {
            "title": "std::isgraph(std::locale)",
            "path": "en.cppreference.com/w/cpp/locale/isgraph.html",
            "wgPageName": "cpp/locale/isgraph",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class charT>\nbool isgraph(charT ch, const locale& loc);"
        },
        {
            "title": "std::islower(std::locale)",
            "path": "en.cppreference.com/w/cpp/locale/islower.html",
            "wgPageName": "cpp/locale/islower",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class charT>\nbool islower(charT ch, const locale& loc);"
        },
        {
            "title": "std::isprint(std::locale)",
            "path": "en.cppreference.com/w/cpp/locale/isprint.html",
            "wgPageName": "cpp/locale/isprint",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class charT>\nbool isprint(charT ch, const locale& loc);"
        },
        {
            "title": "std::ispunct(std::locale)",
            "path": "en.cppreference.com/w/cpp/locale/ispunct.html",
            "wgPageName": "cpp/locale/ispunct",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class charT>\nbool ispunct(charT ch, const locale& loc);"
        },
        {
            "title": "std::isspace(std::locale)",
            "path": "en.cppreference.com/w/cpp/locale/isspace.html",
            "wgPageName": "cpp/locale/isspace",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class charT>\nbool isspace(charT ch, const locale& loc);"
        },
        {
            "title": "std::isupper(std::locale)",
            "path": "en.cppreference.com/w/cpp/locale/isupper.html",
            "wgPageName": "cpp/locale/isupper",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class charT>\nbool isupper(charT ch, const locale& loc);"
        },
        {
            "title": "std::isxdigit(std::locale)",
            "path": "en.cppreference.com/w/cpp/locale/isxdigit.html",
            "wgPageName": "cpp/locale/isxdigit",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class charT>\nbool isxdigit(charT ch, const locale& loc);"
        },
        {
            "title": "LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY, LC_NUMERIC, LC_TIME",
            "path": "en.cppreference.com/w/cpp/locale/LC_categories.html",
            "wgPageName": "cpp/locale/LC_categories",
            "headers": [
                "<clocale>"
            ],
            "sample_declaration": "#define LC_ALL /*implementation defined*/",
            "other_declarations": 5
        },
        {
            "title": "std::lconv",
            "path": "en.cppreference.com/w/cpp/locale/lconv.html",
            "wgPageName": "cpp/locale/lconv",
            "headers": [
                "<clocale>"
            ],
            "sample_declaration": "struct lconv;"
        },
        {
            "title": "std::locale",
            "path": "en.cppreference.com/w/cpp/locale/locale.html",
            "wgPageName": "cpp/locale/locale",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "class locale;"
        },
        {
            "title": "std::locale::~locale",
            "path": "en.cppreference.com/w/cpp/locale/locale/~locale.html",
            "wgPageName": "cpp/locale/locale/~locale",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "~locale();"
        },
        {
            "title": "std::locale::classic",
            "path": "en.cppreference.com/w/cpp/locale/locale/classic.html",
            "wgPageName": "cpp/locale/locale/classic",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "static const locale& classic();"
        },
        {
            "title": "std::locale::combine",
            "path": "en.cppreference.com/w/cpp/locale/locale/combine.html",
            "wgPageName": "cpp/locale/locale/combine",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class Facet>\nlocale combine(const locale& other) const;"
        },
        {
            "title": "std::locale::facet",
            "path": "en.cppreference.com/w/cpp/locale/locale/facet.html",
            "wgPageName": "cpp/locale/locale/facet",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "class locale::facet;"
        },
        {
            "title": "std::locale::facet::facet",
            "path": "en.cppreference.com/w/cpp/locale/locale/facet/facet.html",
            "wgPageName": "cpp/locale/locale/facet/facet",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "explicit facet(std::size_t refs = 0);",
            "other_declarations": 1
        },
        {
            "title": "std::locale::global",
            "path": "en.cppreference.com/w/cpp/locale/locale/global.html",
            "wgPageName": "cpp/locale/locale/global",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "static locale global(const locale& loc);"
        },
        {
            "title": "std::locale::id",
            "path": "en.cppreference.com/w/cpp/locale/locale/id.html",
            "wgPageName": "cpp/locale/locale/id",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "class locale::id;"
        },
        {
            "title": "std::locale::id::id",
            "path": "en.cppreference.com/w/cpp/locale/locale/id/id.html",
            "wgPageName": "cpp/locale/locale/id/id",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "id();",
            "other_declarations": 1
        },
        {
            "title": "std::locale::locale",
            "path": "en.cppreference.com/w/cpp/locale/locale/locale.html",
            "wgPageName": "cpp/locale/locale/locale",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "locale() throw();",
            "other_declarations": 9
        },
        {
            "title": "std::locale::name",
            "path": "en.cppreference.com/w/cpp/locale/locale/name.html",
            "wgPageName": "cpp/locale/locale/name",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "std::string name() const;"
        },
        {
            "title": "std::locale::operator==, operator!=",
            "path": "en.cppreference.com/w/cpp/locale/locale/operator_cmp.html",
            "wgPageName": "cpp/locale/locale/operator_cmp",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "bool operator==(const locale& other) const;",
            "other_declarations": 1
        },
        {
            "title": "std::locale::operator()",
            "path": "en.cppreference.com/w/cpp/locale/locale/operator().html",
            "wgPageName": "cpp/locale/locale/operator()",
            "sample_declaration": "template<class CharT, class Traits, class Alloc>\nbool operator()(\n    const basic_string<CharT, Traits, Alloc>&\n        s1,\n    const basic_string<CharT, Traits, Alloc>&\n        s2) const;"
        },
        {
            "title": "std::locale::operator=",
            "path": "en.cppreference.com/w/cpp/locale/locale/operator=.html",
            "wgPageName": "cpp/locale/locale/operator=",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "const locale& operator=(\n    const locale& other) throw();",
            "other_declarations": 1
        },
        {
            "title": "std::localeconv",
            "path": "en.cppreference.com/w/cpp/locale/localeconv.html",
            "wgPageName": "cpp/locale/localeconv",
            "headers": [
                "<clocale>"
            ],
            "sample_declaration": "std::lconv* localeconv();"
        },
        {
            "title": "std::messages_base",
            "path": "en.cppreference.com/w/cpp/locale/messages_base.html",
            "wgPageName": "cpp/locale/messages_base",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "class messages_base;"
        },
        {
            "title": "std::messages_byname",
            "path": "en.cppreference.com/w/cpp/locale/messages_byname.html",
            "wgPageName": "cpp/locale/messages_byname",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class CharT>\nclass messages_byname\n    : public std::messages<CharT>;"
        },
        {
            "title": "std::messages",
            "path": "en.cppreference.com/w/cpp/locale/messages.html",
            "wgPageName": "cpp/locale/messages",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class CharT>\nclass messages;"
        },
        {
            "title": "std::messages<CharT>::~messages",
            "path": "en.cppreference.com/w/cpp/locale/messages/~messages.html",
            "wgPageName": "cpp/locale/messages/~messages",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "protected:\n~messages();"
        },
        {
            "title": "std::messages<CharT>::close, std::messages<CharT>::do_close",
            "path": "en.cppreference.com/w/cpp/locale/messages/close.html",
            "wgPageName": "cpp/locale/messages/close",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nvoid close(catalog c) const;",
            "other_declarations": 1
        },
        {
            "title": "std::messages<CharT>::get, std::messages<CharT>::do_get",
            "path": "en.cppreference.com/w/cpp/locale/messages/get.html",
            "wgPageName": "cpp/locale/messages/get",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nstring_type get(\n    catalog cat,\n    int set,\n    int msgid,\n    const string_type& dfault) const;",
            "other_declarations": 1
        },
        {
            "title": "std::messages<CharT>::messages",
            "path": "en.cppreference.com/w/cpp/locale/messages/messages.html",
            "wgPageName": "cpp/locale/messages/messages",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "explicit messages(std::size_t refs = 0);"
        },
        {
            "title": "std::messages<CharT>::open, std::messages<CharT>::do_open",
            "path": "en.cppreference.com/w/cpp/locale/messages/open.html",
            "wgPageName": "cpp/locale/messages/open",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\ncatalog open(\n    const std::basic_string<char>& name,\n    const std::locale& loc) const;",
            "other_declarations": 1
        },
        {
            "title": "std::money_base",
            "path": "en.cppreference.com/w/cpp/locale/money_base.html",
            "wgPageName": "cpp/locale/money_base",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "class money_base;"
        },
        {
            "title": "std::money_get",
            "path": "en.cppreference.com/w/cpp/locale/money_get.html",
            "wgPageName": "cpp/locale/money_get",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class InputIt =\n        std::istreambuf_iterator<CharT> >\nclass money_get;"
        },
        {
            "title": "std::money_get<CharT,InputIt>::~money_get",
            "path": "en.cppreference.com/w/cpp/locale/money_get/~money_get.html",
            "wgPageName": "cpp/locale/money_get/~money_get",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "protected:\n~money_get();"
        },
        {
            "title": "std::money_get<CharT,InputIt>::get, do_get",
            "path": "en.cppreference.com/w/cpp/locale/money_get/get.html",
            "wgPageName": "cpp/locale/money_get/get",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\niter_type get(\n    iter_type beg,\n    iter_type end,\n    bool intl,\n    std::ios_base& str,\n    std::ios_base::iostate& err,\n    long double& units) const;",
            "other_declarations": 3
        },
        {
            "title": "std::money_get<CharT,InputIt>::money_get",
            "path": "en.cppreference.com/w/cpp/locale/money_get/money_get.html",
            "wgPageName": "cpp/locale/money_get/money_get",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "explicit money_get(std::size_t refs = 0);"
        },
        {
            "title": "std::money_put",
            "path": "en.cppreference.com/w/cpp/locale/money_put.html",
            "wgPageName": "cpp/locale/money_put",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class OutputIt =\n        std::ostreambuf_iterator<CharT> >\nclass money_put;"
        },
        {
            "title": "std::money_put<CharT,OutputIt>::~money_put",
            "path": "en.cppreference.com/w/cpp/locale/money_put/~money_put.html",
            "wgPageName": "cpp/locale/money_put/~money_put",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "protected:\n~money_put();"
        },
        {
            "title": "std::money_put<CharT,OutputIt>::money_put",
            "path": "en.cppreference.com/w/cpp/locale/money_put/money_put.html",
            "wgPageName": "cpp/locale/money_put/money_put",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "explicit money_put(std::size_t refs = 0);"
        },
        {
            "title": "std::money_put<CharT,OutputIt>::put, do_put",
            "path": "en.cppreference.com/w/cpp/locale/money_put/put.html",
            "wgPageName": "cpp/locale/money_put/put",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\niter_type put(\n    iter_type out,\n    bool intl,\n    std::ios_base& f,\n    char_type fill,\n    long double quant) const;",
            "other_declarations": 3
        },
        {
            "title": "std::moneypunct_byname",
            "path": "en.cppreference.com/w/cpp/locale/moneypunct_byname.html",
            "wgPageName": "cpp/locale/moneypunct_byname",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class CharT, bool Intl = false>\nclass moneypunct_byname\n    : public std::moneypunct<CharT, Intl>;"
        },
        {
            "title": "std::moneypunct",
            "path": "en.cppreference.com/w/cpp/locale/moneypunct.html",
            "wgPageName": "cpp/locale/moneypunct",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    bool International = false>\nclass moneypunct;"
        },
        {
            "title": "std::moneypunct<CharT,International>::~moneypunct",
            "path": "en.cppreference.com/w/cpp/locale/moneypunct/~moneypunct.html",
            "wgPageName": "cpp/locale/moneypunct/~moneypunct",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "protected:\n~moneypunct();"
        },
        {
            "title": "std::moneypunct<CharT,International>::curr_symbol, do_curr_symbol",
            "path": "en.cppreference.com/w/cpp/locale/moneypunct/curr_symbol.html",
            "wgPageName": "cpp/locale/moneypunct/curr_symbol",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nstring_type curr_symbol() const;",
            "other_declarations": 1
        },
        {
            "title": "std::moneypunct<CharT,International>::decimal_point, do_decimal_point",
            "path": "en.cppreference.com/w/cpp/locale/moneypunct/decimal_point.html",
            "wgPageName": "cpp/locale/moneypunct/decimal_point",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nCharT decimal_point() const;",
            "other_declarations": 1
        },
        {
            "title": "std::moneypunct<CharT,International>::frac_digits, do_frac_digits",
            "path": "en.cppreference.com/w/cpp/locale/moneypunct/frac_digits.html",
            "wgPageName": "cpp/locale/moneypunct/frac_digits",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nint frac_digits() const;",
            "other_declarations": 1
        },
        {
            "title": "std::moneypunct<CharT,International>::grouping, do_grouping",
            "path": "en.cppreference.com/w/cpp/locale/moneypunct/grouping.html",
            "wgPageName": "cpp/locale/moneypunct/grouping",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nstd::string grouping() const;",
            "other_declarations": 1
        },
        {
            "title": "std::moneypunct<CharT,International>::moneypunct",
            "path": "en.cppreference.com/w/cpp/locale/moneypunct/moneypunct.html",
            "wgPageName": "cpp/locale/moneypunct/moneypunct",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "explicit moneypunct(std::size_t refs = 0);"
        },
        {
            "title": "std::moneypunct<CharT,International>::pos_format, do_pos_format, neg_format, do_neg_format",
            "path": "en.cppreference.com/w/cpp/locale/moneypunct/pos_format.html",
            "wgPageName": "cpp/locale/moneypunct/pos_format",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\npattern pos_format() const;",
            "other_declarations": 3
        },
        {
            "title": "std::moneypunct<CharT,International>::positive_sign, do_positive_sign, negative_sign, do_negative_sign",
            "path": "en.cppreference.com/w/cpp/locale/moneypunct/positive_sign.html",
            "wgPageName": "cpp/locale/moneypunct/positive_sign",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nstring_type positive_sign() const;",
            "other_declarations": 3
        },
        {
            "title": "std::moneypunct<CharT,International>::thousands_sep, do_thousands_sep",
            "path": "en.cppreference.com/w/cpp/locale/moneypunct/thousands_sep.html",
            "wgPageName": "cpp/locale/moneypunct/thousands_sep",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nchar_type thousands_sep() const;",
            "other_declarations": 1
        },
        {
            "title": "std::num_get",
            "path": "en.cppreference.com/w/cpp/locale/num_get.html",
            "wgPageName": "cpp/locale/num_get",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class InputIt =\n        std::istreambuf_iterator<CharT> >\nclass num_get;"
        },
        {
            "title": "std::num_get<CharT,InputIt>::~num_get",
            "path": "en.cppreference.com/w/cpp/locale/num_get/~num_get.html",
            "wgPageName": "cpp/locale/num_get/~num_get",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "protected:\n~num_get();"
        },
        {
            "title": "std::num_get<CharT,InputIt>::get, std::num_get<CharT,InputIt>::do_get",
            "path": "en.cppreference.com/w/cpp/locale/num_get/get.html",
            "wgPageName": "cpp/locale/num_get/get",
            "sample_declaration": "public:\niter_type get(\n    iter_type in,\n    iter_type end,\n    std::ios_base& str,\n    std::ios_base::iostate& err,\n    bool& v) const;",
            "other_declarations": 21
        },
        {
            "title": "std::num_get<CharT,InputIt>::num_get",
            "path": "en.cppreference.com/w/cpp/locale/num_get/num_get.html",
            "wgPageName": "cpp/locale/num_get/num_get",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "explicit num_get(std::size_t refs = 0);"
        },
        {
            "title": "std::num_put",
            "path": "en.cppreference.com/w/cpp/locale/num_put.html",
            "wgPageName": "cpp/locale/num_put",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class OutputIt =\n        std::ostreambuf_iterator<CharT> >\nclass num_put;"
        },
        {
            "title": "std::num_put<CharT,OutputIt>::~num_put",
            "path": "en.cppreference.com/w/cpp/locale/num_put/~num_put.html",
            "wgPageName": "cpp/locale/num_put/~num_put",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "protected:\n~num_put();"
        },
        {
            "title": "std::num_put<CharT,OutputIt>::num_put",
            "path": "en.cppreference.com/w/cpp/locale/num_put/num_put.html",
            "wgPageName": "cpp/locale/num_put/num_put",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "explicit num_put(std::size_t refs = 0);"
        },
        {
            "title": "std::num_put<CharT,OutputIt>::put, std::num_put<CharT,OutputIt>::do_put",
            "path": "en.cppreference.com/w/cpp/locale/num_put/put.html",
            "wgPageName": "cpp/locale/num_put/put",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\niter_type put(\n    iter_type out,\n    std::ios_base& str,\n    char_type fill,\n    bool val) const;",
            "other_declarations": 15
        },
        {
            "title": "std::numpunct_byname",
            "path": "en.cppreference.com/w/cpp/locale/numpunct_byname.html",
            "wgPageName": "cpp/locale/numpunct_byname",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class CharT>\nclass numpunct_byname\n    : public std::numpunct<CharT>;"
        },
        {
            "title": "std::numpunct",
            "path": "en.cppreference.com/w/cpp/locale/numpunct.html",
            "wgPageName": "cpp/locale/numpunct",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class CharT>\nclass numpunct;"
        },
        {
            "title": "std::numpunct<CharT>::~numpunct",
            "path": "en.cppreference.com/w/cpp/locale/numpunct/~numpunct.html",
            "wgPageName": "cpp/locale/numpunct/~numpunct",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "protected:\n~numpunct();"
        },
        {
            "title": "std::numpunct<CharT>::decimal_point, do_decimal_point",
            "path": "en.cppreference.com/w/cpp/locale/numpunct/decimal_point.html",
            "wgPageName": "cpp/locale/numpunct/decimal_point",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nchar_type decimal_point() const;",
            "other_declarations": 1
        },
        {
            "title": "std::numpunct<CharT>::grouping, std::numpunct<CharT>::do_grouping",
            "path": "en.cppreference.com/w/cpp/locale/numpunct/grouping.html",
            "wgPageName": "cpp/locale/numpunct/grouping",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nstd::string grouping() const;",
            "other_declarations": 1
        },
        {
            "title": "std::numpunct<CharT>::numpunct",
            "path": "en.cppreference.com/w/cpp/locale/numpunct/numpunct.html",
            "wgPageName": "cpp/locale/numpunct/numpunct",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "explicit numpunct(std::size_t refs = 0);"
        },
        {
            "title": "std::numpunct<CharT>::thousands_sep, do_thousands_sep",
            "path": "en.cppreference.com/w/cpp/locale/numpunct/thousands_sep.html",
            "wgPageName": "cpp/locale/numpunct/thousands_sep",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nchar_type thousands_sep() const;",
            "other_declarations": 1
        },
        {
            "title": "std::numpunct<CharT>::truename, do_truename, falsename, do_falsename",
            "path": "en.cppreference.com/w/cpp/locale/numpunct/truefalsename.html",
            "wgPageName": "cpp/locale/numpunct/truefalsename",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\nstring_type truename() const;",
            "other_declarations": 3
        },
        {
            "title": "std::setlocale",
            "path": "en.cppreference.com/w/cpp/locale/setlocale.html",
            "wgPageName": "cpp/locale/setlocale",
            "headers": [
                "<clocale>"
            ],
            "sample_declaration": "char* setlocale(\n    int category,\n    const char* locale);"
        },
        {
            "title": "std::time_base",
            "path": "en.cppreference.com/w/cpp/locale/time_base.html",
            "wgPageName": "cpp/locale/time_base",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "class time_base;"
        },
        {
            "title": "std::time_get_byname",
            "path": "en.cppreference.com/w/cpp/locale/time_get_byname.html",
            "wgPageName": "cpp/locale/time_get_byname",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class InputIt =\n        std::istreambuf_iterator<CharT> >\nclass time_get_byname\n    : public std::time_get<CharT, InputIt>"
        },
        {
            "title": "std::time_get",
            "path": "en.cppreference.com/w/cpp/locale/time_get.html",
            "wgPageName": "cpp/locale/time_get",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class InputIt =\n        std::istreambuf_iterator<CharT> >\nclass time_get;"
        },
        {
            "title": "std::time_get<CharT,InputIt>::~time_get",
            "path": "en.cppreference.com/w/cpp/locale/time_get/~time_get.html",
            "wgPageName": "cpp/locale/time_get/~time_get",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "protected:\n~time_get();"
        },
        {
            "title": "std::time_get<CharT,InputIt>::date_order, std::time_get<CharT,InputIt>::do_date_order",
            "path": "en.cppreference.com/w/cpp/locale/time_get/date_order.html",
            "wgPageName": "cpp/locale/time_get/date_order",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\ndateorder date_order() const;",
            "other_declarations": 1
        },
        {
            "title": "std::time_get<CharT,InputIt>::get_date, std::time_get<CharT,InputIt>::do_get_date",
            "path": "en.cppreference.com/w/cpp/locale/time_get/get_date.html",
            "wgPageName": "cpp/locale/time_get/get_date",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\niter_type get_date(\n    iter_type beg,\n    iter_type end,\n    std::ios_base& str,\n    std::ios_base::iostate& err,\n    std::tm* t) const;",
            "other_declarations": 1
        },
        {
            "title": "std::time_get<CharT,InputIt>::get_monthname, std::time_get<CharT,InputIt>::do_get_monthname",
            "path": "en.cppreference.com/w/cpp/locale/time_get/get_monthname.html",
            "wgPageName": "cpp/locale/time_get/get_monthname",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\niter_type get_monthname(\n    iter_type beg,\n    iter_type end,\n    std::ios_base& str,\n    std::ios_base::iostate& err,\n    std::tm* t) const;",
            "other_declarations": 1
        },
        {
            "title": "std::time_get<CharT,InputIt>::get_time, std::time_get<CharT,InputIt>::do_get_time",
            "path": "en.cppreference.com/w/cpp/locale/time_get/get_time.html",
            "wgPageName": "cpp/locale/time_get/get_time",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\niter_type get_time(\n    iter_type beg,\n    iter_type end,\n    std::ios_base& str,\n    std::ios_base::iostate& err,\n    std::tm* t) const;",
            "other_declarations": 1
        },
        {
            "title": "std::time_get<CharT,InputIt>::get_weekday, std::time_get<CharT,InputIt>::do_get_weekday",
            "path": "en.cppreference.com/w/cpp/locale/time_get/get_weekday.html",
            "wgPageName": "cpp/locale/time_get/get_weekday",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\niter_type get_weekday(\n    iter_type beg,\n    iter_type end,\n    std::ios_base& str,\n    std::ios_base::iostate& err,\n    std::tm* t) const;",
            "other_declarations": 1
        },
        {
            "title": "std::time_get<CharT,InputIt>::get_year, std::time_get<CharT,InputIt>::do_get_year",
            "path": "en.cppreference.com/w/cpp/locale/time_get/get_year.html",
            "wgPageName": "cpp/locale/time_get/get_year",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\niter_type get_year(\n    iter_type s,\n    iter_type end,\n    std::ios_base& str,\n    std::ios_base::iostate& err,\n    std::tm* t) const;",
            "other_declarations": 1
        },
        {
            "title": "std::time_get<CharT,InputIt>::get, std::time_get<CharT,InputIt>::do_get",
            "path": "en.cppreference.com/w/cpp/locale/time_get/get.html",
            "wgPageName": "cpp/locale/time_get/get",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\niter_type get(\n    iter_type beg,\n    iter_type end,\n    std::ios_base& str,\n    std::ios_base::iostate& err,\n    std::tm* t,\n    const char_type* fmtbeg,\n    const char_type* fmtend) const;",
            "other_declarations": 1
        },
        {
            "title": "std::time_get<CharT,InputIt>::time_get",
            "path": "en.cppreference.com/w/cpp/locale/time_get/time_get.html",
            "wgPageName": "cpp/locale/time_get/time_get",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "explicit time_get(std::size_t refs = 0);"
        },
        {
            "title": "std::time_put_byname",
            "path": "en.cppreference.com/w/cpp/locale/time_put_byname.html",
            "wgPageName": "cpp/locale/time_put_byname",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class OutputIterator =\n        std::ostreambuf_iterator<CharT> >\nclass time_put_byname\n    : public std::\n          time_put<CharT, OutputIterator>;"
        },
        {
            "title": "std::time_put",
            "path": "en.cppreference.com/w/cpp/locale/time_put.html",
            "wgPageName": "cpp/locale/time_put",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class OutputIt =\n        std::ostreambuf_iterator<CharT> >\nclass time_put;"
        },
        {
            "title": "std::time_put<CharT,OutputIt>::~time_put",
            "path": "en.cppreference.com/w/cpp/locale/time_put/~time_put.html",
            "wgPageName": "cpp/locale/time_put/~time_put",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "protected:\n~time_put();"
        },
        {
            "title": "std::time_put<CharT,OutputIt>::put, std::time_put<CharT,OutputIt>::do_put",
            "path": "en.cppreference.com/w/cpp/locale/time_put/put.html",
            "wgPageName": "cpp/locale/time_put/put",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "public:\niter_type put(\n    iter_type out,\n    std::ios_base& str,\n    char_type fill,\n    const std::tm* t,\n    const CharT* fmtbeg,\n    const CharT* fmtend) const;",
            "other_declarations": 2
        },
        {
            "title": "std::time_put<CharT,OutputIt>::time_put",
            "path": "en.cppreference.com/w/cpp/locale/time_put/time_put.html",
            "wgPageName": "cpp/locale/time_put/time_put",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "explicit time_put(std::size_t refs = 0);"
        },
        {
            "title": "std::tolower(std::locale)",
            "path": "en.cppreference.com/w/cpp/locale/tolower.html",
            "wgPageName": "cpp/locale/tolower",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class charT>\ncharT tolower(charT ch, const locale& loc);"
        },
        {
            "title": "std::toupper(std::locale)",
            "path": "en.cppreference.com/w/cpp/locale/toupper.html",
            "wgPageName": "cpp/locale/toupper",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class charT>\ncharT toupper(charT ch, const locale& loc);"
        },
        {
            "title": "std::use_facet",
            "path": "en.cppreference.com/w/cpp/locale/use_facet.html",
            "wgPageName": "cpp/locale/use_facet",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<class Facet>\nconst Facet& use_facet(const std::locale& loc);"
        },
        {
            "title": "std::wbuffer_convert",
            "path": "en.cppreference.com/w/cpp/locale/wbuffer_convert.html",
            "wgPageName": "cpp/locale/wbuffer_convert",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<\n    class Codecvt,\n    class Elem = wchar_t,\n    class Tr = std::char_traits<Elem> >\nclass wbuffer_convert\n    : public std::basic_streambuf<Elem, Tr>"
        },
        {
            "title": "std::wbuffer_convert<Codecvt,Elem,Tr>::~wbuffer_convert",
            "path": "en.cppreference.com/w/cpp/locale/wbuffer_convert/~wbuffer_convert.html",
            "wgPageName": "cpp/locale/wbuffer_convert/~wbuffer_convert",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "~wbuffer_convert();"
        },
        {
            "title": "std::wbuffer_convert<Codecvt,Elem,Tr>::rdbuf",
            "path": "en.cppreference.com/w/cpp/locale/wbuffer_convert/rdbuf.html",
            "wgPageName": "cpp/locale/wbuffer_convert/rdbuf",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "std::streambuf* rdbuf() const;",
            "other_declarations": 1
        },
        {
            "title": "std::wbuffer_convert<Codecvt,Elem,Tr>::state",
            "path": "en.cppreference.com/w/cpp/locale/wbuffer_convert/state.html",
            "wgPageName": "cpp/locale/wbuffer_convert/state",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "state_type state() const;"
        },
        {
            "title": "std::wbuffer_convert<Codecvt,Elem,Tr>::wbuffer_convert",
            "path": "en.cppreference.com/w/cpp/locale/wbuffer_convert/wbuffer_convert.html",
            "wgPageName": "cpp/locale/wbuffer_convert/wbuffer_convert",
            "sample_declaration": "wbuffer_convert() : wbuffer_convert(nullptr) {}",
            "other_declarations": 2
        },
        {
            "title": "std::wstring_convert",
            "path": "en.cppreference.com/w/cpp/locale/wstring_convert.html",
            "wgPageName": "cpp/locale/wstring_convert",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "template<\n    class Codecvt,\n    class Elem = wchar_t,\n    class Wide_alloc = std::allocator<Elem>,\n    class Byte_alloc = std::allocator<char> >\nclass wstring_convert;"
        },
        {
            "title": "std::wstring_convert<Codecvt,Elem,Wide_alloc,Byte_alloc>::\n~wstring_convert",
            "path": "en.cppreference.com/w/cpp/locale/wstring_convert/~wstring_convert.html",
            "wgPageName": "cpp/locale/wstring_convert/~wstring_convert",
            "sample_declaration": "~wstring_convert();"
        },
        {
            "title": "std::wstring_convert<Codecvt,Elem,Wide_alloc,Byte_alloc>::converted",
            "path": "en.cppreference.com/w/cpp/locale/wstring_convert/converted.html",
            "wgPageName": "cpp/locale/wstring_convert/converted",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "std::size_t converted() const noexcept;"
        },
        {
            "title": "std::wstring_convert<Codecvt,Elem,Wide_alloc,Byte_alloc>::from_bytes",
            "path": "en.cppreference.com/w/cpp/locale/wstring_convert/from_bytes.html",
            "wgPageName": "cpp/locale/wstring_convert/from_bytes",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "wide_string from_bytes(char byte);",
            "other_declarations": 3
        },
        {
            "title": "std::wstring_convert<Codecvt,Elem,Wide_alloc,Byte_alloc>::state",
            "path": "en.cppreference.com/w/cpp/locale/wstring_convert/state.html",
            "wgPageName": "cpp/locale/wstring_convert/state",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "state_type state() const;"
        },
        {
            "title": "std::wstring_convert<Codecvt,Elem,Wide_alloc,Byte_alloc>::to_bytes",
            "path": "en.cppreference.com/w/cpp/locale/wstring_convert/to_bytes.html",
            "wgPageName": "cpp/locale/wstring_convert/to_bytes",
            "headers": [
                "<locale>"
            ],
            "sample_declaration": "byte_string to_bytes(Elem wchar);",
            "other_declarations": 3
        },
        {
            "title": "std::wstring_convert<Codecvt,Elem,Wide_alloc,Byte_alloc>::wstring_convert",
            "path": "en.cppreference.com/w/cpp/locale/wstring_convert/wstring_convert.html",
            "wgPageName": "cpp/locale/wstring_convert/wstring_convert",
            "sample_declaration": "wstring_convert()\n    : wstring_convert(new Codecvt) {}",
            "other_declarations": 4
        },
        {
            "title": "Dynamic memory management",
            "path": "en.cppreference.com/w/cpp/memory.html",
            "wgPageName": "cpp/memory"
        },
        {
            "title": "std::addressof",
            "path": "en.cppreference.com/w/cpp/memory/addressof.html",
            "wgPageName": "cpp/memory/addressof",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T>\nT* addressof(T& arg) noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::align",
            "path": "en.cppreference.com/w/cpp/memory/align.html",
            "wgPageName": "cpp/memory/align",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "void* align(\n    std::size_t alignment,\n    std::size_t size,\n    void*& ptr,\n    std::size_t& space);"
        },
        {
            "title": "std::allocate_at_least",
            "path": "en.cppreference.com/w/cpp/memory/allocate_at_least.html",
            "wgPageName": "cpp/memory/allocate_at_least",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class Alloc>\n[[nodiscard]] constexpr std::allocation_result<\n    typename std::allocator_traits<\n        Alloc>::pointer>\nallocate_at_least(Alloc& a, std::size_t n);"
        },
        {
            "title": "std::allocation_result",
            "path": "en.cppreference.com/w/cpp/memory/allocation_result.html",
            "wgPageName": "cpp/memory/allocation_result",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class Pointer>\nstruct allocation_result {\n  Pointer ptr;\n  std::size_t count;\n};"
        },
        {
            "title": "std::allocator_arg",
            "path": "en.cppreference.com/w/cpp/memory/allocator_arg_t.html",
            "wgPageName": "cpp/memory/allocator_arg",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "struct allocator_arg_t {\n  explicit allocator_arg_t() = default;\n};",
            "other_declarations": 2
        },
        {
            "title": "std::allocator_arg",
            "path": "en.cppreference.com/w/cpp/memory/allocator_arg.html",
            "wgPageName": "cpp/memory/allocator_arg",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "struct allocator_arg_t {\n  explicit allocator_arg_t() = default;\n};",
            "other_declarations": 2
        },
        {
            "title": "std::allocator_traits",
            "path": "en.cppreference.com/w/cpp/memory/allocator_traits.html",
            "wgPageName": "cpp/memory/allocator_traits",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class Alloc>\nstruct allocator_traits;"
        },
        {
            "title": "std::allocator_traits<Alloc>::allocate",
            "path": "en.cppreference.com/w/cpp/memory/allocator_traits/allocate.html",
            "wgPageName": "cpp/memory/allocator_traits/allocate",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "static pointer allocate(Alloc& a, size_type n);",
            "other_declarations": 3
        },
        {
            "title": "std::allocator_traits<Alloc>::construct",
            "path": "en.cppreference.com/w/cpp/memory/allocator_traits/construct.html",
            "wgPageName": "cpp/memory/allocator_traits/construct",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T, class... Args>\nstatic void\nconstruct(Alloc& a, T* p, Args&&... args);",
            "other_declarations": 1
        },
        {
            "title": "std::allocator_traits<Alloc>::deallocate",
            "path": "en.cppreference.com/w/cpp/memory/allocator_traits/deallocate.html",
            "wgPageName": "cpp/memory/allocator_traits/deallocate",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "static void\ndeallocate(Alloc& a, pointer p, size_type n);",
            "other_declarations": 1
        },
        {
            "title": "std::allocator_traits<Alloc>::destroy",
            "path": "en.cppreference.com/w/cpp/memory/allocator_traits/destroy.html",
            "wgPageName": "cpp/memory/allocator_traits/destroy",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T>\nstatic void destroy(Alloc& a, T* p);",
            "other_declarations": 1
        },
        {
            "title": "std::allocator_traits<Alloc>::max_size",
            "path": "en.cppreference.com/w/cpp/memory/allocator_traits/max_size.html",
            "wgPageName": "cpp/memory/allocator_traits/max_size",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "static size_type max_size(\n    const Alloc& a) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::allocator_traits<Alloc>::select_on_container_copy_construction",
            "path": "en.cppreference.com/w/cpp/memory/allocator_traits/select_on_container_copy_construction.html",
            "wgPageName": "cpp/memory/allocator_traits/select_on_container_copy_construction",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "static Alloc\nselect_on_container_copy_construction(\n    const Alloc& a);",
            "other_declarations": 1
        },
        {
            "title": "std::allocator",
            "path": "en.cppreference.com/w/cpp/memory/allocator.html",
            "wgPageName": "cpp/memory/allocator",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T>\nstruct allocator;",
            "other_declarations": 1
        },
        {
            "title": "std::allocator<T>::~allocator",
            "path": "en.cppreference.com/w/cpp/memory/allocator/~allocator.html",
            "wgPageName": "cpp/memory/allocator/~allocator",
            "sample_declaration": "~allocator();",
            "other_declarations": 1
        },
        {
            "title": "std::allocator<T>::address",
            "path": "en.cppreference.com/w/cpp/memory/allocator/address.html",
            "wgPageName": "cpp/memory/allocator/address",
            "sample_declaration": "pointer address(reference x) const;",
            "other_declarations": 3
        },
        {
            "title": "std::allocator<T>::allocate_at_least",
            "path": "en.cppreference.com/w/cpp/memory/allocator/allocate_at_least.html",
            "wgPageName": "cpp/memory/allocator/allocate_at_least",
            "sample_declaration": "[[nodiscard]] constexpr std::allocation_result<\n    T*>\nallocate_at_least(std::size_t n);"
        },
        {
            "title": "std::allocator<T>::allocate",
            "path": "en.cppreference.com/w/cpp/memory/allocator/allocate.html",
            "wgPageName": "cpp/memory/allocator/allocate",
            "sample_declaration": "pointer allocate(\n    size_type n,\n    const void* hint = 0);",
            "other_declarations": 3
        },
        {
            "title": "std::allocator<T>::allocator",
            "path": "en.cppreference.com/w/cpp/memory/allocator/allocator.html",
            "wgPageName": "cpp/memory/allocator/allocator",
            "sample_declaration": "allocator() throw();",
            "other_declarations": 8
        },
        {
            "title": "std::allocator<T>::construct",
            "path": "en.cppreference.com/w/cpp/memory/allocator/construct.html",
            "wgPageName": "cpp/memory/allocator/construct",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "void construct(pointer p, const_reference val);",
            "other_declarations": 1
        },
        {
            "title": "std::allocator<T>::deallocate",
            "path": "en.cppreference.com/w/cpp/memory/allocator/deallocate.html",
            "wgPageName": "cpp/memory/allocator/deallocate",
            "sample_declaration": "void deallocate(T* p, std::size_t n);",
            "other_declarations": 1
        },
        {
            "title": "std::allocator<T>::destroy",
            "path": "en.cppreference.com/w/cpp/memory/allocator/destroy.html",
            "wgPageName": "cpp/memory/allocator/destroy",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "void destroy(pointer p);",
            "other_declarations": 1
        },
        {
            "title": "std::allocator<T>::max_size",
            "path": "en.cppreference.com/w/cpp/memory/allocator/max_size.html",
            "wgPageName": "cpp/memory/allocator/max_size",
            "sample_declaration": "size_type max_size() const throw();",
            "other_declarations": 1
        },
        {
            "title": "operator==,!=(std::allocator)",
            "path": "en.cppreference.com/w/cpp/memory/allocator/operator_cmp.html",
            "wgPageName": "cpp/memory/allocator/operator_cmp",
            "sample_declaration": "template<class T1, class T2>\nbool operator==(\n    const allocator<T1>& lhs,\n    const allocator<T2>& rhs) throw();",
            "other_declarations": 4
        },
        {
            "title": "std::assume_aligned",
            "path": "en.cppreference.com/w/cpp/memory/assume_aligned.html",
            "wgPageName": "cpp/memory/assume_aligned",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<std::size_t N, class T>\n[[nodiscard]] constexpr T* assume_aligned(\n    T* ptr);"
        },
        {
            "title": "std::auto_ptr",
            "path": "en.cppreference.com/w/cpp/memory/auto_ptr.html",
            "wgPageName": "cpp/memory/auto_ptr",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T>\nclass auto_ptr;",
            "other_declarations": 1
        },
        {
            "title": "std::auto_ptr<T>::~auto_ptr",
            "path": "en.cppreference.com/w/cpp/memory/auto_ptr/~auto_ptr.html",
            "wgPageName": "cpp/memory/auto_ptr/~auto_ptr",
            "sample_declaration": "~auto_ptr() throw();"
        },
        {
            "title": "std::auto_ptr<T>::auto_ptr",
            "path": "en.cppreference.com/w/cpp/memory/auto_ptr/auto_ptr.html",
            "wgPageName": "cpp/memory/auto_ptr/auto_ptr",
            "sample_declaration": "explicit auto_ptr(X* p = 0) throw();",
            "other_declarations": 3
        },
        {
            "title": "std::auto_ptr<T>::get",
            "path": "en.cppreference.com/w/cpp/memory/auto_ptr/get.html",
            "wgPageName": "cpp/memory/auto_ptr/get",
            "sample_declaration": "T* get() const throw();"
        },
        {
            "title": "std::auto_ptr<T>::operator auto_ptr<Y>",
            "path": "en.cppreference.com/w/cpp/memory/auto_ptr/operator_auto_ptr.html",
            "wgPageName": "cpp/memory/auto_ptr/operator_auto_ptr",
            "sample_declaration": "template<class Y>\noperator auto_ptr_ref<Y>() throw();",
            "other_declarations": 1
        },
        {
            "title": "std::auto_ptr<T>::operator*, std::auto_ptr<T>::operator->",
            "path": "en.cppreference.com/w/cpp/memory/auto_ptr/operator*.html",
            "wgPageName": "cpp/memory/auto_ptr/operator*",
            "sample_declaration": "T& operator*() const throw();",
            "other_declarations": 1
        },
        {
            "title": "std::auto_ptr<T>::operator=",
            "path": "en.cppreference.com/w/cpp/memory/auto_ptr/operator=.html",
            "wgPageName": "cpp/memory/auto_ptr/operator=",
            "sample_declaration": "auto_ptr& operator=(auto_ptr& r) throw();",
            "other_declarations": 2
        },
        {
            "title": "std::auto_ptr<T>::release",
            "path": "en.cppreference.com/w/cpp/memory/auto_ptr/release.html",
            "wgPageName": "cpp/memory/auto_ptr/release",
            "sample_declaration": "T* release() throw();"
        },
        {
            "title": "std::auto_ptr<T>::reset",
            "path": "en.cppreference.com/w/cpp/memory/auto_ptr/reset.html",
            "wgPageName": "cpp/memory/auto_ptr/reset",
            "sample_declaration": "void reset(T* p = 0) throw();"
        },
        {
            "title": "std::bad_weak_ptr",
            "path": "en.cppreference.com/w/cpp/memory/bad_weak_ptr.html",
            "wgPageName": "cpp/memory/bad_weak_ptr",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "class bad_weak_ptr;"
        },
        {
            "title": "C memory management library",
            "path": "en.cppreference.com/w/cpp/memory/c.html",
            "wgPageName": "cpp/memory/c"
        },
        {
            "title": "std::aligned_alloc",
            "path": "en.cppreference.com/w/cpp/memory/c/aligned_alloc.html",
            "wgPageName": "cpp/memory/c/aligned_alloc",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "void* aligned_alloc(\n    std::size_t alignment,\n    std::size_t size);"
        },
        {
            "title": "std::calloc",
            "path": "en.cppreference.com/w/cpp/memory/c/calloc.html",
            "wgPageName": "cpp/memory/c/calloc",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "void* calloc(std::size_t num, std::size_t size);"
        },
        {
            "title": "std::free",
            "path": "en.cppreference.com/w/cpp/memory/c/free.html",
            "wgPageName": "cpp/memory/c/free",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "void free(void* ptr);"
        },
        {
            "title": "std::malloc",
            "path": "en.cppreference.com/w/cpp/memory/c/malloc.html",
            "wgPageName": "cpp/memory/c/malloc",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "void* malloc(std::size_t size);"
        },
        {
            "title": "std::realloc",
            "path": "en.cppreference.com/w/cpp/memory/c/realloc.html",
            "wgPageName": "cpp/memory/c/realloc",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "void* realloc(void* ptr, std::size_t new_size);"
        },
        {
            "title": "std::construct_at",
            "path": "en.cppreference.com/w/cpp/memory/construct_at.html",
            "wgPageName": "cpp/memory/construct_at",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T, class... Args>\nconstexpr T* construct_at(T* p, Args&&... args);"
        },
        {
            "title": "std::default_delete",
            "path": "en.cppreference.com/w/cpp/memory/default_delete.html",
            "wgPageName": "cpp/memory/default_delete",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T>\nstruct default_delete;",
            "other_declarations": 1
        },
        {
            "title": "std::destroy_at",
            "path": "en.cppreference.com/w/cpp/memory/destroy_at.html",
            "wgPageName": "cpp/memory/destroy_at",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T>\nvoid destroy_at(T* p);",
            "other_declarations": 1
        },
        {
            "title": "std::destroy_n",
            "path": "en.cppreference.com/w/cpp/memory/destroy_n.html",
            "wgPageName": "cpp/memory/destroy_n",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class ForwardIt, class Size>\nForwardIt destroy_n(ForwardIt first, Size n);",
            "other_declarations": 2
        },
        {
            "title": "std::destroy",
            "path": "en.cppreference.com/w/cpp/memory/destroy.html",
            "wgPageName": "cpp/memory/destroy",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class ForwardIt>\nvoid destroy(ForwardIt first, ForwardIt last);",
            "other_declarations": 2
        },
        {
            "title": "std::enable_shared_from_this",
            "path": "en.cppreference.com/w/cpp/memory/enable_shared_from_this.html",
            "wgPageName": "cpp/memory/enable_shared_from_this",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T>\nclass enable_shared_from_this;"
        },
        {
            "title": "std::enable_shared_from_this<T>::~enable_shared_from_this",
            "path": "en.cppreference.com/w/cpp/memory/enable_shared_from_this/~enable_shared_from_this.html",
            "wgPageName": "cpp/memory/enable_shared_from_this/~enable_shared_from_this",
            "sample_declaration": "~enable_shared_from_this();"
        },
        {
            "title": "std::enable_shared_from_this<T>::enable_shared_from_this",
            "path": "en.cppreference.com/w/cpp/memory/enable_shared_from_this/enable_shared_from_this.html",
            "wgPageName": "cpp/memory/enable_shared_from_this/enable_shared_from_this",
            "sample_declaration": "constexpr enable_shared_from_this() noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::enable_shared_from_this<T>::operator=",
            "path": "en.cppreference.com/w/cpp/memory/enable_shared_from_this/operator=.html",
            "wgPageName": "cpp/memory/enable_shared_from_this/operator=",
            "sample_declaration": "enable_shared_from_this<T>& operator=(\n    const enable_shared_from_this<T>&\n        obj) noexcept;"
        },
        {
            "title": "std::enable_shared_from_this<T>::shared_from_this",
            "path": "en.cppreference.com/w/cpp/memory/enable_shared_from_this/shared_from_this.html",
            "wgPageName": "cpp/memory/enable_shared_from_this/shared_from_this",
            "sample_declaration": "std::shared_ptr<T> shared_from_this();",
            "other_declarations": 1
        },
        {
            "title": "std::enable_shared_from_this<T>::weak_from_this",
            "path": "en.cppreference.com/w/cpp/memory/enable_shared_from_this/weak_from_this.html",
            "wgPageName": "cpp/memory/enable_shared_from_this/weak_from_this",
            "sample_declaration": "std::weak_ptr<T> weak_from_this() noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::declare_no_pointers",
            "path": "en.cppreference.com/w/cpp/memory/gc/declare_no_pointers.html",
            "wgPageName": "cpp/memory/gc/declare_no_pointers",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "void declare_no_pointers(\n    char* p,\n    std::size_t n);"
        },
        {
            "title": "std::declare_reachable",
            "path": "en.cppreference.com/w/cpp/memory/gc/declare_reachable.html",
            "wgPageName": "cpp/memory/gc/declare_reachable",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "void declare_reachable(void* p);"
        },
        {
            "title": "std::get_pointer_safety",
            "path": "en.cppreference.com/w/cpp/memory/gc/get_pointer_safety.html",
            "wgPageName": "cpp/memory/gc/get_pointer_safety",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "std::pointer_safety\nget_pointer_safety() noexcept;"
        },
        {
            "title": "std::pointer_safety",
            "path": "en.cppreference.com/w/cpp/memory/gc/pointer_safety.html",
            "wgPageName": "cpp/memory/gc/pointer_safety",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "enum class pointer_safety {\n  relaxed,\n  preferred,\n  strict\n};"
        },
        {
            "title": "std::undeclare_no_pointers",
            "path": "en.cppreference.com/w/cpp/memory/gc/undeclare_no_pointers.html",
            "wgPageName": "cpp/memory/gc/undeclare_no_pointers",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "void undeclare_no_pointers(\n    char* p,\n    std::size_t n);"
        },
        {
            "title": "std::undeclare_reachable",
            "path": "en.cppreference.com/w/cpp/memory/gc/undeclare_reachable.html",
            "wgPageName": "cpp/memory/gc/undeclare_reachable",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T>\nT* undeclare_reachable(T* p);"
        },
        {
            "title": "std::pmr::get_default_resource",
            "path": "en.cppreference.com/w/cpp/memory/get_default_resource.html",
            "wgPageName": "cpp/memory/get_default_resource",
            "headers": [
                "<memory_resource>"
            ],
            "sample_declaration": "std::pmr::memory_resource*\nget_default_resource() noexcept;"
        },
        {
            "title": "std::get_temporary_buffer",
            "path": "en.cppreference.com/w/cpp/memory/get_temporary_buffer.html",
            "wgPageName": "cpp/memory/get_temporary_buffer",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T>\nstd::pair<T*, std::ptrdiff_t>\nget_temporary_buffer(std::ptrdiff_t count);",
            "other_declarations": 1
        },
        {
            "title": "std::inout_ptr_t",
            "path": "en.cppreference.com/w/cpp/memory/inout_ptr_t.html",
            "wgPageName": "cpp/memory/inout_ptr_t",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<\n    class Smart,\n    class Pointer,\n    class... Args>\nclass inout_ptr_t;"
        },
        {
            "title": "std::inout_ptr_t<Smart,Pointer,Args...>::~inout_ptr_t",
            "path": "en.cppreference.com/w/cpp/memory/inout_ptr_t/~inout_ptr_t.html",
            "wgPageName": "cpp/memory/inout_ptr_t/~inout_ptr_t",
            "sample_declaration": "~inout_ptr_t();"
        },
        {
            "title": "std::inout_ptr_t<Smart,Pointer,Args...>::inout_ptr_t",
            "path": "en.cppreference.com/w/cpp/memory/inout_ptr_t/inout_ptr_t.html",
            "wgPageName": "cpp/memory/inout_ptr_t/inout_ptr_t",
            "sample_declaration": "explicit inoout_ptr_t(Smart& sp, Args... args);",
            "other_declarations": 1
        },
        {
            "title": "std::inout_ptr",
            "path": "en.cppreference.com/w/cpp/memory/inout_ptr_t/inout_ptr.html",
            "wgPageName": "cpp/memory/inout_ptr_t/inout_ptr",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<\n    class Pointer = void,\n    class Smart,\n    class... Args>\nauto inout_ptr(Smart& s, Args&&... args);"
        },
        {
            "title": "std::inout_ptr_t<Smart,Pointer,Args...>::operator Pointer*, std::inout_ptr_t<Smart,Pointer,Args...>::operator void**",
            "path": "en.cppreference.com/w/cpp/memory/inout_ptr_t/operator_ptr.html",
            "wgPageName": "cpp/memory/inout_ptr_t/operator_ptr",
            "sample_declaration": "operator Pointer*() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::make_obj_using_allocator",
            "path": "en.cppreference.com/w/cpp/memory/make_obj_using_allocator.html",
            "wgPageName": "cpp/memory/make_obj_using_allocator",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T, class Alloc, class... Args>\nconstexpr T make_obj_using_allocator(\n    const Alloc& alloc,\n    Args&&... args);"
        },
        {
            "title": "std::pmr::memory_resource",
            "path": "en.cppreference.com/w/cpp/memory/memory_resource.html",
            "wgPageName": "cpp/memory/memory_resource",
            "headers": [
                "<memory_resource>"
            ],
            "sample_declaration": "class memory_resource;"
        },
        {
            "title": "std::pmr::memory_resource::allocate",
            "path": "en.cppreference.com/w/cpp/memory/memory_resource/allocate.html",
            "wgPageName": "cpp/memory/memory_resource/allocate",
            "sample_declaration": "void* allocate(\n    std::size_t bytes,\n    std::size_t alignment =\n        alignof(std::max_align_t));",
            "other_declarations": 1
        },
        {
            "title": "std::pmr::memory_resource::deallocate",
            "path": "en.cppreference.com/w/cpp/memory/memory_resource/deallocate.html",
            "wgPageName": "cpp/memory/memory_resource/deallocate",
            "sample_declaration": "void deallocate(\n    void* p,\n    std::size_t bytes,\n    std::size_t alignment =\n        alignof(std::max_align_t));"
        },
        {
            "title": "std::pmr::memory_resource::do_allocate",
            "path": "en.cppreference.com/w/cpp/memory/memory_resource/do_allocate.html",
            "wgPageName": "cpp/memory/memory_resource/do_allocate",
            "sample_declaration": "virtual void* do_allocate(\n    std::size_t bytes,\n    std::size_t alignment) = 0;"
        },
        {
            "title": "std::pmr::memory_resource::do_deallocate",
            "path": "en.cppreference.com/w/cpp/memory/memory_resource/do_deallocate.html",
            "wgPageName": "cpp/memory/memory_resource/do_deallocate",
            "sample_declaration": "virtual void do_deallocate(\n    void* p,\n    std::size_t bytes,\n    std::size_t alignment) = 0;"
        },
        {
            "title": "std::pmr::memory_resource::do_is_equal",
            "path": "en.cppreference.com/w/cpp/memory/memory_resource/do_is_equal.html",
            "wgPageName": "cpp/memory/memory_resource/do_is_equal",
            "sample_declaration": "virtual bool do_is_equal(\n    const std::pmr::memory_resource& other)\n    const noexcept = 0;"
        },
        {
            "title": "std::pmr::memory_resource::is_equal",
            "path": "en.cppreference.com/w/cpp/memory/memory_resource/is_equal.html",
            "wgPageName": "cpp/memory/memory_resource/is_equal",
            "sample_declaration": "bool is_equal(const memory_resource& other)\n    const noexcept;"
        },
        {
            "title": "std::pmr::memory_resource::memory_resource",
            "path": "en.cppreference.com/w/cpp/memory/memory_resource/memory_resource.html",
            "wgPageName": "cpp/memory/memory_resource/memory_resource",
            "sample_declaration": "memory_resource() = default;",
            "other_declarations": 1
        },
        {
            "title": "std::pmr::operator==, std::pmr::operator!=",
            "path": "en.cppreference.com/w/cpp/memory/memory_resource/operator_eq.html",
            "wgPageName": "cpp/memory/memory_resource/operator_eq",
            "headers": [
                "<memory_resource>"
            ],
            "sample_declaration": "bool operator==(\n    const std::pmr::memory_resource& a,\n    const std::pmr::memory_resource&\n        b) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::pmr::monotonic_buffer_resource",
            "path": "en.cppreference.com/w/cpp/memory/monotonic_buffer_resource.html",
            "wgPageName": "cpp/memory/monotonic_buffer_resource",
            "headers": [
                "<memory_resource>"
            ],
            "sample_declaration": "class monotonic_buffer_resource\n    : public std::pmr::memory_resource;"
        },
        {
            "title": "std::pmr::monotonic_buffer_resource::~monotonic_buffer_resource",
            "path": "en.cppreference.com/w/cpp/memory/monotonic_buffer_resource/~monotonic_buffer_resource.html",
            "wgPageName": "cpp/memory/monotonic_buffer_resource/~monotonic_buffer_resource",
            "sample_declaration": "virtual ~monotonic_buffer_resource();"
        },
        {
            "title": "std::pmr::monotonic_buffer_resource::do_allocate",
            "path": "en.cppreference.com/w/cpp/memory/monotonic_buffer_resource/do_allocate.html",
            "wgPageName": "cpp/memory/monotonic_buffer_resource/do_allocate",
            "sample_declaration": "virtual void* do_allocate(\n    std::size_t bytes,\n    std::size_t alignment);"
        },
        {
            "title": "std::pmr::monotonic_buffer_resource::do_deallocate",
            "path": "en.cppreference.com/w/cpp/memory/monotonic_buffer_resource/do_deallocate.html",
            "wgPageName": "cpp/memory/monotonic_buffer_resource/do_deallocate",
            "sample_declaration": "virtual void do_deallocate(\n    void* p,\n    std::size_t bytes,\n    std::size_t alignment);"
        },
        {
            "title": "std::pmr::monotonic_buffer_resource::do_is_equal",
            "path": "en.cppreference.com/w/cpp/memory/monotonic_buffer_resource/do_is_equal.html",
            "wgPageName": "cpp/memory/monotonic_buffer_resource/do_is_equal",
            "sample_declaration": "virtual bool do_is_equal(\n    const std::pmr::memory_resource& other)\n    const noexcept;"
        },
        {
            "title": "std::pmr::monotonic_buffer_resource::monotonic_buffer_resource",
            "path": "en.cppreference.com/w/cpp/memory/monotonic_buffer_resource/monotonic_buffer_resource.html",
            "wgPageName": "cpp/memory/monotonic_buffer_resource/monotonic_buffer_resource",
            "sample_declaration": "monotonic_buffer_resource();",
            "other_declarations": 6
        },
        {
            "title": "std::pmr::monotonic_buffer_resource::release",
            "path": "en.cppreference.com/w/cpp/memory/monotonic_buffer_resource/release.html",
            "wgPageName": "cpp/memory/monotonic_buffer_resource/release",
            "sample_declaration": "void release();"
        },
        {
            "title": "std::pmr::monotonic_buffer_resource::upstream_resource",
            "path": "en.cppreference.com/w/cpp/memory/monotonic_buffer_resource/upstream_resource.html",
            "wgPageName": "cpp/memory/monotonic_buffer_resource/upstream_resource",
            "sample_declaration": "std::pmr::memory_resource* upstream_resource()\n    const;"
        },
        {
            "title": "std::pmr::new_delete_resource",
            "path": "en.cppreference.com/w/cpp/memory/new_delete_resource.html",
            "wgPageName": "cpp/memory/new_delete_resource",
            "headers": [
                "<memory_resource>"
            ],
            "sample_declaration": "std::pmr::memory_resource*\nnew_delete_resource() noexcept;"
        },
        {
            "title": "Low level memory management",
            "path": "en.cppreference.com/w/cpp/memory/new.html",
            "wgPageName": "cpp/memory/new"
        },
        {
            "title": "std::align_val_t",
            "path": "en.cppreference.com/w/cpp/memory/new/align_val_t.html",
            "wgPageName": "cpp/memory/new/align_val_t",
            "headers": [
                "<new>"
            ],
            "sample_declaration": "enum class align_val_t : std::size_t {};"
        },
        {
            "title": "std::bad_alloc",
            "path": "en.cppreference.com/w/cpp/memory/new/bad_alloc.html",
            "wgPageName": "cpp/memory/new/bad_alloc",
            "headers": [
                "<new>"
            ],
            "sample_declaration": "class bad_alloc;"
        },
        {
            "title": "std::bad_array_new_length",
            "path": "en.cppreference.com/w/cpp/memory/new/bad_array_new_length.html",
            "wgPageName": "cpp/memory/new/bad_array_new_length",
            "headers": [
                "<new>"
            ],
            "sample_declaration": "class bad_array_new_length;"
        },
        {
            "title": "std::destroying_delete_t, std::destroying_delete",
            "path": "en.cppreference.com/w/cpp/memory/new/destroying_delete_t.html",
            "wgPageName": "cpp/memory/new/destroying_delete",
            "headers": [
                "<new>"
            ],
            "sample_declaration": "struct destroying_delete_t {\n  explicit destroying_delete_t() = default;\n};",
            "other_declarations": 1
        },
        {
            "title": "std::get_new_handler",
            "path": "en.cppreference.com/w/cpp/memory/new/get_new_handler.html",
            "wgPageName": "cpp/memory/new/get_new_handler",
            "headers": [
                "<new>"
            ],
            "sample_declaration": "std::new_handler get_new_handler() noexcept;"
        },
        {
            "title": "std::new_handler",
            "path": "en.cppreference.com/w/cpp/memory/new/new_handler.html",
            "wgPageName": "cpp/memory/new/new_handler",
            "headers": [
                "<new>"
            ],
            "sample_declaration": "typedef void (*new_handler)();"
        },
        {
            "title": "std::nothrow",
            "path": "en.cppreference.com/w/cpp/memory/new/nothrow_t.html",
            "wgPageName": "cpp/memory/new/nothrow",
            "headers": [
                "<new>"
            ],
            "sample_declaration": "struct nothrow_t {};",
            "other_declarations": 2
        },
        {
            "title": "std::nothrow",
            "path": "en.cppreference.com/w/cpp/memory/new/nothrow.html",
            "wgPageName": "cpp/memory/new/nothrow",
            "headers": [
                "<new>"
            ],
            "sample_declaration": "struct nothrow_t {};",
            "other_declarations": 2
        },
        {
            "title": "operator delete, operator delete[]",
            "path": "en.cppreference.com/w/cpp/memory/new/operator_delete.html",
            "wgPageName": "cpp/memory/new/operator_delete",
            "headers": [
                "<new>"
            ],
            "sample_declaration": "void operator delete(void* ptr) throw();",
            "other_declarations": 35
        },
        {
            "title": "operator new, operator new[]",
            "path": "en.cppreference.com/w/cpp/memory/new/operator_new.html",
            "wgPageName": "cpp/memory/new/operator_new",
            "headers": [
                "<new>"
            ],
            "sample_declaration": "void* operator new(std::size_t count);",
            "other_declarations": 21
        },
        {
            "title": "std::set_new_handler",
            "path": "en.cppreference.com/w/cpp/memory/new/set_new_handler.html",
            "wgPageName": "cpp/memory/new/set_new_handler",
            "headers": [
                "<new>"
            ],
            "sample_declaration": "std::new_handler set_new_handler(\n    std::new_handler new_p) throw();",
            "other_declarations": 1
        },
        {
            "title": "std::pmr::null_memory_resource",
            "path": "en.cppreference.com/w/cpp/memory/null_memory_resource.html",
            "wgPageName": "cpp/memory/null_memory_resource",
            "headers": [
                "<memory_resource>"
            ],
            "sample_declaration": "std::pmr::memory_resource*\nnull_memory_resource() noexcept;"
        },
        {
            "title": "std::out_ptr_t",
            "path": "en.cppreference.com/w/cpp/memory/out_ptr_t.html",
            "wgPageName": "cpp/memory/out_ptr_t",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<\n    class Smart,\n    class Pointer,\n    class... Args>\nclass out_ptr_t;"
        },
        {
            "title": "std::out_ptr_t<Smart,Pointer,Args...>::~out_ptr_t",
            "path": "en.cppreference.com/w/cpp/memory/out_ptr_t/~out_ptr_t.html",
            "wgPageName": "cpp/memory/out_ptr_t/~out_ptr_t",
            "sample_declaration": "~out_ptr_t();"
        },
        {
            "title": "std::out_ptr_t<Smart,Pointer,Args...>::operator Pointer*, std::out_ptr_t<Smart,Pointer,Args...>::operator void**",
            "path": "en.cppreference.com/w/cpp/memory/out_ptr_t/operator_ptr.html",
            "wgPageName": "cpp/memory/out_ptr_t/operator_ptr",
            "sample_declaration": "operator Pointer*() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::out_ptr_t<Smart,Pointer,Args...>::out_ptr_t",
            "path": "en.cppreference.com/w/cpp/memory/out_ptr_t/out_ptr_t.html",
            "wgPageName": "cpp/memory/out_ptr_t/out_ptr_t",
            "sample_declaration": "explicit out_ptr_t(Smart& sp, Args... args);",
            "other_declarations": 1
        },
        {
            "title": "std::out_ptr",
            "path": "en.cppreference.com/w/cpp/memory/out_ptr_t/out_ptr.html",
            "wgPageName": "cpp/memory/out_ptr_t/out_ptr",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<\n    class Pointer = void,\n    class Smart,\n    class... Args>\nauto out_ptr(Smart& s, Args&&... args);"
        },
        {
            "title": "std::owner_less",
            "path": "en.cppreference.com/w/cpp/memory/owner_less_void.html",
            "wgPageName": "cpp/memory/owner_less_void",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<>\nstruct owner_less<void>;"
        },
        {
            "title": "std::owner_less",
            "path": "en.cppreference.com/w/cpp/memory/owner_less.html",
            "wgPageName": "cpp/memory/owner_less",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T>\nstruct owner_less; /* undefined */",
            "other_declarations": 4
        },
        {
            "title": "std::pointer_traits",
            "path": "en.cppreference.com/w/cpp/memory/pointer_traits.html",
            "wgPageName": "cpp/memory/pointer_traits",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class Ptr>\nstruct pointer_traits;",
            "other_declarations": 1
        },
        {
            "title": "std::pointer_traits<Ptr>::pointer_to",
            "path": "en.cppreference.com/w/cpp/memory/pointer_traits/pointer_to.html",
            "wgPageName": "cpp/memory/pointer_traits/pointer_to",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "static pointer pointer_to(element_type& r);",
            "other_declarations": 2
        },
        {
            "title": "std::pointer_traits<Ptr>::to_address",
            "path": "en.cppreference.com/w/cpp/memory/pointer_traits/to_address.html",
            "wgPageName": "cpp/memory/pointer_traits/to_address",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "static element_type* to_address(\n    pointer p) noexcept;"
        },
        {
            "title": "std::pmr::polymorphic_allocator",
            "path": "en.cppreference.com/w/cpp/memory/polymorphic_allocator.html",
            "wgPageName": "cpp/memory/polymorphic_allocator",
            "headers": [
                "<memory_resource>"
            ],
            "sample_declaration": "template<class T>\nclass polymorphic_allocator;",
            "other_declarations": 1
        },
        {
            "title": "std::pmr::polymorphic_allocator<T>::allocate_bytes",
            "path": "en.cppreference.com/w/cpp/memory/polymorphic_allocator/allocate_bytes.html",
            "wgPageName": "cpp/memory/polymorphic_allocator/allocate_bytes",
            "sample_declaration": "[[nodiscard]] void* allocate_bytes(\n    std::size_t nbytes,\n    std::size_t alignment =\n        alignof(std::max_align_t));"
        },
        {
            "title": "std::pmr::polymorphic_allocator<T>::allocate_object",
            "path": "en.cppreference.com/w/cpp/memory/polymorphic_allocator/allocate_object.html",
            "wgPageName": "cpp/memory/polymorphic_allocator/allocate_object",
            "sample_declaration": "template<class U>\n[[nodiscard]] U* allocate_object(\n    std::size_t n = 1);"
        },
        {
            "title": "std::pmr::polymorphic_allocator<T>::allocate",
            "path": "en.cppreference.com/w/cpp/memory/polymorphic_allocator/allocate.html",
            "wgPageName": "cpp/memory/polymorphic_allocator/allocate",
            "sample_declaration": "T* allocate(std::size_t n);",
            "other_declarations": 1
        },
        {
            "title": "std::pmr::polymorphic_allocator<T>::construct",
            "path": "en.cppreference.com/w/cpp/memory/polymorphic_allocator/construct.html",
            "wgPageName": "cpp/memory/polymorphic_allocator/construct",
            "sample_declaration": "template<class U, class... Args>\nvoid construct(U* p, Args&&... args);",
            "other_declarations": 6
        },
        {
            "title": "std::pmr::polymorphic_allocator<T>::deallocate_bytes",
            "path": "en.cppreference.com/w/cpp/memory/polymorphic_allocator/deallocate_bytes.html",
            "wgPageName": "cpp/memory/polymorphic_allocator/deallocate_bytes",
            "sample_declaration": "void deallocate_bytes(\n    void* p,\n    std::size_t nbytes,\n    std::size_t alignment =\n        alignof(std::max_align_t));"
        },
        {
            "title": "std::pmr::polymorphic_allocator<T>::deallocate_object",
            "path": "en.cppreference.com/w/cpp/memory/polymorphic_allocator/deallocate_object.html",
            "wgPageName": "cpp/memory/polymorphic_allocator/deallocate_object",
            "sample_declaration": "template<class U>\nvoid deallocate_object(U* p, std::size_t n = 1);"
        },
        {
            "title": "std::pmr::polymorphic_allocator<T>::deallocate",
            "path": "en.cppreference.com/w/cpp/memory/polymorphic_allocator/deallocate.html",
            "wgPageName": "cpp/memory/polymorphic_allocator/deallocate",
            "sample_declaration": "void deallocate(T* p, std::size_t n);"
        },
        {
            "title": "std::pmr::polymorphic_allocator<T>::delete_object",
            "path": "en.cppreference.com/w/cpp/memory/polymorphic_allocator/delete_object.html",
            "wgPageName": "cpp/memory/polymorphic_allocator/delete_object",
            "sample_declaration": "template<class U>\nvoid delete_object(U* p);"
        },
        {
            "title": "std::pmr::polymorphic_allocator<T>::destroy",
            "path": "en.cppreference.com/w/cpp/memory/polymorphic_allocator/destroy.html",
            "wgPageName": "cpp/memory/polymorphic_allocator/destroy",
            "sample_declaration": "template<class U>\nvoid destroy(U* p);"
        },
        {
            "title": "std::pmr::polymorphic_allocator<T>::new_object",
            "path": "en.cppreference.com/w/cpp/memory/polymorphic_allocator/new_object.html",
            "wgPageName": "cpp/memory/polymorphic_allocator/new_object",
            "sample_declaration": "template<class U, class... CtorArgs>\n[[nodiscard]] U* new_object(\n    CtorArgs&&... ctor_args);"
        },
        {
            "title": "std::pmr::operator==, std::pmr::operator!=",
            "path": "en.cppreference.com/w/cpp/memory/polymorphic_allocator/operator_eq.html",
            "wgPageName": "cpp/memory/polymorphic_allocator/operator_eq",
            "headers": [
                "<memory_resource>"
            ],
            "sample_declaration": "template<class T1, class T2>\nbool operator==(\n    const std::pmr::polymorphic_allocator<T1>&\n        lhs,\n    const std::pmr::polymorphic_allocator<T2>&\n        rhs) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::pmr::polymorphic_allocator<T>::polymorphic_allocator",
            "path": "en.cppreference.com/w/cpp/memory/polymorphic_allocator/polymorphic_allocator.html",
            "wgPageName": "cpp/memory/polymorphic_allocator/polymorphic_allocator",
            "sample_declaration": "polymorphic_allocator() noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::pmr::polymorphic_allocator<T>::resource",
            "path": "en.cppreference.com/w/cpp/memory/polymorphic_allocator/resource.html",
            "wgPageName": "cpp/memory/polymorphic_allocator/resource",
            "sample_declaration": "std::pmr::memory_resource* resource() const;"
        },
        {
            "title": "std::pmr::polymorphic_allocator<T>::\nselect_on_container_copy_construction",
            "path": "en.cppreference.com/w/cpp/memory/polymorphic_allocator/select_on_container_copy_construction.html",
            "wgPageName": "cpp/memory/polymorphic_allocator/select_on_container_copy_construction",
            "sample_declaration": "polymorphic_allocator\nselect_on_container_copy_construction() const;"
        },
        {
            "title": "std::pmr::pool_options",
            "path": "en.cppreference.com/w/cpp/memory/pool_options.html",
            "wgPageName": "cpp/memory/pool_options",
            "headers": [
                "<memory_resource>"
            ],
            "sample_declaration": "struct pool_options;"
        },
        {
            "title": "std::ranges::construct_at",
            "path": "en.cppreference.com/w/cpp/memory/ranges/construct_at.html",
            "wgPageName": "cpp/memory/ranges/construct_at",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T, class... Args>\nconstexpr T* construct_at(T* p, Args&&... args);"
        },
        {
            "title": "std::ranges::destroy_at",
            "path": "en.cppreference.com/w/cpp/memory/ranges/destroy_at.html",
            "wgPageName": "cpp/memory/ranges/destroy_at",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<std::destructible T>\nconstexpr void destroy_at(T* p) noexcept;"
        },
        {
            "title": "std::ranges::destroy_n",
            "path": "en.cppreference.com/w/cpp/memory/ranges/destroy_n.html",
            "wgPageName": "cpp/memory/ranges/destroy_n",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<no - throw -input - iterator I>\nrequires std::destructible<std::iter_value_t<I>>\nconstexpr I destroy_n(\n    I first,\n    std::iter_difference_t<I> n) noexcept;"
        },
        {
            "title": "std::ranges::destroy",
            "path": "en.cppreference.com/w/cpp/memory/ranges/destroy.html",
            "wgPageName": "cpp/memory/ranges/destroy",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<\n    no - throw -input - iterator I,\n    no - throw -sentinel - for < I > S >\nrequires std::destructible<std::iter_value_t<I>>\nconstexpr I destroy(I first, S last) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "no-throw-input-iterator, no-throw-forward-iterator, no-throw-sentinel-for, no-throw-input-range, no-throw-forward-range",
            "path": "en.cppreference.com/w/cpp/memory/ranges/nothrow_concepts.html",
            "wgPageName": "cpp/memory/ranges/nothrow_concepts",
            "sample_declaration": "template<class I>\n    concept no - throw -input -\n    iterator =  // exposition only\n                // std::input_iterator<I> &&\n                // std::is_lvalue_reference_v<std::iter_reference_t<I>>\n                // &&\n                // std::same_as<std::remove_cvref_t<std::iter_reference_t<I>>,\n                // std::iter_value_t<I>>;",
            "other_declarations": 4
        },
        {
            "title": "std::ranges::uninitialized_copy_n, std::ranges::uninitialized_copy_n_result",
            "path": "en.cppreference.com/w/cpp/memory/ranges/uninitialized_copy_n.html",
            "wgPageName": "cpp/memory/ranges/uninitialized_copy_n",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I,\n    no - throw -input - iterator O,\n    no - throw -sentinel - for < O > S >\nrequires std::constructible_from<\n    std::iter_value_t<O>,\n    std::iter_reference_t<I>>\n    uninitialized_copy_n_result<I, O>\n    uninitialized_copy_n(\n        I ifirst,\n        std::iter_difference_t<I> count,\n        O ofirst,\n        S olast);",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::uninitialized_copy, std::ranges::uninitialized_copy_result",
            "path": "en.cppreference.com/w/cpp/memory/ranges/uninitialized_copy.html",
            "wgPageName": "cpp/memory/ranges/uninitialized_copy",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I,\n    std::sentinel_for<I> S1,\n    no - throw -forward - iterator O,\n    no - throw -sentinel - for < O > S2 >\nrequires std::constructible_from<\n    std::iter_value_t<O>,\n    std::iter_reference_t<I>>\n    uninitialized_copy_result<I, O>\n    uninitialized_copy(\n        I ifirst,\n        S1 ilast,\n        O ofirst,\n        S2 olast);",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::uninitialized_default_construct_n",
            "path": "en.cppreference.com/w/cpp/memory/ranges/uninitialized_default_construct_n.html",
            "wgPageName": "cpp/memory/ranges/uninitialized_default_construct_n",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<no - throw -forward - iterator I>\nrequires std::default_initializable<\n    std::iter_value_t<I>>\n    I uninitialized_default_construct_n(\n        I first,\n        std::iter_difference_t<I> n);"
        },
        {
            "title": "std::ranges::uninitialized_default_construct",
            "path": "en.cppreference.com/w/cpp/memory/ranges/uninitialized_default_construct.html",
            "wgPageName": "cpp/memory/ranges/uninitialized_default_construct",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<\n    no - throw -forward - iterator I,\n    no - throw -sentinel - for < I > S >\nrequires std::default_initializable<\n    std::iter_value_t<I>>\n    I uninitialized_default_construct(\n        I first,\n        S last);",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::uninitialized_fill_n",
            "path": "en.cppreference.com/w/cpp/memory/ranges/uninitialized_fill_n.html",
            "wgPageName": "cpp/memory/ranges/uninitialized_fill_n",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<no - throw -forward - range I, class T>\nrequires std::constructible_from <\n    std::iter_value_t<I>,\nconst T& > I uninitialized_fill_n(\n               I first,\n               std::iter_difference_t<I> n,\n               const T& x);"
        },
        {
            "title": "std::ranges::uninitialized_fill",
            "path": "en.cppreference.com/w/cpp/memory/ranges/uninitialized_fill.html",
            "wgPageName": "cpp/memory/ranges/uninitialized_fill",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<\n    no - throw -forward - iterator I,\n    no - throw -sentinel - for < I > S,\n    class T >\nrequires std::constructible_from <\n    std::iter_value_t<I>,\nconst T& > I uninitialized_fill(\n               I first,\n               S last,\n               const T& x);",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::uninitialized_move_n, std::ranges::uninitialized_move_n_result",
            "path": "en.cppreference.com/w/cpp/memory/ranges/uninitialized_move_n.html",
            "wgPageName": "cpp/memory/ranges/uninitialized_move_n",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I,\n    no - throw -forward - iterator O,\n    no - throw -sentinel - for < O > S >\nrequires std::constructible_from<\n    std::iter_value_t<O>,\n    std::iter_rvalue_reference_t<I>>\n    uninitialized_move_n_result<I, O>\n    uninitialized_move_n(\n        I ifirst,\n        std::iter_difference_t<I> n,\n        O ofirst,\n        S olast);",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::uninitialized_move, std::ranges::uninitialized_move_result",
            "path": "en.cppreference.com/w/cpp/memory/ranges/uninitialized_move.html",
            "wgPageName": "cpp/memory/ranges/uninitialized_move",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<\n    std::input_iterator I,\n    std::sentinel_for<I> S1,\n    no - throw -forward - iterator O,\n    no - throw -sentinel - for < O > S2 >\nrequires std::constructible_from<\n    std::iter_value_t<O>,\n    std::iter_rvalue_reference_t<I>>\n    uninitialized_move_result<I, O>\n    uninitialized_move(\n        I ifirst,\n        S1 ilast,\n        O ofirst,\n        S2 olast);",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::uninitialized_value_construct_n",
            "path": "en.cppreference.com/w/cpp/memory/ranges/uninitialized_value_construct_n.html",
            "wgPageName": "cpp/memory/ranges/uninitialized_value_construct_n",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<no - throw -forward - iterator I>\nrequires std::default_initializable<\n    std::iter_value_t<I>>\n    I uninitialized_value_construct_n(\n        I first,\n        std::iter_difference_t<I> n);"
        },
        {
            "title": "std::ranges::uninitialized_value_construct",
            "path": "en.cppreference.com/w/cpp/memory/ranges/uninitialized_value_construct.html",
            "wgPageName": "cpp/memory/ranges/uninitialized_value_construct",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<\n    no - throw -forward - iterator I,\n    no - throw -sentinel - for < I > S >\nrequires std::default_initializable<\n    std::iter_value_t<I>>\n    I uninitialized_value_construct(\n        I first,\n        S last);",
            "other_declarations": 1
        },
        {
            "title": "std::raw_storage_iterator",
            "path": "en.cppreference.com/w/cpp/memory/raw_storage_iterator.html",
            "wgPageName": "cpp/memory/raw_storage_iterator",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class OutputIt, class T>\nclass raw_storage_iterator\n    : public std::iterator<\n          std::output_iterator_tag,\n          void,\n          void,\n          void,\n          void>;",
            "other_declarations": 1
        },
        {
            "title": "std::raw_storage_iterator<OutputIt,T>::base",
            "path": "en.cppreference.com/w/cpp/memory/raw_storage_iterator/base.html",
            "wgPageName": "cpp/memory/raw_storage_iterator/base",
            "sample_declaration": "OutputIt base() const;"
        },
        {
            "title": "std::raw_storage_iterator<OutputIt,T>::operator++, operator++(int)",
            "path": "en.cppreference.com/w/cpp/memory/raw_storage_iterator/operator_arith.html",
            "wgPageName": "cpp/memory/raw_storage_iterator/operator_arith",
            "sample_declaration": "raw_storage_iterator& operator++();",
            "other_declarations": 1
        },
        {
            "title": "std::raw_storage_iterator<OutputIt,T>::operator*",
            "path": "en.cppreference.com/w/cpp/memory/raw_storage_iterator/operator*.html",
            "wgPageName": "cpp/memory/raw_storage_iterator/operator*",
            "sample_declaration": "raw_storage_iterator& operator*();"
        },
        {
            "title": "std::raw_storage_iterator<OutputIt,T>::operator=",
            "path": "en.cppreference.com/w/cpp/memory/raw_storage_iterator/operator=.html",
            "wgPageName": "cpp/memory/raw_storage_iterator/operator=",
            "sample_declaration": "raw_storage_iterator& operator=(const T& el);",
            "other_declarations": 1
        },
        {
            "title": "std::raw_storage_iterator<OutputIt,T>::raw_storage_iterator",
            "path": "en.cppreference.com/w/cpp/memory/raw_storage_iterator/raw_storage_iterator.html",
            "wgPageName": "cpp/memory/raw_storage_iterator/raw_storage_iterator",
            "sample_declaration": "explicit raw_storage_iterator(OutputIt it);"
        },
        {
            "title": "std::return_temporary_buffer",
            "path": "en.cppreference.com/w/cpp/memory/return_temporary_buffer.html",
            "wgPageName": "cpp/memory/return_temporary_buffer",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T>\nvoid return_temporary_buffer(T* p);"
        },
        {
            "title": "std::scoped_allocator_adaptor",
            "path": "en.cppreference.com/w/cpp/memory/scoped_allocator_adaptor.html",
            "wgPageName": "cpp/memory/scoped_allocator_adaptor",
            "headers": [
                "<scoped_allocator>"
            ],
            "sample_declaration": "template<class OuterAlloc, class... InnerAlloc>\nclass scoped_allocator_adaptor\n    : public OuterAlloc;"
        },
        {
            "title": "std::scoped_allocator_adaptor<OuterAlloc,InnerAlloc...>::\n~scoped_allocator_adaptor",
            "path": "en.cppreference.com/w/cpp/memory/scoped_allocator_adaptor/~scoped_allocator_adaptor.html",
            "wgPageName": "cpp/memory/scoped_allocator_adaptor/~scoped_allocator_adaptor",
            "sample_declaration": "~scoped_allocator_adaptor();"
        },
        {
            "title": "std::scoped_allocator_adaptor<OuterAlloc,InnerAlloc...>::allocate",
            "path": "en.cppreference.com/w/cpp/memory/scoped_allocator_adaptor/allocate.html",
            "wgPageName": "cpp/memory/scoped_allocator_adaptor/allocate",
            "headers": [
                "<scoped_allocator>"
            ],
            "sample_declaration": "pointer allocate(size_type n);",
            "other_declarations": 3
        },
        {
            "title": "std::scoped_allocator_adaptor<OuterAlloc,InnerAlloc...>::construct",
            "path": "en.cppreference.com/w/cpp/memory/scoped_allocator_adaptor/construct.html",
            "wgPageName": "cpp/memory/scoped_allocator_adaptor/construct",
            "headers": [
                "<scoped_allocator>"
            ],
            "sample_declaration": "template<class T, class... Args>\nvoid construct(T* p, Args&&... args);",
            "other_declarations": 6
        },
        {
            "title": "std::scoped_allocator_adaptor<OuterAlloc,InnerAlloc...>::deallocate",
            "path": "en.cppreference.com/w/cpp/memory/scoped_allocator_adaptor/deallocate.html",
            "wgPageName": "cpp/memory/scoped_allocator_adaptor/deallocate",
            "headers": [
                "<scoped_allocator>"
            ],
            "sample_declaration": "void deallocate(\n    pointer p,\n    size_type n) noexcept;"
        },
        {
            "title": "deduction guides for std::scoped_allocator_adaptor",
            "path": "en.cppreference.com/w/cpp/memory/scoped_allocator_adaptor/deduction_guides.html",
            "wgPageName": "cpp/memory/scoped_allocator_adaptor/deduction_guides",
            "headers": [
                "<scoped_allocator>"
            ],
            "sample_declaration": "template<class OuterAlloc, class... InnerAllocs>\nscoped_allocator_adaptor(\n    OuterAlloc,\n    InnerAllocs...)\n    -> scoped_allocator_adaptor<\n        OuterAlloc,\n        InnerAllocs...>;"
        },
        {
            "title": "std::scoped_allocator_adaptor<OuterAlloc,InnerAlloc...>::destroy",
            "path": "en.cppreference.com/w/cpp/memory/scoped_allocator_adaptor/destroy.html",
            "wgPageName": "cpp/memory/scoped_allocator_adaptor/destroy",
            "headers": [
                "<scoped_allocator>"
            ],
            "sample_declaration": "template<class T>\nvoid destroy(T* p);"
        },
        {
            "title": "std::scoped_allocator_adaptor<OuterAlloc,InnerAlloc...>::inner_allocator",
            "path": "en.cppreference.com/w/cpp/memory/scoped_allocator_adaptor/inner_allocator.html",
            "wgPageName": "cpp/memory/scoped_allocator_adaptor/inner_allocator",
            "headers": [
                "<scoped_allocator>"
            ],
            "sample_declaration": "inner_allocator_type&\ninner_allocator() noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::scoped_allocator_adaptor<OuterAlloc,InnerAlloc...>::max_size",
            "path": "en.cppreference.com/w/cpp/memory/scoped_allocator_adaptor/max_size.html",
            "wgPageName": "cpp/memory/scoped_allocator_adaptor/max_size",
            "headers": [
                "<scoped_allocator>"
            ],
            "sample_declaration": "size_type max_size() const;"
        },
        {
            "title": "operator==,!=(std::scoped_allocator_adaptor)",
            "path": "en.cppreference.com/w/cpp/memory/scoped_allocator_adaptor/operator_cmp.html",
            "wgPageName": "cpp/memory/scoped_allocator_adaptor/operator_cmp",
            "headers": [
                "<scoped_allocator>"
            ],
            "sample_declaration": "template<\n    class OuterAlloc1,\n    class OuterAlloc2,\n    class... InnerAllocs>\nbool operator==(\n    const scoped_allocator_adaptor<\n        OuterAlloc1,\n        InnerAllocs...>& lhs,\n    const scoped_allocator_adaptor<\n        OuterAlloc2,\n        InnerAllocs...>& rhs) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::scoped_allocator_adaptor<OuterAlloc,InnerAlloc...>::operator=",
            "path": "en.cppreference.com/w/cpp/memory/scoped_allocator_adaptor/operator=.html",
            "wgPageName": "cpp/memory/scoped_allocator_adaptor/operator=",
            "headers": [
                "<scoped_allocator>"
            ],
            "sample_declaration": "scoped_allocator_adaptor& operator=(\n    const scoped_allocator_adaptor& other) =\n    default;",
            "other_declarations": 1
        },
        {
            "title": "std::scoped_allocator_adaptor<OuterAlloc,InnerAlloc...>::outer_allocator",
            "path": "en.cppreference.com/w/cpp/memory/scoped_allocator_adaptor/outer_allocator.html",
            "wgPageName": "cpp/memory/scoped_allocator_adaptor/outer_allocator",
            "headers": [
                "<scoped_allocator>"
            ],
            "sample_declaration": "outer_allocator_type&\nouter_allocator() noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::scoped_allocator_adaptor<OuterAlloc,InnerAlloc...>::\nscoped_allocator_adaptor",
            "path": "en.cppreference.com/w/cpp/memory/scoped_allocator_adaptor/scoped_allocator_adaptor.html",
            "wgPageName": "cpp/memory/scoped_allocator_adaptor/scoped_allocator_adaptor",
            "headers": [
                "<scoped_allocator>"
            ],
            "sample_declaration": "scoped_allocator_adaptor();",
            "other_declarations": 5
        },
        {
            "title": "std::scoped_allocator_adaptor<OuterAlloc,InnerAlloc...>::\nselect_on_container_copy_construction",
            "path": "en.cppreference.com/w/cpp/memory/scoped_allocator_adaptor/select_on_container_copy_construction.html",
            "wgPageName": "cpp/memory/scoped_allocator_adaptor/select_on_container_copy_construction",
            "headers": [
                "<scoped_allocator>"
            ],
            "sample_declaration": "scoped_allocator_adaptor\nselect_on_container_copy_construction() const;"
        },
        {
            "title": "std::pmr::set_default_resource",
            "path": "en.cppreference.com/w/cpp/memory/set_default_resource.html",
            "wgPageName": "cpp/memory/set_default_resource",
            "headers": [
                "<memory_resource>"
            ],
            "sample_declaration": "std::pmr::memory_resource* set_default_resource(\n    std::pmr::memory_resource* r) noexcept;"
        },
        {
            "title": "std::shared_ptr",
            "path": "en.cppreference.com/w/cpp/memory/shared_ptr.html",
            "wgPageName": "cpp/memory/shared_ptr",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T>\nclass shared_ptr;"
        },
        {
            "title": "std::shared_ptr<T>::~shared_ptr",
            "path": "en.cppreference.com/w/cpp/memory/shared_ptr/~shared_ptr.html",
            "wgPageName": "cpp/memory/shared_ptr/~shared_ptr",
            "sample_declaration": "~shared_ptr();"
        },
        {
            "title": "std::allocate_shared, std::allocate_shared_for_overwrite",
            "path": "en.cppreference.com/w/cpp/memory/shared_ptr/allocate_shared.html",
            "wgPageName": "cpp/memory/shared_ptr/allocate_shared",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T, class Alloc, class... Args>\nshared_ptr<T> allocate_shared(\n    const Alloc& alloc,\n    Args&&... args);",
            "other_declarations": 6
        },
        {
            "title": "std::atomic_...<std::shared_ptr>",
            "path": "en.cppreference.com/w/cpp/memory/shared_ptr/atomic.html",
            "wgPageName": "cpp/memory/shared_ptr/atomic",
            "sample_declaration": "template<class T>\nbool atomic_is_lock_free(\n    const std::shared_ptr<T>* p);",
            "other_declarations": 10
        },
        {
            "title": "std::atomic<std::shared_ptr>",
            "path": "en.cppreference.com/w/cpp/memory/shared_ptr/atomic2.html",
            "wgPageName": "cpp/memory/shared_ptr/atomic2",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T>\nstruct std::atomic<std::shared_ptr<T>>;"
        },
        {
            "title": "deduction guides for std::shared_ptr",
            "path": "en.cppreference.com/w/cpp/memory/shared_ptr/deduction_guides.html",
            "wgPageName": "cpp/memory/shared_ptr/deduction_guides",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T>\nshared_ptr(std::weak_ptr<T>) -> shared_ptr<T>;",
            "other_declarations": 1
        },
        {
            "title": "std::get_deleter",
            "path": "en.cppreference.com/w/cpp/memory/shared_ptr/get_deleter.html",
            "wgPageName": "cpp/memory/shared_ptr/get_deleter",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class Deleter, class T>\nDeleter* get_deleter(\n    const std::shared_ptr<T>& p) noexcept;"
        },
        {
            "title": "std::shared_ptr<T>::get",
            "path": "en.cppreference.com/w/cpp/memory/shared_ptr/get.html",
            "wgPageName": "cpp/memory/shared_ptr/get",
            "sample_declaration": "T* get() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::hash(std::shared_ptr)",
            "path": "en.cppreference.com/w/cpp/memory/shared_ptr/hash.html",
            "wgPageName": "cpp/memory/shared_ptr/hash",
            "sample_declaration": "template<class T>\nstruct hash<shared_ptr<T>>;"
        },
        {
            "title": "std::make_shared, std::make_shared_for_overwrite",
            "path": "en.cppreference.com/w/cpp/memory/shared_ptr/make_shared.html",
            "wgPageName": "cpp/memory/shared_ptr/make_shared",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T, class... Args>\nshared_ptr<T> make_shared(Args&&... args);",
            "other_declarations": 6
        },
        {
            "title": "std::shared_ptr<T>::operator[]",
            "path": "en.cppreference.com/w/cpp/memory/shared_ptr/operator_at.html",
            "wgPageName": "cpp/memory/shared_ptr/operator_at",
            "sample_declaration": "element_type& operator[](\n    std::ptrdiff_t idx) const;"
        },
        {
            "title": "std::shared_ptr<T>::operator bool",
            "path": "en.cppreference.com/w/cpp/memory/shared_ptr/operator_bool.html",
            "wgPageName": "cpp/memory/shared_ptr/operator_bool",
            "sample_declaration": "explicit operator bool() const noexcept;"
        },
        {
            "title": "operator==, !=, <, <=, >, >=, <=> (std::shared_ptr)",
            "path": "en.cppreference.com/w/cpp/memory/shared_ptr/operator_cmp.html",
            "wgPageName": "cpp/memory/shared_ptr/operator_cmp",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T, class U>\nbool operator==(\n    const std::shared_ptr<T>& lhs,\n    const std::shared_ptr<U>& rhs) noexcept;",
            "other_declarations": 19
        },
        {
            "title": "std::shared_ptr<T>::operator<<",
            "path": "en.cppreference.com/w/cpp/memory/shared_ptr/operator_ltlt.html",
            "wgPageName": "cpp/memory/shared_ptr/operator_ltlt",
            "sample_declaration": "template<class T, class U, class V>\nstd::basic_ostream<U, V>& operator<<(\n    std::basic_ostream<U, V>& os,\n    const std::shared_ptr<T>& ptr);"
        },
        {
            "title": "std::shared_ptr<T>::operator*, std::shared_ptr<T>::operator->",
            "path": "en.cppreference.com/w/cpp/memory/shared_ptr/operator*.html",
            "wgPageName": "cpp/memory/shared_ptr/operator*",
            "sample_declaration": "T& operator*() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::shared_ptr<T>::operator=",
            "path": "en.cppreference.com/w/cpp/memory/shared_ptr/operator=.html",
            "wgPageName": "cpp/memory/shared_ptr/operator=",
            "sample_declaration": "shared_ptr& operator=(\n    const shared_ptr& r) noexcept;",
            "other_declarations": 5
        },
        {
            "title": "std::shared_ptr<T>::owner_before",
            "path": "en.cppreference.com/w/cpp/memory/shared_ptr/owner_before.html",
            "wgPageName": "cpp/memory/shared_ptr/owner_before",
            "sample_declaration": "template<class Y>\nbool owner_before(\n    const shared_ptr<Y>& other) const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::static_pointer_cast, std::dynamic_pointer_cast, std::const_pointer_cast, std::reinterpret_pointer_cast",
            "path": "en.cppreference.com/w/cpp/memory/shared_ptr/pointer_cast.html",
            "wgPageName": "cpp/memory/shared_ptr/pointer_cast",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T, class U>\nstd::shared_ptr<T> static_pointer_cast(\n    const std::shared_ptr<U>& r) noexcept;",
            "other_declarations": 7
        },
        {
            "title": "std::shared_ptr<T>::reset",
            "path": "en.cppreference.com/w/cpp/memory/shared_ptr/reset.html",
            "wgPageName": "cpp/memory/shared_ptr/reset",
            "sample_declaration": "void reset() noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::shared_ptr<T>::shared_ptr",
            "path": "en.cppreference.com/w/cpp/memory/shared_ptr/shared_ptr.html",
            "wgPageName": "cpp/memory/shared_ptr/shared_ptr",
            "sample_declaration": "constexpr shared_ptr() noexcept;",
            "other_declarations": 15
        },
        {
            "title": "std::shared_ptr<T>::swap",
            "path": "en.cppreference.com/w/cpp/memory/shared_ptr/swap.html",
            "wgPageName": "cpp/memory/shared_ptr/swap",
            "sample_declaration": "void swap(shared_ptr& r) noexcept;"
        },
        {
            "title": "std::swap(std::shared_ptr)",
            "path": "en.cppreference.com/w/cpp/memory/shared_ptr/swap2.html",
            "wgPageName": "cpp/memory/shared_ptr/swap2",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T>\nvoid swap(\n    std::shared_ptr<T>& lhs,\n    std::shared_ptr<T>& rhs) noexcept;"
        },
        {
            "title": "std::shared_ptr<T>::unique",
            "path": "en.cppreference.com/w/cpp/memory/shared_ptr/unique.html",
            "wgPageName": "cpp/memory/shared_ptr/unique",
            "sample_declaration": "bool unique() const noexcept;"
        },
        {
            "title": "std::shared_ptr<T>::use_count",
            "path": "en.cppreference.com/w/cpp/memory/shared_ptr/use_count.html",
            "wgPageName": "cpp/memory/shared_ptr/use_count",
            "sample_declaration": "long use_count() const noexcept;"
        },
        {
            "title": "std::pmr::synchronized_pool_resource",
            "path": "en.cppreference.com/w/cpp/memory/synchronized_pool_resource.html",
            "wgPageName": "cpp/memory/synchronized_pool_resource",
            "headers": [
                "<memory_resource>"
            ],
            "sample_declaration": "class synchronized_pool_resource\n    : public std::pmr::memory_resource;"
        },
        {
            "title": "std::pmr::synchronized_pool_resource::~synchronized_pool_resource",
            "path": "en.cppreference.com/w/cpp/memory/synchronized_pool_resource/~synchronized_pool_resource.html",
            "wgPageName": "cpp/memory/synchronized_pool_resource/~synchronized_pool_resource",
            "sample_declaration": "virtual ~synchronized_pool_resource();"
        },
        {
            "title": "std::pmr::synchronized_pool_resource::do_allocate",
            "path": "en.cppreference.com/w/cpp/memory/synchronized_pool_resource/do_allocate.html",
            "wgPageName": "cpp/memory/synchronized_pool_resource/do_allocate",
            "sample_declaration": "virtual void* do_allocate(\n    std::size_t bytes,\n    std::size_t alignment);"
        },
        {
            "title": "std::pmr::synchronized_pool_resource::do_deallocate",
            "path": "en.cppreference.com/w/cpp/memory/synchronized_pool_resource/do_deallocate.html",
            "wgPageName": "cpp/memory/synchronized_pool_resource/do_deallocate",
            "sample_declaration": "virtual void do_deallocate(\n    void* p,\n    std::size_t bytes,\n    std::size_t alignment);"
        },
        {
            "title": "std::pmr::synchronized_pool_resource::do_is_equal",
            "path": "en.cppreference.com/w/cpp/memory/synchronized_pool_resource/do_is_equal.html",
            "wgPageName": "cpp/memory/synchronized_pool_resource/do_is_equal",
            "sample_declaration": "virtual bool do_is_equal(\n    const std::pmr::memory_resource& other)\n    const noexcept;"
        },
        {
            "title": "std::pmr::synchronized_pool_resource::options",
            "path": "en.cppreference.com/w/cpp/memory/synchronized_pool_resource/options.html",
            "wgPageName": "cpp/memory/synchronized_pool_resource/options",
            "sample_declaration": "std::pmr::pool_options options() const;"
        },
        {
            "title": "std::pmr::synchronized_pool_resource::release",
            "path": "en.cppreference.com/w/cpp/memory/synchronized_pool_resource/release.html",
            "wgPageName": "cpp/memory/synchronized_pool_resource/release",
            "sample_declaration": "void release();"
        },
        {
            "title": "std::pmr::synchronized_pool_resource::synchronized_pool_resource",
            "path": "en.cppreference.com/w/cpp/memory/synchronized_pool_resource/synchronized_pool_resource.html",
            "wgPageName": "cpp/memory/synchronized_pool_resource/synchronized_pool_resource",
            "sample_declaration": "synchronized_pool_resource();",
            "other_declarations": 4
        },
        {
            "title": "std::pmr::synchronized_pool_resource::upstream_resource",
            "path": "en.cppreference.com/w/cpp/memory/synchronized_pool_resource/upstream_resource.html",
            "wgPageName": "cpp/memory/synchronized_pool_resource/upstream_resource",
            "sample_declaration": "std::pmr::memory_resource* upstream_resource()\n    const;"
        },
        {
            "title": "std::to_address",
            "path": "en.cppreference.com/w/cpp/memory/to_address.html",
            "wgPageName": "cpp/memory/to_address",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class Ptr>\nconstexpr auto to_address(\n    const Ptr& p) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::uninitialized_construct_using_allocator",
            "path": "en.cppreference.com/w/cpp/memory/uninitialized_construct_using_allocator.html",
            "wgPageName": "cpp/memory/uninitialized_construct_using_allocator",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T, class Alloc, class... Args>\nconstexpr T*\nuninitialized_construct_using_allocator(\n    T* p,\n    const Alloc& alloc,\n    Args&&... args);"
        },
        {
            "title": "std::uninitialized_copy_n",
            "path": "en.cppreference.com/w/cpp/memory/uninitialized_copy_n.html",
            "wgPageName": "cpp/memory/uninitialized_copy_n",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<\n    class InputIt,\n    class Size,\n    class NoThrowForwardIt>\nNoThrowForwardIt uninitialized_copy_n(\n    InputIt first,\n    Size count,\n    NoThrowForwardIt d_first);",
            "other_declarations": 1
        },
        {
            "title": "std::uninitialized_copy",
            "path": "en.cppreference.com/w/cpp/memory/uninitialized_copy.html",
            "wgPageName": "cpp/memory/uninitialized_copy",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class InputIt, class NoThrowForwardIt>\nNoThrowForwardIt uninitialized_copy(\n    InputIt first,\n    InputIt last,\n    NoThrowForwardIt d_first);",
            "other_declarations": 1
        },
        {
            "title": "std::uninitialized_default_construct_n",
            "path": "en.cppreference.com/w/cpp/memory/uninitialized_default_construct_n.html",
            "wgPageName": "cpp/memory/uninitialized_default_construct_n",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class ForwardIt, class Size>\nForwardIt uninitialized_default_construct_n(\n    ForwardIt first,\n    Size n);",
            "other_declarations": 1
        },
        {
            "title": "std::uninitialized_default_construct",
            "path": "en.cppreference.com/w/cpp/memory/uninitialized_default_construct.html",
            "wgPageName": "cpp/memory/uninitialized_default_construct",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class ForwardIt>\nvoid uninitialized_default_construct(\n    ForwardIt first,\n    ForwardIt last);",
            "other_declarations": 1
        },
        {
            "title": "std::uninitialized_fill_n",
            "path": "en.cppreference.com/w/cpp/memory/uninitialized_fill_n.html",
            "wgPageName": "cpp/memory/uninitialized_fill_n",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class ForwardIt, class Size, class T>\nvoid uninitialized_fill_n(\n    ForwardIt first,\n    Size count,\n    const T& value);",
            "other_declarations": 2
        },
        {
            "title": "std::uninitialized_fill",
            "path": "en.cppreference.com/w/cpp/memory/uninitialized_fill.html",
            "wgPageName": "cpp/memory/uninitialized_fill",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class ForwardIt, class T>\nvoid uninitialized_fill(\n    ForwardIt first,\n    ForwardIt last,\n    const T& value);",
            "other_declarations": 1
        },
        {
            "title": "std::uninitialized_move_n",
            "path": "en.cppreference.com/w/cpp/memory/uninitialized_move_n.html",
            "wgPageName": "cpp/memory/uninitialized_move_n",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<\n    class InputIt,\n    class Size,\n    class NoThrowForwardIt>\nstd::pair<InputIt, NoThrowForwardIt>\nuninitialized_move_n(\n    InputIt first,\n    Size count,\n    NoThrowForwardIt d_first);",
            "other_declarations": 1
        },
        {
            "title": "std::uninitialized_move",
            "path": "en.cppreference.com/w/cpp/memory/uninitialized_move.html",
            "wgPageName": "cpp/memory/uninitialized_move",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class InputIt, class NoThrowForwardIt>\nNoThrowForwardIt uninitialized_move(\n    InputIt first,\n    InputIt last,\n    NoThrowForwardIt d_first);",
            "other_declarations": 1
        },
        {
            "title": "std::uninitialized_value_construct_n",
            "path": "en.cppreference.com/w/cpp/memory/uninitialized_value_construct_n.html",
            "wgPageName": "cpp/memory/uninitialized_value_construct_n",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class ForwardIt, class Size>\nForwardIt uninitialized_value_construct_n(\n    ForwardIt first,\n    Size n);",
            "other_declarations": 1
        },
        {
            "title": "std::uninitialized_value_construct",
            "path": "en.cppreference.com/w/cpp/memory/uninitialized_value_construct.html",
            "wgPageName": "cpp/memory/uninitialized_value_construct",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class ForwardIt>\nvoid uninitialized_value_construct(\n    ForwardIt first,\n    ForwardIt last);",
            "other_declarations": 1
        },
        {
            "title": "std::unique_ptr",
            "path": "en.cppreference.com/w/cpp/memory/unique_ptr.html",
            "wgPageName": "cpp/memory/unique_ptr",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<\n    class T,\n    class Deleter = std::default_delete<T> >\nclass unique_ptr;",
            "other_declarations": 1
        },
        {
            "title": "std::unique_ptr<T,Deleter>::~unique_ptr",
            "path": "en.cppreference.com/w/cpp/memory/unique_ptr/~unique_ptr.html",
            "wgPageName": "cpp/memory/unique_ptr/~unique_ptr",
            "sample_declaration": "~unique_ptr();"
        },
        {
            "title": "std::unique_ptr<T,Deleter>::get_deleter",
            "path": "en.cppreference.com/w/cpp/memory/unique_ptr/get_deleter.html",
            "wgPageName": "cpp/memory/unique_ptr/get_deleter",
            "sample_declaration": "Deleter& get_deleter() noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::unique_ptr<T,Deleter>::get",
            "path": "en.cppreference.com/w/cpp/memory/unique_ptr/get.html",
            "wgPageName": "cpp/memory/unique_ptr/get",
            "sample_declaration": "pointer get() const noexcept;"
        },
        {
            "title": "std::hash<std::unique_ptr>",
            "path": "en.cppreference.com/w/cpp/memory/unique_ptr/hash.html",
            "wgPageName": "cpp/memory/unique_ptr/hash",
            "sample_declaration": "template<class T, class Deleter>\nstruct hash<unique_ptr<T, Deleter>>;"
        },
        {
            "title": "std::make_unique, std::make_unique_for_overwrite",
            "path": "en.cppreference.com/w/cpp/memory/unique_ptr/make_unique.html",
            "wgPageName": "cpp/memory/unique_ptr/make_unique",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T, class... Args>\nunique_ptr<T> make_unique(Args&&... args);",
            "other_declarations": 9
        },
        {
            "title": "std::unique_ptr<T,Deleter>::operator[]",
            "path": "en.cppreference.com/w/cpp/memory/unique_ptr/operator_at.html",
            "wgPageName": "cpp/memory/unique_ptr/operator_at",
            "sample_declaration": "T& operator[](std::size_t i) const;"
        },
        {
            "title": "std::unique_ptr<T,Deleter>::operator bool",
            "path": "en.cppreference.com/w/cpp/memory/unique_ptr/operator_bool.html",
            "wgPageName": "cpp/memory/unique_ptr/operator_bool",
            "sample_declaration": "explicit operator bool() const noexcept;"
        },
        {
            "title": "operator==,!=,<,<=,>,>=,<=>(std::unique_ptr)",
            "path": "en.cppreference.com/w/cpp/memory/unique_ptr/operator_cmp.html",
            "wgPageName": "cpp/memory/unique_ptr/operator_cmp",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T1, class D1, class T2, class D2>\nbool operator==(\n    const unique_ptr<T1, D1>& x,\n    const unique_ptr<T2, D2>& y);",
            "other_declarations": 19
        },
        {
            "title": "std::unique_ptr<T,Deleter>::operator<<",
            "path": "en.cppreference.com/w/cpp/memory/unique_ptr/operator_ltlt.html",
            "wgPageName": "cpp/memory/unique_ptr/operator_ltlt",
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Y,\n    class D>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::unique_ptr<Y, D>& p);"
        },
        {
            "title": "std::unique_ptr<T,Deleter>::operator*, std::unique_ptr<T,Deleter>::operator->",
            "path": "en.cppreference.com/w/cpp/memory/unique_ptr/operator*.html",
            "wgPageName": "cpp/memory/unique_ptr/operator*",
            "sample_declaration": "typename std::add_lvalue_reference<T>::type\noperator*() const noexcept(\n    noexcept(*std::declval<pointer>()));",
            "other_declarations": 1
        },
        {
            "title": "std::unique_ptr<T,Deleter>::operator=",
            "path": "en.cppreference.com/w/cpp/memory/unique_ptr/operator=.html",
            "wgPageName": "cpp/memory/unique_ptr/operator=",
            "sample_declaration": "unique_ptr& operator=(unique_ptr&& r) noexcept;",
            "other_declarations": 5
        },
        {
            "title": "std::unique_ptr<T,Deleter>::release",
            "path": "en.cppreference.com/w/cpp/memory/unique_ptr/release.html",
            "wgPageName": "cpp/memory/unique_ptr/release",
            "sample_declaration": "pointer release() noexcept;"
        },
        {
            "title": "std::unique_ptr<T,Deleter>::reset",
            "path": "en.cppreference.com/w/cpp/memory/unique_ptr/reset.html",
            "wgPageName": "cpp/memory/unique_ptr/reset",
            "sample_declaration": "void reset(pointer ptr = pointer()) noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::unique_ptr<T,Deleter>::swap",
            "path": "en.cppreference.com/w/cpp/memory/unique_ptr/swap.html",
            "wgPageName": "cpp/memory/unique_ptr/swap",
            "sample_declaration": "void swap(unique_ptr& other) noexcept;"
        },
        {
            "title": "std::swap(std::unique_ptr)",
            "path": "en.cppreference.com/w/cpp/memory/unique_ptr/swap2.html",
            "wgPageName": "cpp/memory/unique_ptr/swap2",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T, class D>\nvoid swap(\n    std::unique_ptr<T, D>& lhs,\n    std::unique_ptr<T, D>& rhs) noexcept;"
        },
        {
            "title": "std::unique_ptr<T,Deleter>::unique_ptr",
            "path": "en.cppreference.com/w/cpp/memory/unique_ptr/unique_ptr.html",
            "wgPageName": "cpp/memory/unique_ptr/unique_ptr",
            "sample_declaration": "constexpr unique_ptr() noexcept;\nconstexpr unique_ptr(std::nullptr_t) noexcept;",
            "other_declarations": 12
        },
        {
            "title": "std::pmr::unsynchronized_pool_resource",
            "path": "en.cppreference.com/w/cpp/memory/unsynchronized_pool_resource.html",
            "wgPageName": "cpp/memory/unsynchronized_pool_resource",
            "headers": [
                "<memory_resource>"
            ],
            "sample_declaration": "class unsynchronized_pool_resource\n    : public std::pmr::memory_resource;"
        },
        {
            "title": "std::pmr::unsynchronized_pool_resource::~unsynchronized_pool_resource",
            "path": "en.cppreference.com/w/cpp/memory/unsynchronized_pool_resource/~unsynchronized_pool_resource.html",
            "wgPageName": "cpp/memory/unsynchronized_pool_resource/~unsynchronized_pool_resource",
            "sample_declaration": "virtual ~unsynchronized_pool_resource();"
        },
        {
            "title": "std::pmr::unsynchronized_pool_resource::do_allocate",
            "path": "en.cppreference.com/w/cpp/memory/unsynchronized_pool_resource/do_allocate.html",
            "wgPageName": "cpp/memory/unsynchronized_pool_resource/do_allocate",
            "sample_declaration": "virtual void* do_allocate(\n    std::size_t bytes,\n    std::size_t alignment);"
        },
        {
            "title": "std::pmr::unsynchronized_pool_resource::do_deallocate",
            "path": "en.cppreference.com/w/cpp/memory/unsynchronized_pool_resource/do_deallocate.html",
            "wgPageName": "cpp/memory/unsynchronized_pool_resource/do_deallocate",
            "sample_declaration": "virtual void do_deallocate(\n    void* p,\n    std::size_t bytes,\n    std::size_t alignment);"
        },
        {
            "title": "std::pmr::unsynchronized_pool_resource::do_is_equal",
            "path": "en.cppreference.com/w/cpp/memory/unsynchronized_pool_resource/do_is_equal.html",
            "wgPageName": "cpp/memory/unsynchronized_pool_resource/do_is_equal",
            "sample_declaration": "virtual bool do_is_equal(\n    const std::pmr::memory_resource& other)\n    const noexcept;"
        },
        {
            "title": "std::pmr::unsynchronized_pool_resource::options",
            "path": "en.cppreference.com/w/cpp/memory/unsynchronized_pool_resource/options.html",
            "wgPageName": "cpp/memory/unsynchronized_pool_resource/options",
            "sample_declaration": "std::pmr::pool_options options() const;"
        },
        {
            "title": "std::pmr::unsynchronized_pool_resource::release",
            "path": "en.cppreference.com/w/cpp/memory/unsynchronized_pool_resource/release.html",
            "wgPageName": "cpp/memory/unsynchronized_pool_resource/release",
            "sample_declaration": "void release();"
        },
        {
            "title": "std::pmr::unsynchronized_pool_resource::unsynchronized_pool_resource",
            "path": "en.cppreference.com/w/cpp/memory/unsynchronized_pool_resource/unsynchronized_pool_resource.html",
            "wgPageName": "cpp/memory/unsynchronized_pool_resource/unsynchronized_pool_resource",
            "sample_declaration": "unsynchronized_pool_resource();",
            "other_declarations": 4
        },
        {
            "title": "std::pmr::unsynchronized_pool_resource::upstream_resource",
            "path": "en.cppreference.com/w/cpp/memory/unsynchronized_pool_resource/upstream_resource.html",
            "wgPageName": "cpp/memory/unsynchronized_pool_resource/upstream_resource",
            "sample_declaration": "std::pmr::memory_resource* upstream_resource()\n    const;"
        },
        {
            "title": "std::uses_allocator_construction_args",
            "path": "en.cppreference.com/w/cpp/memory/uses_allocator_construction_args.html",
            "wgPageName": "cpp/memory/uses_allocator_construction_args",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T, class Alloc, class... Args>\nconstexpr auto uses_allocator_construction_args(\n    const Alloc& alloc,\n    Args&&... args) noexcept;",
            "other_declarations": 8
        },
        {
            "title": "std::uses_allocator",
            "path": "en.cppreference.com/w/cpp/memory/uses_allocator.html",
            "wgPageName": "cpp/memory/uses_allocator",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T, class Alloc>\nstruct uses_allocator;"
        },
        {
            "title": "std::weak_ptr",
            "path": "en.cppreference.com/w/cpp/memory/weak_ptr.html",
            "wgPageName": "cpp/memory/weak_ptr",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T>\nclass weak_ptr;"
        },
        {
            "title": "std::weak_ptr<T>::~weak_ptr",
            "path": "en.cppreference.com/w/cpp/memory/weak_ptr/~weak_ptr.html",
            "wgPageName": "cpp/memory/weak_ptr/~weak_ptr",
            "sample_declaration": "~weak_ptr();"
        },
        {
            "title": "std::atomic(std::weak_ptr)",
            "path": "en.cppreference.com/w/cpp/memory/weak_ptr/atomic2.html",
            "wgPageName": "cpp/memory/weak_ptr/atomic2",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T>\nstruct std::atomic<std::weak_ptr<T>>;"
        },
        {
            "title": "deduction guides for std::weak_ptr",
            "path": "en.cppreference.com/w/cpp/memory/weak_ptr/deduction_guides.html",
            "wgPageName": "cpp/memory/weak_ptr/deduction_guides",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T>\nweak_ptr(std::shared_ptr<T>) -> weak_ptr<T>;"
        },
        {
            "title": "std::weak_ptr<T>::expired",
            "path": "en.cppreference.com/w/cpp/memory/weak_ptr/expired.html",
            "wgPageName": "cpp/memory/weak_ptr/expired",
            "sample_declaration": "bool expired() const noexcept;"
        },
        {
            "title": "std::weak_ptr<T>::lock",
            "path": "en.cppreference.com/w/cpp/memory/weak_ptr/lock.html",
            "wgPageName": "cpp/memory/weak_ptr/lock",
            "sample_declaration": "std::shared_ptr<T> lock() const noexcept;"
        },
        {
            "title": "std::weak_ptr<T>::operator=",
            "path": "en.cppreference.com/w/cpp/memory/weak_ptr/operator=.html",
            "wgPageName": "cpp/memory/weak_ptr/operator=",
            "sample_declaration": "weak_ptr& operator=(const weak_ptr& r) noexcept;",
            "other_declarations": 4
        },
        {
            "title": "std::weak_ptr<T>::owner_before",
            "path": "en.cppreference.com/w/cpp/memory/weak_ptr/owner_before.html",
            "wgPageName": "cpp/memory/weak_ptr/owner_before",
            "sample_declaration": "template<class Y>\nbool owner_before(\n    const weak_ptr<Y>& other) const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::weak_ptr<T>::reset",
            "path": "en.cppreference.com/w/cpp/memory/weak_ptr/reset.html",
            "wgPageName": "cpp/memory/weak_ptr/reset",
            "sample_declaration": "void reset() noexcept;"
        },
        {
            "title": "std::weak_ptr<T>::swap",
            "path": "en.cppreference.com/w/cpp/memory/weak_ptr/swap.html",
            "wgPageName": "cpp/memory/weak_ptr/swap",
            "sample_declaration": "void swap(weak_ptr& r) noexcept;"
        },
        {
            "title": "std::swap(std::weak_ptr)",
            "path": "en.cppreference.com/w/cpp/memory/weak_ptr/swap2.html",
            "wgPageName": "cpp/memory/weak_ptr/swap2",
            "headers": [
                "<memory>"
            ],
            "sample_declaration": "template<class T>\nvoid swap(\n    std::weak_ptr<T>& lhs,\n    std::weak_ptr<T>& rhs) noexcept;"
        },
        {
            "title": "std::weak_ptr<T>::use_count",
            "path": "en.cppreference.com/w/cpp/memory/weak_ptr/use_count.html",
            "wgPageName": "cpp/memory/weak_ptr/use_count",
            "sample_declaration": "long use_count() const noexcept;"
        },
        {
            "title": "std::weak_ptr<T>::weak_ptr",
            "path": "en.cppreference.com/w/cpp/memory/weak_ptr/weak_ptr.html",
            "wgPageName": "cpp/memory/weak_ptr/weak_ptr",
            "sample_declaration": "constexpr weak_ptr() noexcept;",
            "other_declarations": 5
        },
        {
            "title": "Metaprogramming library (since C++11)",
            "path": "en.cppreference.com/w/cpp/meta.html",
            "wgPageName": "cpp/meta"
        },
        {
            "title": "Named Requirements",
            "path": "en.cppreference.com/w/cpp/named_req.html",
            "wgPageName": "cpp/named_req"
        },
        {
            "title": "C++ named requirements: Allocator",
            "path": "en.cppreference.com/w/cpp/named_req/Allocator.html",
            "wgPageName": "cpp/named_req/Allocator"
        },
        {
            "title": "C++ named requirements: AllocatorAwareContainer",
            "path": "en.cppreference.com/w/cpp/named_req/AllocatorAwareContainer.html",
            "wgPageName": "cpp/named_req/AllocatorAwareContainer"
        },
        {
            "title": "C++ named requirements: AssociativeContainer",
            "path": "en.cppreference.com/w/cpp/named_req/AssociativeContainer.html",
            "wgPageName": "cpp/named_req/AssociativeContainer"
        },
        {
            "title": "C++ named requirements: BasicFormatter",
            "path": "en.cppreference.com/w/cpp/named_req/BasicFormatter.html",
            "wgPageName": "cpp/named_req/BasicFormatter"
        },
        {
            "title": "C++ named requirements: BasicLockable",
            "path": "en.cppreference.com/w/cpp/named_req/BasicLockable.html",
            "wgPageName": "cpp/named_req/BasicLockable"
        },
        {
            "title": "C++ named requirements: LegacyBidirectionalIterator",
            "path": "en.cppreference.com/w/cpp/named_req/BidirectionalIterator.html",
            "wgPageName": "cpp/named_req/BidirectionalIterator",
            "sample_declaration": "template<class I>\nconcept __LegacyBidirectionalIterator =\n    __LegacyForwardIterator<I> &&\n    requires(I i) {\n  { --i } -> std::same_as<I&>;\n  { i-- } -> std::convertible_to<const I&>;\n  {\n    *i--\n    } -> std::same_as<std::iter_reference_t<I>>;\n};"
        },
        {
            "title": "C++ named requirements: BinaryPredicate",
            "path": "en.cppreference.com/w/cpp/named_req/BinaryPredicate.html",
            "wgPageName": "cpp/named_req/BinaryPredicate"
        },
        {
            "title": "C++ named requirements: BinaryTypeTrait",
            "path": "en.cppreference.com/w/cpp/named_req/BinaryTypeTrait.html",
            "wgPageName": "cpp/named_req/BinaryTypeTrait"
        },
        {
            "title": "C++ named requirements: BitmaskType",
            "path": "en.cppreference.com/w/cpp/named_req/BitmaskType.html",
            "wgPageName": "cpp/named_req/BitmaskType"
        },
        {
            "title": "C++ named requirements: Callable",
            "path": "en.cppreference.com/w/cpp/named_req/Callable.html",
            "wgPageName": "cpp/named_req/Callable"
        },
        {
            "title": "C++ named requirements: CharTraits",
            "path": "en.cppreference.com/w/cpp/named_req/CharTraits.html",
            "wgPageName": "cpp/named_req/CharTraits",
            "sample_declaration": "template<>\nclass char_traits<char>;\ntemplate<>\nclass char_traits<wchar_t>;\ntemplate<>\nclass char_traits<char8_t>;\ntemplate<>\nclass char_traits<char16_t>;\ntemplate<>\nclass char_traits<char32_t>;"
        },
        {
            "title": "C++ named requirements: Clock",
            "path": "en.cppreference.com/w/cpp/named_req/Clock.html",
            "wgPageName": "cpp/named_req/Clock"
        },
        {
            "title": "C++ named requirements: Compare",
            "path": "en.cppreference.com/w/cpp/named_req/Compare.html",
            "wgPageName": "cpp/named_req/Compare"
        },
        {
            "title": "C++ named requirements: ConstexprIterator",
            "path": "en.cppreference.com/w/cpp/named_req/ConstexprIterator.html",
            "wgPageName": "cpp/named_req/ConstexprIterator"
        },
        {
            "title": "C++ named requirements: Container",
            "path": "en.cppreference.com/w/cpp/named_req/Container.html",
            "wgPageName": "cpp/named_req/Container"
        },
        {
            "title": "C++ named requirements: ContiguousContainer",
            "path": "en.cppreference.com/w/cpp/named_req/ContiguousContainer.html",
            "wgPageName": "cpp/named_req/ContiguousContainer"
        },
        {
            "title": "C++ named requirements: LegacyContiguousIterator",
            "path": "en.cppreference.com/w/cpp/named_req/ContiguousIterator.html",
            "wgPageName": "cpp/named_req/ContiguousIterator"
        },
        {
            "title": "C++ named requirements: CopyAssignable",
            "path": "en.cppreference.com/w/cpp/named_req/CopyAssignable.html",
            "wgPageName": "cpp/named_req/CopyAssignable"
        },
        {
            "title": "C++ named requirements: CopyConstructible",
            "path": "en.cppreference.com/w/cpp/named_req/CopyConstructible.html",
            "wgPageName": "cpp/named_req/CopyConstructible"
        },
        {
            "title": "C++ named requirements: CopyInsertable",
            "path": "en.cppreference.com/w/cpp/named_req/CopyInsertable.html",
            "wgPageName": "cpp/named_req/CopyInsertable"
        },
        {
            "title": "C++ named requirements: DefaultConstructible",
            "path": "en.cppreference.com/w/cpp/named_req/DefaultConstructible.html",
            "wgPageName": "cpp/named_req/DefaultConstructible"
        },
        {
            "title": "C++ named requirements: DefaultInsertable",
            "path": "en.cppreference.com/w/cpp/named_req/DefaultInsertable.html",
            "wgPageName": "cpp/named_req/DefaultInsertable"
        },
        {
            "title": "C++ named requirements: Destructible",
            "path": "en.cppreference.com/w/cpp/named_req/Destructible.html",
            "wgPageName": "cpp/named_req/Destructible"
        },
        {
            "title": "C++ named requirements: EmplaceConstructible (since C++11)",
            "path": "en.cppreference.com/w/cpp/named_req/EmplaceConstructible.html",
            "wgPageName": "cpp/named_req/EmplaceConstructible"
        },
        {
            "title": "C++ named requirements: EqualityComparable",
            "path": "en.cppreference.com/w/cpp/named_req/EqualityComparable.html",
            "wgPageName": "cpp/named_req/EqualityComparable"
        },
        {
            "title": "C++ named requirements: Erasable",
            "path": "en.cppreference.com/w/cpp/named_req/Erasable.html",
            "wgPageName": "cpp/named_req/Erasable"
        },
        {
            "title": "C++ named requirements: FormattedInputFunction",
            "path": "en.cppreference.com/w/cpp/named_req/FormattedInputFunction.html",
            "wgPageName": "cpp/named_req/FormattedInputFunction"
        },
        {
            "title": "C++ named requirements: FormattedOutputFunction",
            "path": "en.cppreference.com/w/cpp/named_req/FormattedOutputFunction.html",
            "wgPageName": "cpp/named_req/FormattedOutputFunction"
        },
        {
            "title": "C++ named requirements: Formatter",
            "path": "en.cppreference.com/w/cpp/named_req/Formatter.html",
            "wgPageName": "cpp/named_req/Formatter"
        },
        {
            "title": "C++ named requirements: LegacyForwardIterator",
            "path": "en.cppreference.com/w/cpp/named_req/ForwardIterator.html",
            "wgPageName": "cpp/named_req/ForwardIterator",
            "sample_declaration": "template<class It>\nconcept __LegacyForwardIterator =\n    __LegacyInputIterator<It> &&\n    std::constructible_from<It> &&\n    std::is_lvalue_reference_v<\n        std::iter_reference_t<It>> &&\n    std::same_as <\n    std::remove_cvref_t<\n        std::iter_reference_t<It>>,\ntypename std::indirectly_readable_traits<\n    It>::value_type > &&requires(It it) {\n  { it++ } -> std::convertible_to<const It&>;\n  {\n    *it++\n    }\n    -> std::same_as<std::iter_reference_t<It>>;\n};"
        },
        {
            "title": "C++ named requirements: FunctionObject",
            "path": "en.cppreference.com/w/cpp/named_req/FunctionObject.html",
            "wgPageName": "cpp/named_req/FunctionObject"
        },
        {
            "title": "C++ named requirements: Hash",
            "path": "en.cppreference.com/w/cpp/named_req/Hash.html",
            "wgPageName": "cpp/named_req/Hash"
        },
        {
            "title": "C++ named requirements: ImplicitLifetimeType",
            "path": "en.cppreference.com/w/cpp/named_req/ImplicitLifetimeType.html",
            "wgPageName": "cpp/named_req/ImplicitLifetimeType"
        },
        {
            "title": "C++ named requirements: LegacyInputIterator",
            "path": "en.cppreference.com/w/cpp/named_req/InputIterator.html",
            "wgPageName": "cpp/named_req/InputIterator",
            "sample_declaration": "template<class I>\nconcept __LegacyInputIterator =\n    __LegacyIterator<I> &&\n    std::equality_comparable<I> &&\n    requires(I i) {\n  typename std::incrementable_traits<\n      I>::difference_type;\n  typename std::indirectly_readable_traits<\n      I>::value_type;\n  typename std::common_reference_t<\n      std::iter_reference_t<I>&&,\n      typename std::indirectly_readable_traits<\n          I>::value_type&>;\n  *i++;\n  typename std::common_reference_t<\n      decltype(*i++)&&,\n      typename std::indirectly_readable_traits<\n          I>::value_type&>;\n  requires std::signed_integral<\n      typename std::incrementable_traits<\n          I>::difference_type>;\n};"
        },
        {
            "title": "C++ named requirements: LegacyIterator",
            "path": "en.cppreference.com/w/cpp/named_req/Iterator.html",
            "wgPageName": "cpp/named_req/Iterator",
            "sample_declaration": "template<class I>\nconcept __LegacyIterator = requires(I i) {\n  { *i } -> __Referenceable;\n  { ++i } -> std::same_as<I&>;\n  { *i++ } -> __Referenceable;\n}\n&&std::copyable<I>;"
        },
        {
            "title": "C++ named requirements: LessThanComparable",
            "path": "en.cppreference.com/w/cpp/named_req/LessThanComparable.html",
            "wgPageName": "cpp/named_req/LessThanComparable"
        },
        {
            "title": "C++ named requirements: LiteralType",
            "path": "en.cppreference.com/w/cpp/named_req/LiteralType.html",
            "wgPageName": "cpp/named_req/LiteralType"
        },
        {
            "title": "C++ named requirements: Lockable",
            "path": "en.cppreference.com/w/cpp/named_req/Lockable.html",
            "wgPageName": "cpp/named_req/Lockable"
        },
        {
            "title": "C++ named requirements: MoveAssignable (since C++11)",
            "path": "en.cppreference.com/w/cpp/named_req/MoveAssignable.html",
            "wgPageName": "cpp/named_req/MoveAssignable"
        },
        {
            "title": "C++ named requirements: MoveConstructible (since C++11)",
            "path": "en.cppreference.com/w/cpp/named_req/MoveConstructible.html",
            "wgPageName": "cpp/named_req/MoveConstructible"
        },
        {
            "title": "C++ named requirements: MoveInsertable (since C++11)",
            "path": "en.cppreference.com/w/cpp/named_req/MoveInsertable.html",
            "wgPageName": "cpp/named_req/MoveInsertable"
        },
        {
            "title": "C++ named requirements: Mutex",
            "path": "en.cppreference.com/w/cpp/named_req/Mutex.html",
            "wgPageName": "cpp/named_req/Mutex"
        },
        {
            "title": "C++ named requirements: NullablePointer (since C++11)",
            "path": "en.cppreference.com/w/cpp/named_req/NullablePointer.html",
            "wgPageName": "cpp/named_req/NullablePointer"
        },
        {
            "title": "C++ named requirements: NumericType",
            "path": "en.cppreference.com/w/cpp/named_req/NumericType.html",
            "wgPageName": "cpp/named_req/NumericType"
        },
        {
            "title": "C++ named requirements: LegacyOutputIterator",
            "path": "en.cppreference.com/w/cpp/named_req/OutputIterator.html",
            "wgPageName": "cpp/named_req/OutputIterator"
        },
        {
            "title": "C++ named requirements: PODType",
            "path": "en.cppreference.com/w/cpp/named_req/PODType.html",
            "wgPageName": "cpp/named_req/PODType"
        },
        {
            "title": "C++ named requirements: Predicate",
            "path": "en.cppreference.com/w/cpp/named_req/Predicate.html",
            "wgPageName": "cpp/named_req/Predicate"
        },
        {
            "title": "C++ named requirements: LegacyRandomAccessIterator",
            "path": "en.cppreference.com/w/cpp/named_req/RandomAccessIterator.html",
            "wgPageName": "cpp/named_req/RandomAccessIterator",
            "sample_declaration": "template<class I>\nconcept __LegacyRandomAccessIterator =\n    __LegacyBidirectionalIterator<I> &&\n    std::totally_ordered<I> && requires(\n        I i,\n        typename std::incrementable_traits<\n            I>::difference_type n) {\n  { i += n } -> std::same_as<I&>;\n  { i -= n } -> std::same_as<I&>;\n  { i + n } -> std::same_as<I>;\n  { n + i } -> std::same_as<I>;\n  { i - n } -> std::same_as<I>;\n  { i - i } -> std::same_as<decltype(n)>;\n  {\n    i[n]\n    } -> std::convertible_to<\n        std::iter_reference_t<I>>;\n};"
        },
        {
            "title": "C++ named requirements: RandomNumberDistribution",
            "path": "en.cppreference.com/w/cpp/named_req/RandomNumberDistribution.html",
            "wgPageName": "cpp/named_req/RandomNumberDistribution"
        },
        {
            "title": "C++ named requirements: RandomNumberEngine",
            "path": "en.cppreference.com/w/cpp/named_req/RandomNumberEngine.html",
            "wgPageName": "cpp/named_req/RandomNumberEngine"
        },
        {
            "title": "C++ named requirements: RandomNumberEngineAdaptor",
            "path": "en.cppreference.com/w/cpp/named_req/RandomNumberEngineAdaptor.html",
            "wgPageName": "cpp/named_req/RandomNumberEngineAdaptor"
        },
        {
            "title": "C++ named requirements: RegexTraits",
            "path": "en.cppreference.com/w/cpp/named_req/RegexTraits.html",
            "wgPageName": "cpp/named_req/RegexTraits",
            "sample_declaration": "template<>\nclass regex_traits<char>;\ntemplate<>\nclass regex_traits<wchar_t>;"
        },
        {
            "title": "C++ named requirements: ReversibleContainer",
            "path": "en.cppreference.com/w/cpp/named_req/ReversibleContainer.html",
            "wgPageName": "cpp/named_req/ReversibleContainer"
        },
        {
            "title": "C++ named requirements: ScalarType",
            "path": "en.cppreference.com/w/cpp/named_req/ScalarType.html",
            "wgPageName": "cpp/named_req/ScalarType"
        },
        {
            "title": "C++ named requirements: SeedSequence",
            "path": "en.cppreference.com/w/cpp/named_req/SeedSequence.html",
            "wgPageName": "cpp/named_req/SeedSequence"
        },
        {
            "title": "C++ named requirements: SequenceContainer",
            "path": "en.cppreference.com/w/cpp/named_req/SequenceContainer.html",
            "wgPageName": "cpp/named_req/SequenceContainer"
        },
        {
            "title": "C++ named requirements: SharedLockable",
            "path": "en.cppreference.com/w/cpp/named_req/SharedLockable.html",
            "wgPageName": "cpp/named_req/SharedLockable"
        },
        {
            "title": "C++ named requirements: SharedMutex",
            "path": "en.cppreference.com/w/cpp/named_req/SharedMutex.html",
            "wgPageName": "cpp/named_req/SharedMutex"
        },
        {
            "title": "C++ named requirements: SharedTimedLockable",
            "path": "en.cppreference.com/w/cpp/named_req/SharedTimedLockable.html",
            "wgPageName": "cpp/named_req/SharedTimedLockable"
        },
        {
            "title": "C++ named requirements: SharedTimedMutex",
            "path": "en.cppreference.com/w/cpp/named_req/SharedTimedMutex.html",
            "wgPageName": "cpp/named_req/SharedTimedMutex"
        },
        {
            "title": "C++ named requirements: StandardLayoutType",
            "path": "en.cppreference.com/w/cpp/named_req/StandardLayoutType.html",
            "wgPageName": "cpp/named_req/StandardLayoutType"
        },
        {
            "title": "C++ named requirements: Swappable",
            "path": "en.cppreference.com/w/cpp/named_req/Swappable.html",
            "wgPageName": "cpp/named_req/Swappable"
        },
        {
            "title": "C++ named requirements: TimedLockable",
            "path": "en.cppreference.com/w/cpp/named_req/TimedLockable.html",
            "wgPageName": "cpp/named_req/TimedLockable"
        },
        {
            "title": "C++ named requirements: TimedMutex",
            "path": "en.cppreference.com/w/cpp/named_req/TimedMutex.html",
            "wgPageName": "cpp/named_req/TimedMutex"
        },
        {
            "title": "C++ named requirements: TransformationTrait",
            "path": "en.cppreference.com/w/cpp/named_req/TransformationTrait.html",
            "wgPageName": "cpp/named_req/TransformationTrait"
        },
        {
            "title": "C++ named requirements: TrivialClock",
            "path": "en.cppreference.com/w/cpp/named_req/TrivialClock.html",
            "wgPageName": "cpp/named_req/TrivialClock"
        },
        {
            "title": "C++ named requirements: TriviallyCopyable",
            "path": "en.cppreference.com/w/cpp/named_req/TriviallyCopyable.html",
            "wgPageName": "cpp/named_req/TriviallyCopyable"
        },
        {
            "title": "C++ named requirements: TrivialType",
            "path": "en.cppreference.com/w/cpp/named_req/TrivialType.html",
            "wgPageName": "cpp/named_req/TrivialType"
        },
        {
            "title": "C++ named requirements: UnaryTypeTrait",
            "path": "en.cppreference.com/w/cpp/named_req/UnaryTypeTrait.html",
            "wgPageName": "cpp/named_req/UnaryTypeTrait"
        },
        {
            "title": "C++ named requirements: UnformattedInputFunction",
            "path": "en.cppreference.com/w/cpp/named_req/UnformattedInputFunction.html",
            "wgPageName": "cpp/named_req/UnformattedInputFunction"
        },
        {
            "title": "C++ named requirements: UnformattedOutputFunction",
            "path": "en.cppreference.com/w/cpp/named_req/UnformattedOutputFunction.html",
            "wgPageName": "cpp/named_req/UnformattedOutputFunction"
        },
        {
            "title": "C++ named requirements: UniformRandomBitGenerator",
            "path": "en.cppreference.com/w/cpp/named_req/UniformRandomBitGenerator.html",
            "wgPageName": "cpp/named_req/UniformRandomBitGenerator"
        },
        {
            "title": "C++ named requirements: UnorderedAssociativeContainer",
            "path": "en.cppreference.com/w/cpp/named_req/UnorderedAssociativeContainer.html",
            "wgPageName": "cpp/named_req/UnorderedAssociativeContainer"
        },
        {
            "title": "C++ named requirements: ValueSwappable",
            "path": "en.cppreference.com/w/cpp/named_req/ValueSwappable.html",
            "wgPageName": "cpp/named_req/ValueSwappable"
        },
        {
            "title": "Numerics library",
            "path": "en.cppreference.com/w/cpp/numeric.html",
            "wgPageName": "cpp/numeric"
        },
        {
            "title": "std::bit_cast",
            "path": "en.cppreference.com/w/cpp/numeric/bit_cast.html",
            "wgPageName": "cpp/numeric/bit_cast",
            "headers": [
                "<bit>"
            ],
            "sample_declaration": "template<class To, class From>\nconstexpr To bit_cast(\n    const From& from) noexcept;"
        },
        {
            "title": "std::bit_ceil",
            "path": "en.cppreference.com/w/cpp/numeric/bit_ceil.html",
            "wgPageName": "cpp/numeric/bit_ceil",
            "headers": [
                "<bit>"
            ],
            "sample_declaration": "template<class T>\nconstexpr T bit_ceil(T x);"
        },
        {
            "title": "std::bit_floor",
            "path": "en.cppreference.com/w/cpp/numeric/bit_floor.html",
            "wgPageName": "cpp/numeric/bit_floor",
            "headers": [
                "<bit>"
            ],
            "sample_declaration": "template<class T>\nconstexpr T bit_floor(T x) noexcept;"
        },
        {
            "title": "std::bit_width",
            "path": "en.cppreference.com/w/cpp/numeric/bit_width.html",
            "wgPageName": "cpp/numeric/bit_width",
            "headers": [
                "<bit>"
            ],
            "sample_declaration": "template<class T>\nconstexpr int bit_width(T x) noexcept;"
        },
        {
            "title": "std::byteswap",
            "path": "en.cppreference.com/w/cpp/numeric/byteswap.html",
            "wgPageName": "cpp/numeric/byteswap",
            "headers": [
                "<bit>"
            ],
            "sample_declaration": "template<class T>\nconstexpr T byteswap(T n) noexcept;"
        },
        {
            "title": "std::complex",
            "path": "en.cppreference.com/w/cpp/numeric/complex.html",
            "wgPageName": "cpp/numeric/complex",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\nclass complex;",
            "other_declarations": 3
        },
        {
            "title": "std::abs(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/abs.html",
            "wgPageName": "cpp/numeric/complex/abs",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\nT abs(const complex<T>& z);"
        },
        {
            "title": "std::acos(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/acos.html",
            "wgPageName": "cpp/numeric/complex/acos",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\ncomplex<T> acos(const complex<T>& z);"
        },
        {
            "title": "std::acosh(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/acosh.html",
            "wgPageName": "cpp/numeric/complex/acosh",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\ncomplex<T> acosh(const complex<T>& z);"
        },
        {
            "title": "std::arg(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/arg.html",
            "wgPageName": "cpp/numeric/complex/arg",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\nT arg(const complex<T>& z);",
            "other_declarations": 3
        },
        {
            "title": "std::asin(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/asin.html",
            "wgPageName": "cpp/numeric/complex/asin",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\ncomplex<T> asin(const complex<T>& z);"
        },
        {
            "title": "std::asinh(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/asinh.html",
            "wgPageName": "cpp/numeric/complex/asinh",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\ncomplex<T> asinh(const complex<T>& z);"
        },
        {
            "title": "std::atan(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/atan.html",
            "wgPageName": "cpp/numeric/complex/atan",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\ncomplex<T> atan(const complex<T>& z);"
        },
        {
            "title": "std::atanh(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/atanh.html",
            "wgPageName": "cpp/numeric/complex/atanh",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\ncomplex<T> atanh(const complex<T>& z);"
        },
        {
            "title": "std::complex<T>::complex",
            "path": "en.cppreference.com/w/cpp/numeric/complex/complex.html",
            "wgPageName": "cpp/numeric/complex/complex",
            "sample_declaration": "complex(const T& re = T(), const T& im = T());",
            "other_declarations": 17
        },
        {
            "title": "std::conj(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/conj.html",
            "wgPageName": "cpp/numeric/complex/conj",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\nstd::complex<T> conj(const std::complex<T>& z);",
            "other_declarations": 3
        },
        {
            "title": "std::cos(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/cos.html",
            "wgPageName": "cpp/numeric/complex/cos",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\ncomplex<T> cos(const complex<T>& z);"
        },
        {
            "title": "std::cosh(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/cosh.html",
            "wgPageName": "cpp/numeric/complex/cosh",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\ncomplex<T> cosh(const complex<T>& z);"
        },
        {
            "title": "std::exp(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/exp.html",
            "wgPageName": "cpp/numeric/complex/exp",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\ncomplex<T> exp(const complex<T>& z);"
        },
        {
            "title": "std::complex<T>::imag",
            "path": "en.cppreference.com/w/cpp/numeric/complex/imag.html",
            "wgPageName": "cpp/numeric/complex/imag",
            "sample_declaration": "T imag() const;",
            "other_declarations": 15
        },
        {
            "title": "std::imag(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/imag2.html",
            "wgPageName": "cpp/numeric/complex/imag2",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\nT imag(const std::complex<T>& z);",
            "other_declarations": 3
        },
        {
            "title": "std::log(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/log.html",
            "wgPageName": "cpp/numeric/complex/log",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\ncomplex<T> log(const complex<T>& z);"
        },
        {
            "title": "std::log10(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/log10.html",
            "wgPageName": "cpp/numeric/complex/log10",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\ncomplex<T> log10(const complex<T>& z);"
        },
        {
            "title": "std::norm(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/norm.html",
            "wgPageName": "cpp/numeric/complex/norm",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\nT norm(const std::complex<T>& z);",
            "other_declarations": 3
        },
        {
            "title": "std::complex<T>::operator+=,-=,*=,/=",
            "path": "en.cppreference.com/w/cpp/numeric/complex/operator_arith.html",
            "wgPageName": "cpp/numeric/complex/operator_arith",
            "sample_declaration": "complex& operator+=(const T& other);",
            "other_declarations": 39
        },
        {
            "title": "std::complex<T>::operator+(unary), operator-(unary)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/operator_arith2.html",
            "wgPageName": "cpp/numeric/complex/operator_arith2",
            "sample_declaration": "template<class T>\nstd::complex<T> operator+(\n    const std::complex<T>& val);",
            "other_declarations": 3
        },
        {
            "title": "operator+,-,*,/ (std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/operator_arith3.html",
            "wgPageName": "cpp/numeric/complex/operator_arith3",
            "sample_declaration": "template<class T>\nstd::complex<T> operator+(\n    const std::complex<T>& lhs,\n    const std::complex<T>& rhs);",
            "other_declarations": 23
        },
        {
            "title": "operator==,!=(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/operator_cmp.html",
            "wgPageName": "cpp/numeric/complex/operator_cmp",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\nbool operator==(\n    const complex<T>& lhs,\n    const complex<T>& rhs);",
            "other_declarations": 11
        },
        {
            "title": "operator<<,>>(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/complex/operator_ltltgtgt",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T, class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::complex<T>& x);",
            "other_declarations": 1
        },
        {
            "title": "std::literals::complex_literals::operator\"\"i, operator\"\"if, operator\"\"il",
            "path": "en.cppreference.com/w/cpp/numeric/complex/operator\"\"i.html",
            "wgPageName": "cpp/numeric/complex/operator\\\"\\\"i",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "constexpr complex<double> operator\"\"i(\n    long double arg);\nconstexpr complex<double> operator\"\"i(\n    unsigned long long arg);",
            "other_declarations": 2
        },
        {
            "title": "std::complex<T>::operator=",
            "path": "en.cppreference.com/w/cpp/numeric/complex/operator=.html",
            "wgPageName": "cpp/numeric/complex/operator=",
            "sample_declaration": "complex& operator=(const T& x);",
            "other_declarations": 11
        },
        {
            "title": "std::polar(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/polar.html",
            "wgPageName": "cpp/numeric/complex/polar",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\ncomplex<T> polar(\n    const T& r,\n    const T& theta = T());"
        },
        {
            "title": "std::pow(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/pow.html",
            "wgPageName": "cpp/numeric/complex/pow",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\ncomplex<T> pow(\n    const complex<T>& x,\n    const complex<T>& y);",
            "other_declarations": 5
        },
        {
            "title": "std::proj(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/proj.html",
            "wgPageName": "cpp/numeric/complex/proj",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\nstd::complex<T> proj(const std::complex<T>& z);",
            "other_declarations": 3
        },
        {
            "title": "std::complex<T>::real",
            "path": "en.cppreference.com/w/cpp/numeric/complex/real.html",
            "wgPageName": "cpp/numeric/complex/real",
            "sample_declaration": "T real() const;",
            "other_declarations": 15
        },
        {
            "title": "std::real(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/real2.html",
            "wgPageName": "cpp/numeric/complex/real2",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\nT real(const std::complex<T>& z);",
            "other_declarations": 3
        },
        {
            "title": "std::sin(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/sin.html",
            "wgPageName": "cpp/numeric/complex/sin",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\ncomplex<T> sin(const complex<T>& z);"
        },
        {
            "title": "std::sinh(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/sinh.html",
            "wgPageName": "cpp/numeric/complex/sinh",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\ncomplex<T> sinh(const complex<T>& z);"
        },
        {
            "title": "std::sqrt(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/sqrt.html",
            "wgPageName": "cpp/numeric/complex/sqrt",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\ncomplex<T> sqrt(const complex<T>& z);"
        },
        {
            "title": "std::tan(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/tan.html",
            "wgPageName": "cpp/numeric/complex/tan",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\ncomplex<T> tan(const complex<T>& z);"
        },
        {
            "title": "std::tanh(std::complex)",
            "path": "en.cppreference.com/w/cpp/numeric/complex/tanh.html",
            "wgPageName": "cpp/numeric/complex/tanh",
            "headers": [
                "<complex>"
            ],
            "sample_declaration": "template<class T>\ncomplex<T> tanh(const complex<T>& z);"
        },
        {
            "title": "Mathematical constants",
            "path": "en.cppreference.com/w/cpp/numeric/constants.html",
            "wgPageName": "cpp/numeric/constants"
        },
        {
            "title": "std::countl_one",
            "path": "en.cppreference.com/w/cpp/numeric/countl_one.html",
            "wgPageName": "cpp/numeric/countl_one",
            "headers": [
                "<bit>"
            ],
            "sample_declaration": "template<class T>\nconstexpr int countl_one(T x) noexcept;"
        },
        {
            "title": "std::countl_zero",
            "path": "en.cppreference.com/w/cpp/numeric/countl_zero.html",
            "wgPageName": "cpp/numeric/countl_zero",
            "headers": [
                "<bit>"
            ],
            "sample_declaration": "template<class T>\nconstexpr int countl_zero(T x) noexcept;"
        },
        {
            "title": "std::countr_one",
            "path": "en.cppreference.com/w/cpp/numeric/countr_one.html",
            "wgPageName": "cpp/numeric/countr_one",
            "headers": [
                "<bit>"
            ],
            "sample_declaration": "template<class T>\nconstexpr int countr_one(T x) noexcept;"
        },
        {
            "title": "std::countr_zero",
            "path": "en.cppreference.com/w/cpp/numeric/countr_zero.html",
            "wgPageName": "cpp/numeric/countr_zero",
            "headers": [
                "<bit>"
            ],
            "sample_declaration": "template<class T>\nconstexpr int countr_zero(T x) noexcept;"
        },
        {
            "title": "Floating-point environment",
            "path": "en.cppreference.com/w/cpp/numeric/fenv.html",
            "wgPageName": "cpp/numeric/fenv"
        },
        {
            "title": "FE_DFL_ENV",
            "path": "en.cppreference.com/w/cpp/numeric/fenv/FE_DFL_ENV.html",
            "wgPageName": "cpp/numeric/fenv/FE_DFL_ENV",
            "headers": [
                "<cfenv>"
            ],
            "sample_declaration": "#define FE_DFL_ENV /*implementation defined*/"
        },
        {
            "title": "FE_DIVBYZERO, FE_INEXACT, FE_INVALID, FE_OVERFLOW, FE_UNDERFLOW, FE_ALL_EXCEPT",
            "path": "en.cppreference.com/w/cpp/numeric/fenv/FE_exceptions.html",
            "wgPageName": "cpp/numeric/fenv/FE_exceptions",
            "headers": [
                "<cfenv>"
            ],
            "sample_declaration": "#define FE_DIVBYZERO /*implementation defined \\\n                        power of 2*/",
            "other_declarations": 5
        },
        {
            "title": "FE_DOWNWARD, FE_TONEAREST, FE_TOWARDZERO, FE_UPWARD",
            "path": "en.cppreference.com/w/cpp/numeric/fenv/FE_round.html",
            "wgPageName": "cpp/numeric/fenv/FE_round",
            "headers": [
                "<cfenv>"
            ],
            "sample_declaration": "#define FE_DOWNWARD /*implementation defined*/",
            "other_declarations": 3
        },
        {
            "title": "std::feclearexcept",
            "path": "en.cppreference.com/w/cpp/numeric/fenv/feclearexcept.html",
            "wgPageName": "cpp/numeric/fenv/feclearexcept",
            "headers": [
                "<cfenv>"
            ],
            "sample_declaration": "int feclearexcept(int excepts);"
        },
        {
            "title": "std::fegetenv, std::fesetenv",
            "path": "en.cppreference.com/w/cpp/numeric/fenv/feenv.html",
            "wgPageName": "cpp/numeric/fenv/feenv",
            "headers": [
                "<cfenv>"
            ],
            "sample_declaration": "int fegetenv(std::fenv_t* envp)",
            "other_declarations": 1
        },
        {
            "title": "std::fegetexceptflag, std::fesetexceptflag",
            "path": "en.cppreference.com/w/cpp/numeric/fenv/feexceptflag.html",
            "wgPageName": "cpp/numeric/fenv/feexceptflag",
            "headers": [
                "<cfenv>"
            ],
            "sample_declaration": "int fegetexceptflag(\n    std::fexcept_t* flagp,\n    int excepts);",
            "other_declarations": 1
        },
        {
            "title": "std::feholdexcept",
            "path": "en.cppreference.com/w/cpp/numeric/fenv/feholdexcept.html",
            "wgPageName": "cpp/numeric/fenv/feholdexcept",
            "headers": [
                "<cfenv>"
            ],
            "sample_declaration": "int feholdexcept(std::fenv_t* envp)"
        },
        {
            "title": "std::feraiseexcept",
            "path": "en.cppreference.com/w/cpp/numeric/fenv/feraiseexcept.html",
            "wgPageName": "cpp/numeric/fenv/feraiseexcept",
            "headers": [
                "<cfenv>"
            ],
            "sample_declaration": "int feraiseexcept(int excepts);"
        },
        {
            "title": "std::fegetround, std::fesetround",
            "path": "en.cppreference.com/w/cpp/numeric/fenv/feround.html",
            "wgPageName": "cpp/numeric/fenv/feround",
            "headers": [
                "<cfenv>"
            ],
            "sample_declaration": "int fesetround(int round)",
            "other_declarations": 1
        },
        {
            "title": "std::fetestexcept",
            "path": "en.cppreference.com/w/cpp/numeric/fenv/fetestexcept.html",
            "wgPageName": "cpp/numeric/fenv/fetestexcept",
            "headers": [
                "<cfenv>"
            ],
            "sample_declaration": "int fetestexcept(int excepts);"
        },
        {
            "title": "std::feupdateenv",
            "path": "en.cppreference.com/w/cpp/numeric/fenv/feupdateenv.html",
            "wgPageName": "cpp/numeric/fenv/feupdateenv",
            "headers": [
                "<cfenv>"
            ],
            "sample_declaration": "int feupdateenv(const std::fenv_t* envp)"
        },
        {
            "title": "std::gcd",
            "path": "en.cppreference.com/w/cpp/numeric/gcd.html",
            "wgPageName": "cpp/numeric/gcd",
            "headers": [
                "<numeric>"
            ],
            "sample_declaration": "template<class M, class N>\nconstexpr std::common_type_t<M, N> gcd(\n    M m,\n    N n);"
        },
        {
            "title": "std::has_single_bit",
            "path": "en.cppreference.com/w/cpp/numeric/has_single_bit.html",
            "wgPageName": "cpp/numeric/has_single_bit",
            "headers": [
                "<bit>"
            ],
            "sample_declaration": "template<class T>\nconstexpr bool has_single_bit(T x) noexcept;"
        },
        {
            "title": "std::lcm",
            "path": "en.cppreference.com/w/cpp/numeric/lcm.html",
            "wgPageName": "cpp/numeric/lcm",
            "headers": [
                "<numeric>"
            ],
            "sample_declaration": "template<class M, class N>\nconstexpr std::common_type_t<M, N> lcm(\n    M m,\n    N n);"
        },
        {
            "title": "std::lerp",
            "path": "en.cppreference.com/w/cpp/numeric/lerp.html",
            "wgPageName": "cpp/numeric/lerp",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "constexpr float\nlerp(float a, float b, float t) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "Common mathematical functions",
            "path": "en.cppreference.com/w/cpp/numeric/math.html",
            "wgPageName": "cpp/numeric/math"
        },
        {
            "title": "std::abs, std::labs, std::llabs, std::imaxabs",
            "path": "en.cppreference.com/w/cpp/numeric/math/abs.html",
            "wgPageName": "cpp/numeric/math/abs",
            "headers": [
                "<cstdlib>",
                "<cmath>",
                "<cstdlib>",
                "<cinttypes>"
            ],
            "sample_declaration": "int abs(int n);",
            "other_declarations": 6
        },
        {
            "title": "std::acos, std::acosf, std::acosl",
            "path": "en.cppreference.com/w/cpp/numeric/math/acos.html",
            "wgPageName": "cpp/numeric/math/acos",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float acos(float arg);",
            "other_declarations": 5
        },
        {
            "title": "std::acosh, std::acoshf, std::acoshl",
            "path": "en.cppreference.com/w/cpp/numeric/math/acosh.html",
            "wgPageName": "cpp/numeric/math/acosh",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float acosh(float arg);\nfloat acoshf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "std::asin, std::asinf, std::asinl",
            "path": "en.cppreference.com/w/cpp/numeric/math/asin.html",
            "wgPageName": "cpp/numeric/math/asin",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float asin(float arg);",
            "other_declarations": 5
        },
        {
            "title": "std::asinh, std::asinhf, std::asinhl",
            "path": "en.cppreference.com/w/cpp/numeric/math/asinh.html",
            "wgPageName": "cpp/numeric/math/asinh",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float asinh(float arg);\nfloat asinhf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "std::atan, std::atanf, std::atanl",
            "path": "en.cppreference.com/w/cpp/numeric/math/atan.html",
            "wgPageName": "cpp/numeric/math/atan",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float atan(float arg);",
            "other_declarations": 5
        },
        {
            "title": "std::atan2, std::atan2f, std::atan2l",
            "path": "en.cppreference.com/w/cpp/numeric/math/atan2.html",
            "wgPageName": "cpp/numeric/math/atan2",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float atan2(float y, float x);",
            "other_declarations": 5
        },
        {
            "title": "std::atanh, std::atanhf, std::atanhl",
            "path": "en.cppreference.com/w/cpp/numeric/math/atanh.html",
            "wgPageName": "cpp/numeric/math/atanh",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float atanh(float arg);\nfloat atanhf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "std::cbrt, std::cbrtf, std::cbrtl",
            "path": "en.cppreference.com/w/cpp/numeric/math/cbrt.html",
            "wgPageName": "cpp/numeric/math/cbrt",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float cbrt(float arg);\nfloat cbrtf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "std::ceil, std::ceilf, std::ceill",
            "path": "en.cppreference.com/w/cpp/numeric/math/ceil.html",
            "wgPageName": "cpp/numeric/math/ceil",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float ceil(float arg);",
            "other_declarations": 5
        },
        {
            "title": "std::copysign, std::copysignf, std::copysignl",
            "path": "en.cppreference.com/w/cpp/numeric/math/copysign.html",
            "wgPageName": "cpp/numeric/math/copysign",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float copysign(float mag, float sgn);",
            "other_declarations": 5
        },
        {
            "title": "std::cos, std::cosf, std::cosl",
            "path": "en.cppreference.com/w/cpp/numeric/math/cos.html",
            "wgPageName": "cpp/numeric/math/cos",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float cos(float arg);",
            "other_declarations": 5
        },
        {
            "title": "std::cosh, std::coshf, std::coshl",
            "path": "en.cppreference.com/w/cpp/numeric/math/cosh.html",
            "wgPageName": "cpp/numeric/math/cosh",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float cosh(float arg);",
            "other_declarations": 5
        },
        {
            "title": "std::div, std::ldiv, std::lldiv",
            "path": "en.cppreference.com/w/cpp/numeric/math/div.html",
            "wgPageName": "cpp/numeric/math/div",
            "headers": [
                "<cstdlib>",
                "<cinttypes>"
            ],
            "sample_declaration": "std::div_t div(int x, int y);",
            "other_declarations": 6
        },
        {
            "title": "std::erf, std::erff, std::erfl",
            "path": "en.cppreference.com/w/cpp/numeric/math/erf.html",
            "wgPageName": "cpp/numeric/math/erf",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float erf(float arg);\nfloat erff(float arg);",
            "other_declarations": 3
        },
        {
            "title": "std::erfc, std::erfcf, std::erfcl",
            "path": "en.cppreference.com/w/cpp/numeric/math/erfc.html",
            "wgPageName": "cpp/numeric/math/erfc",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float erfc(float arg);\nfloat erfcf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "std::exp, std::expf, std::expl",
            "path": "en.cppreference.com/w/cpp/numeric/math/exp.html",
            "wgPageName": "cpp/numeric/math/exp",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float exp(float arg);",
            "other_declarations": 5
        },
        {
            "title": "std::exp2, std::exp2f, std::exp2l",
            "path": "en.cppreference.com/w/cpp/numeric/math/exp2.html",
            "wgPageName": "cpp/numeric/math/exp2",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float exp2(float n);\nfloat exp2f(float n);",
            "other_declarations": 3
        },
        {
            "title": "std::expm1, std::expm1f, std::expm1l",
            "path": "en.cppreference.com/w/cpp/numeric/math/expm1.html",
            "wgPageName": "cpp/numeric/math/expm1",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float expm1(float arg);\nfloat expm1f(float arg);",
            "other_declarations": 3
        },
        {
            "title": "std::abs(float), std::fabs, std::fabsf, std::fabsl",
            "path": "en.cppreference.com/w/cpp/numeric/math/fabs.html",
            "wgPageName": "cpp/numeric/math/fabs",
            "headers": [
                "<cmath>",
                "<cstdlib>",
                "<cmath>"
            ],
            "sample_declaration": "float abs(float arg);",
            "other_declarations": 8
        },
        {
            "title": "std::fdim, std::fdimf, std::fdiml",
            "path": "en.cppreference.com/w/cpp/numeric/math/fdim.html",
            "wgPageName": "cpp/numeric/math/fdim",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float fdim(float x, float y);",
            "other_declarations": 5
        },
        {
            "title": "std::floor, std::floorf, std::floorl",
            "path": "en.cppreference.com/w/cpp/numeric/math/floor.html",
            "wgPageName": "cpp/numeric/math/floor",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float floor(float arg);",
            "other_declarations": 5
        },
        {
            "title": "std::fma, std::fmaf, std::fmal",
            "path": "en.cppreference.com/w/cpp/numeric/math/fma.html",
            "wgPageName": "cpp/numeric/math/fma",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float fma(float x, float y, float z);",
            "other_declarations": 8
        },
        {
            "title": "std::fmax, std::fmaxf, std::fmaxl",
            "path": "en.cppreference.com/w/cpp/numeric/math/fmax.html",
            "wgPageName": "cpp/numeric/math/fmax",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float fmax(float x, float y);",
            "other_declarations": 5
        },
        {
            "title": "std::fmin, std::fminf, std::fminl",
            "path": "en.cppreference.com/w/cpp/numeric/math/fmin.html",
            "wgPageName": "cpp/numeric/math/fmin",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float fmin(float x, float y);",
            "other_declarations": 5
        },
        {
            "title": "std::fmod, std::fmodf, std::fmodl",
            "path": "en.cppreference.com/w/cpp/numeric/math/fmod.html",
            "wgPageName": "cpp/numeric/math/fmod",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float fmod(float x, float y);",
            "other_declarations": 5
        },
        {
            "title": "FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN",
            "path": "en.cppreference.com/w/cpp/numeric/math/FP_categories.html",
            "wgPageName": "cpp/numeric/math/FP_categories",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "#define FP_NORMAL /*implementation defined*/",
            "other_declarations": 4
        },
        {
            "title": "std::fpclassify",
            "path": "en.cppreference.com/w/cpp/numeric/math/fpclassify.html",
            "wgPageName": "cpp/numeric/math/fpclassify",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "int fpclassify(float arg);",
            "other_declarations": 3
        },
        {
            "title": "std::frexp, std::frexpf, std::frexpl",
            "path": "en.cppreference.com/w/cpp/numeric/math/frexp.html",
            "wgPageName": "cpp/numeric/math/frexp",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float frexp(float arg, int* exp);",
            "other_declarations": 5
        },
        {
            "title": "HUGE_VALF, HUGE_VAL, HUGE_VALL",
            "path": "en.cppreference.com/w/cpp/numeric/math/HUGE_VAL.html",
            "wgPageName": "cpp/numeric/math/HUGE_VAL",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "#define HUGE_VALF /*implementation defined*/",
            "other_declarations": 2
        },
        {
            "title": "std::hypot, std::hypotf, std::hypotl",
            "path": "en.cppreference.com/w/cpp/numeric/math/hypot.html",
            "wgPageName": "cpp/numeric/math/hypot",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float hypot(float x, float y);\nfloat hypotf(float x, float y);",
            "other_declarations": 7
        },
        {
            "title": "std::ilogb, std::ilogbf, std::ilogbl",
            "path": "en.cppreference.com/w/cpp/numeric/math/ilogb.html",
            "wgPageName": "cpp/numeric/math/ilogb",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "int ilogb(float arg);\nint ilogbf(float arg);",
            "other_declarations": 5
        },
        {
            "title": "INFINITY",
            "path": "en.cppreference.com/w/cpp/numeric/math/INFINITY.html",
            "wgPageName": "cpp/numeric/math/INFINITY",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "#define INFINITY /*implementation defined*/"
        },
        {
            "title": "std::isfinite",
            "path": "en.cppreference.com/w/cpp/numeric/math/isfinite.html",
            "wgPageName": "cpp/numeric/math/isfinite",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "bool isfinite(float arg);",
            "other_declarations": 3
        },
        {
            "title": "std::isgreater",
            "path": "en.cppreference.com/w/cpp/numeric/math/isgreater.html",
            "wgPageName": "cpp/numeric/math/isgreater",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "bool isgreater(float x, float y);",
            "other_declarations": 3
        },
        {
            "title": "std::isgreaterequal",
            "path": "en.cppreference.com/w/cpp/numeric/math/isgreaterequal.html",
            "wgPageName": "cpp/numeric/math/isgreaterequal",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "bool isgreaterequal(float x, float y);",
            "other_declarations": 3
        },
        {
            "title": "std::isinf",
            "path": "en.cppreference.com/w/cpp/numeric/math/isinf.html",
            "wgPageName": "cpp/numeric/math/isinf",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "bool isinf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "std::isless",
            "path": "en.cppreference.com/w/cpp/numeric/math/isless.html",
            "wgPageName": "cpp/numeric/math/isless",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "bool isless(float x, float y);",
            "other_declarations": 3
        },
        {
            "title": "std::islessequal",
            "path": "en.cppreference.com/w/cpp/numeric/math/islessequal.html",
            "wgPageName": "cpp/numeric/math/islessequal",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "bool islessequal(float x, float y);",
            "other_declarations": 3
        },
        {
            "title": "std::islessgreater",
            "path": "en.cppreference.com/w/cpp/numeric/math/islessgreater.html",
            "wgPageName": "cpp/numeric/math/islessgreater",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "bool islessgreater(float x, float y);",
            "other_declarations": 3
        },
        {
            "title": "std::isnan",
            "path": "en.cppreference.com/w/cpp/numeric/math/isnan.html",
            "wgPageName": "cpp/numeric/math/isnan",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "bool isnan(float arg);",
            "other_declarations": 3
        },
        {
            "title": "std::isnormal",
            "path": "en.cppreference.com/w/cpp/numeric/math/isnormal.html",
            "wgPageName": "cpp/numeric/math/isnormal",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "bool isnormal(float arg);",
            "other_declarations": 3
        },
        {
            "title": "std::isunordered",
            "path": "en.cppreference.com/w/cpp/numeric/math/isunordered.html",
            "wgPageName": "cpp/numeric/math/isunordered",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "bool isunordered(float x, float y);",
            "other_declarations": 3
        },
        {
            "title": "std::ldexp, std::ldexpf, std::ldexpl",
            "path": "en.cppreference.com/w/cpp/numeric/math/ldexp.html",
            "wgPageName": "cpp/numeric/math/ldexp",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float ldexp(float x, int exp);",
            "other_declarations": 5
        },
        {
            "title": "std::lgamma, std::lgammaf, std::lgammal",
            "path": "en.cppreference.com/w/cpp/numeric/math/lgamma.html",
            "wgPageName": "cpp/numeric/math/lgamma",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float lgamma(float arg);\nfloat lgammaf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "std::log, std::logf, std::logl",
            "path": "en.cppreference.com/w/cpp/numeric/math/log.html",
            "wgPageName": "cpp/numeric/math/log",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float log(float arg);",
            "other_declarations": 5
        },
        {
            "title": "std::log10, std::log10f, std::log10l",
            "path": "en.cppreference.com/w/cpp/numeric/math/log10.html",
            "wgPageName": "cpp/numeric/math/log10",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float log10(float arg);",
            "other_declarations": 5
        },
        {
            "title": "std::log1p, std::log1pf, std::log1pl",
            "path": "en.cppreference.com/w/cpp/numeric/math/log1p.html",
            "wgPageName": "cpp/numeric/math/log1p",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float log1p(float arg);\nfloat log1pf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "std::log2, std::log2f, std::log2l",
            "path": "en.cppreference.com/w/cpp/numeric/math/log2.html",
            "wgPageName": "cpp/numeric/math/log2",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float log2(float arg);\nfloat log2f(float arg);",
            "other_declarations": 3
        },
        {
            "title": "std::logb, std::logbf, std::logbl",
            "path": "en.cppreference.com/w/cpp/numeric/math/logb.html",
            "wgPageName": "cpp/numeric/math/logb",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float logb(float arg);",
            "other_declarations": 5
        },
        {
            "title": "MATH_ERRNO, MATH_ERREXCEPT, math_errhandling",
            "path": "en.cppreference.com/w/cpp/numeric/math/math_errhandling.html",
            "wgPageName": "cpp/numeric/math/math_errhandling",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "#define MATH_ERRNO 1",
            "other_declarations": 2
        },
        {
            "title": "std::modf, std::modff, std::modfl",
            "path": "en.cppreference.com/w/cpp/numeric/math/modf.html",
            "wgPageName": "cpp/numeric/math/modf",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float modf(float x, float* iptr);",
            "other_declarations": 4
        },
        {
            "title": "std::nan, std::nanf, std::nanl",
            "path": "en.cppreference.com/w/cpp/numeric/math/nan.html",
            "wgPageName": "cpp/numeric/math/nan",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float nanf(const char* arg);",
            "other_declarations": 2
        },
        {
            "title": "std::nearbyint, std::nearbyintf, std::nearbyintl",
            "path": "en.cppreference.com/w/cpp/numeric/math/nearbyint.html",
            "wgPageName": "cpp/numeric/math/nearbyint",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float nearbyint(float arg);\nfloat nearbyintf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "std::nextafter, std::nextafterf, std::nextafterl, std::nexttoward, std::nexttowardf, std::nexttowardl",
            "path": "en.cppreference.com/w/cpp/numeric/math/nextafter.html",
            "wgPageName": "cpp/numeric/math/nextafter",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float nextafter(float from, float to);",
            "other_declarations": 11
        },
        {
            "title": "std::pow, std::powf, std::powl",
            "path": "en.cppreference.com/w/cpp/numeric/math/pow.html",
            "wgPageName": "cpp/numeric/math/pow",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float pow(float base, float exp);",
            "other_declarations": 8
        },
        {
            "title": "std::remainder, std::remainderf, std::remainderl",
            "path": "en.cppreference.com/w/cpp/numeric/math/remainder.html",
            "wgPageName": "cpp/numeric/math/remainder",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float remainder(float x, float y);",
            "other_declarations": 5
        },
        {
            "title": "std::remquo, std::remquof, std::remquol",
            "path": "en.cppreference.com/w/cpp/numeric/math/remquo.html",
            "wgPageName": "cpp/numeric/math/remquo",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float remquo(float x, float y, int* quo);",
            "other_declarations": 5
        },
        {
            "title": "std::rint, std::rintf, std::rintl, std::lrint, std::lrintf, std::lrintl, std::llrint, std::llrintf",
            "path": "en.cppreference.com/w/cpp/numeric/math/rint.html",
            "wgPageName": "cpp/numeric/math/rint",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float rint(float arg);\nfloat rintf(float arg);",
            "other_declarations": 11
        },
        {
            "title": "std::round, std::roundf, std::roundl, std::lround, std::lroundf, std::lroundl, std::llround, std::llroundf",
            "path": "en.cppreference.com/w/cpp/numeric/math/round.html",
            "wgPageName": "cpp/numeric/math/round",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float round(float arg);",
            "other_declarations": 17
        },
        {
            "title": "std::scalbn, std::scalbnf, std::scalbnl, std::scalbln, std::scalblnf, std::scalblnl",
            "path": "en.cppreference.com/w/cpp/numeric/math/scalbn.html",
            "wgPageName": "cpp/numeric/math/scalbn",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float scalbn(float x, int exp);",
            "other_declarations": 11
        },
        {
            "title": "std::signbit",
            "path": "en.cppreference.com/w/cpp/numeric/math/signbit.html",
            "wgPageName": "cpp/numeric/math/signbit",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "bool signbit(float arg);",
            "other_declarations": 3
        },
        {
            "title": "std::sin, std::sinf, std::sinl",
            "path": "en.cppreference.com/w/cpp/numeric/math/sin.html",
            "wgPageName": "cpp/numeric/math/sin",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float sin(float arg);",
            "other_declarations": 5
        },
        {
            "title": "std::sinh, std::sinhf, std::sinhl",
            "path": "en.cppreference.com/w/cpp/numeric/math/sinh.html",
            "wgPageName": "cpp/numeric/math/sinh",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float sinh(float arg);",
            "other_declarations": 5
        },
        {
            "title": "std::sqrt, std::sqrtf, std::sqrtl",
            "path": "en.cppreference.com/w/cpp/numeric/math/sqrt.html",
            "wgPageName": "cpp/numeric/math/sqrt",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float sqrt(float arg);",
            "other_declarations": 5
        },
        {
            "title": "std::tan, std::tanf, std::tanl",
            "path": "en.cppreference.com/w/cpp/numeric/math/tan.html",
            "wgPageName": "cpp/numeric/math/tan",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float tan(float arg);",
            "other_declarations": 5
        },
        {
            "title": "std::tanh, std::tanhf, std::tanhl",
            "path": "en.cppreference.com/w/cpp/numeric/math/tanh.html",
            "wgPageName": "cpp/numeric/math/tanh",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float tanh(float arg);",
            "other_declarations": 5
        },
        {
            "title": "std::tgamma, std::tgammaf, std::tgammal",
            "path": "en.cppreference.com/w/cpp/numeric/math/tgamma.html",
            "wgPageName": "cpp/numeric/math/tgamma",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float tgamma(float arg);\nfloat tgammaf(float arg);",
            "other_declarations": 3
        },
        {
            "title": "std::trunc, std::truncf, std::truncl",
            "path": "en.cppreference.com/w/cpp/numeric/math/trunc.html",
            "wgPageName": "cpp/numeric/math/trunc",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "float trunc(float arg);",
            "other_declarations": 5
        },
        {
            "title": "std::midpoint",
            "path": "en.cppreference.com/w/cpp/numeric/midpoint.html",
            "wgPageName": "cpp/numeric/midpoint",
            "headers": [
                "<numeric>"
            ],
            "sample_declaration": "template<class T>\nconstexpr T midpoint(T a, T b) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::popcount",
            "path": "en.cppreference.com/w/cpp/numeric/popcount.html",
            "wgPageName": "cpp/numeric/popcount",
            "headers": [
                "<bit>"
            ],
            "sample_declaration": "template<class T>\nconstexpr int popcount(T x) noexcept;"
        },
        {
            "title": "Pseudo-random number generation",
            "path": "en.cppreference.com/w/cpp/numeric/random.html",
            "wgPageName": "cpp/numeric/random"
        },
        {
            "title": "std::bernoulli_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/bernoulli_distribution.html",
            "wgPageName": "cpp/numeric/random/bernoulli_distribution",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "class bernoulli_distribution;"
        },
        {
            "title": "std::bernoulli_distribution::bernoulli_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/bernoulli_distribution/bernoulli_distribution.html",
            "wgPageName": "cpp/numeric/random/bernoulli_distribution/bernoulli_distribution",
            "sample_declaration": "bernoulli_distribution()\n    : bernoulli_distribution(0.5) {}",
            "other_declarations": 2
        },
        {
            "title": "std::bernoulli_distribution::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/bernoulli_distribution/max.html",
            "wgPageName": "cpp/numeric/random/bernoulli_distribution/max",
            "sample_declaration": "result_type max() const;"
        },
        {
            "title": "std::bernoulli_distribution::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/bernoulli_distribution/min.html",
            "wgPageName": "cpp/numeric/random/bernoulli_distribution/min",
            "sample_declaration": "result_type min() const;"
        },
        {
            "title": "operator==,!=(std::bernoulli_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/bernoulli_distribution/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/bernoulli_distribution/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const bernoulli_distribution& lhs,\n    const bernoulli_distribution& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::bernoulli_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/bernoulli_distribution/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/bernoulli_distribution/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    const bernoulli_distribution& d);",
            "other_declarations": 1
        },
        {
            "title": "std::bernoulli_distribution::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/bernoulli_distribution/operator().html",
            "wgPageName": "cpp/numeric/random/bernoulli_distribution/operator()",
            "sample_declaration": "template<class Generator>\nresult_type operator()(Generator& g);",
            "other_declarations": 1
        },
        {
            "title": "std::bernoulli_distribution::p",
            "path": "en.cppreference.com/w/cpp/numeric/random/bernoulli_distribution/p.html",
            "wgPageName": "cpp/numeric/random/bernoulli_distribution/p",
            "sample_declaration": "double p() const;"
        },
        {
            "title": "std::bernoulli_distribution::param",
            "path": "en.cppreference.com/w/cpp/numeric/random/bernoulli_distribution/param.html",
            "wgPageName": "cpp/numeric/random/bernoulli_distribution/param",
            "sample_declaration": "param_type param() const;",
            "other_declarations": 1
        },
        {
            "title": "std::bernoulli_distribution::reset",
            "path": "en.cppreference.com/w/cpp/numeric/random/bernoulli_distribution/reset.html",
            "wgPageName": "cpp/numeric/random/bernoulli_distribution/reset",
            "sample_declaration": "void reset();"
        },
        {
            "title": "std::binomial_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/binomial_distribution.html",
            "wgPageName": "cpp/numeric/random/binomial_distribution",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<class IntType = int>\nclass binomial_distribution;"
        },
        {
            "title": "std::binomial_distribution<IntType>::binomial_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/binomial_distribution/binomial_distribution.html",
            "wgPageName": "cpp/numeric/random/binomial_distribution/binomial_distribution",
            "sample_declaration": "binomial_distribution()\n    : binomial_distribution(1) {}",
            "other_declarations": 2
        },
        {
            "title": "std::binomial_distribution<IntType>::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/binomial_distribution/max.html",
            "wgPageName": "cpp/numeric/random/binomial_distribution/max",
            "sample_declaration": "result_type max() const;"
        },
        {
            "title": "std::binomial_distribution<IntType>::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/binomial_distribution/min.html",
            "wgPageName": "cpp/numeric/random/binomial_distribution/min",
            "sample_declaration": "result_type min() const;"
        },
        {
            "title": "operator==,!=(std::binomial_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/binomial_distribution/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/binomial_distribution/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const binomial_distribution& lhs,\n    const binomial_distribution& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::binomial_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/binomial_distribution/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/binomial_distribution/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    const binomial_distribution& d);",
            "other_declarations": 1
        },
        {
            "title": "std::binomial_distribution<IntType>::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/binomial_distribution/operator().html",
            "wgPageName": "cpp/numeric/random/binomial_distribution/operator()",
            "sample_declaration": "template<class Generator>\nresult_type operator()(Generator& g);",
            "other_declarations": 1
        },
        {
            "title": "std::binomial_distribution<IntType>::param",
            "path": "en.cppreference.com/w/cpp/numeric/random/binomial_distribution/param.html",
            "wgPageName": "cpp/numeric/random/binomial_distribution/param",
            "sample_declaration": "param_type param() const;",
            "other_declarations": 1
        },
        {
            "title": "std::binomial_distribution<IntType>::p, t",
            "path": "en.cppreference.com/w/cpp/numeric/random/binomial_distribution/params.html",
            "wgPageName": "cpp/numeric/random/binomial_distribution/params",
            "sample_declaration": "double p() const;",
            "other_declarations": 1
        },
        {
            "title": "std::binomial_distribution<IntType>::reset",
            "path": "en.cppreference.com/w/cpp/numeric/random/binomial_distribution/reset.html",
            "wgPageName": "cpp/numeric/random/binomial_distribution/reset",
            "sample_declaration": "void reset();"
        },
        {
            "title": "std::cauchy_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/cauchy_distribution.html",
            "wgPageName": "cpp/numeric/random/cauchy_distribution",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<class RealType = double>\nclass cauchy_distribution;"
        },
        {
            "title": "std::cauchy_distribution<RealType>::cauchy_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/cauchy_distribution/cauchy_distribution.html",
            "wgPageName": "cpp/numeric/random/cauchy_distribution/cauchy_distribution",
            "sample_declaration": "cauchy_distribution()\n    : cauchy_distribution(0.0) {}",
            "other_declarations": 2
        },
        {
            "title": "std::cauchy_distribution<RealType>::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/cauchy_distribution/max.html",
            "wgPageName": "cpp/numeric/random/cauchy_distribution/max",
            "sample_declaration": "result_type max() const;"
        },
        {
            "title": "std::cauchy_distribution<RealType>::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/cauchy_distribution/min.html",
            "wgPageName": "cpp/numeric/random/cauchy_distribution/min",
            "sample_declaration": "result_type min() const;"
        },
        {
            "title": "operator==,!=(std::cauchy_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/cauchy_distribution/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/cauchy_distribution/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const cauchy_distribution& lhs,\n    const cauchy_distribution& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::cauchy_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/cauchy_distribution/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/cauchy_distribution/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    const cauchy_distribution& d);",
            "other_declarations": 1
        },
        {
            "title": "std::cauchy_distribution<RealType>::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/cauchy_distribution/operator().html",
            "wgPageName": "cpp/numeric/random/cauchy_distribution/operator()",
            "sample_declaration": "template<class Generator>\nresult_type operator()(Generator& g);",
            "other_declarations": 1
        },
        {
            "title": "std::cauchy_distribution<RealType>::param",
            "path": "en.cppreference.com/w/cpp/numeric/random/cauchy_distribution/param.html",
            "wgPageName": "cpp/numeric/random/cauchy_distribution/param",
            "sample_declaration": "param_type param() const;",
            "other_declarations": 1
        },
        {
            "title": "std::cauchy_distribution<RealType>::a, b",
            "path": "en.cppreference.com/w/cpp/numeric/random/cauchy_distribution/params.html",
            "wgPageName": "cpp/numeric/random/cauchy_distribution/params",
            "sample_declaration": "RealType a() const;",
            "other_declarations": 1
        },
        {
            "title": "std::cauchy_distribution<RealType>::reset",
            "path": "en.cppreference.com/w/cpp/numeric/random/cauchy_distribution/reset.html",
            "wgPageName": "cpp/numeric/random/cauchy_distribution/reset",
            "sample_declaration": "void reset();"
        },
        {
            "title": "std::chi_squared_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/chi_squared_distribution.html",
            "wgPageName": "cpp/numeric/random/chi_squared_distribution",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<class RealType = double>\nclass chi_squared_distribution;"
        },
        {
            "title": "std::chi_squared_distribution<RealType>::chi_squared_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/chi_squared_distribution/chi_squared_distribution.html",
            "wgPageName": "cpp/numeric/random/chi_squared_distribution/chi_squared_distribution",
            "sample_declaration": "chi_squared_distribution()\n    : chi_squared_distribution(1.0) {}",
            "other_declarations": 2
        },
        {
            "title": "std::chi_squared_distribution<RealType>::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/chi_squared_distribution/max.html",
            "wgPageName": "cpp/numeric/random/chi_squared_distribution/max",
            "sample_declaration": "result_type max() const;"
        },
        {
            "title": "std::chi_squared_distribution<RealType>::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/chi_squared_distribution/min.html",
            "wgPageName": "cpp/numeric/random/chi_squared_distribution/min",
            "sample_declaration": "result_type min() const;"
        },
        {
            "title": "std::chi_squared_distribution<RealType>::n",
            "path": "en.cppreference.com/w/cpp/numeric/random/chi_squared_distribution/n.html",
            "wgPageName": "cpp/numeric/random/chi_squared_distribution/n",
            "sample_declaration": "RealType n() const;"
        },
        {
            "title": "operator==,!=(std::chi_squared_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/chi_squared_distribution/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/chi_squared_distribution/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const chi_squared_distribution& lhs,\n    const chi_squared_distribution& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::chi_squared_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/chi_squared_distribution/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/chi_squared_distribution/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    const chi_squared_distribution& d);",
            "other_declarations": 1
        },
        {
            "title": "std::chi_squared_distribution<RealType>::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/chi_squared_distribution/operator().html",
            "wgPageName": "cpp/numeric/random/chi_squared_distribution/operator()",
            "sample_declaration": "template<class Generator>\nresult_type operator()(Generator& g);",
            "other_declarations": 1
        },
        {
            "title": "std::chi_squared_distribution<RealType>::param",
            "path": "en.cppreference.com/w/cpp/numeric/random/chi_squared_distribution/param.html",
            "wgPageName": "cpp/numeric/random/chi_squared_distribution/param",
            "sample_declaration": "param_type param() const;",
            "other_declarations": 1
        },
        {
            "title": "std::chi_squared_distribution<RealType>::reset",
            "path": "en.cppreference.com/w/cpp/numeric/random/chi_squared_distribution/reset.html",
            "wgPageName": "cpp/numeric/random/chi_squared_distribution/reset",
            "sample_declaration": "void reset();"
        },
        {
            "title": "std::discard_block_engine",
            "path": "en.cppreference.com/w/cpp/numeric/random/discard_block_engine.html",
            "wgPageName": "cpp/numeric/random/discard_block_engine",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<\n    class Engine,\n    std::size_t P,\n    std::size_t R>\nclass discard_block_engine;"
        },
        {
            "title": "std::discard_block_engine<Engine,P,R>::base",
            "path": "en.cppreference.com/w/cpp/numeric/random/discard_block_engine/base.html",
            "wgPageName": "cpp/numeric/random/discard_block_engine/base",
            "sample_declaration": "const Engine& base() const noexcept;"
        },
        {
            "title": "std::discard_block_engine<Engine,P,R>::discard_block_engine",
            "path": "en.cppreference.com/w/cpp/numeric/random/discard_block_engine/discard_block_engine.html",
            "wgPageName": "cpp/numeric/random/discard_block_engine/discard_block_engine",
            "sample_declaration": "discard_block_engine();",
            "other_declarations": 4
        },
        {
            "title": "std::discard_block_engine<Engine,P,R>::discard",
            "path": "en.cppreference.com/w/cpp/numeric/random/discard_block_engine/discard.html",
            "wgPageName": "cpp/numeric/random/discard_block_engine/discard",
            "sample_declaration": "void discard(unsigned long long z);"
        },
        {
            "title": "std::discard_block_engine<Engine,P,R>::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/discard_block_engine/max.html",
            "wgPageName": "cpp/numeric/random/discard_block_engine/max",
            "sample_declaration": "static constexpr result_type max();"
        },
        {
            "title": "std::discard_block_engine<Engine,P,R>::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/discard_block_engine/min.html",
            "wgPageName": "cpp/numeric/random/discard_block_engine/min",
            "sample_declaration": "static constexpr result_type min();"
        },
        {
            "title": "operator==,!=(std::discard_block_engine)",
            "path": "en.cppreference.com/w/cpp/numeric/random/discard_block_engine/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/discard_block_engine/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const discard_block_engine& lhs,\n    const discard_block_engine& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::discard_block_engine)",
            "path": "en.cppreference.com/w/cpp/numeric/random/discard_block_engine/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/discard_block_engine/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    discard_block_engine<>& e);",
            "other_declarations": 1
        },
        {
            "title": "std::discard_block_engine<Engine,P,R>::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/discard_block_engine/operator().html",
            "wgPageName": "cpp/numeric/random/discard_block_engine/operator()",
            "sample_declaration": "result_type operator()();"
        },
        {
            "title": "std::discard_block_engine<Engine,P,R>::seed",
            "path": "en.cppreference.com/w/cpp/numeric/random/discard_block_engine/seed.html",
            "wgPageName": "cpp/numeric/random/discard_block_engine/seed",
            "sample_declaration": "void seed();",
            "other_declarations": 2
        },
        {
            "title": "std::discrete_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/discrete_distribution.html",
            "wgPageName": "cpp/numeric/random/discrete_distribution",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<class IntType = int>\nclass discrete_distribution;"
        },
        {
            "title": "std::discrete_distribution<IntType>::discrete_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/discrete_distribution/discrete_distribution.html",
            "wgPageName": "cpp/numeric/random/discrete_distribution/discrete_distribution",
            "sample_declaration": "discrete_distribution();",
            "other_declarations": 4
        },
        {
            "title": "std::discrete_distribution<IntType>::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/discrete_distribution/max.html",
            "wgPageName": "cpp/numeric/random/discrete_distribution/max",
            "sample_declaration": "result_type max() const;"
        },
        {
            "title": "std::discrete_distribution<IntType>::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/discrete_distribution/min.html",
            "wgPageName": "cpp/numeric/random/discrete_distribution/min",
            "sample_declaration": "result_type min() const;"
        },
        {
            "title": "operator==,!=(std::discrete_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/discrete_distribution/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/discrete_distribution/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const discrete_distribution& lhs,\n    const discrete_distribution& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::discrete_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/discrete_distribution/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/discrete_distribution/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    const discrete_distribution& d);",
            "other_declarations": 1
        },
        {
            "title": "std::discrete_distribution<IntType>::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/discrete_distribution/operator().html",
            "wgPageName": "cpp/numeric/random/discrete_distribution/operator()",
            "sample_declaration": "template<class Generator>\nresult_type operator()(Generator& g);",
            "other_declarations": 1
        },
        {
            "title": "std::discrete_distribution<IntType>::param",
            "path": "en.cppreference.com/w/cpp/numeric/random/discrete_distribution/param.html",
            "wgPageName": "cpp/numeric/random/discrete_distribution/param",
            "sample_declaration": "param_type param() const;",
            "other_declarations": 1
        },
        {
            "title": "std::discrete_distribution<IntType>::probabilities",
            "path": "en.cppreference.com/w/cpp/numeric/random/discrete_distribution/probabilities.html",
            "wgPageName": "cpp/numeric/random/discrete_distribution/probabilities",
            "sample_declaration": "std::vector<double> probabilities() const;"
        },
        {
            "title": "std::discrete_distribution<IntType>::reset",
            "path": "en.cppreference.com/w/cpp/numeric/random/discrete_distribution/reset.html",
            "wgPageName": "cpp/numeric/random/discrete_distribution/reset",
            "sample_declaration": "void reset();"
        },
        {
            "title": "std::exponential_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/exponential_distribution.html",
            "wgPageName": "cpp/numeric/random/exponential_distribution",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<class RealType = double>\nclass exponential_distribution;"
        },
        {
            "title": "std::exponential_distribution<RealType>::exponential_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/exponential_distribution/exponential_distribution.html",
            "wgPageName": "cpp/numeric/random/exponential_distribution/exponential_distribution",
            "sample_declaration": "exponential_distribution()\n    : exponential_distribution(1.0) {}",
            "other_declarations": 2
        },
        {
            "title": "std::exponential_distribution<RealType>::lambda",
            "path": "en.cppreference.com/w/cpp/numeric/random/exponential_distribution/lambda.html",
            "wgPageName": "cpp/numeric/random/exponential_distribution/lambda",
            "sample_declaration": "RealType lambda() const;"
        },
        {
            "title": "std::exponential_distribution<RealType>::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/exponential_distribution/max.html",
            "wgPageName": "cpp/numeric/random/exponential_distribution/max",
            "sample_declaration": "result_type max() const;"
        },
        {
            "title": "std::exponential_distribution<RealType>::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/exponential_distribution/min.html",
            "wgPageName": "cpp/numeric/random/exponential_distribution/min",
            "sample_declaration": "result_type min() const;"
        },
        {
            "title": "operator==,!=(std::exponential_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/exponential_distribution/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/exponential_distribution/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const exponential_distribution& lhs,\n    const exponential_distribution& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::exponential_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/exponential_distribution/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/exponential_distribution/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    const exponential_distribution& d);",
            "other_declarations": 1
        },
        {
            "title": "std::exponential_distribution<RealType>::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/exponential_distribution/operator().html",
            "wgPageName": "cpp/numeric/random/exponential_distribution/operator()",
            "sample_declaration": "template<class Generator>\nresult_type operator()(Generator& g);",
            "other_declarations": 1
        },
        {
            "title": "std::exponential_distribution<RealType>::param",
            "path": "en.cppreference.com/w/cpp/numeric/random/exponential_distribution/param.html",
            "wgPageName": "cpp/numeric/random/exponential_distribution/param",
            "sample_declaration": "param_type param() const;",
            "other_declarations": 1
        },
        {
            "title": "std::exponential_distribution<RealType>::reset",
            "path": "en.cppreference.com/w/cpp/numeric/random/exponential_distribution/reset.html",
            "wgPageName": "cpp/numeric/random/exponential_distribution/reset",
            "sample_declaration": "void reset();"
        },
        {
            "title": "std::extreme_value_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/extreme_value_distribution.html",
            "wgPageName": "cpp/numeric/random/extreme_value_distribution",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<class RealType = double>\nclass extreme_value_distribution;"
        },
        {
            "title": "std::extreme_value_distribution<RealType>::extreme_value_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/extreme_value_distribution/extreme_value_distribution.html",
            "wgPageName": "cpp/numeric/random/extreme_value_distribution/extreme_value_distribution",
            "sample_declaration": "extreme_value_distribution()\n    : extreme_value_distribution(0.0) {}",
            "other_declarations": 2
        },
        {
            "title": "std::extreme_value_distribution<RealType>::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/extreme_value_distribution/max.html",
            "wgPageName": "cpp/numeric/random/extreme_value_distribution/max",
            "sample_declaration": "result_type max() const;"
        },
        {
            "title": "std::extreme_value_distribution<RealType>::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/extreme_value_distribution/min.html",
            "wgPageName": "cpp/numeric/random/extreme_value_distribution/min",
            "sample_declaration": "result_type min() const;"
        },
        {
            "title": "operator==,!=(std::extreme_value_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/extreme_value_distribution/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/extreme_value_distribution/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const extreme_value_distribution& lhs,\n    const extreme_value_distribution& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::extreme_value_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/extreme_value_distribution/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/extreme_value_distribution/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    const extreme_value_distribution& d);",
            "other_declarations": 1
        },
        {
            "title": "std::extreme_value_distribution<RealType>::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/extreme_value_distribution/operator().html",
            "wgPageName": "cpp/numeric/random/extreme_value_distribution/operator()",
            "sample_declaration": "template<class Generator>\nresult_type operator()(Generator& g);",
            "other_declarations": 1
        },
        {
            "title": "std::extreme_value_distribution<RealType>::param",
            "path": "en.cppreference.com/w/cpp/numeric/random/extreme_value_distribution/param.html",
            "wgPageName": "cpp/numeric/random/extreme_value_distribution/param",
            "sample_declaration": "param_type param() const;",
            "other_declarations": 1
        },
        {
            "title": "std::extreme_value_distribution<RealType>::a, b",
            "path": "en.cppreference.com/w/cpp/numeric/random/extreme_value_distribution/params.html",
            "wgPageName": "cpp/numeric/random/extreme_value_distribution/params",
            "sample_declaration": "RealType a() const;",
            "other_declarations": 1
        },
        {
            "title": "std::extreme_value_distribution<RealType>::reset",
            "path": "en.cppreference.com/w/cpp/numeric/random/extreme_value_distribution/reset.html",
            "wgPageName": "cpp/numeric/random/extreme_value_distribution/reset",
            "sample_declaration": "void reset();"
        },
        {
            "title": "std::fisher_f_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/fisher_f_distribution.html",
            "wgPageName": "cpp/numeric/random/fisher_f_distribution",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<class RealType = double>\nclass fisher_f_distribution;"
        },
        {
            "title": "std::fisher_f_distribution<RealType>::fisher_f_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/fisher_f_distribution/fisher_f_distribution.html",
            "wgPageName": "cpp/numeric/random/fisher_f_distribution/fisher_f_distribution",
            "sample_declaration": "fisher_f_distribution()\n    : fisher_f_distribution(1.0) {}",
            "other_declarations": 2
        },
        {
            "title": "std::fisher_f_distribution<RealType>::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/fisher_f_distribution/max.html",
            "wgPageName": "cpp/numeric/random/fisher_f_distribution/max",
            "sample_declaration": "result_type max() const;"
        },
        {
            "title": "std::fisher_f_distribution<RealType>::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/fisher_f_distribution/min.html",
            "wgPageName": "cpp/numeric/random/fisher_f_distribution/min",
            "sample_declaration": "result_type min() const;"
        },
        {
            "title": "operator==,!=(std::fisher_f_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/fisher_f_distribution/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/fisher_f_distribution/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const fisher_f_distribution& lhs,\n    const fisher_f_distribution& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::fisher_f_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/fisher_f_distribution/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/fisher_f_distribution/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    const fisher_f_distribution& d);",
            "other_declarations": 1
        },
        {
            "title": "std::fisher_f_distribution<RealType>::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/fisher_f_distribution/operator().html",
            "wgPageName": "cpp/numeric/random/fisher_f_distribution/operator()",
            "sample_declaration": "template<class Generator>\nresult_type operator()(Generator& g);",
            "other_declarations": 1
        },
        {
            "title": "std::fisher_f_distribution<RealType>::param",
            "path": "en.cppreference.com/w/cpp/numeric/random/fisher_f_distribution/param.html",
            "wgPageName": "cpp/numeric/random/fisher_f_distribution/param",
            "sample_declaration": "param_type param() const;",
            "other_declarations": 1
        },
        {
            "title": "std::fisher_f_distribution<RealType>::m, n",
            "path": "en.cppreference.com/w/cpp/numeric/random/fisher_f_distribution/params.html",
            "wgPageName": "cpp/numeric/random/fisher_f_distribution/params",
            "sample_declaration": "RealType m() const;",
            "other_declarations": 1
        },
        {
            "title": "std::fisher_f_distribution<RealType>::reset",
            "path": "en.cppreference.com/w/cpp/numeric/random/fisher_f_distribution/reset.html",
            "wgPageName": "cpp/numeric/random/fisher_f_distribution/reset",
            "sample_declaration": "void reset();"
        },
        {
            "title": "std::gamma_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/gamma_distribution.html",
            "wgPageName": "cpp/numeric/random/gamma_distribution",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<class RealType = double>\nclass gamma_distribution;"
        },
        {
            "title": "std::gamma_distribution<RealType>::gamma_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/gamma_distribution/gamma_distribution.html",
            "wgPageName": "cpp/numeric/random/gamma_distribution/gamma_distribution",
            "sample_declaration": "gamma_distribution()\n    : gamma_distribution(1.0) {}",
            "other_declarations": 2
        },
        {
            "title": "std::gamma_distribution<RealType>::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/gamma_distribution/max.html",
            "wgPageName": "cpp/numeric/random/gamma_distribution/max",
            "sample_declaration": "result_type max() const;"
        },
        {
            "title": "std::gamma_distribution<RealType>::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/gamma_distribution/min.html",
            "wgPageName": "cpp/numeric/random/gamma_distribution/min",
            "sample_declaration": "result_type min() const;"
        },
        {
            "title": "operator==,!=(std::gamma_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/gamma_distribution/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/gamma_distribution/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const gamma_distribution& lhs,\n    const gamma_distribution& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::gamma_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/gamma_distribution/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/gamma_distribution/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    const gamma_distribution& d);",
            "other_declarations": 1
        },
        {
            "title": "std::gamma_distribution<RealType>::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/gamma_distribution/operator().html",
            "wgPageName": "cpp/numeric/random/gamma_distribution/operator()",
            "sample_declaration": "template<class Generator>\nresult_type operator()(Generator& g);",
            "other_declarations": 1
        },
        {
            "title": "std::gamma_distribution<RealType>::param",
            "path": "en.cppreference.com/w/cpp/numeric/random/gamma_distribution/param.html",
            "wgPageName": "cpp/numeric/random/gamma_distribution/param",
            "sample_declaration": "param_type param() const;",
            "other_declarations": 1
        },
        {
            "title": "std::gamma_distribution<RealType>::alpha, beta",
            "path": "en.cppreference.com/w/cpp/numeric/random/gamma_distribution/params.html",
            "wgPageName": "cpp/numeric/random/gamma_distribution/params",
            "sample_declaration": "RealType alpha() const;",
            "other_declarations": 1
        },
        {
            "title": "std::gamma_distribution<RealType>::reset",
            "path": "en.cppreference.com/w/cpp/numeric/random/gamma_distribution/reset.html",
            "wgPageName": "cpp/numeric/random/gamma_distribution/reset",
            "sample_declaration": "void reset();"
        },
        {
            "title": "std::generate_canonical",
            "path": "en.cppreference.com/w/cpp/numeric/random/generate_canonical.html",
            "wgPageName": "cpp/numeric/random/generate_canonical",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<\n    class RealType,\n    std::size_t Bits,\n    class Generator>\nRealType generate_canonical(Generator& g);"
        },
        {
            "title": "std::geometric_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/geometric_distribution.html",
            "wgPageName": "cpp/numeric/random/geometric_distribution",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<class IntType = int>\nclass geometric_distribution;"
        },
        {
            "title": "std::geometric_distribution<IntType>::geometric_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/geometric_distribution/geometric_distribution.html",
            "wgPageName": "cpp/numeric/random/geometric_distribution/geometric_distribution",
            "sample_declaration": "geometric_distribution()\n    : geometric_distribution(0.5) {}",
            "other_declarations": 2
        },
        {
            "title": "std::geometric_distribution<IntType>::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/geometric_distribution/max.html",
            "wgPageName": "cpp/numeric/random/geometric_distribution/max",
            "sample_declaration": "result_type max() const;"
        },
        {
            "title": "std::geometric_distribution<IntType>::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/geometric_distribution/min.html",
            "wgPageName": "cpp/numeric/random/geometric_distribution/min",
            "sample_declaration": "result_type min() const;"
        },
        {
            "title": "operator==,!=(std::geometric_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/geometric_distribution/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/geometric_distribution/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const geometric_distribution& lhs,\n    const geometric_distribution& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::geometric_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/geometric_distribution/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/geometric_distribution/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    const geometric_distribution& d);",
            "other_declarations": 1
        },
        {
            "title": "std::geometric_distribution<IntType>::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/geometric_distribution/operator().html",
            "wgPageName": "cpp/numeric/random/geometric_distribution/operator()",
            "sample_declaration": "template<class Generator>\nresult_type operator()(Generator& g);",
            "other_declarations": 1
        },
        {
            "title": "std::geometric_distribution<IntType>::p",
            "path": "en.cppreference.com/w/cpp/numeric/random/geometric_distribution/p.html",
            "wgPageName": "cpp/numeric/random/geometric_distribution/p",
            "sample_declaration": "double p() const;"
        },
        {
            "title": "std::geometric_distribution<IntType>::param",
            "path": "en.cppreference.com/w/cpp/numeric/random/geometric_distribution/param.html",
            "wgPageName": "cpp/numeric/random/geometric_distribution/param",
            "sample_declaration": "param_type param() const;",
            "other_declarations": 1
        },
        {
            "title": "std::geometric_distribution<IntType>::reset",
            "path": "en.cppreference.com/w/cpp/numeric/random/geometric_distribution/reset.html",
            "wgPageName": "cpp/numeric/random/geometric_distribution/reset",
            "sample_declaration": "void reset();"
        },
        {
            "title": "std::independent_bits_engine",
            "path": "en.cppreference.com/w/cpp/numeric/random/independent_bits_engine.html",
            "wgPageName": "cpp/numeric/random/independent_bits_engine",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<\n    class Engine,\n    std::size_t W,\n    class UIntType>\nclass independent_bits_engine;"
        },
        {
            "title": "std::independent_bits_engine<Engine,W,UIntType>::base",
            "path": "en.cppreference.com/w/cpp/numeric/random/independent_bits_engine/base.html",
            "wgPageName": "cpp/numeric/random/independent_bits_engine/base",
            "sample_declaration": "const Engine& base() const noexcept;"
        },
        {
            "title": "std::independent_bits_engine<Engine,W,UIntType>::discard",
            "path": "en.cppreference.com/w/cpp/numeric/random/independent_bits_engine/discard.html",
            "wgPageName": "cpp/numeric/random/independent_bits_engine/discard",
            "sample_declaration": "void discard(unsigned long long z);"
        },
        {
            "title": "std::independent_bits_engine<Engine,W,UIntType>::independent_bits_engine",
            "path": "en.cppreference.com/w/cpp/numeric/random/independent_bits_engine/independent_bits_engine.html",
            "wgPageName": "cpp/numeric/random/independent_bits_engine/independent_bits_engine",
            "sample_declaration": "independent_bits_engine();",
            "other_declarations": 4
        },
        {
            "title": "std::independent_bits_engine<Engine,W,UIntType>::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/independent_bits_engine/max.html",
            "wgPageName": "cpp/numeric/random/independent_bits_engine/max",
            "sample_declaration": "static constexpr result_type max();"
        },
        {
            "title": "std::independent_bits_engine<Engine,W,UIntType>::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/independent_bits_engine/min.html",
            "wgPageName": "cpp/numeric/random/independent_bits_engine/min",
            "sample_declaration": "static constexpr result_type min();"
        },
        {
            "title": "operator==,!=(std::independent_bits_engine)",
            "path": "en.cppreference.com/w/cpp/numeric/random/independent_bits_engine/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/independent_bits_engine/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const independent_bits_engine& lhs,\n    const independent_bits_engine& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::independent_bits_engine)",
            "path": "en.cppreference.com/w/cpp/numeric/random/independent_bits_engine/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/independent_bits_engine/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    independent_bits_engine<>& e);",
            "other_declarations": 1
        },
        {
            "title": "std::independent_bits_engine<Engine,W,UIntType>::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/independent_bits_engine/operator().html",
            "wgPageName": "cpp/numeric/random/independent_bits_engine/operator()",
            "sample_declaration": "result_type operator()();"
        },
        {
            "title": "std::independent_bits_engine<Engine,W,UIntType>::seed",
            "path": "en.cppreference.com/w/cpp/numeric/random/independent_bits_engine/seed.html",
            "wgPageName": "cpp/numeric/random/independent_bits_engine/seed",
            "sample_declaration": "void seed();",
            "other_declarations": 2
        },
        {
            "title": "std::linear_congruential_engine",
            "path": "en.cppreference.com/w/cpp/numeric/random/linear_congruential_engine.html",
            "wgPageName": "cpp/numeric/random/linear_congruential_engine",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<\n    class UIntType,\n    UIntType a,\n    UIntType c,\n    UIntType m>\nclass linear_congruential_engine;"
        },
        {
            "title": "std::linear_congruential_engine<UIntType,a,c,m>::discard",
            "path": "en.cppreference.com/w/cpp/numeric/random/linear_congruential_engine/discard.html",
            "wgPageName": "cpp/numeric/random/linear_congruential_engine/discard",
            "sample_declaration": "void discard(unsigned long long z);"
        },
        {
            "title": "std::linear_congruential_engine<UIntType,a,c,m>::linear_congruential_engine",
            "path": "en.cppreference.com/w/cpp/numeric/random/linear_congruential_engine/linear_congruential_engine.html",
            "wgPageName": "cpp/numeric/random/linear_congruential_engine/linear_congruential_engine",
            "sample_declaration": "linear_congruential_engine()\n    : linear_congruential_engine(default_seed) {\n}",
            "other_declarations": 3
        },
        {
            "title": "std::linear_congruential_engine<UIntType,a,c,m>::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/linear_congruential_engine/max.html",
            "wgPageName": "cpp/numeric/random/linear_congruential_engine/max",
            "sample_declaration": "static constexpr result_type max();"
        },
        {
            "title": "std::linear_congruential_engine<UIntType,a,c,m>::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/linear_congruential_engine/min.html",
            "wgPageName": "cpp/numeric/random/linear_congruential_engine/min",
            "sample_declaration": "static constexpr result_type min();"
        },
        {
            "title": "operator==,!=(std::linear_congruential_engine)",
            "path": "en.cppreference.com/w/cpp/numeric/random/linear_congruential_engine/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/linear_congruential_engine/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const linear_congruential_engine& lhs,\n    const linear_congruential_engine& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::linear_congruential_engine)",
            "path": "en.cppreference.com/w/cpp/numeric/random/linear_congruential_engine/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/linear_congruential_engine/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    const linear_congruential_engine& e);",
            "other_declarations": 1
        },
        {
            "title": "std::linear_congruential_engine<UIntType,a,c,m>::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/linear_congruential_engine/operator().html",
            "wgPageName": "cpp/numeric/random/linear_congruential_engine/operator()",
            "sample_declaration": "result_type operator()();"
        },
        {
            "title": "std::linear_congruential_engine<UIntType,a,c,m>::seed",
            "path": "en.cppreference.com/w/cpp/numeric/random/linear_congruential_engine/seed.html",
            "wgPageName": "cpp/numeric/random/linear_congruential_engine/seed",
            "sample_declaration": "void seed(result_type value = default_seed);",
            "other_declarations": 1
        },
        {
            "title": "std::lognormal_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/lognormal_distribution.html",
            "wgPageName": "cpp/numeric/random/lognormal_distribution",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<class RealType = double>\nclass lognormal_distribution;"
        },
        {
            "title": "std::lognormal_distribution<RealType>::lognormal_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/lognormal_distribution/lognormal_distribution.html",
            "wgPageName": "cpp/numeric/random/lognormal_distribution/lognormal_distribution",
            "sample_declaration": "lognormal_distribution()\n    : lognormal_distribution(0.0) {}",
            "other_declarations": 2
        },
        {
            "title": "std::lognormal_distribution<RealType>::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/lognormal_distribution/max.html",
            "wgPageName": "cpp/numeric/random/lognormal_distribution/max",
            "sample_declaration": "result_type max() const;"
        },
        {
            "title": "std::lognormal_distribution<RealType>::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/lognormal_distribution/min.html",
            "wgPageName": "cpp/numeric/random/lognormal_distribution/min",
            "sample_declaration": "result_type min() const;"
        },
        {
            "title": "operator==,!=(std::lognormal_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/lognormal_distribution/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/lognormal_distribution/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const lognormal_distribution& lhs,\n    const lognormal_distribution& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::lognormal_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/lognormal_distribution/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/lognormal_distribution/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    const lognormal_distribution& d);",
            "other_declarations": 1
        },
        {
            "title": "std::lognormal_distribution<RealType>::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/lognormal_distribution/operator().html",
            "wgPageName": "cpp/numeric/random/lognormal_distribution/operator()",
            "sample_declaration": "template<class Generator>\nresult_type operator()(Generator& g);",
            "other_declarations": 1
        },
        {
            "title": "std::lognormal_distribution<RealType>::param",
            "path": "en.cppreference.com/w/cpp/numeric/random/lognormal_distribution/param.html",
            "wgPageName": "cpp/numeric/random/lognormal_distribution/param",
            "sample_declaration": "param_type param() const;",
            "other_declarations": 1
        },
        {
            "title": "std::lognormal_distribution<RealType>::m, s",
            "path": "en.cppreference.com/w/cpp/numeric/random/lognormal_distribution/params.html",
            "wgPageName": "cpp/numeric/random/lognormal_distribution/params",
            "sample_declaration": "RealType m() const;",
            "other_declarations": 1
        },
        {
            "title": "std::lognormal_distribution<RealType>::reset",
            "path": "en.cppreference.com/w/cpp/numeric/random/lognormal_distribution/reset.html",
            "wgPageName": "cpp/numeric/random/lognormal_distribution/reset",
            "sample_declaration": "void reset();"
        },
        {
            "title": "std::mersenne_twister_engine",
            "path": "en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html",
            "wgPageName": "cpp/numeric/random/mersenne_twister_engine",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<\n    class UIntType,\n    std::size_t w,\n    std::size_t n,\n    std::size_t m,\n    std::size_t r,\n    UIntType a,\n    std::size_t u,\n    UIntType d,\n    std::size_t s,\n    UIntType b,\n    std::size_t t,\n    UIntType c,\n    std::size_t l,\n    UIntType f>\nclass mersenne_twister_engine;"
        },
        {
            "title": "std::mersenne_twister_engine<UIntType,w,n,m,r,a,u,d,s,b,t,c,l,f>::discard",
            "path": "en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine/discard.html",
            "wgPageName": "cpp/numeric/random/mersenne_twister_engine/discard",
            "sample_declaration": "void discard(unsigned long long z);"
        },
        {
            "title": "std::mersenne_twister_engine<UIntType,w,n,m,r,a,u,d,s,b,t,c,l,f>::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine/max.html",
            "wgPageName": "cpp/numeric/random/mersenne_twister_engine/max",
            "sample_declaration": "static constexpr result_type max();"
        },
        {
            "title": "std::mersenne_twister_engine<UIntType,w,n,m,r,a,u,d,s,b,t,c,l,f>::mersenne_twister_engine",
            "path": "en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine/mersenne_twister_engine.html",
            "wgPageName": "cpp/numeric/random/mersenne_twister_engine/mersenne_twister_engine",
            "sample_declaration": "mersenne_twister_engine()\n    : mersenne_twister_engine(default_seed) {}",
            "other_declarations": 3
        },
        {
            "title": "std::mersenne_twister_engine<UIntType,w,n,m,r,a,u,d,s,b,t,c,l,f>::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine/min.html",
            "wgPageName": "cpp/numeric/random/mersenne_twister_engine/min",
            "sample_declaration": "static constexpr result_type min();"
        },
        {
            "title": "operator==,!=(std::mersenne_twister_engine)",
            "path": "en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/mersenne_twister_engine/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const mersenne_twister_engine& lhs,\n    const mersenne_twister_engine& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::mersenne_twister_engine)",
            "path": "en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/mersenne_twister_engine/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    const mersenne_twister_engine& e);",
            "other_declarations": 1
        },
        {
            "title": "std::mersenne_twister_engine<UIntType,w,n,m,r,a,u,d,s,b,t,c,l,f>::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine/operator().html",
            "wgPageName": "cpp/numeric/random/mersenne_twister_engine/operator()",
            "sample_declaration": "result_type operator()();"
        },
        {
            "title": "std::mersenne_twister_engine<UIntType,w,n,m,r,a,u,d,s,b,t,c,l,f>::seed",
            "path": "en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine/seed.html",
            "wgPageName": "cpp/numeric/random/mersenne_twister_engine/seed",
            "sample_declaration": "void seed(result_type value = default_seed);",
            "other_declarations": 1
        },
        {
            "title": "std::negative_binomial_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/negative_binomial_distribution.html",
            "wgPageName": "cpp/numeric/random/negative_binomial_distribution",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<class IntType = int>\nclass negative_binomial_distribution;"
        },
        {
            "title": "std::negative_binomial_distribution<IntType>::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/negative_binomial_distribution/max.html",
            "wgPageName": "cpp/numeric/random/negative_binomial_distribution/max",
            "sample_declaration": "result_type max() const;"
        },
        {
            "title": "std::negative_binomial_distribution<IntType>::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/negative_binomial_distribution/min.html",
            "wgPageName": "cpp/numeric/random/negative_binomial_distribution/min",
            "sample_declaration": "result_type min() const;"
        },
        {
            "title": "std::negative_binomial_distribution<IntType>::negative_binomial_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/negative_binomial_distribution/negative_binomial_distribution.html",
            "wgPageName": "cpp/numeric/random/negative_binomial_distribution/negative_binomial_distribution",
            "sample_declaration": "negative_binomial_distribution()\n    : negative_binomial_distribution(1) {}",
            "other_declarations": 2
        },
        {
            "title": "operator==,!=(std::negative_binomial_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/negative_binomial_distribution/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/negative_binomial_distribution/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const negative_binomial_distribution& lhs,\n    const negative_binomial_distribution& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::negative_binomial_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/negative_binomial_distribution/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/negative_binomial_distribution/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    const negative_binomial_distribution& d);",
            "other_declarations": 1
        },
        {
            "title": "std::negative_binomial_distribution<IntType>::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/negative_binomial_distribution/operator().html",
            "wgPageName": "cpp/numeric/random/negative_binomial_distribution/operator()",
            "sample_declaration": "template<class Generator>\nresult_type operator()(Generator& g);",
            "other_declarations": 1
        },
        {
            "title": "std::negative_binomial_distribution<IntType>::param",
            "path": "en.cppreference.com/w/cpp/numeric/random/negative_binomial_distribution/param.html",
            "wgPageName": "cpp/numeric/random/negative_binomial_distribution/param",
            "sample_declaration": "param_type param() const;",
            "other_declarations": 1
        },
        {
            "title": "std::negative_binomial_distribution<IntType>::p, k",
            "path": "en.cppreference.com/w/cpp/numeric/random/negative_binomial_distribution/params.html",
            "wgPageName": "cpp/numeric/random/negative_binomial_distribution/params",
            "sample_declaration": "double p() const;",
            "other_declarations": 1
        },
        {
            "title": "std::negative_binomial_distribution<IntType>::reset",
            "path": "en.cppreference.com/w/cpp/numeric/random/negative_binomial_distribution/reset.html",
            "wgPageName": "cpp/numeric/random/negative_binomial_distribution/reset",
            "sample_declaration": "void reset();"
        },
        {
            "title": "std::normal_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/normal_distribution.html",
            "wgPageName": "cpp/numeric/random/normal_distribution",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<class RealType = double>\nclass normal_distribution;"
        },
        {
            "title": "std::normal_distribution<RealType>::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/normal_distribution/max.html",
            "wgPageName": "cpp/numeric/random/normal_distribution/max",
            "sample_declaration": "result_type max() const;"
        },
        {
            "title": "std::normal_distribution<RealType>::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/normal_distribution/min.html",
            "wgPageName": "cpp/numeric/random/normal_distribution/min",
            "sample_declaration": "result_type min() const;"
        },
        {
            "title": "std::normal_distribution<RealType>::normal_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/normal_distribution/normal_distribution.html",
            "wgPageName": "cpp/numeric/random/normal_distribution/normal_distribution",
            "sample_declaration": "normal_distribution()\n    : normal_distribution(0.0) {}",
            "other_declarations": 2
        },
        {
            "title": "operator==,!=(std::normal_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/normal_distribution/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/normal_distribution/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const normal_distribution& lhs,\n    const normal_distribution& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::normal_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/normal_distribution/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/normal_distribution/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    const normal_distribution& d);",
            "other_declarations": 1
        },
        {
            "title": "std::normal_distribution<RealType>::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/normal_distribution/operator().html",
            "wgPageName": "cpp/numeric/random/normal_distribution/operator()",
            "sample_declaration": "template<class Generator>\nresult_type operator()(Generator& g);",
            "other_declarations": 1
        },
        {
            "title": "std::normal_distribution<RealType>::param",
            "path": "en.cppreference.com/w/cpp/numeric/random/normal_distribution/param.html",
            "wgPageName": "cpp/numeric/random/normal_distribution/param",
            "sample_declaration": "param_type param() const;",
            "other_declarations": 1
        },
        {
            "title": "std::normal_distribution<RealType>::mean, stddev",
            "path": "en.cppreference.com/w/cpp/numeric/random/normal_distribution/params.html",
            "wgPageName": "cpp/numeric/random/normal_distribution/params",
            "sample_declaration": "RealType mean() const;",
            "other_declarations": 1
        },
        {
            "title": "std::normal_distribution<RealType>::reset",
            "path": "en.cppreference.com/w/cpp/numeric/random/normal_distribution/reset.html",
            "wgPageName": "cpp/numeric/random/normal_distribution/reset",
            "sample_declaration": "void reset();"
        },
        {
            "title": "std::piecewise_constant_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/piecewise_constant_distribution.html",
            "wgPageName": "cpp/numeric/random/piecewise_constant_distribution",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<class RealType = double>\nclass piecewise_constant_distribution;"
        },
        {
            "title": "std::piecewise_constant_distribution<RealType>::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/piecewise_constant_distribution/max.html",
            "wgPageName": "cpp/numeric/random/piecewise_constant_distribution/max",
            "sample_declaration": "result_type max() const;"
        },
        {
            "title": "std::piecewise_constant_distribution<RealType>::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/piecewise_constant_distribution/min.html",
            "wgPageName": "cpp/numeric/random/piecewise_constant_distribution/min",
            "sample_declaration": "result_type min() const;"
        },
        {
            "title": "operator==,!=(std::piecewise_constant_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/piecewise_constant_distribution/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/piecewise_constant_distribution/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const piecewise_constant_distribution& lhs,\n    const piecewise_constant_distribution& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::piecewise_constant_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/piecewise_constant_distribution/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/piecewise_constant_distribution/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    const piecewise_constant_distribution& d);",
            "other_declarations": 1
        },
        {
            "title": "std::piecewise_constant_distribution<RealType>::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/piecewise_constant_distribution/operator().html",
            "wgPageName": "cpp/numeric/random/piecewise_constant_distribution/operator()",
            "sample_declaration": "template<class Generator>\nresult_type operator()(Generator& g);",
            "other_declarations": 1
        },
        {
            "title": "std::piecewise_constant_distribution<RealType>::param",
            "path": "en.cppreference.com/w/cpp/numeric/random/piecewise_constant_distribution/param.html",
            "wgPageName": "cpp/numeric/random/piecewise_constant_distribution/param",
            "sample_declaration": "param_type param() const;",
            "other_declarations": 1
        },
        {
            "title": "std::piecewise_constant_distribution<RealType>::intervals, densities",
            "path": "en.cppreference.com/w/cpp/numeric/random/piecewise_constant_distribution/params.html",
            "wgPageName": "cpp/numeric/random/piecewise_constant_distribution/params",
            "sample_declaration": "std::vector<RealType> intervals() const;",
            "other_declarations": 1
        },
        {
            "title": "std::piecewise_constant_distribution<RealType>::piecewise_constant_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/piecewise_constant_distribution/piecewise_constant_distribution.html",
            "wgPageName": "cpp/numeric/random/piecewise_constant_distribution/piecewise_constant_distribution",
            "sample_declaration": "piecewise_constant_distribution();",
            "other_declarations": 4
        },
        {
            "title": "std::piecewise_constant_distribution<RealType>::reset",
            "path": "en.cppreference.com/w/cpp/numeric/random/piecewise_constant_distribution/reset.html",
            "wgPageName": "cpp/numeric/random/piecewise_constant_distribution/reset",
            "sample_declaration": "void reset();"
        },
        {
            "title": "std::piecewise_linear_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/piecewise_linear_distribution.html",
            "wgPageName": "cpp/numeric/random/piecewise_linear_distribution",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<class RealType = double>\nclass piecewise_linear_distribution;"
        },
        {
            "title": "std::piecewise_linear_distribution<RealType>::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/piecewise_linear_distribution/max.html",
            "wgPageName": "cpp/numeric/random/piecewise_linear_distribution/max",
            "sample_declaration": "result_type max() const;"
        },
        {
            "title": "std::piecewise_linear_distribution<RealType>::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/piecewise_linear_distribution/min.html",
            "wgPageName": "cpp/numeric/random/piecewise_linear_distribution/min",
            "sample_declaration": "result_type min() const;"
        },
        {
            "title": "operator==,!=(std::piecewise_linear_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/piecewise_linear_distribution/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/piecewise_linear_distribution/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const piecewise_linear_distribution& lhs,\n    const piecewise_linear_distribution& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::piecewise_linear_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/piecewise_linear_distribution/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/piecewise_linear_distribution/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    const piecewise_linear_distribution& d);",
            "other_declarations": 1
        },
        {
            "title": "std::piecewise_linear_distribution<RealType>::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/piecewise_linear_distribution/operator().html",
            "wgPageName": "cpp/numeric/random/piecewise_linear_distribution/operator()",
            "sample_declaration": "template<class Generator>\nresult_type operator()(Generator& g);",
            "other_declarations": 1
        },
        {
            "title": "std::piecewise_linear_distribution<RealType>::param",
            "path": "en.cppreference.com/w/cpp/numeric/random/piecewise_linear_distribution/param.html",
            "wgPageName": "cpp/numeric/random/piecewise_linear_distribution/param",
            "sample_declaration": "param_type param() const;",
            "other_declarations": 1
        },
        {
            "title": "std::piecewise_linear_distribution<RealType>::intervals, densities",
            "path": "en.cppreference.com/w/cpp/numeric/random/piecewise_linear_distribution/params.html",
            "wgPageName": "cpp/numeric/random/piecewise_linear_distribution/params",
            "sample_declaration": "std::vector<RealType> intervals() const;",
            "other_declarations": 1
        },
        {
            "title": "std::piecewise_linear_distribution<RealType>::piecewise_linear_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/piecewise_linear_distribution/piecewise_linear_distribution.html",
            "wgPageName": "cpp/numeric/random/piecewise_linear_distribution/piecewise_linear_distribution",
            "sample_declaration": "piecewise_linear_distribution();",
            "other_declarations": 4
        },
        {
            "title": "std::piecewise_linear_distribution<RealType>::reset",
            "path": "en.cppreference.com/w/cpp/numeric/random/piecewise_linear_distribution/reset.html",
            "wgPageName": "cpp/numeric/random/piecewise_linear_distribution/reset",
            "sample_declaration": "void reset();"
        },
        {
            "title": "std::poisson_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/poisson_distribution.html",
            "wgPageName": "cpp/numeric/random/poisson_distribution",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<class IntType = int>\nclass poisson_distribution;"
        },
        {
            "title": "std::poisson_distribution<IntType>::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/poisson_distribution/max.html",
            "wgPageName": "cpp/numeric/random/poisson_distribution/max",
            "sample_declaration": "result_type max() const;"
        },
        {
            "title": "std::poisson_distribution<IntType>::mean",
            "path": "en.cppreference.com/w/cpp/numeric/random/poisson_distribution/mean.html",
            "wgPageName": "cpp/numeric/random/poisson_distribution/mean",
            "sample_declaration": "double mean() const;"
        },
        {
            "title": "std::poisson_distribution<IntType>::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/poisson_distribution/min.html",
            "wgPageName": "cpp/numeric/random/poisson_distribution/min",
            "sample_declaration": "result_type min() const;"
        },
        {
            "title": "operator==,!=(std::poisson_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/poisson_distribution/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/poisson_distribution/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const poisson_distribution& lhs,\n    const poisson_distribution& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::poisson_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/poisson_distribution/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/poisson_distribution/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    const poisson_distribution& d);",
            "other_declarations": 1
        },
        {
            "title": "std::poisson_distribution<IntType>::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/poisson_distribution/operator().html",
            "wgPageName": "cpp/numeric/random/poisson_distribution/operator()",
            "sample_declaration": "template<class Generator>\nresult_type operator()(Generator& g);",
            "other_declarations": 1
        },
        {
            "title": "std::poisson_distribution<IntType>::param",
            "path": "en.cppreference.com/w/cpp/numeric/random/poisson_distribution/param.html",
            "wgPageName": "cpp/numeric/random/poisson_distribution/param",
            "sample_declaration": "param_type param() const;",
            "other_declarations": 1
        },
        {
            "title": "std::poisson_distribution<IntType>::poisson_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/poisson_distribution/poisson_distribution.html",
            "wgPageName": "cpp/numeric/random/poisson_distribution/poisson_distribution",
            "sample_declaration": "poisson_distribution()\n    : poisson_distribution(1.0) {}",
            "other_declarations": 2
        },
        {
            "title": "std::poisson_distribution<IntType>::reset",
            "path": "en.cppreference.com/w/cpp/numeric/random/poisson_distribution/reset.html",
            "wgPageName": "cpp/numeric/random/poisson_distribution/reset",
            "sample_declaration": "void reset();"
        },
        {
            "title": "RAND_MAX",
            "path": "en.cppreference.com/w/cpp/numeric/random/RAND_MAX.html",
            "wgPageName": "cpp/numeric/random/RAND_MAX",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "#define RAND_MAX /*implementation defined*/"
        },
        {
            "title": "std::rand",
            "path": "en.cppreference.com/w/cpp/numeric/random/rand.html",
            "wgPageName": "cpp/numeric/random/rand",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "int rand();"
        },
        {
            "title": "std::random_device",
            "path": "en.cppreference.com/w/cpp/numeric/random/random_device.html",
            "wgPageName": "cpp/numeric/random/random_device",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "class random_device;"
        },
        {
            "title": "std::random_device::entropy",
            "path": "en.cppreference.com/w/cpp/numeric/random/random_device/entropy.html",
            "wgPageName": "cpp/numeric/random/random_device/entropy",
            "sample_declaration": "double entropy() const noexcept;"
        },
        {
            "title": "std::random_device::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/random_device/max.html",
            "wgPageName": "cpp/numeric/random/random_device/max",
            "sample_declaration": "static constexpr result_type max();"
        },
        {
            "title": "std::random_device::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/random_device/min.html",
            "wgPageName": "cpp/numeric/random/random_device/min",
            "sample_declaration": "static constexpr result_type min();"
        },
        {
            "title": "std::random_device::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/random_device/operator().html",
            "wgPageName": "cpp/numeric/random/random_device/operator()",
            "sample_declaration": "result_type operator()();"
        },
        {
            "title": "std::random_device::random_device",
            "path": "en.cppreference.com/w/cpp/numeric/random/random_device/random_device.html",
            "wgPageName": "cpp/numeric/random/random_device/random_device",
            "sample_declaration": "random_device()\n    : random_device(\n          /*implementation-defined*/) {}",
            "other_declarations": 2
        },
        {
            "title": "std::seed_seq",
            "path": "en.cppreference.com/w/cpp/numeric/random/seed_seq.html",
            "wgPageName": "cpp/numeric/random/seed_seq",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "class seed_seq;"
        },
        {
            "title": "std::seed_seq::generate",
            "path": "en.cppreference.com/w/cpp/numeric/random/seed_seq/generate.html",
            "wgPageName": "cpp/numeric/random/seed_seq/generate",
            "sample_declaration": "template<class RandomIt>\nvoid generate(RandomIt begin, RandomIt end);"
        },
        {
            "title": "std::seed_seq::param",
            "path": "en.cppreference.com/w/cpp/numeric/random/seed_seq/param.html",
            "wgPageName": "cpp/numeric/random/seed_seq/param",
            "sample_declaration": "template<class OutputIt>\nvoid param(OutputIt dest) const;"
        },
        {
            "title": "std::seed_seq::seed_seq",
            "path": "en.cppreference.com/w/cpp/numeric/random/seed_seq/seed_seq.html",
            "wgPageName": "cpp/numeric/random/seed_seq/seed_seq",
            "sample_declaration": "seed_seq() noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::seed_seq::size",
            "path": "en.cppreference.com/w/cpp/numeric/random/seed_seq/size.html",
            "wgPageName": "cpp/numeric/random/seed_seq/size",
            "sample_declaration": "std::size_t size() const noexcept;"
        },
        {
            "title": "std::shuffle_order_engine",
            "path": "en.cppreference.com/w/cpp/numeric/random/shuffle_order_engine.html",
            "wgPageName": "cpp/numeric/random/shuffle_order_engine",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<class Engine, std::size_t K>\nclass shuffle_order_engine;"
        },
        {
            "title": "std::shuffle_order_engine<Engine,K>::base",
            "path": "en.cppreference.com/w/cpp/numeric/random/shuffle_order_engine/base.html",
            "wgPageName": "cpp/numeric/random/shuffle_order_engine/base",
            "sample_declaration": "const Engine& base() const noexcept;"
        },
        {
            "title": "std::shuffle_order_engine<Engine,K>::discard",
            "path": "en.cppreference.com/w/cpp/numeric/random/shuffle_order_engine/discard.html",
            "wgPageName": "cpp/numeric/random/shuffle_order_engine/discard",
            "sample_declaration": "void discard(unsigned long long z);"
        },
        {
            "title": "std::shuffle_order_engine<Engine,K>::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/shuffle_order_engine/max.html",
            "wgPageName": "cpp/numeric/random/shuffle_order_engine/max",
            "sample_declaration": "static constexpr result_type max();"
        },
        {
            "title": "std::shuffle_order_engine<Engine,K>::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/shuffle_order_engine/min.html",
            "wgPageName": "cpp/numeric/random/shuffle_order_engine/min",
            "sample_declaration": "static constexpr result_type min();"
        },
        {
            "title": "operator==,!=(std::shuffle_order_engine)",
            "path": "en.cppreference.com/w/cpp/numeric/random/shuffle_order_engine/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/shuffle_order_engine/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const shuffle_order_engine& lhs,\n    const shuffle_order_engine& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::shuffle_order_engine)",
            "path": "en.cppreference.com/w/cpp/numeric/random/shuffle_order_engine/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/shuffle_order_engine/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    shuffle_order_engine<>& e);",
            "other_declarations": 1
        },
        {
            "title": "std::shuffle_order_engine<Engine,K>::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/shuffle_order_engine/operator().html",
            "wgPageName": "cpp/numeric/random/shuffle_order_engine/operator()",
            "sample_declaration": "result_type operator()();"
        },
        {
            "title": "std::shuffle_order_engine<Engine,K>::seed",
            "path": "en.cppreference.com/w/cpp/numeric/random/shuffle_order_engine/seed.html",
            "wgPageName": "cpp/numeric/random/shuffle_order_engine/seed",
            "sample_declaration": "void seed();",
            "other_declarations": 2
        },
        {
            "title": "std::shuffle_order_engine<Engine,K>::shuffle_order_engine",
            "path": "en.cppreference.com/w/cpp/numeric/random/shuffle_order_engine/shuffle_order_engine.html",
            "wgPageName": "cpp/numeric/random/shuffle_order_engine/shuffle_order_engine",
            "sample_declaration": "shuffle_order_engine();",
            "other_declarations": 4
        },
        {
            "title": "std::srand",
            "path": "en.cppreference.com/w/cpp/numeric/random/srand.html",
            "wgPageName": "cpp/numeric/random/srand",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "void srand(unsigned seed);"
        },
        {
            "title": "std::student_t_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/student_t_distribution.html",
            "wgPageName": "cpp/numeric/random/student_t_distribution",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<class RealType = double>\nclass student_t_distribution;"
        },
        {
            "title": "std::student_t_distribution<RealType>::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/student_t_distribution/max.html",
            "wgPageName": "cpp/numeric/random/student_t_distribution/max",
            "sample_declaration": "result_type max() const;"
        },
        {
            "title": "std::student_t_distribution<RealType>::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/student_t_distribution/min.html",
            "wgPageName": "cpp/numeric/random/student_t_distribution/min",
            "sample_declaration": "result_type min() const;"
        },
        {
            "title": "std::student_t_distribution<RealType>::n",
            "path": "en.cppreference.com/w/cpp/numeric/random/student_t_distribution/n.html",
            "wgPageName": "cpp/numeric/random/student_t_distribution/n",
            "sample_declaration": "RealType n() const;"
        },
        {
            "title": "operator==,!=(std::student_t_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/student_t_distribution/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/student_t_distribution/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const student_t_distribution& lhs,\n    const student_t_distribution& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::student_t_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/student_t_distribution/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/student_t_distribution/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    const student_t_distribution& d);",
            "other_declarations": 1
        },
        {
            "title": "std::student_t_distribution<RealType>::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/student_t_distribution/operator().html",
            "wgPageName": "cpp/numeric/random/student_t_distribution/operator()",
            "sample_declaration": "template<class Generator>\nresult_type operator()(Generator& g);",
            "other_declarations": 1
        },
        {
            "title": "std::student_t_distribution<RealType>::param",
            "path": "en.cppreference.com/w/cpp/numeric/random/student_t_distribution/param.html",
            "wgPageName": "cpp/numeric/random/student_t_distribution/param",
            "sample_declaration": "param_type param() const;",
            "other_declarations": 1
        },
        {
            "title": "std::student_t_distribution<RealType>::reset",
            "path": "en.cppreference.com/w/cpp/numeric/random/student_t_distribution/reset.html",
            "wgPageName": "cpp/numeric/random/student_t_distribution/reset",
            "sample_declaration": "void reset();"
        },
        {
            "title": "std::student_t_distribution<RealType>::student_t_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/student_t_distribution/student_t_distribution.html",
            "wgPageName": "cpp/numeric/random/student_t_distribution/student_t_distribution",
            "sample_declaration": "student_t_distribution()\n    : student_t_distribution(1) {}",
            "other_declarations": 2
        },
        {
            "title": "std::subtract_with_carry_engine",
            "path": "en.cppreference.com/w/cpp/numeric/random/subtract_with_carry_engine.html",
            "wgPageName": "cpp/numeric/random/subtract_with_carry_engine",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<\n    class UIntType,\n    std::size_t w,\n    std::size_t s,\n    std::size_t r>\nclass subtract_with_carry_engine;"
        },
        {
            "title": "std::subtract_with_carry_engine<UIntType,w,s,r>::discard",
            "path": "en.cppreference.com/w/cpp/numeric/random/subtract_with_carry_engine/discard.html",
            "wgPageName": "cpp/numeric/random/subtract_with_carry_engine/discard",
            "sample_declaration": "void discard(unsigned long long z);"
        },
        {
            "title": "std::subtract_with_carry_engine<UIntType,w,s,r>::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/subtract_with_carry_engine/max.html",
            "wgPageName": "cpp/numeric/random/subtract_with_carry_engine/max",
            "sample_declaration": "static constexpr result_type max();"
        },
        {
            "title": "std::subtract_with_carry_engine<UIntType,w,s,r>::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/subtract_with_carry_engine/min.html",
            "wgPageName": "cpp/numeric/random/subtract_with_carry_engine/min",
            "sample_declaration": "static constexpr result_type min();"
        },
        {
            "title": "operator==,!=(std::subtract_with_carry_engine)",
            "path": "en.cppreference.com/w/cpp/numeric/random/subtract_with_carry_engine/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/subtract_with_carry_engine/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const subtract_with_carry_engine& lhs,\n    const subtract_with_carry_engine& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::subtract_with_carry_engine)",
            "path": "en.cppreference.com/w/cpp/numeric/random/subtract_with_carry_engine/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/subtract_with_carry_engine/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    const subtract_with_carry_engine& e);",
            "other_declarations": 1
        },
        {
            "title": "std::subtract_with_carry_engine<UIntType,w,s,r>::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/subtract_with_carry_engine/operator().html",
            "wgPageName": "cpp/numeric/random/subtract_with_carry_engine/operator()",
            "sample_declaration": "result_type operator()();"
        },
        {
            "title": "std::subtract_with_carry_engine<UIntType,w,s,r>::seed",
            "path": "en.cppreference.com/w/cpp/numeric/random/subtract_with_carry_engine/seed.html",
            "wgPageName": "cpp/numeric/random/subtract_with_carry_engine/seed",
            "sample_declaration": "void seed(result_type value = default_seed);",
            "other_declarations": 1
        },
        {
            "title": "std::subtract_with_carry_engine<UIntType,w,s,r>::subtract_with_carry_engine",
            "path": "en.cppreference.com/w/cpp/numeric/random/subtract_with_carry_engine/subtract_with_carry_engine.html",
            "wgPageName": "cpp/numeric/random/subtract_with_carry_engine/subtract_with_carry_engine",
            "sample_declaration": "subtract_with_carry_engine()\n    : subtract_with_carry_engine(default_seed) {\n}",
            "other_declarations": 3
        },
        {
            "title": "std::uniform_int_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution.html",
            "wgPageName": "cpp/numeric/random/uniform_int_distribution",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<class IntType = int>\nclass uniform_int_distribution;"
        },
        {
            "title": "std::uniform_int_distribution<IntType>::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution/max.html",
            "wgPageName": "cpp/numeric/random/uniform_int_distribution/max",
            "sample_declaration": "result_type max() const;"
        },
        {
            "title": "std::uniform_int_distribution<IntType>::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution/min.html",
            "wgPageName": "cpp/numeric/random/uniform_int_distribution/min",
            "sample_declaration": "result_type min() const;"
        },
        {
            "title": "operator==,!=(std::uniform_int_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/uniform_int_distribution/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const uniform_int_distribution& lhs,\n    const uniform_int_distribution& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::uniform_int_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/uniform_int_distribution/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    const uniform_int_distribution& d);",
            "other_declarations": 1
        },
        {
            "title": "std::uniform_int_distribution<IntType>::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution/operator().html",
            "wgPageName": "cpp/numeric/random/uniform_int_distribution/operator()",
            "sample_declaration": "template<class Generator>\nresult_type operator()(Generator& g);",
            "other_declarations": 1
        },
        {
            "title": "std::uniform_int_distribution<IntType>::param",
            "path": "en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution/param.html",
            "wgPageName": "cpp/numeric/random/uniform_int_distribution/param",
            "sample_declaration": "param_type param() const;",
            "other_declarations": 1
        },
        {
            "title": "std::uniform_int_distribution<IntType>::a, b",
            "path": "en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution/params.html",
            "wgPageName": "cpp/numeric/random/uniform_int_distribution/params",
            "sample_declaration": "result_type a() const;",
            "other_declarations": 1
        },
        {
            "title": "std::uniform_int_distribution<IntType>::reset",
            "path": "en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution/reset.html",
            "wgPageName": "cpp/numeric/random/uniform_int_distribution/reset",
            "sample_declaration": "void reset();"
        },
        {
            "title": "std::uniform_int_distribution<IntType>::uniform_int_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution/uniform_int_distribution.html",
            "wgPageName": "cpp/numeric/random/uniform_int_distribution/uniform_int_distribution",
            "sample_declaration": "uniform_int_distribution()\n    : uniform_int_distribution(0) {}",
            "other_declarations": 2
        },
        {
            "title": "std::uniform_random_bit_generator",
            "path": "en.cppreference.com/w/cpp/numeric/random/uniform_random_bit_generator.html",
            "wgPageName": "cpp/numeric/random/uniform_random_bit_generator",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<class G>\nconcept uniform_random_bit_generator =\n    std::invocable<G&> &&\n    std::unsigned_integral<\n        std::invoke_result_t<G&>> && requires {\n  {\n    G::min()\n    } -> std::same_as<std::invoke_result_t<G&>>;\n  {\n    G::max()\n    } -> std::same_as<std::invoke_result_t<G&>>;\n  requires std::bool_constant<(\n      G::min() < G::max())>::value;\n};"
        },
        {
            "title": "std::uniform_real_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution.html",
            "wgPageName": "cpp/numeric/random/uniform_real_distribution",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<class RealType = double>\nclass uniform_real_distribution;"
        },
        {
            "title": "std::uniform_real_distribution<RealType>::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution/max.html",
            "wgPageName": "cpp/numeric/random/uniform_real_distribution/max",
            "sample_declaration": "result_type max() const;"
        },
        {
            "title": "std::uniform_real_distribution<RealType>::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution/min.html",
            "wgPageName": "cpp/numeric/random/uniform_real_distribution/min",
            "sample_declaration": "result_type min() const;"
        },
        {
            "title": "operator==,!=(std::uniform_real_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/uniform_real_distribution/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const uniform_real_distribution& lhs,\n    const uniform_real_distribution& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::uniform_real_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/uniform_real_distribution/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    const uniform_real_distribution& d);",
            "other_declarations": 1
        },
        {
            "title": "std::uniform_real_distribution<RealType>::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution/operator().html",
            "wgPageName": "cpp/numeric/random/uniform_real_distribution/operator()",
            "sample_declaration": "template<class Generator>\nresult_type operator()(Generator& g);",
            "other_declarations": 1
        },
        {
            "title": "std::uniform_real_distribution<RealType>::param",
            "path": "en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution/param.html",
            "wgPageName": "cpp/numeric/random/uniform_real_distribution/param",
            "sample_declaration": "param_type param() const;",
            "other_declarations": 1
        },
        {
            "title": "std::uniform_real_distribution<RealType>::a, b",
            "path": "en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution/params.html",
            "wgPageName": "cpp/numeric/random/uniform_real_distribution/params",
            "sample_declaration": "result_type a() const;",
            "other_declarations": 1
        },
        {
            "title": "std::uniform_real_distribution<RealType>::reset",
            "path": "en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution/reset.html",
            "wgPageName": "cpp/numeric/random/uniform_real_distribution/reset",
            "sample_declaration": "void reset();"
        },
        {
            "title": "std::uniform_real_distribution<RealType>::uniform_real_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution/uniform_real_distribution.html",
            "wgPageName": "cpp/numeric/random/uniform_real_distribution/uniform_real_distribution",
            "sample_declaration": "uniform_real_distribution()\n    : uniform_real_distribution(0.0) {}",
            "other_declarations": 2
        },
        {
            "title": "std::uniform_random_bit_generator",
            "path": "en.cppreference.com/w/cpp/numeric/random/UniformRandomBitGenerator.html",
            "wgPageName": "cpp/numeric/random/uniform_random_bit_generator",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<class G>\nconcept uniform_random_bit_generator =\n    std::invocable<G&> &&\n    std::unsigned_integral<\n        std::invoke_result_t<G&>> && requires {\n  {\n    G::min()\n    } -> std::same_as<std::invoke_result_t<G&>>;\n  {\n    G::max()\n    } -> std::same_as<std::invoke_result_t<G&>>;\n  requires std::bool_constant<(\n      G::min() < G::max())>::value;\n};"
        },
        {
            "title": "std::weibull_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/weibull_distribution.html",
            "wgPageName": "cpp/numeric/random/weibull_distribution",
            "headers": [
                "<random>"
            ],
            "sample_declaration": "template<class RealType = double>\nclass weibull_distribution;"
        },
        {
            "title": "std::weibull_distribution<RealType>::max",
            "path": "en.cppreference.com/w/cpp/numeric/random/weibull_distribution/max.html",
            "wgPageName": "cpp/numeric/random/weibull_distribution/max",
            "sample_declaration": "result_type max() const;"
        },
        {
            "title": "std::weibull_distribution<RealType>::min",
            "path": "en.cppreference.com/w/cpp/numeric/random/weibull_distribution/min.html",
            "wgPageName": "cpp/numeric/random/weibull_distribution/min",
            "sample_declaration": "result_type min() const;"
        },
        {
            "title": "operator==,!=(std::weibull_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/weibull_distribution/operator_cmp.html",
            "wgPageName": "cpp/numeric/random/weibull_distribution/operator_cmp",
            "sample_declaration": "friend bool operator==(\n    const weibull_distribution& lhs,\n    const weibull_distribution& rhs);",
            "other_declarations": 1
        },
        {
            "title": "operator<<,>>(std::weibull_distribution)",
            "path": "en.cppreference.com/w/cpp/numeric/random/weibull_distribution/operator_ltltgtgt.html",
            "wgPageName": "cpp/numeric/random/weibull_distribution/operator_ltltgtgt",
            "sample_declaration": "template<class CharT, class Traits>\nfriend std::basic_ostream<CharT, Traits>&\noperator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    const weibull_distribution& d);",
            "other_declarations": 1
        },
        {
            "title": "std::weibull_distribution<RealType>::operator()",
            "path": "en.cppreference.com/w/cpp/numeric/random/weibull_distribution/operator().html",
            "wgPageName": "cpp/numeric/random/weibull_distribution/operator()",
            "sample_declaration": "template<class Generator>\nresult_type operator()(Generator& g);",
            "other_declarations": 1
        },
        {
            "title": "std::weibull_distribution<RealType>::param",
            "path": "en.cppreference.com/w/cpp/numeric/random/weibull_distribution/param.html",
            "wgPageName": "cpp/numeric/random/weibull_distribution/param",
            "sample_declaration": "param_type param() const;",
            "other_declarations": 1
        },
        {
            "title": "std::weibull_distribution<RealType>::a, b",
            "path": "en.cppreference.com/w/cpp/numeric/random/weibull_distribution/params.html",
            "wgPageName": "cpp/numeric/random/weibull_distribution/params",
            "sample_declaration": "RealType a() const;",
            "other_declarations": 1
        },
        {
            "title": "std::weibull_distribution<RealType>::reset",
            "path": "en.cppreference.com/w/cpp/numeric/random/weibull_distribution/reset.html",
            "wgPageName": "cpp/numeric/random/weibull_distribution/reset",
            "sample_declaration": "void reset();"
        },
        {
            "title": "std::weibull_distribution<RealType>::weibull_distribution",
            "path": "en.cppreference.com/w/cpp/numeric/random/weibull_distribution/weibull_distribution.html",
            "wgPageName": "cpp/numeric/random/weibull_distribution/weibull_distribution",
            "sample_declaration": "weibull_distribution()\n    : weibull_distribution(1.0) {}",
            "other_declarations": 2
        },
        {
            "title": "Compile-time rational arithmetic (since C++11)",
            "path": "en.cppreference.com/w/cpp/numeric/ratio.html",
            "wgPageName": "cpp/numeric/ratio"
        },
        {
            "title": "std::ratio_add",
            "path": "en.cppreference.com/w/cpp/numeric/ratio/ratio_add.html",
            "wgPageName": "cpp/numeric/ratio/ratio_add",
            "headers": [
                "<ratio>"
            ],
            "sample_declaration": "template<class R1, class R2>\nusing ratio_add = /* see below */;"
        },
        {
            "title": "std::ratio_divide",
            "path": "en.cppreference.com/w/cpp/numeric/ratio/ratio_divide.html",
            "wgPageName": "cpp/numeric/ratio/ratio_divide",
            "headers": [
                "<ratio>"
            ],
            "sample_declaration": "template<class R1, class R2>\nusing ratio_divide = /* see below */;"
        },
        {
            "title": "std::ratio_equal",
            "path": "en.cppreference.com/w/cpp/numeric/ratio/ratio_equal.html",
            "wgPageName": "cpp/numeric/ratio/ratio_equal",
            "headers": [
                "<ratio>"
            ],
            "sample_declaration": "template<class R1, class R2>\nstruct ratio_equal : std::integral_constant<\n                         bool,\n                         /* see below */> {};"
        },
        {
            "title": "std::ratio_greater_equal",
            "path": "en.cppreference.com/w/cpp/numeric/ratio/ratio_greater_equal.html",
            "wgPageName": "cpp/numeric/ratio/ratio_greater_equal",
            "headers": [
                "<ratio>"
            ],
            "sample_declaration": "template<class R1, class R2>\nstruct ratio_greater_equal\n    : std::integral_constant<\n          bool,\n          /* see below */> {};"
        },
        {
            "title": "std::ratio_greater",
            "path": "en.cppreference.com/w/cpp/numeric/ratio/ratio_greater.html",
            "wgPageName": "cpp/numeric/ratio/ratio_greater",
            "headers": [
                "<ratio>"
            ],
            "sample_declaration": "template<class R1, class R2>\nstruct ratio_greater : std::integral_constant<\n                           bool,\n                           /* see below */> {};"
        },
        {
            "title": "std::ratio_less_equal",
            "path": "en.cppreference.com/w/cpp/numeric/ratio/ratio_less_equal.html",
            "wgPageName": "cpp/numeric/ratio/ratio_less_equal",
            "headers": [
                "<ratio>"
            ],
            "sample_declaration": "template<class R1, class R2>\nstruct ratio_less_equal\n    : std::integral_constant<\n          bool,\n          /* see below */> {};"
        },
        {
            "title": "std::ratio_less",
            "path": "en.cppreference.com/w/cpp/numeric/ratio/ratio_less.html",
            "wgPageName": "cpp/numeric/ratio/ratio_less",
            "headers": [
                "<ratio>"
            ],
            "sample_declaration": "template<class R1, class R2>\nstruct ratio_less : std::integral_constant<\n                        bool,\n                        /* see below */> {};"
        },
        {
            "title": "std::ratio_multiply",
            "path": "en.cppreference.com/w/cpp/numeric/ratio/ratio_multiply.html",
            "wgPageName": "cpp/numeric/ratio/ratio_multiply",
            "headers": [
                "<ratio>"
            ],
            "sample_declaration": "template<class R1, class R2>\nusing ratio_multiply = /* see below */;"
        },
        {
            "title": "std::ratio_not_equal",
            "path": "en.cppreference.com/w/cpp/numeric/ratio/ratio_not_equal.html",
            "wgPageName": "cpp/numeric/ratio/ratio_not_equal",
            "headers": [
                "<ratio>"
            ],
            "sample_declaration": "template<class R1, class R2>\nstruct ratio_not_equal : std::integral_constant<\n                             bool,\n                             /* see below */> {\n};"
        },
        {
            "title": "std::ratio_subtract",
            "path": "en.cppreference.com/w/cpp/numeric/ratio/ratio_subtract.html",
            "wgPageName": "cpp/numeric/ratio/ratio_subtract",
            "headers": [
                "<ratio>"
            ],
            "sample_declaration": "template<class R1, class R2>\nusing ratio_subtract = /* see below */;"
        },
        {
            "title": "std::ratio",
            "path": "en.cppreference.com/w/cpp/numeric/ratio/ratio.html",
            "wgPageName": "cpp/numeric/ratio/ratio",
            "headers": [
                "<ratio>"
            ],
            "sample_declaration": "template<\n    std::intmax_t Num,\n    std::intmax_t Denom = 1>\nclass ratio;"
        },
        {
            "title": "std::rotl",
            "path": "en.cppreference.com/w/cpp/numeric/rotl.html",
            "wgPageName": "cpp/numeric/rotl",
            "headers": [
                "<bit>"
            ],
            "sample_declaration": "template<class T>\n[[nodiscard]] constexpr T rotl(\n    T x,\n    int s) noexcept;"
        },
        {
            "title": "std::rotr",
            "path": "en.cppreference.com/w/cpp/numeric/rotr.html",
            "wgPageName": "cpp/numeric/rotr",
            "headers": [
                "<bit>"
            ],
            "sample_declaration": "template<class T>\n[[nodiscard]] constexpr T rotr(\n    T x,\n    int s) noexcept;"
        },
        {
            "title": "Mathematical special functions (since C++17)",
            "path": "en.cppreference.com/w/cpp/numeric/special_functions.html",
            "wgPageName": "cpp/numeric/special_functions"
        },
        {
            "title": "std::assoc_laguerre, std::assoc_laguerref, std::assoc_laguerrel",
            "path": "en.cppreference.com/w/cpp/numeric/special_functions/assoc_laguerre.html",
            "wgPageName": "cpp/numeric/special_functions/assoc_laguerre",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "double assoc_laguerre(\n    unsigned int n,\n    unsigned int m,\n    double x);\nfloat assoc_laguerre(\n    unsigned int n,\n    unsigned int m,\n    float x);\nlong double assoc_laguerre(\n    unsigned int n,\n    unsigned int m,\n    long double x);\nfloat assoc_laguerref(\n    unsigned int n,\n    unsigned int m,\n    float x);\nlong double assoc_laguerrel(\n    unsigned int n,\n    unsigned int m,\n    long double x);",
            "other_declarations": 1
        },
        {
            "title": "std::assoc_legendre, std::assoc_legendref, std::assoc_legendrel",
            "path": "en.cppreference.com/w/cpp/numeric/special_functions/assoc_legendre.html",
            "wgPageName": "cpp/numeric/special_functions/assoc_legendre",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "double assoc_legendre(\n    unsigned int n,\n    unsigned int m,\n    double x);\nfloat assoc_legendre(\n    unsigned int n,\n    unsigned int m,\n    float x);\nlong double assoc_legendre(\n    unsigned int n,\n    unsigned int m,\n    long double x);\nfloat assoc_legendref(\n    unsigned int n,\n    unsigned int m,\n    float x);\nlong double assoc_legendrel(\n    unsigned int n,\n    unsigned int m,\n    long double x);",
            "other_declarations": 1
        },
        {
            "title": "std::beta, std::betaf, std::betal",
            "path": "en.cppreference.com/w/cpp/numeric/special_functions/beta.html",
            "wgPageName": "cpp/numeric/special_functions/beta",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "double beta(double x, double y);\nfloat betaf(float x, float y);\nlong double betal(long double x, long double y);",
            "other_declarations": 1
        },
        {
            "title": "std::comp_ellint_1, std::comp_ellint_1f, std::comp_ellint_1l",
            "path": "en.cppreference.com/w/cpp/numeric/special_functions/comp_ellint_1.html",
            "wgPageName": "cpp/numeric/special_functions/comp_ellint_1",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "double comp_ellint_1(double k);\nfloat comp_ellint_1(float k);\nlong double comp_ellint_1(long double k);\nfloat comp_ellint_1f(float k);\nlong double comp_ellint_1l(long double k);",
            "other_declarations": 1
        },
        {
            "title": "std::comp_ellint_2, std::comp_ellint_2f, std::comp_ellint_2l",
            "path": "en.cppreference.com/w/cpp/numeric/special_functions/comp_ellint_2.html",
            "wgPageName": "cpp/numeric/special_functions/comp_ellint_2",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "double comp_ellint_2(double k);\nfloat comp_ellint_2(float k);\nlong double comp_ellint_2(long double k);\nfloat comp_ellint_2f(float k);\nlong double comp_ellint_2l(long double k);",
            "other_declarations": 1
        },
        {
            "title": "std::comp_ellint_3, std::comp_ellint_3f, std::comp_ellint_3l",
            "path": "en.cppreference.com/w/cpp/numeric/special_functions/comp_ellint_3.html",
            "wgPageName": "cpp/numeric/special_functions/comp_ellint_3",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "double comp_ellint_3(double k, double );\nfloat comp_ellint_3f(float k, float );\nlong double comp_ellint_3l(\n    long double k,\n    long double );",
            "other_declarations": 1
        },
        {
            "title": "std::cyl_bessel_i, std::cyl_bessel_if, std::cyl_bessel_il",
            "path": "en.cppreference.com/w/cpp/numeric/special_functions/cyl_bessel_i.html",
            "wgPageName": "cpp/numeric/special_functions/cyl_bessel_i",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "double cyl_bessel_i(double , double x);\nfloat cyl_bessel_if(float , float x);\nlong double cyl_bessel_il(\n    long double ,\n    long double x);",
            "other_declarations": 1
        },
        {
            "title": "std::cyl_bessel_j, std::cyl_bessel_jf, std::cyl_bessel_jl",
            "path": "en.cppreference.com/w/cpp/numeric/special_functions/cyl_bessel_j.html",
            "wgPageName": "cpp/numeric/special_functions/cyl_bessel_j",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "double cyl_bessel_j(double , double x);\nfloat cyl_bessel_jf(float , float x);\nlong double cyl_bessel_jl(\n    long double ,\n    long double x);",
            "other_declarations": 1
        },
        {
            "title": "std::cyl_bessel_k, std::cyl_bessel_kf, std::cyl_bessel_kl",
            "path": "en.cppreference.com/w/cpp/numeric/special_functions/cyl_bessel_k.html",
            "wgPageName": "cpp/numeric/special_functions/cyl_bessel_k",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "double cyl_bessel_k(double , double x);\nfloat cyl_bessel_kf(float , float x);\nlong double cyl_bessel_kl(\n    long double ,\n    long double x);",
            "other_declarations": 1
        },
        {
            "title": "std::cyl_neumann, std::cyl_neumannf, std::cyl_neumannl",
            "path": "en.cppreference.com/w/cpp/numeric/special_functions/cyl_neumann.html",
            "wgPageName": "cpp/numeric/special_functions/cyl_neumann",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "double cyl_neumann(double , double x);\nfloat cyl_neumannf(float , float x);\nlong double cyl_neumannl(\n    long double ,\n    long double x);",
            "other_declarations": 1
        },
        {
            "title": "std::ellint_1, std::ellint_1f, std::ellint_1l",
            "path": "en.cppreference.com/w/cpp/numeric/special_functions/ellint_1.html",
            "wgPageName": "cpp/numeric/special_functions/ellint_1",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "double ellint_1(double k, double );\nfloat ellint_1f(float k, float );\nlong double ellint_1l(\n    long double k,\n    long double );",
            "other_declarations": 1
        },
        {
            "title": "std::ellint_2, std::ellint_2f, std::ellint_2l",
            "path": "en.cppreference.com/w/cpp/numeric/special_functions/ellint_2.html",
            "wgPageName": "cpp/numeric/special_functions/ellint_2",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "double ellint_2(double k, double );\nfloat ellint_2f(float k, float );\nlong double ellint_2l(\n    long double k,\n    long double );",
            "other_declarations": 1
        },
        {
            "title": "std::ellint_3, std::ellint_3f, std::ellint_3l",
            "path": "en.cppreference.com/w/cpp/numeric/special_functions/ellint_3.html",
            "wgPageName": "cpp/numeric/special_functions/ellint_3",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "double ellint_3(double k, double , double );\nfloat ellint_3f(float k, float , float );\nlong double ellint_3l(\n    long double k,\n    long double ,\n    long double );",
            "other_declarations": 1
        },
        {
            "title": "std::expint, std::expintf, std::expintl",
            "path": "en.cppreference.com/w/cpp/numeric/special_functions/expint.html",
            "wgPageName": "cpp/numeric/special_functions/expint",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "double expint(double arg);\nfloat expint(float arg);\nlong double expint(long double arg);\nfloat expintf(float arg);\nlong double expintl(long double arg);",
            "other_declarations": 1
        },
        {
            "title": "std::hermite, std::hermitef, std::hermitel",
            "path": "en.cppreference.com/w/cpp/numeric/special_functions/hermite.html",
            "wgPageName": "cpp/numeric/special_functions/hermite",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "double hermite(unsigned int n, double x);\nfloat hermite(unsigned int n, float x);\nlong double hermite(\n    unsigned int n,\n    long double x);\nfloat hermitef(unsigned int n, float x);\nlong double hermitel(\n    unsigned int n,\n    long double x);",
            "other_declarations": 1
        },
        {
            "title": "std::laguerre, std::laguerref, std::laguerrel",
            "path": "en.cppreference.com/w/cpp/numeric/special_functions/laguerre.html",
            "wgPageName": "cpp/numeric/special_functions/laguerre",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "double laguerre(unsigned int n, double x);\nfloat laguerre(unsigned int n, float x);\nlong double laguerre(\n    unsigned int n,\n    long double x);\nfloat laguerref(unsigned int n, float x);\nlong double laguerrel(\n    unsigned int n,\n    long double x);",
            "other_declarations": 1
        },
        {
            "title": "std::legendre, std::legendref, std::legendrel",
            "path": "en.cppreference.com/w/cpp/numeric/special_functions/legendre.html",
            "wgPageName": "cpp/numeric/special_functions/legendre",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "double legendre(unsigned int n, double x);\nfloat legendre(unsigned int n, float x);\nlong double legendre(\n    unsigned int n,\n    long double x);\nfloat legendref(unsigned int n, float x);\nlong double legendrel(\n    unsigned int n,\n    long double x);",
            "other_declarations": 1
        },
        {
            "title": "std::riemann_zeta, std::riemann_zetaf, std::riemann_zetal",
            "path": "en.cppreference.com/w/cpp/numeric/special_functions/riemann_zeta.html",
            "wgPageName": "cpp/numeric/special_functions/riemann_zeta",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "double riemann_zeta(double arg);\nfloat riemann_zeta(float arg);\nlong double riemann_zeta(long double arg);\nfloat riemann_zetaf(float arg);\nlong double riemann_zetal(long double arg);",
            "other_declarations": 1
        },
        {
            "title": "std::sph_bessel, std::sph_besself, std::sph_bessell",
            "path": "en.cppreference.com/w/cpp/numeric/special_functions/sph_bessel.html",
            "wgPageName": "cpp/numeric/special_functions/sph_bessel",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "double sph_bessel(unsigned n, double x);\nfloat sph_bessel(unsigned n, float x);\nlong double sph_bessel(\n    unsigned n,\n    long double x);\nfloat sph_besself(unsigned n, float x);\nlong double sph_bessell(\n    unsigned n,\n    long double x);",
            "other_declarations": 1
        },
        {
            "title": "std::sph_legendre, std::sph_legendref, std::sph_legendrel",
            "path": "en.cppreference.com/w/cpp/numeric/special_functions/sph_legendre.html",
            "wgPageName": "cpp/numeric/special_functions/sph_legendre",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "double\nsph_legendre(unsigned l, unsigned m, double );\nfloat sph_legendre(\n    unsigned l,\n    unsigned m,\n    float );\nlong double sph_legendre(\n    unsigned l,\n    unsigned m,\n    long double );\nfloat sph_legendref(\n    unsigned l,\n    unsigned m,\n    float );\nlong double sph_legendrel(\n    unsigned l,\n    unsigned m,\n    long double );",
            "other_declarations": 1
        },
        {
            "title": "std::sph_neumann, std::sph_neumannf, std::sph_neumannl",
            "path": "en.cppreference.com/w/cpp/numeric/special_functions/sph_neumann.html",
            "wgPageName": "cpp/numeric/special_functions/sph_neumann",
            "headers": [
                "<cmath>"
            ],
            "sample_declaration": "double sph_neumann(unsigned n, double x);\nfloat sph_neumann(unsigned n, float x);\nlong double sph_neumann(\n    unsigned n,\n    long double x);\nfloat sph_neumannf(unsigned n, float x);\nlong double sph_neumannl(\n    unsigned n,\n    long double x);",
            "other_declarations": 1
        },
        {
            "title": "std::valarray",
            "path": "en.cppreference.com/w/cpp/numeric/valarray.html",
            "wgPageName": "cpp/numeric/valarray",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "template<class T>\nclass valarray;"
        },
        {
            "title": "std::valarray<T>::~valarray",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/~valarray.html",
            "wgPageName": "cpp/numeric/valarray/~valarray",
            "sample_declaration": "~valarray()"
        },
        {
            "title": "std::abs(std::valarray)",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/abs.html",
            "wgPageName": "cpp/numeric/valarray/abs",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "template<class T>\nvalarray<T> abs(const valarray<T>& va);"
        },
        {
            "title": "std::acos(std::valarray)",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/acos.html",
            "wgPageName": "cpp/numeric/valarray/acos",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "template<class T>\nvalarray<T> acos(const valarray<T>& va);"
        },
        {
            "title": "std::valarray<T>::apply",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/apply.html",
            "wgPageName": "cpp/numeric/valarray/apply",
            "sample_declaration": "valarray<T> apply(T func(T)) const;",
            "other_declarations": 1
        },
        {
            "title": "std::asin(std::valarray)",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/asin.html",
            "wgPageName": "cpp/numeric/valarray/asin",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "template<class T>\nvalarray<T> asin(const valarray<T>& va);"
        },
        {
            "title": "std::atan(std::valarray)",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/atan.html",
            "wgPageName": "cpp/numeric/valarray/atan",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "template<class T>\nvalarray<T> atan(const valarray<T>& va);"
        },
        {
            "title": "std::atan2(std::valarray)",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/atan2.html",
            "wgPageName": "cpp/numeric/valarray/atan2",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "template<class T>\nstd::valarray<T> atan2(\n    const std::valarray<T>& y,\n    const std::valarray<T>& x);",
            "other_declarations": 2
        },
        {
            "title": "std::begin(std::valarray)",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/begin2.html",
            "wgPageName": "cpp/numeric/valarray/begin2",
            "sample_declaration": "template<class T>\n/*unspecified1*/ begin(valarray<T>& v);",
            "other_declarations": 1
        },
        {
            "title": "std::cos(std::valarray)",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/cos.html",
            "wgPageName": "cpp/numeric/valarray/cos",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "template<class T>\nvalarray<T> cos(const valarray<T>& va);"
        },
        {
            "title": "std::cosh(std::valarray)",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/cosh.html",
            "wgPageName": "cpp/numeric/valarray/cosh",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "template<class T>\nvalarray<T> cosh(const valarray<T>& va);"
        },
        {
            "title": "std::valarray<T>::cshift",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/cshift.html",
            "wgPageName": "cpp/numeric/valarray/cshift",
            "sample_declaration": "valarray<T> cshift(int count) const;"
        },
        {
            "title": "deduction guides for std::valarray",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/deduction_guides.html",
            "wgPageName": "cpp/numeric/valarray/deduction_guides",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "template<typename T, std::size_t cnt>\nvalarray(const T (&)[cnt], std::size_t)\n    -> valarray<T>;"
        },
        {
            "title": "std::end(std::valarray)",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/end2.html",
            "wgPageName": "cpp/numeric/valarray/end2",
            "sample_declaration": "template<class T>\n/*unspecified1*/ end(valarray<T>& v);",
            "other_declarations": 1
        },
        {
            "title": "std::exp(std::valarray)",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/exp.html",
            "wgPageName": "cpp/numeric/valarray/exp",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "template<class T>\nvalarray<T> exp(const valarray<T>& va);"
        },
        {
            "title": "std::gslice_array",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/gslice_array.html",
            "wgPageName": "cpp/numeric/valarray/gslice_array",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "template<class T>\nclass gslice_array;"
        },
        {
            "title": "std::gslice_array<T>::~gslice_array",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/gslice_array/~gslice_array.html",
            "wgPageName": "cpp/numeric/valarray/gslice_array/~gslice_array",
            "sample_declaration": "~gslice_array();"
        },
        {
            "title": "std::gslice_array<T>::gslice_array",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/gslice_array/gslice_array.html",
            "wgPageName": "cpp/numeric/valarray/gslice_array/gslice_array",
            "sample_declaration": "gslice_array(const gslice_array& other);",
            "other_declarations": 1
        },
        {
            "title": "std::gslice_array<T>::operator+=,-=,*=,/=,%=,&=,|=,^=,<<=,>>=",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/gslice_array/operator_arith.html",
            "wgPageName": "cpp/numeric/valarray/gslice_array/operator_arith",
            "sample_declaration": "void operator+=(\n    const std::valarray<T>& other) const;",
            "other_declarations": 9
        },
        {
            "title": "std::gslice_array<T>::operator=",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/gslice_array/operator=.html",
            "wgPageName": "cpp/numeric/valarray/gslice_array/operator=",
            "sample_declaration": "void operator=(const T& value) const;",
            "other_declarations": 2
        },
        {
            "title": "std::gslice",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/gslice.html",
            "wgPageName": "cpp/numeric/valarray/gslice",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "class gslice;"
        },
        {
            "title": "std::indirect_array",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/indirect_array.html",
            "wgPageName": "cpp/numeric/valarray/indirect_array",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "template<class T>\nclass indirect_array;"
        },
        {
            "title": "std::indirect_array<T>::~indirect_array",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/indirect_array/~indirect_array.html",
            "wgPageName": "cpp/numeric/valarray/indirect_array/~indirect_array",
            "sample_declaration": "~indirect_array();"
        },
        {
            "title": "std::indirect_array<T>::indirect_array",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/indirect_array/indirect_array.html",
            "wgPageName": "cpp/numeric/valarray/indirect_array/indirect_array",
            "sample_declaration": "indirect_array(const indirect_array& other);",
            "other_declarations": 1
        },
        {
            "title": "std::indirect_array<T>::operator+=,-=,*=,/=,%=,&=,|=,^=,<<=,>>=",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/indirect_array/operator_arith.html",
            "wgPageName": "cpp/numeric/valarray/indirect_array/operator_arith",
            "sample_declaration": "void operator+=(\n    const std::valarray<T>& other) const;",
            "other_declarations": 9
        },
        {
            "title": "std::indirect_array<T>::operator=",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/indirect_array/operator=.html",
            "wgPageName": "cpp/numeric/valarray/indirect_array/operator=",
            "sample_declaration": "void operator=(const T& value) const;",
            "other_declarations": 2
        },
        {
            "title": "std::log(std::valarray)",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/log.html",
            "wgPageName": "cpp/numeric/valarray/log",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "template<class T>\nvalarray<T> log(const valarray<T>& va);"
        },
        {
            "title": "std::log10(std::valarray)",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/log10.html",
            "wgPageName": "cpp/numeric/valarray/log10",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "template<class T>\nvalarray<T> log10(const valarray<T>& va);"
        },
        {
            "title": "std::mask_array",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/mask_array.html",
            "wgPageName": "cpp/numeric/valarray/mask_array",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "template<class T>\nclass mask_array;"
        },
        {
            "title": "std::mask_array<T>::~mask_array",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/mask_array/~mask_array.html",
            "wgPageName": "cpp/numeric/valarray/mask_array/~mask_array",
            "sample_declaration": "~mask_array();"
        },
        {
            "title": "std::mask_array<T>::mask_array",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/mask_array/mask_array.html",
            "wgPageName": "cpp/numeric/valarray/mask_array/mask_array",
            "sample_declaration": "mask_array(const mask_array& other);",
            "other_declarations": 1
        },
        {
            "title": "std::mask_array<T>::operator+=,-=,*=,/=,%=,&=,|=,^=,<<=,>>=",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/mask_array/operator_arith.html",
            "wgPageName": "cpp/numeric/valarray/mask_array/operator_arith",
            "sample_declaration": "void operator+=(\n    const std::valarray<T>& other) const;",
            "other_declarations": 9
        },
        {
            "title": "std::mask_array<T>::operator=",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/mask_array/operator=.html",
            "wgPageName": "cpp/numeric/valarray/mask_array/operator=",
            "sample_declaration": "void operator=(const T& value) const;",
            "other_declarations": 2
        },
        {
            "title": "std::valarray<T>::max",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/max.html",
            "wgPageName": "cpp/numeric/valarray/max",
            "sample_declaration": "T max() const;"
        },
        {
            "title": "std::valarray<T>::min",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/min.html",
            "wgPageName": "cpp/numeric/valarray/min",
            "sample_declaration": "T min() const;"
        },
        {
            "title": "std::valarray<T>::operator+,-,~,!",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/operator_arith.html",
            "wgPageName": "cpp/numeric/valarray/operator_arith",
            "sample_declaration": "valarray<T> operator+() const;",
            "other_declarations": 3
        },
        {
            "title": "std::valarray<T>::operator+=,-=,*=,/=,%=,&=,|=,<<=,>>=",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/operator_arith2.html",
            "wgPageName": "cpp/numeric/valarray/operator_arith2",
            "sample_declaration": "valarray<T>& operator+=(const valarray<T>& v);\nvalarray<T>& operator-=(const valarray<T>& v);\nvalarray<T>& operator*=(const valarray<T>& v);\nvalarray<T>& operator/=(const valarray<T>& v);\nvalarray<T>& operator%=(const valarray<T>& v);\nvalarray<T>& operator&=(const valarray<T>& v);\nvalarray<T>& operator|=(const valarray<T>& v);\nvalarray<T>& operator^=(const valarray<T>& v);\nvalarray<T>& operator<<=(const valarray<T>& v);\nvalarray<T>& operator>>=(const valarray<T>& v);",
            "other_declarations": 1
        },
        {
            "title": "operator+,-,*,/,%,&,|,^,<<,>>,&&,|| (std::valarray)",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/operator_arith3.html",
            "wgPageName": "cpp/numeric/valarray/operator_arith3",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "template<class T>\nstd::valarray<T> operator+(\n    const std::valarray<T>& lhs,\n    const std::valarray<T>& rhs);\ntemplate<class T>\nstd::valarray<T> operator-(\n    const std::valarray<T>& lhs,\n    const std::valarray<T>& rhs);\ntemplate<class T>\nstd::valarray<T> operator*(\n    const std::valarray<T>& lhs,\n    const std::valarray<T>& rhs);\ntemplate<class T>\nstd::valarray<T> operator/(\n    const std::valarray<T>& lhs,\n    const std::valarray<T>& rhs);\ntemplate<class T>\nstd::valarray<T> operator%(\n    const std::valarray<T>& lhs,\n    const std::valarray<T>& rhs);\ntemplate<class T>\nstd::valarray<T> operator&(\n    const std::valarray<T>& lhs,\n    const std::valarray<T>& rhs);\ntemplate<class T>\nstd::valarray<T> operator|(\n    const std::valarray<T>& lhs,\n    const std::valarray<T>& rhs);\ntemplate<class T>\nstd::valarray<T> operator^(\n    const std::valarray<T>& lhs,\n    const std::valarray<T>& rhs);\ntemplate<class T>\nstd::valarray<T> operator<<(\n    const std::valarray<T>& lhs,\n    const std::valarray<T>& rhs);\ntemplate<class T>\nstd::valarray<T> operator>>(\n    const std::valarray<T>& lhs,\n    const std::valarray<T>& rhs);\ntemplate<class T>\nstd::valarray<bool> operator&&(\n    const std::valarray<T>& lhs,\n    const std::valarray<T>& rhs);\ntemplate<class T>\nstd::valarray<bool> operator||(\n    const std::valarray<T>& lhs,\n    const std::valarray<T>& rhs);",
            "other_declarations": 2
        },
        {
            "title": "std::valarray<T>::operator[]",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/operator_at.html",
            "wgPageName": "cpp/numeric/valarray/operator_at",
            "sample_declaration": "T operator[](std::size_t pos) const;",
            "other_declarations": 10
        },
        {
            "title": "operator==,!=,<,<=,>,>=(std::valarray)",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/operator_cmp.html",
            "wgPageName": "cpp/numeric/valarray/operator_cmp",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "template<class T>\nstd::valarray<bool> operator==(\n    const std::valarray<T>& lhs,\n    const std::valarray<T>& rhs);\ntemplate<class T>\nstd::valarray<bool> operator!=(\n    const std::valarray<T>& lhs,\n    const std::valarray<T>& rhs);\ntemplate<class T>\nstd::valarray<bool> operator<(\n    const std::valarray<T>& lhs,\n    const std::valarray<T>& rhs);\ntemplate<class T>\nstd::valarray<bool> operator<=(\n    const std::valarray<T>& lhs,\n    const std::valarray<T>& rhs);\ntemplate<class T>\nstd::valarray<bool> operator>(\n    const std::valarray<T>& lhs,\n    const std::valarray<T>& rhs);\ntemplate<class T>\nstd::valarray<bool> operator>=(\n    const std::valarray<T>& lhs,\n    const std::valarray<T>& rhs);",
            "other_declarations": 2
        },
        {
            "title": "std::valarray<T>::operator=",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/operator=.html",
            "wgPageName": "cpp/numeric/valarray/operator=",
            "sample_declaration": "valarray<T>& operator=(\n    const valarray<T>& other);",
            "other_declarations": 7
        },
        {
            "title": "std::pow(std::valarray)",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/pow.html",
            "wgPageName": "cpp/numeric/valarray/pow",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "template<class T>\nstd::valarray<T> pow(\n    const std::valarray<T>& base,\n    const std::valarray<T>& exp);",
            "other_declarations": 2
        },
        {
            "title": "std::valarray<T>::resize",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/resize.html",
            "wgPageName": "cpp/numeric/valarray/resize",
            "sample_declaration": "void resize(std::size_t count, T value = T());"
        },
        {
            "title": "std::valarray<T>::shift",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/shift.html",
            "wgPageName": "cpp/numeric/valarray/shift",
            "sample_declaration": "valarray<T> shift(int count) const;"
        },
        {
            "title": "std::sin(std::valarray)",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/sin.html",
            "wgPageName": "cpp/numeric/valarray/sin",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "template<class T>\nvalarray<T> sin(const valarray<T>& va);"
        },
        {
            "title": "std::sinh(std::valarray)",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/sinh.html",
            "wgPageName": "cpp/numeric/valarray/sinh",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "template<class T>\nvalarray<T> sinh(const valarray<T>& va);"
        },
        {
            "title": "std::valarray<T>::size",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/size.html",
            "wgPageName": "cpp/numeric/valarray/size",
            "sample_declaration": "std::size_t size() const;"
        },
        {
            "title": "std::slice_array",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/slice_array.html",
            "wgPageName": "cpp/numeric/valarray/slice_array",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "template<class T>\nclass slice_array;"
        },
        {
            "title": "std::slice_array<T>::~slice_array",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/slice_array/~slice_array.html",
            "wgPageName": "cpp/numeric/valarray/slice_array/~slice_array",
            "sample_declaration": "~slice_array();"
        },
        {
            "title": "std::slice_array<T>::operator+=,-=,*=,/=,%=,&=,|=,^=,<<=,>>=",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/slice_array/operator_arith.html",
            "wgPageName": "cpp/numeric/valarray/slice_array/operator_arith",
            "sample_declaration": "void operator+=(\n    const std::valarray<T>& other) const;",
            "other_declarations": 9
        },
        {
            "title": "std::slice_array<T>::operator=",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/slice_array/operator=.html",
            "wgPageName": "cpp/numeric/valarray/slice_array/operator=",
            "sample_declaration": "void operator=(const T& value) const;",
            "other_declarations": 2
        },
        {
            "title": "std::slice_array<T>::slice_array",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/slice_array/slice_array.html",
            "wgPageName": "cpp/numeric/valarray/slice_array/slice_array",
            "sample_declaration": "slice_array(const slice_array& other);",
            "other_declarations": 1
        },
        {
            "title": "std::slice",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/slice.html",
            "wgPageName": "cpp/numeric/valarray/slice",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "class slice;"
        },
        {
            "title": "std::sqrt(std::valarray)",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/sqrt.html",
            "wgPageName": "cpp/numeric/valarray/sqrt",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "template<class T>\nvalarray<T> sqrt(const valarray<T>& va);"
        },
        {
            "title": "std::valarray<T>::sum",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/sum.html",
            "wgPageName": "cpp/numeric/valarray/sum",
            "sample_declaration": "T sum() const;"
        },
        {
            "title": "std::valarray<T>::swap",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/swap.html",
            "wgPageName": "cpp/numeric/valarray/swap",
            "sample_declaration": "void swap(valarray& other);",
            "other_declarations": 1
        },
        {
            "title": "std::swap(std::valarray)",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/swap2.html",
            "wgPageName": "cpp/numeric/valarray/swap2",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "template<class T>\nvoid swap(\n    std::valarray<T>& lhs,\n    std::valarray<T>& rhs) noexcept;"
        },
        {
            "title": "std::tan(std::valarray)",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/tan.html",
            "wgPageName": "cpp/numeric/valarray/tan",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "template<class T>\nvalarray<T> tan(const valarray<T>& va);"
        },
        {
            "title": "std::tanh(std::valarray)",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/tanh.html",
            "wgPageName": "cpp/numeric/valarray/tanh",
            "headers": [
                "<valarray>"
            ],
            "sample_declaration": "template<class T>\nvalarray<T> tanh(const valarray<T>& va);"
        },
        {
            "title": "std::valarray<T>::valarray",
            "path": "en.cppreference.com/w/cpp/numeric/valarray/valarray.html",
            "wgPageName": "cpp/numeric/valarray/valarray",
            "sample_declaration": "valarray();",
            "other_declarations": 10
        },
        {
            "title": "Preprocessor",
            "path": "en.cppreference.com/w/cpp/preprocessor.html",
            "wgPageName": "cpp/preprocessor"
        },
        {
            "title": "Conditional inclusion",
            "path": "en.cppreference.com/w/cpp/preprocessor/conditional.html",
            "wgPageName": "cpp/preprocessor/conditional"
        },
        {
            "title": "Diagnostic directives",
            "path": "en.cppreference.com/w/cpp/preprocessor/error.html",
            "wgPageName": "cpp/preprocessor/error"
        },
        {
            "title": "Implementation defined behavior control",
            "path": "en.cppreference.com/w/cpp/preprocessor/impl.html",
            "wgPageName": "cpp/preprocessor/impl"
        },
        {
            "title": "Source file inclusion",
            "path": "en.cppreference.com/w/cpp/preprocessor/include.html",
            "wgPageName": "cpp/preprocessor/include"
        },
        {
            "title": "Filename and line information",
            "path": "en.cppreference.com/w/cpp/preprocessor/line.html",
            "wgPageName": "cpp/preprocessor/line"
        },
        {
            "title": "Replacing text macros",
            "path": "en.cppreference.com/w/cpp/preprocessor/replace.html",
            "wgPageName": "cpp/preprocessor/replace"
        },
        {
            "title": "Ranges library (C++20)",
            "path": "en.cppreference.com/w/cpp/ranges.html",
            "wgPageName": "cpp/ranges",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "namespace std {\nnamespace views = ranges::views;\n}"
        },
        {
            "title": "std::ranges::views::adjacent, std::ranges::adjacent_view",
            "path": "en.cppreference.com/w/cpp/ranges/adjacent_view.html",
            "wgPageName": "cpp/ranges/adjacent_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<ranges::forward_range V, std::size_t N>\nrequires ranges::view<V> &&\n    (N > 0) class adjacent_view\n    : public ranges::view_interface<\n          adjacent_view<V, N>>",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::adjacent_view<V,N>::adjacent_view",
            "path": "en.cppreference.com/w/cpp/ranges/adjacent_view/adjacent_view.html",
            "wgPageName": "cpp/ranges/adjacent_view/adjacent_view",
            "sample_declaration": "adjacent_view() requires\n    std::default_initializable<V>\n= default;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::adjacent_view<V,N>::begin",
            "path": "en.cppreference.com/w/cpp/ranges/adjacent_view/begin.html",
            "wgPageName": "cpp/ranges/adjacent_view/begin",
            "sample_declaration": "constexpr auto begin() requires(\n    !__SimpleView<V>);",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::views::all, std::ranges::views::all_t",
            "path": "en.cppreference.com/w/cpp/ranges/all_view.html",
            "wgPageName": "cpp/ranges/all_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "inline constexpr /* unspecified */ all =\n    /* unspecified */;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::views::as_const, std::ranges::as_const_view",
            "path": "en.cppreference.com/w/cpp/ranges/as_const_view.html",
            "wgPageName": "cpp/ranges/as_const_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<ranges::view V>\nrequires ranges::input_range<V>\nclass as_const_view\n    : public ranges::view_interface<\n          as_const_view<V>>",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::views::as_rvalue, std::ranges::as_rvalue_view",
            "path": "en.cppreference.com/w/cpp/ranges/as_rvalue_view.html",
            "wgPageName": "cpp/ranges/as_rvalue_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<ranges::view V>\nrequires ranges::input_range<V>\nclass as_rvalue_view\n    : public ranges::view_interface<\n          as_rvalue_view<V>>",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::views::istream, std::ranges::basic_istream_view, std::ranges::istream_view, std::ranges::wistream_view",
            "path": "en.cppreference.com/w/cpp/ranges/basic_istream_view.html",
            "wgPageName": "cpp/ranges/basic_istream_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<\n    std::movable Val,\n    class CharT,\n    class Traits = std::char_traits<CharT>>\nrequires std::default_initializable<Val> &&\n    /*stream-extractable*/<\n        Val,\n        CharT,\n        Traits> class basic_istream_view\n    : public ranges::view_interface<\n          basic_istream_view<\n              Val,\n              CharT,\n              Traits>>",
            "other_declarations": 4
        },
        {
            "title": "std::ranges::basic_istream_view::iterator",
            "path": "en.cppreference.com/w/cpp/ranges/basic_istream_view/iterator.html",
            "wgPageName": "cpp/ranges/basic_istream_view/iterator",
            "sample_declaration": "struct /*iterator*/;"
        },
        {
            "title": "std::ranges::begin",
            "path": "en.cppreference.com/w/cpp/ranges/begin.html",
            "wgPageName": "cpp/ranges/begin",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "inline namespace /*unspecified*/ {\ninline constexpr /*unspecified*/ begin =\n    /*unspecified*/;\n}",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::bidirectional_range",
            "path": "en.cppreference.com/w/cpp/ranges/bidirectional_range.html",
            "wgPageName": "cpp/ranges/bidirectional_range",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<class T>\nconcept bidirectional_range =\n    ranges::forward_range<T> &&\n    std::bidirectional_iterator<\n        ranges::iterator_t<T>>;"
        },
        {
            "title": "std::ranges::borrowed_iterator_t, std::ranges::borrowed_subrange_t",
            "path": "en.cppreference.com/w/cpp/ranges/borrowed_iterator_t.html",
            "wgPageName": "cpp/ranges/borrowed_iterator_t",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<ranges::range R>\nusing borrowed_iterator_t = /* see below */;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::borrowed_range, std::ranges::enable_borrowed_range",
            "path": "en.cppreference.com/w/cpp/ranges/borrowed_range.html",
            "wgPageName": "cpp/ranges/borrowed_range",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<class R>\nconcept borrowed_range = ranges::range<R> &&\n    (std::is_lvalue_reference_v<R> ||\n     ranges::enable_borrowed_range<\n         std::remove_cvref_t<R>>);",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::cbegin",
            "path": "en.cppreference.com/w/cpp/ranges/cbegin.html",
            "wgPageName": "cpp/ranges/cbegin",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "inline namespace /*unspecified*/ {\ninline constexpr /*unspecified*/ cbegin =\n    /*unspecified*/;\n}",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::cdata",
            "path": "en.cppreference.com/w/cpp/ranges/cdata.html",
            "wgPageName": "cpp/ranges/cdata",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "inline namespace /*unspecified*/ {\ninline constexpr /*unspecified*/ cdata =\n    /*unspecified*/;\n}",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::cend",
            "path": "en.cppreference.com/w/cpp/ranges/cend.html",
            "wgPageName": "cpp/ranges/cend",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "inline namespace /*unspecified*/ {\ninline constexpr /*unspecified*/ cend =\n    /*unspecified*/;\n}",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::common_range",
            "path": "en.cppreference.com/w/cpp/ranges/common_range.html",
            "wgPageName": "cpp/ranges/common_range",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<class T>\nconcept common_range =\n    ranges::range<T> && std::same_as<\n        ranges::iterator_t<T>,\n        ranges::sentinel_t<T>>;"
        },
        {
            "title": "std::ranges::views::common, std::ranges::common_view",
            "path": "en.cppreference.com/w/cpp/ranges/common_view.html",
            "wgPageName": "cpp/ranges/common_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<ranges::view V>\nrequires(\n    !ranges::common_range<V> &&\n    std::copyable<ranges::iterator_t<\n        V>>) class common_view\n    : public ranges::view_interface<\n          common_view<V>>",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::common_view<V>::base",
            "path": "en.cppreference.com/w/cpp/ranges/common_view/base.html",
            "wgPageName": "cpp/ranges/common_view/base",
            "sample_declaration": "constexpr V base()\n    const& requires std::copy_constructible<V>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::common_view<V>::begin",
            "path": "en.cppreference.com/w/cpp/ranges/common_view/begin.html",
            "wgPageName": "cpp/ranges/common_view/begin",
            "sample_declaration": "constexpr auto begin();",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::common_view<V>::common_view",
            "path": "en.cppreference.com/w/cpp/ranges/common_view/common_view.html",
            "wgPageName": "cpp/ranges/common_view/common_view",
            "sample_declaration": "common_view() = default;",
            "other_declarations": 1
        },
        {
            "title": "deduction guides for std::ranges::common_view",
            "path": "en.cppreference.com/w/cpp/ranges/common_view/deduction_guides.html",
            "wgPageName": "cpp/ranges/common_view/deduction_guides",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<class R>\ncommon_view(R&&)\n    -> common_view<views::all_t<R>>;"
        },
        {
            "title": "std::ranges::common_view<V>::end",
            "path": "en.cppreference.com/w/cpp/ranges/common_view/end.html",
            "wgPageName": "cpp/ranges/common_view/end",
            "sample_declaration": "constexpr auto end();",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::common_view<V>::size",
            "path": "en.cppreference.com/w/cpp/ranges/common_view/size.html",
            "wgPageName": "cpp/ranges/common_view/size",
            "sample_declaration": "constexpr auto size() requires\n    ranges::sized_range<V>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::constant_range",
            "path": "en.cppreference.com/w/cpp/ranges/constant_range.html",
            "wgPageName": "cpp/ranges/constant_range",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<class T>\nconcept constant_range =\n    ranges::input_range<T> &&\n    /*constant-iterator*/<\n        ranges::iterator_t<T>>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::contiguous_range",
            "path": "en.cppreference.com/w/cpp/ranges/contiguous_range.html",
            "wgPageName": "cpp/ranges/contiguous_range",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<class T>\nconcept contiguous_range =\n    ranges::random_access_range<T> &&\n    std::contiguous_iterator<\n        ranges::iterator_t<T>> &&\n    requires(T& t) {\n  {\n    ranges::data(t)\n    } -> std::same_as<std::add_pointer_t<\n        ranges::range_reference_t<T>>>;\n};"
        },
        {
            "title": "Copyable wrapper (C++20)",
            "path": "en.cppreference.com/w/cpp/ranges/copyable_wrapper.html",
            "wgPageName": "cpp/ranges/copyable_wrapper",
            "sample_declaration": "template<class T>\nrequires std::copy_constructible<T> &&\n    std::is_object_v<T>\nclass /*copyable-box*/;"
        },
        {
            "title": "std::ranges::crbegin",
            "path": "en.cppreference.com/w/cpp/ranges/crbegin.html",
            "wgPageName": "cpp/ranges/crbegin",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "inline namespace /*unspecified*/ {\ninline constexpr /*unspecified*/ crbegin =\n    /*unspecified*/;\n}",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::crend",
            "path": "en.cppreference.com/w/cpp/ranges/crend.html",
            "wgPageName": "cpp/ranges/crend",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "inline namespace /*unspecified*/ {\ninline constexpr /*unspecified*/ crend =\n    /*unspecified*/;\n}",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::dangling",
            "path": "en.cppreference.com/w/cpp/ranges/dangling.html",
            "wgPageName": "cpp/ranges/dangling",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "struct dangling;"
        },
        {
            "title": "std::ranges::data",
            "path": "en.cppreference.com/w/cpp/ranges/data.html",
            "wgPageName": "cpp/ranges/data",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "inline namespace /*unspecified*/ {\ninline constexpr /*unspecified*/ data =\n    /*unspecified*/;\n}",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::views::drop, std::ranges::drop_view",
            "path": "en.cppreference.com/w/cpp/ranges/drop_view.html",
            "wgPageName": "cpp/ranges/drop_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<ranges::view V>\nclass drop_view : public ranges::view_interface<\n                      drop_view<V>>",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::drop_view<V>::base",
            "path": "en.cppreference.com/w/cpp/ranges/drop_view/base.html",
            "wgPageName": "cpp/ranges/drop_view/base",
            "sample_declaration": "constexpr V base()\n    const& requires std::copy_constructible<V>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::drop_view<V>::begin",
            "path": "en.cppreference.com/w/cpp/ranges/drop_view/begin.html",
            "wgPageName": "cpp/ranges/drop_view/begin",
            "sample_declaration": "constexpr auto begin() requires(\n    !(__SimpleView<V> &&\n      ranges::random_access_range<const V> &&\n      ranges::sized_range<const V>));",
            "other_declarations": 1
        },
        {
            "title": "deduction guides for std::ranges::drop_view",
            "path": "en.cppreference.com/w/cpp/ranges/drop_view/deduction_guides.html",
            "wgPageName": "cpp/ranges/drop_view/deduction_guides",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<class R>\ndrop_view(R&&, ranges::range_difference_t<R>)\n    -> drop_view<views::all_t<R>>;"
        },
        {
            "title": "std::ranges::drop_view<V>::drop_view",
            "path": "en.cppreference.com/w/cpp/ranges/drop_view/drop_view.html",
            "wgPageName": "cpp/ranges/drop_view/drop_view",
            "sample_declaration": "drop_view() requires\n    std::default_initializable<V>\n= default;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::drop_view<V>::end",
            "path": "en.cppreference.com/w/cpp/ranges/drop_view/end.html",
            "wgPageName": "cpp/ranges/drop_view/end",
            "sample_declaration": "constexpr auto end() requires(!__SimpleView<V>);",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::drop_view<V>::size",
            "path": "en.cppreference.com/w/cpp/ranges/drop_view/size.html",
            "wgPageName": "cpp/ranges/drop_view/size",
            "sample_declaration": "constexpr auto size() requires\n    ranges::sized_range<V>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::views::drop_while, std::ranges::drop_while_view",
            "path": "en.cppreference.com/w/cpp/ranges/drop_while_view.html",
            "wgPageName": "cpp/ranges/drop_while_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<ranges::view V, class Pred>\nrequires ranges::input_range<V> &&\n    std::is_object_v<Pred> &&\n    std::indirect_unary_predicate<\n        const Pred,\n        ranges::iterator_t<V>>\nclass drop_while_view\n    : public ranges::view_interface<\n          drop_while_view<V, Pred>>",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::drop_while_view<V,Pred>::base",
            "path": "en.cppreference.com/w/cpp/ranges/drop_while_view/base.html",
            "wgPageName": "cpp/ranges/drop_while_view/base",
            "sample_declaration": "constexpr V base()\n    const& requires std::copy_constructible<V>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::drop_while_view<V,Pred>::begin",
            "path": "en.cppreference.com/w/cpp/ranges/drop_while_view/begin.html",
            "wgPageName": "cpp/ranges/drop_while_view/begin",
            "sample_declaration": "constexpr auto begin();"
        },
        {
            "title": "deduction guides for std::ranges::drop_while_view",
            "path": "en.cppreference.com/w/cpp/ranges/drop_while_view/deduction_guides.html",
            "wgPageName": "cpp/ranges/drop_while_view/deduction_guides",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<class R, class Pred>\ndrop_while_view(R&&, Pred)\n    -> drop_while_view<views::all_t<R>, Pred>;"
        },
        {
            "title": "std::ranges::drop_while_view<V,Pred>::drop_while_view",
            "path": "en.cppreference.com/w/cpp/ranges/drop_while_view/drop_while_view.html",
            "wgPageName": "cpp/ranges/drop_while_view/drop_while_view",
            "sample_declaration": "drop_while_view() requires\n    std::default_initializable<V> &&\n    std::default_initializable<Pred>\n= default;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::drop_while_view<V,Pred>::end",
            "path": "en.cppreference.com/w/cpp/ranges/drop_while_view/end.html",
            "wgPageName": "cpp/ranges/drop_while_view/end",
            "sample_declaration": "constexpr auto end();"
        },
        {
            "title": "std::ranges::drop_while_view<V,Pred>::pred",
            "path": "en.cppreference.com/w/cpp/ranges/drop_while_view/pred.html",
            "wgPageName": "cpp/ranges/drop_while_view/pred",
            "sample_declaration": "constexpr const Pred& pred() const;"
        },
        {
            "title": "std::ranges::views::elements, std::ranges::elements_view",
            "path": "en.cppreference.com/w/cpp/ranges/elements_view.html",
            "wgPageName": "cpp/ranges/elements_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<ranges::input_range V, std::size_t N>\nrequires view<V> && /*has-tuple-element*/<\n    ranges::range_value_t<V>,\n    N>&& /*has-tuple-element*/\n    <std::remove_reference_t<\n         ranges::range_reference_t<V>>,\n     N>&& /*returnable-element*/\n    <ranges::range_reference_t<V>,\n     N> class elements_view\n    : public ranges::view_interface<\n          elements_view<V, N>>;",
            "other_declarations": 4
        },
        {
            "title": "std::ranges::elements_view<V,N>::base",
            "path": "en.cppreference.com/w/cpp/ranges/elements_view/base.html",
            "wgPageName": "cpp/ranges/elements_view/base",
            "sample_declaration": "constexpr V base()\n    const& requires std::copy_constructible<V>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::elements_view<V,N>::begin",
            "path": "en.cppreference.com/w/cpp/ranges/elements_view/begin.html",
            "wgPageName": "cpp/ranges/elements_view/begin",
            "sample_declaration": "constexpr auto begin() requires(\n    !__SimpleView<V>);",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::elements_view<V,N>::elements_view",
            "path": "en.cppreference.com/w/cpp/ranges/elements_view/elements_view.html",
            "wgPageName": "cpp/ranges/elements_view/elements_view",
            "sample_declaration": "elements_view() requires\n    std::default_initializable<V>\n= default;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::elements_view<V,N>::end",
            "path": "en.cppreference.com/w/cpp/ranges/elements_view/end.html",
            "wgPageName": "cpp/ranges/elements_view/end",
            "sample_declaration": "constexpr auto end() requires(\n    !__SimpleView<V> &&\n    !ranges::common_range<V>);",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::elements_view<V,N>::iterator",
            "path": "en.cppreference.com/w/cpp/ranges/elements_view/iterator.html",
            "wgPageName": "cpp/ranges/elements_view/iterator",
            "sample_declaration": "template<bool Const>\nclass /*iterator*/;"
        },
        {
            "title": "std::ranges::elements_view<V,F>::iterator<Const>::base",
            "path": "en.cppreference.com/w/cpp/ranges/elements_view/iterator/base.html",
            "wgPageName": "cpp/ranges/elements_view/iterator/base",
            "sample_declaration": "constexpr const ranges::iterator_t<Base>& base()\n    const& noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::elements_view<V,F>::iterator<Const>::iterator",
            "path": "en.cppreference.com/w/cpp/ranges/elements_view/iterator/iterator.html",
            "wgPageName": "cpp/ranges/elements_view/iterator/iterator",
            "sample_declaration": "/*iterator*/ () requires\n    std::default_initializable<\n        ranges::iterator_t<Base>>\n= default;",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::elements_view<V,F>::iterator<Const>::operator++,--,+=,-=",
            "path": "en.cppreference.com/w/cpp/ranges/elements_view/iterator/operator_arith.html",
            "wgPageName": "cpp/ranges/elements_view/iterator/operator_arith",
            "sample_declaration": "constexpr /*iterator*/& operator++();",
            "other_declarations": 6
        },
        {
            "title": "operator+,-(ranges::elements_view::iterator)",
            "path": "en.cppreference.com/w/cpp/ranges/elements_view/iterator/operator_arith2.html",
            "wgPageName": "cpp/ranges/elements_view/iterator/operator_arith2",
            "sample_declaration": "friend constexpr /*iterator*/ operator+(\n    const /*iterator*/& i,\n    difference_type n) requires\n    ranges::random_access_range<Base>;",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::elements_view<V,F>::iterator<Const>::operator[]",
            "path": "en.cppreference.com/w/cpp/ranges/elements_view/iterator/operator_at.html",
            "wgPageName": "cpp/ranges/elements_view/iterator/operator_at",
            "sample_declaration": "constexpr decltype(auto) operator[](\n    difference_type n) const requires\n    ranges::random_access_range<Base>;"
        },
        {
            "title": "operator==,<,>,<=,>=,<=>(ranges::elements_view::iterator)",
            "path": "en.cppreference.com/w/cpp/ranges/elements_view/iterator/operator_cmp.html",
            "wgPageName": "cpp/ranges/elements_view/iterator/operator_cmp",
            "sample_declaration": "friend constexpr bool operator==(\n    const /*iterator*/& x,\n    const /*iterator*/& y) requires\n    std::equality_comparable<\n        ranges::iterator_t<Base>>;",
            "other_declarations": 5
        },
        {
            "title": "std::ranges::elements_view<V,F>::iterator<Const>::operator*",
            "path": "en.cppreference.com/w/cpp/ranges/elements_view/iterator/operator*.html",
            "wgPageName": "cpp/ranges/elements_view/iterator/operator*",
            "sample_declaration": "constexpr decltype(auto) operator*() const;"
        },
        {
            "title": "std::ranges::elements_view<V,N>::sentinel",
            "path": "en.cppreference.com/w/cpp/ranges/elements_view/sentinel.html",
            "wgPageName": "cpp/ranges/elements_view/sentinel",
            "sample_declaration": "template<bool Const>\nclass /*sentinel*/;  // exposition only"
        },
        {
            "title": "std::ranges::elements_view<V,F>::sentinel<Const>::base",
            "path": "en.cppreference.com/w/cpp/ranges/elements_view/sentinel/base.html",
            "wgPageName": "cpp/ranges/elements_view/sentinel/base",
            "sample_declaration": "constexpr ranges::sentinel_t<Base> base() const;"
        },
        {
            "title": "operator==(ranges::elements_view::sentinel)",
            "path": "en.cppreference.com/w/cpp/ranges/elements_view/sentinel/operator_cmp.html",
            "wgPageName": "cpp/ranges/elements_view/sentinel/operator_cmp",
            "sample_declaration": "template<bool OtherConst>\nrequires std::sentinel_for<\n    ranges::sentinel_t<Base>,\n    ranges::iterator_t<\n        /*maybe-const*/<OtherConst, V>>>\nfriend constexpr bool operator==(\n    const /*iterator*/<OtherConst>& x,\n    const /*sentinel*/& y);"
        },
        {
            "title": "operator-(ranges::elements_view::sentinel)",
            "path": "en.cppreference.com/w/cpp/ranges/elements_view/sentinel/operator-.html",
            "wgPageName": "cpp/ranges/elements_view/sentinel/operator-",
            "sample_declaration": "template<bool OtherConst>\nrequires std::sized_sentinel_for<\n    ranges::sentinel_t<Base>,\n    ranges::iterator_t<\n        /*maybe-const*/<OtherConst, V>>>\nfriend constexpr ranges::range_difference_t<\n    /*maybe-const*/<OtherConst, V>>\noperator-(\n    const /*iterator*/<OtherConst>& x,\n    const /*sentinel*/& y);",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::elements_view<V,F>::sentinel<Const>::sentinel",
            "path": "en.cppreference.com/w/cpp/ranges/elements_view/sentinel/sentinel.html",
            "wgPageName": "cpp/ranges/elements_view/sentinel/sentinel",
            "sample_declaration": "/*sentinel*/ () = default;",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::elements_view<V,N>::size",
            "path": "en.cppreference.com/w/cpp/ranges/elements_view/size.html",
            "wgPageName": "cpp/ranges/elements_view/size",
            "sample_declaration": "constexpr auto size() requires\n    ranges::sized_range<V>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::views::empty, std::ranges::empty_view",
            "path": "en.cppreference.com/w/cpp/ranges/empty_view.html",
            "wgPageName": "cpp/ranges/empty_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<class T>\nrequires std::is_object_v<T>\nclass empty_view\n    : public ranges::view_interface<\n          empty_view<T>>",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::empty",
            "path": "en.cppreference.com/w/cpp/ranges/empty.html",
            "wgPageName": "cpp/ranges/empty",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "inline namespace /*unspecified*/ {\ninline constexpr auto empty = /*unspecified*/;\n}",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::end",
            "path": "en.cppreference.com/w/cpp/ranges/end.html",
            "wgPageName": "cpp/ranges/end",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "inline namespace /*unspecified*/ {\ninline constexpr /*unspecified*/ end =\n    /*unspecified*/;\n}",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::views::filter, std::ranges::filter_view",
            "path": "en.cppreference.com/w/cpp/ranges/filter_view.html",
            "wgPageName": "cpp/ranges/filter_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<\n    ranges::input_range V,\n    std::indirect_unary_predicate<\n        ranges::iterator_t<V>> Pred>\nrequires ranges::view<V> &&\n    std::is_object_v<Pred>\nclass filter_view\n    : public ranges::view_interface<\n          filter_view<V, Pred>>",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::filter_view<V,Pred>::iterator",
            "path": "en.cppreference.com/w/cpp/ranges/filter_view/iterator.html",
            "wgPageName": "cpp/ranges/filter_view/iterator",
            "sample_declaration": "class /*iterator*/;"
        },
        {
            "title": "std::ranges::filter_view<V,Pred>::sentinel",
            "path": "en.cppreference.com/w/cpp/ranges/filter_view/sentinel.html",
            "wgPageName": "cpp/ranges/filter_view/sentinel",
            "sample_declaration": "class /*sentinel*/;"
        },
        {
            "title": "std::ranges::forward_range",
            "path": "en.cppreference.com/w/cpp/ranges/forward_range.html",
            "wgPageName": "cpp/ranges/forward_range",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<class T>\nconcept forward_range =\n    ranges::input_range<T> &&\n    std::forward_iterator<\n        ranges::iterator_t<T>>;"
        },
        {
            "title": "std::from_range, std::from_range_t",
            "path": "en.cppreference.com/w/cpp/ranges/from_range.html",
            "wgPageName": "cpp/ranges/from_range",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "struct from_range_t {\n  explicit from_range_t() = default;\n};",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::input_range",
            "path": "en.cppreference.com/w/cpp/ranges/input_range.html",
            "wgPageName": "cpp/ranges/input_range",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<class T>\nconcept input_range = ranges::range<T> &&\n    std::input_iterator<ranges::iterator_t<T>>;"
        },
        {
            "title": "std::ranges::views::iota, std::ranges::iota_view",
            "path": "en.cppreference.com/w/cpp/ranges/iota_view.html",
            "wgPageName": "cpp/ranges/iota_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<\n    std::weakly_incrementable W,\n    std::semiregular Bound =\n        std::unreachable_sentinel_t>\nrequires __WeaklyEqualityComparableWith<\n    W,\n    Bound> && std::copyable<W>\nclass iota_view : public ranges::view_interface<\n                      iota_view<W, Bound>>",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::iota_view<W, Bound>::iterator",
            "path": "en.cppreference.com/w/cpp/ranges/iota_view/iterator.html",
            "wgPageName": "cpp/ranges/iota_view/iterator",
            "sample_declaration": "struct /*iterator*/;",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::iota_view<W, Bound>::sentinel",
            "path": "en.cppreference.com/w/cpp/ranges/iota_view/sentinel.html",
            "wgPageName": "cpp/ranges/iota_view/sentinel",
            "sample_declaration": "struct /*sentinel*/;"
        },
        {
            "title": "std::ranges::iterator_t, std::ranges::const_iterator_t, std::ranges::sentinel_t, std::ranges::range_size_t, std::ranges::range_difference_t, std::ranges::range_value_t, std::ranges::range_reference_t, std::ranges::range_const_reference_t",
            "path": "en.cppreference.com/w/cpp/ranges/iterator_t.html",
            "wgPageName": "cpp/ranges/iterator_t",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<class T>\nusing iterator_t =\n    decltype(ranges::begin(std::declval<T&>()));",
            "other_declarations": 8
        },
        {
            "title": "std::ranges::views::join, std::ranges::join_view",
            "path": "en.cppreference.com/w/cpp/ranges/join_view.html",
            "wgPageName": "cpp/ranges/join_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<ranges::input_range V>\nrequires ranges::view<V> && ranges::input_range<\n    ranges::range_reference_t<V>>\nclass join_view : public ranges::view_interface<\n                      join_view<V>>",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::join_view<V>::base",
            "path": "en.cppreference.com/w/cpp/ranges/join_view/base.html",
            "wgPageName": "cpp/ranges/join_view/base",
            "sample_declaration": "constexpr V base()\n    const& requires std::copy_constructible<V>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::join_view<V>::begin",
            "path": "en.cppreference.com/w/cpp/ranges/join_view/begin.html",
            "wgPageName": "cpp/ranges/join_view/begin",
            "sample_declaration": "constexpr auto begin();",
            "other_declarations": 1
        },
        {
            "title": "deduction guides for std::ranges::join_view",
            "path": "en.cppreference.com/w/cpp/ranges/join_view/deduction_guides.html",
            "wgPageName": "cpp/ranges/join_view/deduction_guides",
            "sample_declaration": "template<class R>\nexplicit join_view(R&&)\n    -> join_view<views::all_t<R>>;"
        },
        {
            "title": "std::ranges::join_view<V>::end",
            "path": "en.cppreference.com/w/cpp/ranges/join_view/end.html",
            "wgPageName": "cpp/ranges/join_view/end",
            "sample_declaration": "constexpr auto end();",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::join_view<V>::iterator",
            "path": "en.cppreference.com/w/cpp/ranges/join_view/iterator.html",
            "wgPageName": "cpp/ranges/join_view/iterator",
            "sample_declaration": "template<bool Const>\nclass /*iterator*/"
        },
        {
            "title": "iter_move(ranges::join_view::iterator)",
            "path": "en.cppreference.com/w/cpp/ranges/join_view/iterator/iter_move.html",
            "wgPageName": "cpp/ranges/join_view/iterator/iter_move",
            "sample_declaration": "friend constexpr decltype(auto)\niter_move(const /*iterator*/& i) noexcept(\n    /*see below*/);"
        },
        {
            "title": "iter_swap(ranges::join_view::iterator)",
            "path": "en.cppreference.com/w/cpp/ranges/join_view/iterator/iter_swap.html",
            "wgPageName": "cpp/ranges/join_view/iterator/iter_swap",
            "sample_declaration": "friend constexpr void iter_swap(\n    const /*iterator*/& x,\n    const /*iterator*/&\n        y) noexcept(/*see below*/) requires\n    std::indirectly_swappable<InnerIter>;"
        },
        {
            "title": "std::ranges::join_view<V>::iterator<Const>::iterator",
            "path": "en.cppreference.com/w/cpp/ranges/join_view/iterator/iterator.html",
            "wgPageName": "cpp/ranges/join_view/iterator/iterator",
            "sample_declaration": "/*iterator*/ () requires\n    std::default_initializable<OuterIter> &&\n    std::default_initializable<InnerIter>\n= default;",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::join_view<V>::iterator<Const>::operator++,--",
            "path": "en.cppreference.com/w/cpp/ranges/join_view/iterator/operator_arith.html",
            "wgPageName": "cpp/ranges/join_view/iterator/operator_arith",
            "sample_declaration": "constexpr /*iterator*/& operator++();",
            "other_declarations": 4
        },
        {
            "title": "operator==(ranges::join_view::iterator, ranges::join_view::iterator)",
            "path": "en.cppreference.com/w/cpp/ranges/join_view/iterator/operator_cmp.html",
            "wgPageName": "cpp/ranges/join_view/iterator/operator_cmp",
            "sample_declaration": "friend constexpr bool operator==(\n    const /*iterator*/& x,\n    const /*iterator*/&\n        y) requires /*ref-is-glvalue*/&& std::\n    equality_comparable<\n        ranges::iterator_t<Base>>&& std::\n        equality_comparable<ranges::iterator_t<\n            ranges::range_reference_t<Base>>>;"
        },
        {
            "title": "std::ranges::join_view<V>::iterator<Const>::operator*,->",
            "path": "en.cppreference.com/w/cpp/ranges/join_view/iterator/operator*.html",
            "wgPageName": "cpp/ranges/join_view/iterator/operator*",
            "sample_declaration": "constexpr decltype(auto) operator*() const;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::join_view<V>::iterator<Const>::satisfy",
            "path": "en.cppreference.com/w/cpp/ranges/join_view/iterator/satisfy.html",
            "wgPageName": "cpp/ranges/join_view/iterator/satisfy",
            "sample_declaration": "private:\nconstexpr void satisfy();  // exposition only"
        },
        {
            "title": "std::ranges::join_view<V>::join_view",
            "path": "en.cppreference.com/w/cpp/ranges/join_view/join_view.html",
            "wgPageName": "cpp/ranges/join_view/join_view",
            "sample_declaration": "join_view() requires\n    std::default_initializable<V>\n= default;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::join_view<V>::sentinel",
            "path": "en.cppreference.com/w/cpp/ranges/join_view/sentinel.html",
            "wgPageName": "cpp/ranges/join_view/sentinel",
            "sample_declaration": "template<bool Const>\nclass /*sentinel*/"
        },
        {
            "title": "operator==(ranges::join_view::iterator, ranges::join_view::sentinel)",
            "path": "en.cppreference.com/w/cpp/ranges/join_view/sentinel/operator_cmp.html",
            "wgPageName": "cpp/ranges/join_view/sentinel/operator_cmp",
            "sample_declaration": "friend constexpr bool operator==(\n    const /*iterator*/<Const>& x,\n    const /*sentinel*/& y);"
        },
        {
            "title": "std::ranges::join_view<V>::sentinel<Const>::sentinel",
            "path": "en.cppreference.com/w/cpp/ranges/join_view/sentinel/sentinel.html",
            "wgPageName": "cpp/ranges/join_view/sentinel/sentinel",
            "sample_declaration": "/*sentinel*/ () = default;",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::views::join_with, std::ranges::join_with_view",
            "path": "en.cppreference.com/w/cpp/ranges/join_with_view.html",
            "wgPageName": "cpp/ranges/join_with_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<\n    ranges::input_range V,\n    ranges::forward_range Pattern>\nrequires ranges::view<V> && ranges::input_range<\n    ranges::range_reference_t<V>> &&\n    ranges::view<Pattern> &&\n    /* range_reference_t<V> and Pattern have\n       compatible elements (see below) */\n    class join_with_view\n    : ranges::view_interface<\n          join_with_view<V, Pattern>>",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::join_with_view<V,Pattern>::base",
            "path": "en.cppreference.com/w/cpp/ranges/join_with_view/base.html",
            "wgPageName": "cpp/ranges/join_with_view/base",
            "sample_declaration": "constexpr V base()\n    const& requires std::copy_constructible<V>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::join_with_view<V,Pattern>::begin",
            "path": "en.cppreference.com/w/cpp/ranges/join_with_view/begin.html",
            "wgPageName": "cpp/ranges/join_with_view/begin",
            "sample_declaration": "constexpr auto begin();",
            "other_declarations": 1
        },
        {
            "title": "deduction guides for std::ranges::join_with_view",
            "path": "en.cppreference.com/w/cpp/ranges/join_with_view/deduction_guides.html",
            "wgPageName": "cpp/ranges/join_with_view/deduction_guides",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<class R, class P>\njoin_with_view(R&&, P&&) -> join_with_view<\n    views::all_t<R>,\n    views::all_t<P>>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::join_with_view<V,Pattern>::end",
            "path": "en.cppreference.com/w/cpp/ranges/join_with_view/end.html",
            "wgPageName": "cpp/ranges/join_with_view/end",
            "sample_declaration": "constexpr auto end();",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::join_with_view<V,Pattern>::iterator",
            "path": "en.cppreference.com/w/cpp/ranges/join_with_view/iterator.html",
            "wgPageName": "cpp/ranges/join_with_view/iterator",
            "sample_declaration": "template<bool Const>\nclass /*iterator*/"
        },
        {
            "title": "iter_move(ranges::join_with_view::iterator)",
            "path": "en.cppreference.com/w/cpp/ranges/join_with_view/iterator/iter_move.html",
            "wgPageName": "cpp/ranges/join_with_view/iterator/iter_move",
            "sample_declaration": "friend constexpr decltype(auto) iter_move(\n    const /*iterator*/& i);"
        },
        {
            "title": "iter_swap(ranges::join_with_view::iterator)",
            "path": "en.cppreference.com/w/cpp/ranges/join_with_view/iterator/iter_swap.html",
            "wgPageName": "cpp/ranges/join_with_view/iterator/iter_swap",
            "sample_declaration": "friend constexpr void iter_swap(\n    const /*iterator*/& x,\n    const /*iterator*/& y) requires\n    std::indirectly_swappable<\n        ranges::iterator_t<InnerBase>,\n        ranges::iterator_t<PatternBase>>;"
        },
        {
            "title": "std::ranges::join_with_view<V,Pattern>::iterator<Const>::iterator",
            "path": "en.cppreference.com/w/cpp/ranges/join_with_view/iterator/iterator.html",
            "wgPageName": "cpp/ranges/join_with_view/iterator/iterator",
            "sample_declaration": "/*iterator*/ () requires\n    std::default_initializable<\n        ranges::iterator_t<Base>>\n= default;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::join_with_view<V,Pattern>::iterator<Const>::operator++,--",
            "path": "en.cppreference.com/w/cpp/ranges/join_with_view/iterator/operator_arith.html",
            "wgPageName": "cpp/ranges/join_with_view/iterator/operator_arith",
            "sample_declaration": "constexpr /*iterator*/& operator++();",
            "other_declarations": 4
        },
        {
            "title": "operator==(ranges::join_with_view::iterator)",
            "path": "en.cppreference.com/w/cpp/ranges/join_with_view/iterator/operator_cmp.html",
            "wgPageName": "cpp/ranges/join_with_view/iterator/operator_cmp",
            "sample_declaration": "friend constexpr bool operator==(\n    const /*iterator*/& x,\n    const /*iterator*/& y) requires\n    std::is_reference_v<InnerBase> &&\n    std::equality_comparable<\n        ranges::iterator_t<Base>> &&\n    std::equality_comparable<\n        ranges::iterator_t<InnerBase>>;"
        },
        {
            "title": "std::ranges::join_with_view<V,Pattern>::iterator<Const>::operator*",
            "path": "en.cppreference.com/w/cpp/ranges/join_with_view/iterator/operator*.html",
            "wgPageName": "cpp/ranges/join_with_view/iterator/operator*",
            "sample_declaration": "constexpr decltype(auto) operator*() const;"
        },
        {
            "title": "std::ranges::join_with_view<V,Pattern>::join_with_view",
            "path": "en.cppreference.com/w/cpp/ranges/join_with_view/join_with_view.html",
            "wgPageName": "cpp/ranges/join_with_view/join_with_view",
            "sample_declaration": "join_with_view() requires\n    std::default_initializable<V> &&\n    std::default_initializable<Pattern>\n= default;",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::join_with_view<V,Pattern>::sentinel",
            "path": "en.cppreference.com/w/cpp/ranges/join_with_view/sentinel.html",
            "wgPageName": "cpp/ranges/join_with_view/sentinel",
            "sample_declaration": "template<bool Const>\nclass /*sentinel*/"
        },
        {
            "title": "operator==(ranges::join_with_view::iterator, ranges::join_with_view::sentinel)",
            "path": "en.cppreference.com/w/cpp/ranges/join_with_view/sentinel/operator_cmp.html",
            "wgPageName": "cpp/ranges/join_with_view/sentinel/operator_cmp",
            "sample_declaration": "friend constexpr bool operator==(\n    const /*iterator*/<Const>& x,\n    const /*sentinel*/& y);"
        },
        {
            "title": "std::ranges::join_with_view<V,Pattern>::sentinel<Const>::sentinel",
            "path": "en.cppreference.com/w/cpp/ranges/join_with_view/sentinel/sentinel.html",
            "wgPageName": "cpp/ranges/join_with_view/sentinel/sentinel",
            "sample_declaration": "/*sentinel*/ () = default;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::views::keys, std::ranges::keys_view",
            "path": "en.cppreference.com/w/cpp/ranges/keys_view.html",
            "wgPageName": "cpp/ranges/keys_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<class R>\nusing keys_view = ranges::elements_view<R, 0>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::views::lazy_split, std::ranges::lazy_split_view",
            "path": "en.cppreference.com/w/cpp/ranges/lazy_split_view.html",
            "wgPageName": "cpp/ranges/lazy_split_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<\n    ranges::input_range V,\n    ranges::forward_range Pattern>\nrequires ranges::view<V> &&\n    ranges::view<Pattern> &&\n    std::indirectly_comparable<\n        ranges::iterator_t<V>,\n        ranges::iterator_t<Pattern>,\n        ranges::equal_to> &&\n    (ranges::forward_range<V> ||\n     /*tiny_range*/<\n         Pattern>)class lazy_split_view\n    : public ranges::view_interface<\n          lazy_split_view<V, Pattern>>",
            "other_declarations": 4
        },
        {
            "title": "std::ranges::lazy_split_view<V,Pattern>::base",
            "path": "en.cppreference.com/w/cpp/ranges/lazy_split_view/base.html",
            "wgPageName": "cpp/ranges/lazy_split_view/base",
            "sample_declaration": "constexpr V base()\n    const& requires std::copy_constructible<V>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::lazy_split_view<V,Pattern>::begin",
            "path": "en.cppreference.com/w/cpp/ranges/lazy_split_view/begin.html",
            "wgPageName": "cpp/ranges/lazy_split_view/begin",
            "sample_declaration": "constexpr auto begin();",
            "other_declarations": 1
        },
        {
            "title": "deduction guides for std::ranges::lazy_split_view",
            "path": "en.cppreference.com/w/cpp/ranges/lazy_split_view/deduction_guides.html",
            "wgPageName": "cpp/ranges/lazy_split_view/deduction_guides",
            "sample_declaration": "template<class R, class P>\nlazy_split_view(R&&, P&&) -> lazy_split_view<\n    ranges::all_t<R>,\n    ranges::all_t<P>>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::lazy_split_view<V,Pattern>::end",
            "path": "en.cppreference.com/w/cpp/ranges/lazy_split_view/end.html",
            "wgPageName": "cpp/ranges/lazy_split_view/end",
            "sample_declaration": "constexpr auto end() requires\n    ranges::forward_range<V> &&\n    ranges::common_range<V>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::lazy_split_view<V, Pattern>::inner_iterator",
            "path": "en.cppreference.com/w/cpp/ranges/lazy_split_view/inner_iterator.html",
            "wgPageName": "cpp/ranges/lazy_split_view/inner_iterator",
            "sample_declaration": "template<bool Const>\nstruct /*inner_iterator*/;"
        },
        {
            "title": "std::ranges::lazy_split_view<V,Pattern>::lazy_split_view",
            "path": "en.cppreference.com/w/cpp/ranges/lazy_split_view/lazy_split_view.html",
            "wgPageName": "cpp/ranges/lazy_split_view/lazy_split_view",
            "sample_declaration": "lazy_split_view() requires\n    std::default_initializable<V> &&\n    std::default_initializable<Pattern>\n= default;",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::lazy_split_view<V, Pattern>::outer_iterator",
            "path": "en.cppreference.com/w/cpp/ranges/lazy_split_view/outer_iterator.html",
            "wgPageName": "cpp/ranges/lazy_split_view/outer_iterator",
            "sample_declaration": "template<bool Const>\nstruct /*outer_iterator*/;"
        },
        {
            "title": "std::ranges::lazy_split_view<V, Pattern>::outer_iterator<Const>::value_type",
            "path": "en.cppreference.com/w/cpp/ranges/lazy_split_view/value_type.html",
            "wgPageName": "cpp/ranges/lazy_split_view/value_type",
            "sample_declaration": "struct value_type\n    : ranges::view_interface<value_type>"
        },
        {
            "title": "std::ranges::output_range",
            "path": "en.cppreference.com/w/cpp/ranges/output_range.html",
            "wgPageName": "cpp/ranges/output_range",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<class R, class T>\nconcept output_range = ranges::range<R> && std::\n    output_iterator<ranges::iterator_t<R>, T>;"
        },
        {
            "title": "std::ranges::owning_view",
            "path": "en.cppreference.com/w/cpp/ranges/owning_view.html",
            "wgPageName": "cpp/ranges/owning_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<ranges::range R>\nrequires std::movable<R> &&\n    (!/*is-initializer-list*/<\n        R>)class owning_view\n    : public ranges::view_interface<\n          owning_view<R>>"
        },
        {
            "title": "std::ranges::random_access_range",
            "path": "en.cppreference.com/w/cpp/ranges/random_access_range.html",
            "wgPageName": "cpp/ranges/random_access_range",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<class T>\nconcept random_access_range =\n    ranges::bidirectional_range<T> &&\n    std::random_access_iterator<\n        ranges::iterator_t<T>>;"
        },
        {
            "title": "std::ranges::range",
            "path": "en.cppreference.com/w/cpp/ranges/range.html",
            "wgPageName": "cpp/ranges/range",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<class T>\nconcept range = requires(T& t) {\n  ranges::begin(\n      t);  // equality-preserving for forward\n           // iterators ranges::end (t); };"
        },
        {
            "title": "std::ranges::rbegin",
            "path": "en.cppreference.com/w/cpp/ranges/rbegin.html",
            "wgPageName": "cpp/ranges/rbegin",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "inline namespace /*unspecified*/ {\ninline constexpr /*unspecified*/ rbegin =\n    /*unspecified*/;\n}",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::ref_view",
            "path": "en.cppreference.com/w/cpp/ranges/ref_view.html",
            "wgPageName": "cpp/ranges/ref_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<ranges::range R>\nrequires std::is_object_v<R>\nclass ref_view\n    : public ranges::view_interface<ref_view<R>>"
        },
        {
            "title": "std::ranges::rend",
            "path": "en.cppreference.com/w/cpp/ranges/rend.html",
            "wgPageName": "cpp/ranges/rend",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "inline namespace /*unspecified*/ {\ninline constexpr /*unspecified*/ rend =\n    /*unspecified*/;\n}",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::views::repeat, std::ranges::repeat_view",
            "path": "en.cppreference.com/w/cpp/ranges/repeat_view.html",
            "wgPageName": "cpp/ranges/repeat_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<\n    std::move_constructible W,\n    std::semiregular Bound =\n        std::unreachable_sentinel_t>\nrequires(\n    std::is_object_v<W>&&\n        std::same_as<W, std::remove_cv_t<W>> &&\n    (/*is-integer-like*/<Bound> ||\n     std::same_as<\n         Bound,\n         std::unreachable_sentinel_t>)) class\n    repeat_view : public ranges::view_interface<\n                      repeat_view<W, Bound>>",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::repeat_view<W, Bound>::iterator",
            "path": "en.cppreference.com/w/cpp/ranges/repeat_view/iterator.html",
            "wgPageName": "cpp/ranges/repeat_view/iterator",
            "sample_declaration": "struct /*iterator*/;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::views::reverse, std::ranges::reverse_view",
            "path": "en.cppreference.com/w/cpp/ranges/reverse_view.html",
            "wgPageName": "cpp/ranges/reverse_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<ranges::view V>\nrequires ranges::bidirectional_range<V>\nclass reverse_view\n    : public ranges::view_interface<\n          reverse_view<V>>",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::views::single, std::ranges::single_view",
            "path": "en.cppreference.com/w/cpp/ranges/single_view.html",
            "wgPageName": "cpp/ranges/single_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<std::copy_constructible T>\nrequires std::is_object_v<T>\nclass single_view\n    : public ranges::view_interface<\n          single_view<T>>",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::size",
            "path": "en.cppreference.com/w/cpp/ranges/size.html",
            "wgPageName": "cpp/ranges/size",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "inline namespace /*unspecified*/ {\ninline constexpr auto size = /*unspecified*/;\n}",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::sized_range, std::ranges::disable_sized_range",
            "path": "en.cppreference.com/w/cpp/ranges/sized_range.html",
            "wgPageName": "cpp/ranges/sized_range",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<class T>\nconcept sized_range = ranges::range<T> &&\n    requires(T& t) {\n  ranges::size(t);\n};",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::views::split, std::ranges::split_view",
            "path": "en.cppreference.com/w/cpp/ranges/split_view.html",
            "wgPageName": "cpp/ranges/split_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<\n    ranges::forward_range V,\n    ranges::forward_range Pattern>\nrequires ranges::view<V> &&\n    ranges::view<Pattern> &&\n    std::indirectly_comparable<\n        ranges::iterator_t<V>,\n        ranges::iterator_t<Pattern>,\n        ranges::equal_to>\nclass split_view\n    : public ranges::view_interface<\n          split_view<V, Pattern>>",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::split_view<V,Pattern>::base",
            "path": "en.cppreference.com/w/cpp/ranges/split_view/base.html",
            "wgPageName": "cpp/ranges/split_view/base",
            "sample_declaration": "constexpr V base()\n    const& requires std::copy_constructible<V>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::split_view<V,Pattern>::begin",
            "path": "en.cppreference.com/w/cpp/ranges/split_view/begin.html",
            "wgPageName": "cpp/ranges/split_view/begin",
            "sample_declaration": "constexpr /*iterator*/ begin();"
        },
        {
            "title": "deduction guides for std::ranges::split_view",
            "path": "en.cppreference.com/w/cpp/ranges/split_view/deduction_guides.html",
            "wgPageName": "cpp/ranges/split_view/deduction_guides",
            "sample_declaration": "template<class R, class P>\nsplit_view(R&&, P&&) -> split_view<\n    ranges::all_t<R>,\n    ranges::all_t<P>>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::split_view<V,Pattern>::end",
            "path": "en.cppreference.com/w/cpp/ranges/split_view/end.html",
            "wgPageName": "cpp/ranges/split_view/end",
            "sample_declaration": "constexpr auto end() const;"
        },
        {
            "title": "std::ranges::split_view<V,Pattern>::find_next",
            "path": "en.cppreference.com/w/cpp/ranges/split_view/find_next.html",
            "wgPageName": "cpp/ranges/split_view/find_next",
            "sample_declaration": "constexpr ranges::subrange<\n    ranges::iterator_t<V>>\nfind_next(ranges::iterator_t<V>\n              it);  // exposition only"
        },
        {
            "title": "std::ranges::split_view<V,Pattern>::iterator",
            "path": "en.cppreference.com/w/cpp/ranges/split_view/iterator.html",
            "wgPageName": "cpp/ranges/split_view/iterator",
            "sample_declaration": "class /*iterator*/;  // exposition only"
        },
        {
            "title": "std::ranges::split_view<V,Pattern>::sentinel",
            "path": "en.cppreference.com/w/cpp/ranges/split_view/sentinel.html",
            "wgPageName": "cpp/ranges/split_view/sentinel",
            "sample_declaration": "class /*sentinel*/;  // exposition only"
        },
        {
            "title": "std::ranges::split_view<V,Pattern>::split_view",
            "path": "en.cppreference.com/w/cpp/ranges/split_view/split_view.html",
            "wgPageName": "cpp/ranges/split_view/split_view",
            "sample_declaration": "split_view() requires\n    std::default_initializable<V> &&\n    std::default_initializable<Pattern>\n= default;",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::ssize",
            "path": "en.cppreference.com/w/cpp/ranges/ssize.html",
            "wgPageName": "cpp/ranges/ssize",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "inline namespace /*unspecified*/ {\ninline constexpr /*unspecified*/ ssize =\n    /*unspecified*/;\n}",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::subrange_kind",
            "path": "en.cppreference.com/w/cpp/ranges/subrange_kind.html",
            "wgPageName": "cpp/ranges/subrange_kind",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "enum class subrange_kind : bool {\n  unsized,\n  sized\n};"
        },
        {
            "title": "std::ranges::subrange",
            "path": "en.cppreference.com/w/cpp/ranges/subrange.html",
            "wgPageName": "cpp/ranges/subrange",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<\n    std::input_or_output_iterator I,\n    std::sentinel_for<I> S = I,\n    ranges::subrange_kind K =\n        std::sized_sentinel_for<S, I>\n            ? ranges::subrange_kind::sized\n            : ranges::subrange_kind::unsized>\nrequires(\n    K == ranges::subrange_kind::sized ||\n    !std::\n        sized_sentinel_for<S, I>) class subrange\n    : public ranges::view_interface<\n          subrange<I, S, K>>"
        },
        {
            "title": "std::ranges::subrange<I,S,K>::advance",
            "path": "en.cppreference.com/w/cpp/ranges/subrange/advance.html",
            "wgPageName": "cpp/ranges/subrange/advance",
            "sample_declaration": "constexpr subrange& advance(\n    std::iter_difference_t<I> n);"
        },
        {
            "title": "std::ranges::subrange<I,S,K>::begin",
            "path": "en.cppreference.com/w/cpp/ranges/subrange/begin.html",
            "wgPageName": "cpp/ranges/subrange/begin",
            "sample_declaration": "constexpr I begin()\n    const requires std::copyable<I>;",
            "other_declarations": 1
        },
        {
            "title": "deduction guides for std::ranges::subrange",
            "path": "en.cppreference.com/w/cpp/ranges/subrange/deduction_guides.html",
            "wgPageName": "cpp/ranges/subrange/deduction_guides",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<\n    std::input_or_output_iterator I,\n    std::sentinel_for<I> S>\nsubrange(I, S) -> subrange<I, S>;",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::subrange<I,S,K>::empty",
            "path": "en.cppreference.com/w/cpp/ranges/subrange/empty.html",
            "wgPageName": "cpp/ranges/subrange/empty",
            "sample_declaration": "constexpr bool empty() const;"
        },
        {
            "title": "std::ranges::subrange<I,S,K>::end",
            "path": "en.cppreference.com/w/cpp/ranges/subrange/end.html",
            "wgPageName": "cpp/ranges/subrange/end",
            "sample_declaration": "constexpr S end() const;"
        },
        {
            "title": "std::ranges::get(std::ranges::subrange)",
            "path": "en.cppreference.com/w/cpp/ranges/subrange/get.html",
            "wgPageName": "cpp/ranges/subrange/get",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<\n    std::size_t N,\n    class I,\n    class S,\n    ranges::subrange_kind K>\nrequires(\n    (N == 0 && std::copyable<I>) ||\n    N == 1) constexpr auto get(const ranges::\n                                   subrange<\n                                       I,\n                                       S,\n                                       K>& r);",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::subrange<I,S,K>::next",
            "path": "en.cppreference.com/w/cpp/ranges/subrange/next.html",
            "wgPageName": "cpp/ranges/subrange/next",
            "sample_declaration": "[[nodiscard]] constexpr subrange next(\n    std::iter_difference_t<I> n = 1)\n    const& requires std::forward_iterator<I>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::subrange<I,S,K>::operator PairLike",
            "path": "en.cppreference.com/w/cpp/ranges/subrange/operator_PairLike.html",
            "wgPageName": "cpp/ranges/subrange/operator_PairLike",
            "sample_declaration": "template</*different-from*/<subrange> PairLike>\nrequires /*pair-like-convertible-from*/<\n    PairLike,\n    const I&,\n    const S&> constexpr\noperator PairLike() const;",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::subrange<I,S,K>::prev",
            "path": "en.cppreference.com/w/cpp/ranges/subrange/prev.html",
            "wgPageName": "cpp/ranges/subrange/prev",
            "sample_declaration": "[[nodiscard]] constexpr subrange prev(\n    std::iter_difference_t<I> n = 1) const\n    requires std::bidirectional_iterator<I>;"
        },
        {
            "title": "std::ranges::subrange<I,S,K>::size",
            "path": "en.cppreference.com/w/cpp/ranges/subrange/size.html",
            "wgPageName": "cpp/ranges/subrange/size",
            "sample_declaration": "constexpr /* see below */ size() const\n    requires(K == ranges::subrange_kind::sized);"
        },
        {
            "title": "std::ranges::subrange<I,S,K>::subrange",
            "path": "en.cppreference.com/w/cpp/ranges/subrange/subrange.html",
            "wgPageName": "cpp/ranges/subrange/subrange",
            "sample_declaration": "subrange() requires\n    std::default_initializable<I>\n= default;",
            "other_declarations": 4
        },
        {
            "title": "std::tuple_element<std::ranges::subrange>",
            "path": "en.cppreference.com/w/cpp/ranges/subrange/tuple_element.html",
            "wgPageName": "cpp/ranges/subrange/tuple_element",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<\n    class I,\n    class S,\n    ranges::subrange_kind K>\nstruct tuple_element<\n    0,\n    ranges::subrange<I, S, K>>;",
            "other_declarations": 3
        },
        {
            "title": "std::tuple_size<std:ranges::subrange>",
            "path": "en.cppreference.com/w/cpp/ranges/subrange/tuple_size.html",
            "wgPageName": "cpp/ranges/subrange/tuple_size",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<\n    class I,\n    class S,\n    ranges::subrange_kind K>\nstruct tuple_size<ranges::subrange<I, S, K>>\n    : std::integral_constant<std::size_t, 2> {};"
        },
        {
            "title": "std::ranges::views::take, std::ranges::take_view",
            "path": "en.cppreference.com/w/cpp/ranges/take_view.html",
            "wgPageName": "cpp/ranges/take_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<ranges::view V>\nclass take_view : public ranges::view_interface<\n                      take_view<V>>",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::take_view<V>::base",
            "path": "en.cppreference.com/w/cpp/ranges/take_view/base.html",
            "wgPageName": "cpp/ranges/take_view/base",
            "sample_declaration": "constexpr V base()\n    const& requires std::copy_constructible<V>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::take_view<V>::begin",
            "path": "en.cppreference.com/w/cpp/ranges/take_view/begin.html",
            "wgPageName": "cpp/ranges/take_view/begin",
            "sample_declaration": "constexpr auto begin() requires(\n    !__SimpleView<V>);",
            "other_declarations": 1
        },
        {
            "title": "deduction guides for std::ranges::take_view",
            "path": "en.cppreference.com/w/cpp/ranges/take_view/deduction_guides.html",
            "wgPageName": "cpp/ranges/take_view/deduction_guides",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<class R>\ntake_view(R&&, ranges::range_difference_t<R>)\n    -> take_view<views::all_t<R>>;"
        },
        {
            "title": "std::ranges::take_view<V>::end",
            "path": "en.cppreference.com/w/cpp/ranges/take_view/end.html",
            "wgPageName": "cpp/ranges/take_view/end",
            "sample_declaration": "constexpr auto end() requires(!__SimpleView<V>);",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::take_view<V>::sentinel",
            "path": "en.cppreference.com/w/cpp/ranges/take_view/sentinel.html",
            "wgPageName": "cpp/ranges/take_view/sentinel",
            "sample_declaration": "template<bool Const>\nclass /*sentinel*/"
        },
        {
            "title": "std::ranges::take_view<V>::sentinel<Const>::base",
            "path": "en.cppreference.com/w/cpp/ranges/take_view/sentinel/base.html",
            "wgPageName": "cpp/ranges/take_view/sentinel/base",
            "sample_declaration": "constexpr ranges::sentinel_t<Base> base() const;"
        },
        {
            "title": "operator==(std::ranges::take_view::sentinel<Const>)",
            "path": "en.cppreference.com/w/cpp/ranges/take_view/sentinel/operator_cmp.html",
            "wgPageName": "cpp/ranges/take_view/sentinel/operator_cmp",
            "sample_declaration": "friend constexpr bool operator==(\n    const std::counted_iterator<\n        ranges::iterator_t<Base>>& y,\n    const /*sentinel*/& x);",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::take_view<V>::sentinel<Const>::sentinel",
            "path": "en.cppreference.com/w/cpp/ranges/take_view/sentinel/sentinel.html",
            "wgPageName": "cpp/ranges/take_view/sentinel/sentinel",
            "sample_declaration": "/*sentinel*/ () = default;",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::take_view<V>::size",
            "path": "en.cppreference.com/w/cpp/ranges/take_view/size.html",
            "wgPageName": "cpp/ranges/take_view/size",
            "sample_declaration": "constexpr auto size() requires\n    ranges::sized_range<V>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::take_view<V>::take_view",
            "path": "en.cppreference.com/w/cpp/ranges/take_view/take_view.html",
            "wgPageName": "cpp/ranges/take_view/take_view",
            "sample_declaration": "take_view() requires\n    std::default_initializable<V>\n= default;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::views::take_while, std::ranges::take_while_view",
            "path": "en.cppreference.com/w/cpp/ranges/take_while_view.html",
            "wgPageName": "cpp/ranges/take_while_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<ranges::view V, class Pred>\nrequires ranges::input_range<V> &&\n    std::is_object_v<Pred> &&\n    std::indirect_unary_predicate<\n        const Pred,\n        ranges::iterator_t<V>>\nclass take_while_view\n    : public ranges::view_interface<\n          take_while_view<V, Pred>>",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::take_while_view<V,Pred>::base",
            "path": "en.cppreference.com/w/cpp/ranges/take_while_view/base.html",
            "wgPageName": "cpp/ranges/take_while_view/base",
            "sample_declaration": "constexpr V base()\n    const& requires std::copy_constructible<V>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::take_while_view<V,Pred>::begin",
            "path": "en.cppreference.com/w/cpp/ranges/take_while_view/begin.html",
            "wgPageName": "cpp/ranges/take_while_view/begin",
            "sample_declaration": "constexpr auto begin() requires(\n    !__SimpleView<V>);",
            "other_declarations": 1
        },
        {
            "title": "deduction guides for std::ranges::take_while_view",
            "path": "en.cppreference.com/w/cpp/ranges/take_while_view/deduction_guides.html",
            "wgPageName": "cpp/ranges/take_while_view/deduction_guides",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<class R, class Pred>\ntake_while_view(R&&, Pred)\n    -> take_while_view<views::all_t<R>, Pred>;"
        },
        {
            "title": "std::ranges::take_while_view<V,Pred>::end",
            "path": "en.cppreference.com/w/cpp/ranges/take_while_view/end.html",
            "wgPageName": "cpp/ranges/take_while_view/end",
            "sample_declaration": "constexpr auto end() requires(!__SimpleView<V>);",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::take_while_view<V,Pred>::pred",
            "path": "en.cppreference.com/w/cpp/ranges/take_while_view/pred.html",
            "wgPageName": "cpp/ranges/take_while_view/pred",
            "sample_declaration": "constexpr const Pred& pred() const;"
        },
        {
            "title": "std::ranges::take_while_view<V,Pred>::sentinel",
            "path": "en.cppreference.com/w/cpp/ranges/take_while_view/sentinel.html",
            "wgPageName": "cpp/ranges/take_while_view/sentinel",
            "sample_declaration": "template<bool Const>\nclass /*sentinel*/;  // exposition only"
        },
        {
            "title": "std::ranges::take_while_view<V,Pred>::sentinel<Const>::base",
            "path": "en.cppreference.com/w/cpp/ranges/take_while_view/sentinel/base.html",
            "wgPageName": "cpp/ranges/take_while_view/sentinel/base",
            "sample_declaration": "constexpr ranges::sentinel_t<Base> base() const;"
        },
        {
            "title": "operator==(ranges::take_while_view::sentinel)",
            "path": "en.cppreference.com/w/cpp/ranges/take_while_view/sentinel/operator_cmp.html",
            "wgPageName": "cpp/ranges/take_while_view/sentinel/operator_cmp",
            "sample_declaration": "friend constexpr bool operator==(\n    const ranges::iterator_t<Base>& x,\n    const /*sentinel*/& y);"
        },
        {
            "title": "std::ranges::take_while_view<V,Pred>::sentinel<Const>::sentinel",
            "path": "en.cppreference.com/w/cpp/ranges/take_while_view/sentinel/sentinel.html",
            "wgPageName": "cpp/ranges/take_while_view/sentinel/sentinel",
            "sample_declaration": "/*sentinel*/ () = default;",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::take_while_view<V,Pred>::take_while_view",
            "path": "en.cppreference.com/w/cpp/ranges/take_while_view/take_while_view.html",
            "wgPageName": "cpp/ranges/take_while_view/take_while_view",
            "sample_declaration": "take_while_view() requires\n    std::default_initializable<V> &&\n    std::default_initializable<Pred>\n= default;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::to",
            "path": "en.cppreference.com/w/cpp/ranges/to.html",
            "wgPageName": "cpp/ranges/to",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<\n    class C,\n    ranges::input_range R,\n    class... Args>\nrequires(!ranges::view<C>) constexpr C\n    to(R&& r, Args&&... args);",
            "other_declarations": 7
        },
        {
            "title": "std::ranges::views::transform, std::ranges::transform_view",
            "path": "en.cppreference.com/w/cpp/ranges/transform_view.html",
            "wgPageName": "cpp/ranges/transform_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<\n    ranges::input_range V,\n    std::copy_constructible F>\nrequires ranges::view<V> &&\n    std::is_object_v<F> &&\n    std::regular_invocable<\n        F&,\n        ranges::range_reference_t<V>> &&\n    /* invoke_result_t<F&,\n       range_reference_t<V>>& is a valid type */\n    class transform_view\n    : public ranges::view_interface<\n          transform_view<V, F>>",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::transform_view<V,F>::base",
            "path": "en.cppreference.com/w/cpp/ranges/transform_view/base.html",
            "wgPageName": "cpp/ranges/transform_view/base",
            "sample_declaration": "constexpr V base()\n    const& requires std::copy_constructible<V>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::transform_view<V,F>::begin",
            "path": "en.cppreference.com/w/cpp/ranges/transform_view/begin.html",
            "wgPageName": "cpp/ranges/transform_view/begin",
            "sample_declaration": "constexpr /*iterator*/<false> begin();",
            "other_declarations": 1
        },
        {
            "title": "deduction guides for std::ranges::transform_view",
            "path": "en.cppreference.com/w/cpp/ranges/transform_view/deduction_guides.html",
            "wgPageName": "cpp/ranges/transform_view/deduction_guides",
            "sample_declaration": "template<class R, class F>\ntransform_view(R&&, F)\n    -> transform_view<views::all_t<R>, F>;"
        },
        {
            "title": "std::ranges::transform_view<V,F>::end",
            "path": "en.cppreference.com/w/cpp/ranges/transform_view/end.html",
            "wgPageName": "cpp/ranges/transform_view/end",
            "sample_declaration": "constexpr /*sentinel*/<false> end();",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::transform_view<V,F>::iterator",
            "path": "en.cppreference.com/w/cpp/ranges/transform_view/iterator.html",
            "wgPageName": "cpp/ranges/transform_view/iterator",
            "sample_declaration": "template<bool Const>\nclass /*iterator*/"
        },
        {
            "title": "std::ranges::transform_view<V,F>::iterator<Const>::base",
            "path": "en.cppreference.com/w/cpp/ranges/transform_view/iterator/base.html",
            "wgPageName": "cpp/ranges/transform_view/iterator/base",
            "sample_declaration": "constexpr const ranges::iterator_t<Base>& base()\n    const& noexcept;",
            "other_declarations": 1
        },
        {
            "title": "iter_move(ranges::transform_view::iterator)",
            "path": "en.cppreference.com/w/cpp/ranges/transform_view/iterator/iter_move.html",
            "wgPageName": "cpp/ranges/transform_view/iterator/iter_move",
            "sample_declaration": "friend constexpr decltype(auto)\niter_move(const /*iterator*/& i) noexcept(\n    /* see below */);"
        },
        {
            "title": "std::ranges::transform_view<V,F>::iterator<Const>::iterator",
            "path": "en.cppreference.com/w/cpp/ranges/transform_view/iterator/iterator.html",
            "wgPageName": "cpp/ranges/transform_view/iterator/iterator",
            "sample_declaration": "/*iterator*/ () requires\n    std::default_initializable<\n        ranges::iterator_t<Base>>\n= default;",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::transform_view<V,F>::iterator<Const>::operator++,--,+=,-=",
            "path": "en.cppreference.com/w/cpp/ranges/transform_view/iterator/operator_arith.html",
            "wgPageName": "cpp/ranges/transform_view/iterator/operator_arith",
            "sample_declaration": "constexpr /*iterator*/& operator++();",
            "other_declarations": 6
        },
        {
            "title": "operator+,-(ranges::transform_view::iterator)",
            "path": "en.cppreference.com/w/cpp/ranges/transform_view/iterator/operator_arith2.html",
            "wgPageName": "cpp/ranges/transform_view/iterator/operator_arith2",
            "sample_declaration": "friend constexpr /*iterator*/ operator+(\n    /*iterator*/ i,\n    difference_type n) requires\n    ranges::random_access_range<Base>;",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::transform_view<V,F>::iterator<Const>::operator[]",
            "path": "en.cppreference.com/w/cpp/ranges/transform_view/iterator/operator_at.html",
            "wgPageName": "cpp/ranges/transform_view/iterator/operator_at",
            "sample_declaration": "constexpr decltype(auto) operator[](\n    difference_type n) const requires\n    ranges::random_access_range<Base>;"
        },
        {
            "title": "operator==,<,>,<=,>=,<=>(ranges::transform_view::iterator)",
            "path": "en.cppreference.com/w/cpp/ranges/transform_view/iterator/operator_cmp.html",
            "wgPageName": "cpp/ranges/transform_view/iterator/operator_cmp",
            "sample_declaration": "friend constexpr bool operator==(\n    const /*iterator*/& x,\n    const /*iterator*/& y) requires\n    std::equality_comparable<\n        ranges::iterator_t<Base>>;",
            "other_declarations": 5
        },
        {
            "title": "std::ranges::transform_view<V,F>::iterator<Const>::operator*",
            "path": "en.cppreference.com/w/cpp/ranges/transform_view/iterator/operator*.html",
            "wgPageName": "cpp/ranges/transform_view/iterator/operator*",
            "sample_declaration": "constexpr decltype(auto) operator*() const;"
        },
        {
            "title": "std::ranges::transform_view<V,F>::sentinel",
            "path": "en.cppreference.com/w/cpp/ranges/transform_view/sentinel.html",
            "wgPageName": "cpp/ranges/transform_view/sentinel",
            "sample_declaration": "template<bool Const>\nclass /*sentinel*/"
        },
        {
            "title": "std::ranges::transform_view<V,F>::sentinel<Const>::base",
            "path": "en.cppreference.com/w/cpp/ranges/transform_view/sentinel/base.html",
            "wgPageName": "cpp/ranges/transform_view/sentinel/base",
            "sample_declaration": "constexpr ranges::sentinel_t<Base> base() const;"
        },
        {
            "title": "operator==(ranges::transform_view::sentinel)",
            "path": "en.cppreference.com/w/cpp/ranges/transform_view/sentinel/operator_cmp.html",
            "wgPageName": "cpp/ranges/transform_view/sentinel/operator_cmp",
            "sample_declaration": "friend constexpr bool operator==(\n    const /*iterator*/<Const>& x,\n    const /*sentinel*/& y);"
        },
        {
            "title": "operator-(ranges::transform_view::sentinel)",
            "path": "en.cppreference.com/w/cpp/ranges/transform_view/sentinel/operator-.html",
            "wgPageName": "cpp/ranges/transform_view/sentinel/operator-",
            "sample_declaration": "friend constexpr ranges::range_difference_t<\n    Base>\noperator-(\n    const /*iterator*/<Const>& x,\n    const /*sentinel*/& y) requires\n    std::sized_sentinel_for<\n        ranges::sentinel_t<Base>,\n        ranges::iterator_t<Base>>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::transform_view<V,F>::sentinel<Const>::sentinel",
            "path": "en.cppreference.com/w/cpp/ranges/transform_view/sentinel/sentinel.html",
            "wgPageName": "cpp/ranges/transform_view/sentinel/sentinel",
            "sample_declaration": "/*sentinel*/ () = default;",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::transform_view<V,F>::size",
            "path": "en.cppreference.com/w/cpp/ranges/transform_view/size.html",
            "wgPageName": "cpp/ranges/transform_view/size",
            "sample_declaration": "constexpr auto size() requires\n    ranges::sized_range<V>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::transform_view<V,F>::transform_view",
            "path": "en.cppreference.com/w/cpp/ranges/transform_view/transform_view.html",
            "wgPageName": "cpp/ranges/transform_view/transform_view",
            "sample_declaration": "transform_view() requires\n    std::default_initializable<V> &&\n    std::default_initializable<F>\n= default;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::views::values, std::ranges::values_view",
            "path": "en.cppreference.com/w/cpp/ranges/values_view.html",
            "wgPageName": "cpp/ranges/values_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<class R>\nusing values_view = ranges::elements_view<R, 1>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::views::counted",
            "path": "en.cppreference.com/w/cpp/ranges/view_counted.html",
            "wgPageName": "cpp/ranges/view_counted",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "inline constexpr /*unspecified*/ counted =\n    /*unspecified*/;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::view_interface",
            "path": "en.cppreference.com/w/cpp/ranges/view_interface.html",
            "wgPageName": "cpp/ranges/view_interface",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<class D>\nrequires std::is_class_v<D> &&\n    std::same_as<D, std::remove_cv_t<D>>\nclass view_interface;"
        },
        {
            "title": "std::ranges::view_interface<D>::back",
            "path": "en.cppreference.com/w/cpp/ranges/view_interface/back.html",
            "wgPageName": "cpp/ranges/view_interface/back",
            "sample_declaration": "constexpr decltype(auto) back() requires\n    ranges::bidirectional_range<D> &&\n    ranges::common_range<D>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::view_interface<D>::data",
            "path": "en.cppreference.com/w/cpp/ranges/view_interface/data.html",
            "wgPageName": "cpp/ranges/view_interface/data",
            "sample_declaration": "constexpr auto data() requires std::\n    contiguous_iterator<ranges::iterator_t<D>>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::view_interface<D>::empty",
            "path": "en.cppreference.com/w/cpp/ranges/view_interface/empty.html",
            "wgPageName": "cpp/ranges/view_interface/empty",
            "sample_declaration": "constexpr bool empty() requires\n    ranges::sized_range<D> ||\n    ranges::forward_range<D>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::view_interface<D>::front",
            "path": "en.cppreference.com/w/cpp/ranges/view_interface/front.html",
            "wgPageName": "cpp/ranges/view_interface/front",
            "sample_declaration": "constexpr decltype(auto) front() requires\n    ranges::forward_range<D>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::view_interface<D>::operator[]",
            "path": "en.cppreference.com/w/cpp/ranges/view_interface/operator_at.html",
            "wgPageName": "cpp/ranges/view_interface/operator_at",
            "sample_declaration": "template<ranges::random_access_range R = D>\nconstexpr decltype(auto) operator[](\n    ranges::range_difference_t<R> n);",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::view_interface<D>::operator bool",
            "path": "en.cppreference.com/w/cpp/ranges/view_interface/operator_bool.html",
            "wgPageName": "cpp/ranges/view_interface/operator_bool",
            "sample_declaration": "explicit constexpr operator bool() requires\n    /* see below */;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::view_interface<D>::size",
            "path": "en.cppreference.com/w/cpp/ranges/view_interface/size.html",
            "wgPageName": "cpp/ranges/view_interface/size",
            "sample_declaration": "constexpr auto size() requires\n    ranges::forward_range<D> &&\n    std::sized_sentinel_for<\n        ranges::sentinel_t<D>,\n        ranges::iterator_t<D>>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::view, std::ranges::enable_view, std::ranges::view_base",
            "path": "en.cppreference.com/w/cpp/ranges/view.html",
            "wgPageName": "cpp/ranges/view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<class T>\nconcept view = ranges::range<T> &&\n    std::movable<T> && ranges::enable_view<T>;",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::viewable_range",
            "path": "en.cppreference.com/w/cpp/ranges/viewable_range.html",
            "wgPageName": "cpp/ranges/viewable_range",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<class T>\nconcept viewable_range = ranges::range<T> &&\n    ((ranges::view<std::remove_cvref_t<T>> &&\n      std::constructible_from<\n          std::remove_cvref_t<T>,\n          T>) ||\n     (!ranges::view<std::remove_cvref_t<T>> &&\n      (std::is_lvalue_reference_v<T> ||\n       (std::movable<\n            std::remove_reference_t<T>> &&\n        !/*is-initializer-list*/<T>))));"
        },
        {
            "title": "std::ranges::views::zip_transform, std::ranges::zip_transform_view",
            "path": "en.cppreference.com/w/cpp/ranges/zip_transform_view.html",
            "wgPageName": "cpp/ranges/zip_transform_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<\n    std::copy_constructible F,\n    ranges::input_range... Views>\nrequires(ranges::view<Views>&&...) &&\n    (sizeof...(Views) > 0) &&\n    std::is_object_v<F>&& std::\n        regular_invocable<\n            F&,\n            ranges::range_reference_t<\n                Views>...>&& /*can-reference*/\n    <std::invoke_result_t<\n        F&,\n        ranges::range_reference_t<\n            Views>...>> class zip_transform_view\n    : public ranges::view_interface<\n          zip_transform_view<F, Views...>>",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::zip_transform_view<F,Views...>::begin",
            "path": "en.cppreference.com/w/cpp/ranges/zip_transform_view/begin.html",
            "wgPageName": "cpp/ranges/zip_transform_view/begin",
            "sample_declaration": "constexpr auto begin();",
            "other_declarations": 1
        },
        {
            "title": "deduction guides for std::ranges::zip_transform_view",
            "path": "en.cppreference.com/w/cpp/ranges/zip_transform_view/deduction_guides.html",
            "wgPageName": "cpp/ranges/zip_transform_view/deduction_guides",
            "sample_declaration": "template<class F, class... Rs>\nzip_transform_view(F, Rs&&...)\n    -> zip_transform_view<\n        F,\n        views::all_t<Rs>...>;"
        },
        {
            "title": "std::ranges::zip_transform_view<F,Views...>::end",
            "path": "en.cppreference.com/w/cpp/ranges/zip_transform_view/end.html",
            "wgPageName": "cpp/ranges/zip_transform_view/end",
            "sample_declaration": "constexpr auto end();",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::zip_transform_view<F,Views...>::iterator",
            "path": "en.cppreference.com/w/cpp/ranges/zip_transform_view/iterator.html",
            "wgPageName": "cpp/ranges/zip_transform_view/iterator",
            "sample_declaration": "template<bool Const>\nclass /*iterator*/;  // exposition only"
        },
        {
            "title": "std::ranges::zip_transform_view<F,Views...>::iterator<Const>::iterator",
            "path": "en.cppreference.com/w/cpp/ranges/zip_transform_view/iterator/iterator.html",
            "wgPageName": "cpp/ranges/zip_transform_view/iterator/iterator",
            "sample_declaration": "/*iterator*/ iterator() = default;",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::zip_transform_view<F,Views...>::iterator<Const>::operator++,--,+=,-=",
            "path": "en.cppreference.com/w/cpp/ranges/zip_transform_view/iterator/operator_arith.html",
            "wgPageName": "cpp/ranges/zip_transform_view/iterator/operator_arith",
            "sample_declaration": "constexpr /*iterator*/& operator++();",
            "other_declarations": 6
        },
        {
            "title": "operator+,-(ranges::zip_transform_view::iterator)",
            "path": "en.cppreference.com/w/cpp/ranges/zip_transform_view/iterator/operator_arith2.html",
            "wgPageName": "cpp/ranges/zip_transform_view/iterator/operator_arith2",
            "sample_declaration": "friend constexpr /*iterator*/ operator+(\n    const /*iterator*/& i,\n    difference_type n) requires\n    ranges::random_access_range<Base>;",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::zip_transform_view<F,Views...>::iterator<Const>::operator[]",
            "path": "en.cppreference.com/w/cpp/ranges/zip_transform_view/iterator/operator_at.html",
            "wgPageName": "cpp/ranges/zip_transform_view/iterator/operator_at",
            "sample_declaration": "constexpr decltype(auto) operator[](\n    difference_type n) const requires\n    ranges::random_access_range<Base>;"
        },
        {
            "title": "operator==,<,>,<=,>=,<=>(ranges::zip_transform_view::iterator)",
            "path": "en.cppreference.com/w/cpp/ranges/zip_transform_view/iterator/operator_cmp.html",
            "wgPageName": "cpp/ranges/zip_transform_view/iterator/operator_cmp",
            "sample_declaration": "friend constexpr bool operator==(\n    const /*iterator*/& x,\n    const /*iterator*/& y) requires std::\n    equality_comparable</*ziperator*/<Const>>;",
            "other_declarations": 5
        },
        {
            "title": "std::ranges::zip_transform_view<F,Views...>::iterator<Const>::operator*",
            "path": "en.cppreference.com/w/cpp/ranges/zip_transform_view/iterator/operator*.html",
            "wgPageName": "cpp/ranges/zip_transform_view/iterator/operator*",
            "sample_declaration": "constexpr decltype(auto) operator*() const\n    noexcept(/* see description */);"
        },
        {
            "title": "std::ranges::zip_transform_view<F,Views...>::sentinel",
            "path": "en.cppreference.com/w/cpp/ranges/zip_transform_view/sentinel.html",
            "wgPageName": "cpp/ranges/zip_transform_view/sentinel",
            "sample_declaration": "template<bool Const>\nclass /*sentinel*/;  // exposition only"
        },
        {
            "title": "operator==(ranges::zip_transform_view::sentinel)",
            "path": "en.cppreference.com/w/cpp/ranges/zip_transform_view/sentinel/operator_cmp.html",
            "wgPageName": "cpp/ranges/zip_transform_view/sentinel/operator_cmp",
            "sample_declaration": "template<bool OtherConst>\nrequires std::sentinel_for<\n    /*zentinel*/<Const>,\n    /*ziperator*/<OtherConst>>\nfriend constexpr bool operator==(\n    const /*iterator*/<OtherConst>& x,\n    const /*sentinel*/& y);"
        },
        {
            "title": "operator-(ranges::zip_transform_view::sentinel)",
            "path": "en.cppreference.com/w/cpp/ranges/zip_transform_view/sentinel/operator-.html",
            "wgPageName": "cpp/ranges/zip_transform_view/sentinel/operator-",
            "sample_declaration": "template<bool OtherConst>\nrequires std::sized_sentinel_for<\n    /*zentinel*/<Const>,\n    /*ziperator*/<OtherConst>>\nfriend constexpr ranges::range_difference_t<\n    /*maybe-const*/<OtherConst, /*InnerView*/>>\noperator-(\n    const /*iterator*/<OtherConst>& x,\n    const /*sentinel*/& y);",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::zip_transform_view<F,Views...>::sentinel<Const>::sentinel",
            "path": "en.cppreference.com/w/cpp/ranges/zip_transform_view/sentinel/sentinel.html",
            "wgPageName": "cpp/ranges/zip_transform_view/sentinel/sentinel",
            "sample_declaration": "/*sentinel*/ () = default;",
            "other_declarations": 2
        },
        {
            "title": "std::ranges::zip_transform_view<F,Views...>::size",
            "path": "en.cppreference.com/w/cpp/ranges/zip_transform_view/size.html",
            "wgPageName": "cpp/ranges/zip_transform_view/size",
            "sample_declaration": "constexpr auto size() requires\n    ranges::sized_range</*InnerView*/>;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::zip_transform_view<F,Views...>::zip_transform_view",
            "path": "en.cppreference.com/w/cpp/ranges/zip_transform_view/zip_transform_view.html",
            "wgPageName": "cpp/ranges/zip_transform_view/zip_transform_view",
            "sample_declaration": "zip_transform_view() = default;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::views::zip, std::ranges::zip_view",
            "path": "en.cppreference.com/w/cpp/ranges/zip_view.html",
            "wgPageName": "cpp/ranges/zip_view",
            "headers": [
                "<ranges>"
            ],
            "sample_declaration": "template<ranges::input_range... Views>\nrequires(ranges::view<Views>&&...) &&\n    (sizeof...(Views) > 0) class zip_view\n    : public ranges::view_interface<\n          zip_view<Views...>>",
            "other_declarations": 6
        },
        {
            "title": "std::ranges::zip_view<Views...>::begin",
            "path": "en.cppreference.com/w/cpp/ranges/zip_view/begin.html",
            "wgPageName": "cpp/ranges/zip_view/begin",
            "sample_declaration": "constexpr auto begin() requires(\n    !(/*simple-view*/<Views> && ...));",
            "other_declarations": 1
        },
        {
            "title": "deduction guides for std::ranges::zip_view",
            "path": "en.cppreference.com/w/cpp/ranges/zip_view/deduction_guides.html",
            "wgPageName": "cpp/ranges/zip_view/deduction_guides",
            "sample_declaration": "template<class... Rs>\nzip_view(Rs&&...)\n    -> zip_view<views::all_t<Rs>...>;"
        },
        {
            "title": "std::ranges::zip_view<Views...>::end",
            "path": "en.cppreference.com/w/cpp/ranges/zip_view/end.html",
            "wgPageName": "cpp/ranges/zip_view/end",
            "sample_declaration": "constexpr auto end() requires (!(/*simple-view*/<Views> && ...);",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::zip_view<Views...>::iterator",
            "path": "en.cppreference.com/w/cpp/ranges/zip_view/iterator.html",
            "wgPageName": "cpp/ranges/zip_view/iterator",
            "sample_declaration": "template<bool Const>\nclass /*iterator*/;  // exposition only",
            "other_declarations": 3
        },
        {
            "title": "iter_move(ranges::zip_view::iterator)",
            "path": "en.cppreference.com/w/cpp/ranges/zip_view/iterator/iter_move.html",
            "wgPageName": "cpp/ranges/zip_view/iterator/iter_move",
            "sample_declaration": "friend constexpr auto\niter_move(const iterator& i) noexcept(\n    /* see below */);"
        },
        {
            "title": "iter_swap(ranges::zip_view::iterator)",
            "path": "en.cppreference.com/w/cpp/ranges/zip_view/iterator/iter_swap.html",
            "wgPageName": "cpp/ranges/zip_view/iterator/iter_swap",
            "sample_declaration": "friend constexpr void\niter_swap(const /*iterator*/& x, const /*iterator*/& y) noexcept(\n    /* see below */) requires(std::\n                                  indirectly_swappable<\n                                      ranges::iterator_t<\n                                          /*maybe-const*/\n                                          <Const,\n                                           Views>>>&&...);"
        },
        {
            "title": "std::ranges::zip_view<Views...>::iterator<Const>::iterator",
            "path": "en.cppreference.com/w/cpp/ranges/zip_view/iterator/iterator.html",
            "wgPageName": "cpp/ranges/zip_view/iterator/iterator",
            "sample_declaration": "/*iterator*/ () = default;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::zip_view<Views...>::iterator<Const>::operator++,--,+=,-=",
            "path": "en.cppreference.com/w/cpp/ranges/zip_view/iterator/operator_arith.html",
            "wgPageName": "cpp/ranges/zip_view/iterator/operator_arith",
            "sample_declaration": "constexpr /*iterator*/& operator++();",
            "other_declarations": 6
        },
        {
            "title": "operator+,-(ranges::zip_view::iterator)",
            "path": "en.cppreference.com/w/cpp/ranges/zip_view/iterator/operator_arith2.html",
            "wgPageName": "cpp/ranges/zip_view/iterator/operator_arith2",
            "sample_declaration": "friend constexpr /*iterator*/ operator+(\n    const /*iterator*/& i,\n    difference_type n) requires\n    /*all-random-access*/<Const, Views...>;",
            "other_declarations": 3
        },
        {
            "title": "std::ranges::zip_view<Views...>::iterator<Const>::operator[]",
            "path": "en.cppreference.com/w/cpp/ranges/zip_view/iterator/operator_at.html",
            "wgPageName": "cpp/ranges/zip_view/iterator/operator_at",
            "sample_declaration": "constexpr auto operator[](\n    difference_type n) const requires\n    /*all-random-access*/<Const, Views...>;"
        },
        {
            "title": "operator==,<,>,<=,>=,<=>(ranges::zip_view::iterator)",
            "path": "en.cppreference.com/w/cpp/ranges/zip_view/iterator/operator_cmp.html",
            "wgPageName": "cpp/ranges/zip_view/iterator/operator_cmp",
            "sample_declaration": "friend constexpr bool operator==(\n    const /*iterator*/& x,\n    const /*iterator*/&\n        y) requires(std::\n                        equality_comparable<\n                            ranges::iterator_t<\n                                /*maybe-const*/\n                                <Const,\n                                 Views>>>&&...);",
            "other_declarations": 5
        },
        {
            "title": "std::ranges::zip_view<Views...>::iterator<Const>::operator*",
            "path": "en.cppreference.com/w/cpp/ranges/zip_view/iterator/operator*.html",
            "wgPageName": "cpp/ranges/zip_view/iterator/operator*",
            "sample_declaration": "constexpr auto operator*() const;"
        },
        {
            "title": "std::ranges::zip_view<Views...>::sentinel",
            "path": "en.cppreference.com/w/cpp/ranges/zip_view/sentinel.html",
            "wgPageName": "cpp/ranges/zip_view/sentinel",
            "sample_declaration": "template<bool Const>\nclass /*sentinel*/;  // exposition only"
        },
        {
            "title": "operator==(ranges::zip_view::iterator, ranges::zip_view::sentinel)",
            "path": "en.cppreference.com/w/cpp/ranges/zip_view/sentinel/operator_cmp.html",
            "wgPageName": "cpp/ranges/zip_view/sentinel/operator_cmp",
            "sample_declaration": "template<bool OtherConst>\nrequires(\n    std::sentinel_for<\n        ranges::sentinel_t<\n            /*maybe-const*/<Const, Views>>,\n        ranges::iterator_t</*maybe-const*/<\n            OtherConst,\n            Views>>>&&...) friend constexpr bool\noperator==(\n    const /*iterator*/<OtherConst>& x,\n    const /*sentinel*/& y);"
        },
        {
            "title": "operator-(ranges::zip_view::sentinel)",
            "path": "en.cppreference.com/w/cpp/ranges/zip_view/sentinel/operator-.html",
            "wgPageName": "cpp/ranges/zip_view/sentinel/operator-",
            "sample_declaration": "template<bool OtherConst>\nrequires(\n    std::sized_sentinel_for<\n        ranges::sentinel_t<\n            /*maybe-const*/<Const, Views>>,\n        ranges::iterator_t</*maybe-const*/<\n            OtherConst,\n            Views>>>&&...) friend constexpr std::\n    common_type_t<ranges::range_difference_t<\n        /*maybe-const*/<OtherConst, Views>>...>\n    operator-(\n        const iterator<OtherConst>& x,\n        const sentinel& y);",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::zip_view<Views...>::sentinel<Const>::sentinel",
            "path": "en.cppreference.com/w/cpp/ranges/zip_view/sentinel/sentinel.html",
            "wgPageName": "cpp/ranges/zip_view/sentinel/sentinel",
            "sample_declaration": "/*sentinel*/ () = default;",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::zip_view<Views...>::size",
            "path": "en.cppreference.com/w/cpp/ranges/zip_view/size.html",
            "wgPageName": "cpp/ranges/zip_view/size",
            "sample_declaration": "constexpr auto size() requires(\n    ranges::sized_range<Views>&&...);",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::zip_view<Views...>::zip_view",
            "path": "en.cppreference.com/w/cpp/ranges/zip_view/zip_view.html",
            "wgPageName": "cpp/ranges/zip_view/zip_view",
            "sample_declaration": "zip_view() = default;",
            "other_declarations": 1
        },
        {
            "title": "Regular expressions library (since C++11)",
            "path": "en.cppreference.com/w/cpp/regex.html",
            "wgPageName": "cpp/regex"
        },
        {
            "title": "std::basic_regex",
            "path": "en.cppreference.com/w/cpp/regex/basic_regex.html",
            "wgPageName": "cpp/regex/basic_regex",
            "headers": [
                "<regex>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::regex_traits<CharT> >\nclass basic_regex;"
        },
        {
            "title": "std::basic_regex<CharT,Traits>::~basic_regex",
            "path": "en.cppreference.com/w/cpp/regex/basic_regex/~basic_regex.html",
            "wgPageName": "cpp/regex/basic_regex/~basic_regex",
            "sample_declaration": "~basic_regex();"
        },
        {
            "title": "std::basic_regex<CharT,Traits>::assign",
            "path": "en.cppreference.com/w/cpp/regex/basic_regex/assign.html",
            "wgPageName": "cpp/regex/basic_regex/assign",
            "sample_declaration": "basic_regex& assign(const basic_regex& other);",
            "other_declarations": 6
        },
        {
            "title": "std::basic_regex<CharT,Traits>::basic_regex",
            "path": "en.cppreference.com/w/cpp/regex/basic_regex/basic_regex.html",
            "wgPageName": "cpp/regex/basic_regex/basic_regex",
            "sample_declaration": "basic_regex();",
            "other_declarations": 7
        },
        {
            "title": "std::basic_regex constants",
            "path": "en.cppreference.com/w/cpp/regex/basic_regex/constants.html",
            "wgPageName": "cpp/regex/basic_regex/constants",
            "headers": [
                "<regex>"
            ],
            "sample_declaration": "static constexpr std::regex_constants::\n    syntax_option_type icase =\n        std::regex_constants::icase;\nstatic constexpr std::regex_constants::\n    syntax_option_type nosubs =\n        std::regex_constants::nosubs;\nstatic constexpr std::regex_constants::\n    syntax_option_type optimize =\n        std::regex_constants::optimize;\nstatic constexpr std::regex_constants::\n    syntax_option_type collate =\n        std::regex_constants::collate;\nstatic constexpr std::regex_constants::\n    syntax_option_type ECMAScript =\n        std::regex_constants::ECMAScript;\nstatic constexpr std::regex_constants::\n    syntax_option_type basic =\n        std::regex_constants::basic;\nstatic constexpr std::regex_constants::\n    syntax_option_type extended =\n        std::regex_constants::extended;\nstatic constexpr std::regex_constants::\n    syntax_option_type awk =\n        std::regex_constants::awk;\nstatic constexpr std::regex_constants::\n    syntax_option_type grep =\n        std::regex_constants::grep;\nstatic constexpr std::regex_constants::\n    syntax_option_type egrep =\n        std::regex_constants::egrep;",
            "other_declarations": 1
        },
        {
            "title": "deduction guides for std::basic_regex",
            "path": "en.cppreference.com/w/cpp/regex/basic_regex/deduction_guides.html",
            "wgPageName": "cpp/regex/basic_regex/deduction_guides",
            "headers": [
                "<regex>"
            ],
            "sample_declaration": "template<class ForwardIt>\nbasic_regex(\n    ForwardIt,\n    ForwardIt,\n    std::regex_constants::syntax_option_type =\n        std::regex_constants::ECMAScript)\n    -> basic_regex<\n        typename std::iterator_traits<\n            ForwardIt>::value_type>;"
        },
        {
            "title": "std::basic_regex<CharT,Traits>::flags",
            "path": "en.cppreference.com/w/cpp/regex/basic_regex/flags.html",
            "wgPageName": "cpp/regex/basic_regex/flags",
            "sample_declaration": "flag_type flags() const;"
        },
        {
            "title": "std::basic_regex<CharT,Traits>::getloc",
            "path": "en.cppreference.com/w/cpp/regex/basic_regex/getloc.html",
            "wgPageName": "cpp/regex/basic_regex/getloc",
            "sample_declaration": "locale_type getloc() const;"
        },
        {
            "title": "std::basic_regex<CharT,Traits>::imbue",
            "path": "en.cppreference.com/w/cpp/regex/basic_regex/imbue.html",
            "wgPageName": "cpp/regex/basic_regex/imbue",
            "sample_declaration": "locale_type imbue(locale_type loc);"
        },
        {
            "title": "std::basic_regex<CharT,Traits>::mark_count",
            "path": "en.cppreference.com/w/cpp/regex/basic_regex/mark_count.html",
            "wgPageName": "cpp/regex/basic_regex/mark_count",
            "sample_declaration": "unsigned mark_count() const;"
        },
        {
            "title": "std::basic_regex<CharT,Traits>::operator=",
            "path": "en.cppreference.com/w/cpp/regex/basic_regex/operator=.html",
            "wgPageName": "cpp/regex/basic_regex/operator=",
            "headers": [
                "<regex>"
            ],
            "sample_declaration": "basic_regex& operator=(\n    const basic_regex& other);",
            "other_declarations": 4
        },
        {
            "title": "std::basic_regex<CharT,Traits>::swap",
            "path": "en.cppreference.com/w/cpp/regex/basic_regex/swap.html",
            "wgPageName": "cpp/regex/basic_regex/swap",
            "sample_declaration": "void swap(basic_regex& other) noexcept;"
        },
        {
            "title": "std::swap(std::basic_regex)",
            "path": "en.cppreference.com/w/cpp/regex/basic_regex/swap2.html",
            "wgPageName": "cpp/regex/basic_regex/swap2",
            "sample_declaration": "template<class CharT, class Traits>\nvoid swap(\n    basic_regex<CharT, Traits>& lhs,\n    basic_regex<CharT, Traits>& rhs) noexcept;"
        },
        {
            "title": "Modified ECMAScript regular expression grammar",
            "path": "en.cppreference.com/w/cpp/regex/ecmascript.html",
            "wgPageName": "cpp/regex/ecmascript"
        },
        {
            "title": "std::regex_constants::error_type",
            "path": "en.cppreference.com/w/cpp/regex/error_type.html",
            "wgPageName": "cpp/regex/error_type",
            "headers": [
                "<regex>"
            ],
            "sample_declaration": "typedef /*implementation defined*/ error_type;",
            "other_declarations": 2
        },
        {
            "title": "std::regex_constants::match_flag_type",
            "path": "en.cppreference.com/w/cpp/regex/match_flag_type.html",
            "wgPageName": "cpp/regex/match_flag_type",
            "headers": [
                "<regex>"
            ],
            "sample_declaration": "typedef /*unspecified*/ match_flag_type;",
            "other_declarations": 2
        },
        {
            "title": "std::match_results",
            "path": "en.cppreference.com/w/cpp/regex/match_results.html",
            "wgPageName": "cpp/regex/match_results",
            "headers": [
                "<regex>"
            ],
            "sample_declaration": "template<\n    class BidirIt,\n    class Alloc =\n        std::allocator<std::sub_match<BidirIt>>>\nclass match_results;",
            "other_declarations": 1
        },
        {
            "title": "std::match_results<BidirIt,Alloc>::~match_results",
            "path": "en.cppreference.com/w/cpp/regex/match_results/~match_results.html",
            "wgPageName": "cpp/regex/match_results/~match_results",
            "sample_declaration": "~match_results();"
        },
        {
            "title": "std::match_results<BidirIt,Alloc>::begin, std::match_results<BidirIt,Alloc>::cbegin",
            "path": "en.cppreference.com/w/cpp/regex/match_results/begin.html",
            "wgPageName": "cpp/regex/match_results/begin",
            "sample_declaration": "iterator begin() noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::match_results<BidirIt,Alloc>::empty",
            "path": "en.cppreference.com/w/cpp/regex/match_results/empty.html",
            "wgPageName": "cpp/regex/match_results/empty",
            "sample_declaration": "bool empty() const;",
            "other_declarations": 1
        },
        {
            "title": "std::match_results<BidirIt,Alloc>::end, std::match_results<BidirIt,Alloc>::cend",
            "path": "en.cppreference.com/w/cpp/regex/match_results/end.html",
            "wgPageName": "cpp/regex/match_results/end",
            "sample_declaration": "iterator end() noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::match_results<BidirIt,Alloc>::format",
            "path": "en.cppreference.com/w/cpp/regex/match_results/format.html",
            "wgPageName": "cpp/regex/match_results/format",
            "sample_declaration": "template<class OutputIt>\nOutputIt format(\n    OutputIt out,\n    const char_type* fmt_first,\n    const char_type* fmt_last,\n    std::regex_constants::match_flag_type\n        flags = std::regex_constants::\n            format_default) const;",
            "other_declarations": 3
        },
        {
            "title": "std::match_results<BidirIt,Alloc>::get_allocator",
            "path": "en.cppreference.com/w/cpp/regex/match_results/get_allocator.html",
            "wgPageName": "cpp/regex/match_results/get_allocator",
            "sample_declaration": "allocator_type get_allocator() const;"
        },
        {
            "title": "std::match_results<BidirIt,Alloc>::length",
            "path": "en.cppreference.com/w/cpp/regex/match_results/length.html",
            "wgPageName": "cpp/regex/match_results/length",
            "sample_declaration": "difference_type length(size_type n = 0) const;"
        },
        {
            "title": "std::match_results<BidirIt,Alloc>::match_results",
            "path": "en.cppreference.com/w/cpp/regex/match_results/match_results.html",
            "wgPageName": "cpp/regex/match_results/match_results",
            "sample_declaration": "match_results() : match_results(Allocator()) {}",
            "other_declarations": 3
        },
        {
            "title": "std::match_results<BidirIt,Alloc>::max_size",
            "path": "en.cppreference.com/w/cpp/regex/match_results/max_size.html",
            "wgPageName": "cpp/regex/match_results/max_size",
            "sample_declaration": "size_type max_size() const noexcept;"
        },
        {
            "title": "std::match_results<BidirIt,Alloc>::operator[]",
            "path": "en.cppreference.com/w/cpp/regex/match_results/operator_at.html",
            "wgPageName": "cpp/regex/match_results/operator_at",
            "sample_declaration": "const_reference operator[](size_type n) const;"
        },
        {
            "title": "operator==,!=(std::match_results)",
            "path": "en.cppreference.com/w/cpp/regex/match_results/operator_cmp.html",
            "wgPageName": "cpp/regex/match_results/operator_cmp",
            "headers": [
                "<regex>"
            ],
            "sample_declaration": "template<class BidirIt, class Alloc>\nbool operator==(\n    match_results<BidirIt, Alloc>& lhs,\n    match_results<BidirIt, Alloc>& rhs);",
            "other_declarations": 1
        },
        {
            "title": "std::match_results<BidirIt,Alloc>::operator=",
            "path": "en.cppreference.com/w/cpp/regex/match_results/operator=.html",
            "wgPageName": "cpp/regex/match_results/operator=",
            "headers": [
                "<regex>"
            ],
            "sample_declaration": "match_results& operator=(\n    const match_results& other);",
            "other_declarations": 1
        },
        {
            "title": "std::match_results<BidirIt,Alloc>::position",
            "path": "en.cppreference.com/w/cpp/regex/match_results/position.html",
            "wgPageName": "cpp/regex/match_results/position",
            "sample_declaration": "difference_type position(size_type n = 0) const;"
        },
        {
            "title": "std::match_results<BidirIt,Alloc>::prefix",
            "path": "en.cppreference.com/w/cpp/regex/match_results/prefix.html",
            "wgPageName": "cpp/regex/match_results/prefix",
            "sample_declaration": "const_reference prefix() const;"
        },
        {
            "title": "std::match_results<BidirIt,Alloc>::ready",
            "path": "en.cppreference.com/w/cpp/regex/match_results/ready.html",
            "wgPageName": "cpp/regex/match_results/ready",
            "sample_declaration": "bool ready() const;"
        },
        {
            "title": "std::match_results<BidirIt,Alloc>::size",
            "path": "en.cppreference.com/w/cpp/regex/match_results/size.html",
            "wgPageName": "cpp/regex/match_results/size",
            "sample_declaration": "size_type size() const noexcept;"
        },
        {
            "title": "std::match_results<BidirIt,Alloc>::str",
            "path": "en.cppreference.com/w/cpp/regex/match_results/str.html",
            "wgPageName": "cpp/regex/match_results/str",
            "sample_declaration": "string_type str(size_type n = 0) const;"
        },
        {
            "title": "std::match_results<BidirIt,Alloc>::suffix",
            "path": "en.cppreference.com/w/cpp/regex/match_results/suffix.html",
            "wgPageName": "cpp/regex/match_results/suffix",
            "sample_declaration": "const_reference suffix() const;"
        },
        {
            "title": "std::match_results<BidirIt,Alloc>::swap",
            "path": "en.cppreference.com/w/cpp/regex/match_results/swap.html",
            "wgPageName": "cpp/regex/match_results/swap",
            "sample_declaration": "void swap(match_results& other) noexcept;"
        },
        {
            "title": "std::swap(std::match_results)",
            "path": "en.cppreference.com/w/cpp/regex/match_results/swap2.html",
            "wgPageName": "cpp/regex/match_results/swap2",
            "headers": [
                "<regex>"
            ],
            "sample_declaration": "template<class BidirIt, class Alloc>\nvoid swap(\n    match_results<BidirIt, Alloc>& x1,\n    match_results<BidirIt, Alloc>& x2) noexcept;"
        },
        {
            "title": "std::regex_error",
            "path": "en.cppreference.com/w/cpp/regex/regex_error.html",
            "wgPageName": "cpp/regex/regex_error",
            "headers": [
                "<regex>"
            ],
            "sample_declaration": "class regex_error;"
        },
        {
            "title": "std::regex_error::code",
            "path": "en.cppreference.com/w/cpp/regex/regex_error/code.html",
            "wgPageName": "cpp/regex/regex_error/code",
            "headers": [
                "<regex>"
            ],
            "sample_declaration": "std::regex_constants::error_type code() const;"
        },
        {
            "title": "std::regex_error::operator=",
            "path": "en.cppreference.com/w/cpp/regex/regex_error/operator=.html",
            "wgPageName": "cpp/regex/regex_error/operator=",
            "sample_declaration": "regex_error& operator=(\n    const regex_error& other) noexcept;"
        },
        {
            "title": "std::regex_error::regex_error",
            "path": "en.cppreference.com/w/cpp/regex/regex_error/regex_error.html",
            "wgPageName": "cpp/regex/regex_error/regex_error",
            "headers": [
                "<regex>"
            ],
            "sample_declaration": "regex_error(\n    std::regex_constants::error_type ecode);",
            "other_declarations": 1
        },
        {
            "title": "std::regex_iterator",
            "path": "en.cppreference.com/w/cpp/regex/regex_iterator.html",
            "wgPageName": "cpp/regex/regex_iterator",
            "headers": [
                "<regex>"
            ],
            "sample_declaration": "template<\n    class BidirIt,\n    class CharT = typename std::iterator_traits<\n        BidirIt>::value_type,\n    class Traits = std::regex_traits<CharT> >\nclass regex_iterator"
        },
        {
            "title": "std::regex_iterator<BidirIt,CharT,Traits>::operator++, operator++(int)",
            "path": "en.cppreference.com/w/cpp/regex/regex_iterator/operator_arith.html",
            "wgPageName": "cpp/regex/regex_iterator/operator_arith",
            "sample_declaration": "regex_iterator& operator++();",
            "other_declarations": 1
        },
        {
            "title": "std::regex_iterator<BidirIt,CharT,Traits>::operator==,operator!=",
            "path": "en.cppreference.com/w/cpp/regex/regex_iterator/operator_cmp.html",
            "wgPageName": "cpp/regex/regex_iterator/operator_cmp",
            "sample_declaration": "bool operator==(\n    const regex_iterator& rhs) const;",
            "other_declarations": 1
        },
        {
            "title": "std::regex_iterator<BidirIt,CharT,Traits>::operator*,operator->",
            "path": "en.cppreference.com/w/cpp/regex/regex_iterator/operator*.html",
            "wgPageName": "cpp/regex/regex_iterator/operator*",
            "sample_declaration": "const value_type& operator*() const;",
            "other_declarations": 1
        },
        {
            "title": "std::regex_iterator<BidirIt,CharT,Traits>::operator=",
            "path": "en.cppreference.com/w/cpp/regex/regex_iterator/operator=.html",
            "wgPageName": "cpp/regex/regex_iterator/operator=",
            "sample_declaration": "regex_iterator& operator=(\n    const regex_iterator& other);"
        },
        {
            "title": "std::regex_iterator<BidirIt,CharT,Traits>::regex_iterator",
            "path": "en.cppreference.com/w/cpp/regex/regex_iterator/regex_iterator.html",
            "wgPageName": "cpp/regex/regex_iterator/regex_iterator",
            "sample_declaration": "regex_iterator();",
            "other_declarations": 3
        },
        {
            "title": "std::regex_match",
            "path": "en.cppreference.com/w/cpp/regex/regex_match.html",
            "wgPageName": "cpp/regex/regex_match",
            "headers": [
                "<regex>"
            ],
            "sample_declaration": "template<\n    class BidirIt,\n    class Alloc,\n    class CharT,\n    class Traits>\nbool regex_match(\n    BidirIt first,\n    BidirIt last,\n    std::match_results<BidirIt, Alloc>& m,\n    const std::basic_regex<CharT, Traits>& e,\n    std::regex_constants::match_flag_type\n        flags = std::regex_constants::\n            match_default);",
            "other_declarations": 6
        },
        {
            "title": "std::regex_replace",
            "path": "en.cppreference.com/w/cpp/regex/regex_replace.html",
            "wgPageName": "cpp/regex/regex_replace",
            "headers": [
                "<regex>"
            ],
            "sample_declaration": "template<\n    class OutputIt,\n    class BidirIt,\n    class Traits,\n    class CharT,\n    class STraits,\n    class SAlloc>\nOutputIt regex_replace(\n    OutputIt out,\n    BidirIt first,\n    BidirIt last,\n    const std::basic_regex<CharT, Traits>& re,\n    const std::\n        basic_string<CharT, STraits, SAlloc>&\n            fmt,\n    std::regex_constants::match_flag_type\n        flags = std::regex_constants::\n            match_default);",
            "other_declarations": 5
        },
        {
            "title": "std::regex_search",
            "path": "en.cppreference.com/w/cpp/regex/regex_search.html",
            "wgPageName": "cpp/regex/regex_search",
            "headers": [
                "<regex>"
            ],
            "sample_declaration": "template<\n    class BidirIt,\n    class Alloc,\n    class CharT,\n    class Traits>\nbool regex_search(\n    BidirIt first,\n    BidirIt last,\n    std::match_results<BidirIt, Alloc>& m,\n    const std::basic_regex<CharT, Traits>& e,\n    std::regex_constants::match_flag_type\n        flags = std::regex_constants::\n            match_default);",
            "other_declarations": 6
        },
        {
            "title": "std::regex_token_iterator",
            "path": "en.cppreference.com/w/cpp/regex/regex_token_iterator.html",
            "wgPageName": "cpp/regex/regex_token_iterator",
            "headers": [
                "<regex>"
            ],
            "sample_declaration": "template<\n    class BidirIt,\n    class CharT = typename std::iterator_traits<\n        BidirIt>::value_type,\n    class Traits = std::regex_traits<CharT> >\nclass regex_token_iterator"
        },
        {
            "title": "std::regex_token_iterator<BidirIt,CharT,Traits>::operator++, operator++(int)",
            "path": "en.cppreference.com/w/cpp/regex/regex_token_iterator/operator_arith.html",
            "wgPageName": "cpp/regex/regex_token_iterator/operator_arith",
            "sample_declaration": "regex_token_iterator& operator++();",
            "other_declarations": 1
        },
        {
            "title": "std::regex_token_iterator<BidirIt,CharT,Traits>::operator==, operator!=",
            "path": "en.cppreference.com/w/cpp/regex/regex_token_iterator/operator_cmp.html",
            "wgPageName": "cpp/regex/regex_token_iterator/operator_cmp",
            "sample_declaration": "bool operator==(\n    const regex_token_iterator& other) const;",
            "other_declarations": 1
        },
        {
            "title": "std::regex_token_iterator<BidirIt,CharT,Traits>::operator*, operator->",
            "path": "en.cppreference.com/w/cpp/regex/regex_token_iterator/operator*.html",
            "wgPageName": "cpp/regex/regex_token_iterator/operator*",
            "sample_declaration": "const value_type& operator*() const;",
            "other_declarations": 1
        },
        {
            "title": "std::regex_token_iterator<BidirIt,CharT,Traits>::operator=",
            "path": "en.cppreference.com/w/cpp/regex/regex_token_iterator/operator=.html",
            "wgPageName": "cpp/regex/regex_token_iterator/operator=",
            "sample_declaration": "regex_token_iterator& operator=(\n    const regex_token_iterator& other);"
        },
        {
            "title": "std::regex_token_iterator<BidirIt,CharT,Traits>::regex_token_iterator",
            "path": "en.cppreference.com/w/cpp/regex/regex_token_iterator/regex_token_iterator.html",
            "wgPageName": "cpp/regex/regex_token_iterator/regex_token_iterator",
            "sample_declaration": "regex_token_iterator();",
            "other_declarations": 9
        },
        {
            "title": "std::regex_traits",
            "path": "en.cppreference.com/w/cpp/regex/regex_traits.html",
            "wgPageName": "cpp/regex/regex_traits",
            "headers": [
                "<regex>"
            ],
            "sample_declaration": "template<class CharT>\nclass regex_traits;"
        },
        {
            "title": "std::regex_traits<CharT>::getloc",
            "path": "en.cppreference.com/w/cpp/regex/regex_traits/getloc.html",
            "wgPageName": "cpp/regex/regex_traits/getloc",
            "sample_declaration": "locale_type getloc() const;"
        },
        {
            "title": "std::regex_traits<CharT>::imbue",
            "path": "en.cppreference.com/w/cpp/regex/regex_traits/imbue.html",
            "wgPageName": "cpp/regex/regex_traits/imbue",
            "sample_declaration": "locale_type imbue(locale_type loc);"
        },
        {
            "title": "std::regex_traits<CharT>::isctype",
            "path": "en.cppreference.com/w/cpp/regex/regex_traits/isctype.html",
            "wgPageName": "cpp/regex/regex_traits/isctype",
            "sample_declaration": "bool isctype(CharT c, char_class_type f) const;"
        },
        {
            "title": "std::regex_traits<CharT>::length",
            "path": "en.cppreference.com/w/cpp/regex/regex_traits/length.html",
            "wgPageName": "cpp/regex/regex_traits/length",
            "sample_declaration": "static std::size_t length(const char_type* p);"
        },
        {
            "title": "std::regex_traits<CharT>::lookup_classname",
            "path": "en.cppreference.com/w/cpp/regex/regex_traits/lookup_classname.html",
            "wgPageName": "cpp/regex/regex_traits/lookup_classname",
            "sample_declaration": "template<class ForwardIt>\nchar_class_type lookup_classname(\n    ForwardIt first,\n    ForwardIt last,\n    bool icase = false) const;"
        },
        {
            "title": "std::regex_traits<CharT>::lookup_collatename",
            "path": "en.cppreference.com/w/cpp/regex/regex_traits/lookup_collatename.html",
            "wgPageName": "cpp/regex/regex_traits/lookup_collatename",
            "sample_declaration": "template<class ForwardIt>\nstring_type lookup_collatename(\n    ForwardIt first,\n    ForwardIt last) const;"
        },
        {
            "title": "std::regex_traits<CharT>::regex_traits",
            "path": "en.cppreference.com/w/cpp/regex/regex_traits/regex_traits.html",
            "wgPageName": "cpp/regex/regex_traits/regex_traits",
            "sample_declaration": "regex_traits();"
        },
        {
            "title": "std::regex_traits<CharT>::transform_primary",
            "path": "en.cppreference.com/w/cpp/regex/regex_traits/transform_primary.html",
            "wgPageName": "cpp/regex/regex_traits/transform_primary",
            "sample_declaration": "template<class ForwardIt>\nstring_type transform_primary(\n    ForwardIt first,\n    ForwardIt last) const;"
        },
        {
            "title": "std::regex_traits<CharT>::transform",
            "path": "en.cppreference.com/w/cpp/regex/regex_traits/transform.html",
            "wgPageName": "cpp/regex/regex_traits/transform",
            "sample_declaration": "template<class ForwardIt>\nstring_type transform(\n    ForwardIt first,\n    ForwardIt last) const;"
        },
        {
            "title": "std::regex_traits<CharT>::translate_nocase",
            "path": "en.cppreference.com/w/cpp/regex/regex_traits/translate_nocase.html",
            "wgPageName": "cpp/regex/regex_traits/translate_nocase",
            "sample_declaration": "CharT translate_nocase(CharT c) const;"
        },
        {
            "title": "std::regex_traits<CharT>::translate",
            "path": "en.cppreference.com/w/cpp/regex/regex_traits/translate.html",
            "wgPageName": "cpp/regex/regex_traits/translate",
            "sample_declaration": "CharT translate(CharT c) const;"
        },
        {
            "title": "std::regex_traits<CharT>::value",
            "path": "en.cppreference.com/w/cpp/regex/regex_traits/value.html",
            "wgPageName": "cpp/regex/regex_traits/value",
            "sample_declaration": "int value(CharT ch, int radix) const;"
        },
        {
            "title": "std::sub_match",
            "path": "en.cppreference.com/w/cpp/regex/sub_match.html",
            "wgPageName": "cpp/regex/sub_match",
            "headers": [
                "<regex>"
            ],
            "sample_declaration": "template<class BidirIt>\nclass sub_match;"
        },
        {
            "title": "std::sub_match<BidirIt>::compare",
            "path": "en.cppreference.com/w/cpp/regex/sub_match/compare.html",
            "wgPageName": "cpp/regex/sub_match/compare",
            "sample_declaration": "int compare(const sub_match& m) const;",
            "other_declarations": 2
        },
        {
            "title": "std::sub_match<BidirIt>::length",
            "path": "en.cppreference.com/w/cpp/regex/sub_match/length.html",
            "wgPageName": "cpp/regex/sub_match/length",
            "sample_declaration": "difference_type length() const;"
        },
        {
            "title": "operator==,!=,<,<=,>,>=,<=>(std::sub_match)",
            "path": "en.cppreference.com/w/cpp/regex/sub_match/operator_cmp.html",
            "wgPageName": "cpp/regex/sub_match/operator_cmp",
            "headers": [
                "<regex>"
            ],
            "sample_declaration": "template<class BidirIt>\nbool operator==(\n    const std::sub_match<BidirIt>& lhs,\n    const std::sub_match<BidirIt>& rhs);",
            "other_declarations": 45
        },
        {
            "title": "operator<<(std::sub_match)",
            "path": "en.cppreference.com/w/cpp/regex/sub_match/operator_ltlt.html",
            "wgPageName": "cpp/regex/sub_match/operator_ltlt",
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class BidirIt>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const sub_match<BidirIt>& m);"
        },
        {
            "title": "std::sub_match<BidirIt>::operator string_type, std::sub_match<BidirIt>::str",
            "path": "en.cppreference.com/w/cpp/regex/sub_match/str.html",
            "wgPageName": "cpp/regex/sub_match/str",
            "sample_declaration": "operator string_type() const;",
            "other_declarations": 1
        },
        {
            "title": "std::sub_match<BidirIt>::sub_match",
            "path": "en.cppreference.com/w/cpp/regex/sub_match/sub_match.html",
            "wgPageName": "cpp/regex/sub_match/sub_match",
            "sample_declaration": "constexpr sub_match();"
        },
        {
            "title": "std::regex_constants::syntax_option_type",
            "path": "en.cppreference.com/w/cpp/regex/syntax_option_type.html",
            "wgPageName": "cpp/regex/syntax_option_type",
            "headers": [
                "<regex>"
            ],
            "sample_declaration": "typedef /*unspecified*/ syntax_option_type;",
            "other_declarations": 2
        },
        {
            "title": "C++ Standard Library",
            "path": "en.cppreference.com/w/cpp/standard_library.html",
            "wgPageName": "cpp/standard_library"
        },
        {
            "title": "Strings library",
            "path": "en.cppreference.com/w/cpp/string.html",
            "wgPageName": "cpp/string",
            "headers": [
                "<string>"
            ],
            "sample_declaration": "template<>\nclass char_traits<char>;",
            "other_declarations": 4
        },
        {
            "title": "std::basic_string_view",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view.html",
            "wgPageName": "cpp/string/basic_string_view",
            "headers": [
                "<string_view>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT> >\nclass basic_string_view;"
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::at",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/at.html",
            "wgPageName": "cpp/string/basic_string_view/at",
            "sample_declaration": "constexpr const_reference at(\n    size_type pos) const;"
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::back",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/back.html",
            "wgPageName": "cpp/string/basic_string_view/back",
            "sample_declaration": "constexpr const_reference back() const;"
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::basic_string_view",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/basic_string_view.html",
            "wgPageName": "cpp/string/basic_string_view/basic_string_view",
            "sample_declaration": "constexpr basic_string_view() noexcept;",
            "other_declarations": 6
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::begin, std::basic_string_view<CharT,Traits>::cbegin",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/begin.html",
            "wgPageName": "cpp/string/basic_string_view/begin",
            "sample_declaration": "constexpr const_iterator begin() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::compare",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/compare.html",
            "wgPageName": "cpp/string/basic_string_view/compare",
            "sample_declaration": "constexpr int compare(\n    basic_string_view v) const noexcept;",
            "other_declarations": 5
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::contains",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/contains.html",
            "wgPageName": "cpp/string/basic_string_view/contains",
            "sample_declaration": "constexpr bool contains(\n    basic_string_view sv) const noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::copy",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/copy.html",
            "wgPageName": "cpp/string/basic_string_view/copy",
            "sample_declaration": "size_type copy(\n    CharT* dest,\n    size_type count,\n    size_type pos = 0) const;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::data",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/data.html",
            "wgPageName": "cpp/string/basic_string_view/data",
            "sample_declaration": "constexpr const_pointer data() const noexcept;"
        },
        {
            "title": "deduction guides for std::basic_string_view",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/deduction_guides.html",
            "wgPageName": "cpp/string/basic_string_view/deduction_guides",
            "headers": [
                "<string_view>"
            ],
            "sample_declaration": "template<class It, class End>\nbasic_string_view(It, End)\n    -> basic_string_view<std::iter_value_t<It>>;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::empty",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/empty.html",
            "wgPageName": "cpp/string/basic_string_view/empty",
            "sample_declaration": "constexpr bool empty() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::end, std::basic_string_view<CharT,Traits>::cend",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/end.html",
            "wgPageName": "cpp/string/basic_string_view/end",
            "sample_declaration": "constexpr const_iterator end() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::ends_with",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/ends_with.html",
            "wgPageName": "cpp/string/basic_string_view/ends_with",
            "sample_declaration": "constexpr bool ends_with(\n    basic_string_view sv) const noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::find_first_not_of",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/find_first_not_of.html",
            "wgPageName": "cpp/string/basic_string_view/find_first_not_of",
            "sample_declaration": "constexpr size_type find_first_not_of(\n    basic_string_view v,\n    size_type pos = 0) const noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::find_first_of",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/find_first_of.html",
            "wgPageName": "cpp/string/basic_string_view/find_first_of",
            "sample_declaration": "constexpr size_type find_first_of(\n    basic_string_view v,\n    size_type pos = 0) const noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::find_last_not_of",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/find_last_not_of.html",
            "wgPageName": "cpp/string/basic_string_view/find_last_not_of",
            "sample_declaration": "constexpr size_type find_last_not_of(\n    basic_string_view v,\n    size_type pos = npos) const noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::find_last_of",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/find_last_of.html",
            "wgPageName": "cpp/string/basic_string_view/find_last_of",
            "sample_declaration": "constexpr size_type find_last_of(\n    basic_string_view v,\n    size_type pos = npos) const noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::find",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/find.html",
            "wgPageName": "cpp/string/basic_string_view/find",
            "sample_declaration": "constexpr size_type find(\n    basic_string_view v,\n    size_type pos = 0) const noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::front",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/front.html",
            "wgPageName": "cpp/string/basic_string_view/front",
            "sample_declaration": "constexpr const_reference front() const;"
        },
        {
            "title": "std::hash (std::string_view, std::wstring_view, std::u16string_view, std::u32string_view)",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/hash.html",
            "wgPageName": "cpp/string/basic_string_view/hash",
            "headers": [
                "<string_view>"
            ],
            "sample_declaration": "template<>\nstruct hash<std::string_view>;",
            "other_declarations": 4
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::max_size",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/max_size.html",
            "wgPageName": "cpp/string/basic_string_view/max_size",
            "sample_declaration": "constexpr size_type max_size() const noexcept;"
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::npos",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/npos.html",
            "wgPageName": "cpp/string/basic_string_view/npos",
            "sample_declaration": "static constexpr size_type npos = size_type(-1);"
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::operator[]",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/operator_at.html",
            "wgPageName": "cpp/string/basic_string_view/operator_at",
            "sample_declaration": "constexpr const_reference operator[](\n    size_type pos) const;"
        },
        {
            "title": "operator==,!=,<,<=,>,>=,<=>(std::basic_string_view)",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/operator_cmp.html",
            "wgPageName": "cpp/string/basic_string_view/operator_cmp",
            "headers": [
                "<string_view>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nconstexpr bool operator==(\n    std::basic_string_view<CharT, Traits> lhs,\n    std::basic_string_view<CharT, Traits>\n        rhs) noexcept;",
            "other_declarations": 6
        },
        {
            "title": "operator<<(std::basic_string_view)",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/operator_ltlt.html",
            "wgPageName": "cpp/string/basic_string_view/operator_ltlt",
            "headers": [
                "<string_view>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    std::basic_string_view<CharT, Traits> v);"
        },
        {
            "title": "std::literals::string_view_literals::operator\"\"sv",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/operator\"\"sv.html",
            "wgPageName": "cpp/string/basic_string_view/operator\\\"\\\"sv",
            "headers": [
                "<string_view>"
            ],
            "sample_declaration": "constexpr std::string_view operator\"\" sv(\n    const char* str,\n    std::size_t len) noexcept;",
            "other_declarations": 4
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::operator=",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/operator=.html",
            "wgPageName": "cpp/string/basic_string_view/operator=",
            "sample_declaration": "constexpr basic_string_view& operator=(\n    const basic_string_view& view) noexcept =\n    default;"
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::rbegin, std::basic_string_view<CharT,Traits>::crbegin",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/rbegin.html",
            "wgPageName": "cpp/string/basic_string_view/rbegin",
            "sample_declaration": "constexpr const_reverse_iterator rbegin()\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::remove_prefix",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/remove_prefix.html",
            "wgPageName": "cpp/string/basic_string_view/remove_prefix",
            "sample_declaration": "constexpr void remove_prefix(size_type n);"
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::remove_suffix",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/remove_suffix.html",
            "wgPageName": "cpp/string/basic_string_view/remove_suffix",
            "sample_declaration": "constexpr void remove_suffix(size_type n);"
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::rend, std::basic_string_view<CharT,Traits>::crend",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/rend.html",
            "wgPageName": "cpp/string/basic_string_view/rend",
            "sample_declaration": "constexpr const_reverse_iterator rend()\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::rfind",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/rfind.html",
            "wgPageName": "cpp/string/basic_string_view/rfind",
            "sample_declaration": "constexpr size_type rfind(\n    basic_string_view v,\n    size_type pos = npos) const noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::size, std::basic_string_view<CharT,Traits>::length",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/size.html",
            "wgPageName": "cpp/string/basic_string_view/size",
            "sample_declaration": "constexpr size_type size() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::starts_with",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/starts_with.html",
            "wgPageName": "cpp/string/basic_string_view/starts_with",
            "sample_declaration": "constexpr bool starts_with(\n    basic_string_view sv) const noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::substr",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/substr.html",
            "wgPageName": "cpp/string/basic_string_view/substr",
            "sample_declaration": "constexpr basic_string_view substr(\n    size_type pos = 0,\n    size_type count = npos) const;"
        },
        {
            "title": "std::basic_string_view<CharT,Traits>::swap",
            "path": "en.cppreference.com/w/cpp/string/basic_string_view/swap.html",
            "wgPageName": "cpp/string/basic_string_view/swap",
            "sample_declaration": "constexpr void swap(\n    basic_string_view& v) noexcept;"
        },
        {
            "title": "std::basic_string",
            "path": "en.cppreference.com/w/cpp/string/basic_string.html",
            "wgPageName": "cpp/string/basic_string",
            "headers": [
                "<string>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits = std::char_traits<CharT>,\n    class Allocator = std::allocator<CharT> >\nclass basic_string;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::append",
            "path": "en.cppreference.com/w/cpp/string/basic_string/append.html",
            "wgPageName": "cpp/string/basic_string/append",
            "sample_declaration": "basic_string& append(size_type count, CharT ch);",
            "other_declarations": 18
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::assign",
            "path": "en.cppreference.com/w/cpp/string/basic_string/assign.html",
            "wgPageName": "cpp/string/basic_string/assign",
            "sample_declaration": "basic_string& assign(size_type count, CharT ch);",
            "other_declarations": 21
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::at",
            "path": "en.cppreference.com/w/cpp/string/basic_string/at.html",
            "wgPageName": "cpp/string/basic_string/at",
            "sample_declaration": "reference at(size_type pos);",
            "other_declarations": 3
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::back",
            "path": "en.cppreference.com/w/cpp/string/basic_string/back.html",
            "wgPageName": "cpp/string/basic_string/back",
            "sample_declaration": "CharT& back();",
            "other_declarations": 3
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::basic_string",
            "path": "en.cppreference.com/w/cpp/string/basic_string/basic_string.html",
            "wgPageName": "cpp/string/basic_string/basic_string",
            "sample_declaration": "basic_string();\nexplicit basic_string(const Allocator& alloc);",
            "other_declarations": 29
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::begin, std::basic_string<CharT,Traits,Allocator>::cbegin",
            "path": "en.cppreference.com/w/cpp/string/basic_string/begin.html",
            "wgPageName": "cpp/string/basic_string/begin",
            "sample_declaration": "iterator begin();",
            "other_declarations": 7
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::c_str",
            "path": "en.cppreference.com/w/cpp/string/basic_string/c_str.html",
            "wgPageName": "cpp/string/basic_string/c_str",
            "sample_declaration": "const CharT* c_str() const;",
            "other_declarations": 2
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::capacity",
            "path": "en.cppreference.com/w/cpp/string/basic_string/capacity.html",
            "wgPageName": "cpp/string/basic_string/capacity",
            "sample_declaration": "size_type capacity() const;",
            "other_declarations": 2
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::clear",
            "path": "en.cppreference.com/w/cpp/string/basic_string/clear.html",
            "wgPageName": "cpp/string/basic_string/clear",
            "sample_declaration": "void clear();",
            "other_declarations": 2
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::compare",
            "path": "en.cppreference.com/w/cpp/string/basic_string/compare.html",
            "wgPageName": "cpp/string/basic_string/compare",
            "sample_declaration": "int compare(const basic_string& str) const;",
            "other_declarations": 19
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::contains",
            "path": "en.cppreference.com/w/cpp/string/basic_string/contains.html",
            "wgPageName": "cpp/string/basic_string/contains",
            "sample_declaration": "constexpr bool contains(\n    std::basic_string_view<CharT, Traits> sv)\n    const noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::copy",
            "path": "en.cppreference.com/w/cpp/string/basic_string/copy.html",
            "wgPageName": "cpp/string/basic_string/copy",
            "sample_declaration": "size_type copy(\n    CharT* dest,\n    size_type count,\n    size_type pos = 0) const;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::data",
            "path": "en.cppreference.com/w/cpp/string/basic_string/data.html",
            "wgPageName": "cpp/string/basic_string/data",
            "sample_declaration": "const CharT* data() const;",
            "other_declarations": 4
        },
        {
            "title": "deduction guides for std::basic_string",
            "path": "en.cppreference.com/w/cpp/string/basic_string/deduction_guides.html",
            "wgPageName": "cpp/string/basic_string/deduction_guides",
            "headers": [
                "<string>"
            ],
            "sample_declaration": "template<\n    class InputIt,\n    class Alloc = std::allocator<\n        typename std::iterator_traits<\n            InputIt>::value_type> >\nbasic_string(InputIt, InputIt, Alloc = Alloc())\n    -> basic_string<\n        typename std::iterator_traits<\n            InputIt>::value_type,\n        std::char_traits<\n            typename std::iterator_traits<\n                InputIt>::value_type>,\n        Alloc>;",
            "other_declarations": 2
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::empty",
            "path": "en.cppreference.com/w/cpp/string/basic_string/empty.html",
            "wgPageName": "cpp/string/basic_string/empty",
            "sample_declaration": "bool empty() const;",
            "other_declarations": 2
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::end, std::basic_string<CharT,Traits,Allocator>::cend",
            "path": "en.cppreference.com/w/cpp/string/basic_string/end.html",
            "wgPageName": "cpp/string/basic_string/end",
            "sample_declaration": "iterator end();",
            "other_declarations": 7
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::ends_with",
            "path": "en.cppreference.com/w/cpp/string/basic_string/ends_with.html",
            "wgPageName": "cpp/string/basic_string/ends_with",
            "sample_declaration": "constexpr bool ends_with(\n    std::basic_string_view<CharT, Traits> sv)\n    const noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::erase",
            "path": "en.cppreference.com/w/cpp/string/basic_string/erase.html",
            "wgPageName": "cpp/string/basic_string/erase",
            "sample_declaration": "basic_string& erase(\n    size_type index = 0,\n    size_type count = npos);",
            "other_declarations": 7
        },
        {
            "title": "std::erase, std::erase_if (std::basic_string)",
            "path": "en.cppreference.com/w/cpp/string/basic_string/erase2.html",
            "wgPageName": "cpp/string/basic_string/erase2",
            "headers": [
                "<string>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Alloc,\n    class U>\nconstexpr typename std::basic_string<\n    CharT,\n    Traits,\n    Alloc>::size_type\nerase(\n    std::basic_string<CharT, Traits, Alloc>& c,\n    const U& value);",
            "other_declarations": 1
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::find_first_not_of",
            "path": "en.cppreference.com/w/cpp/string/basic_string/find_first_not_of.html",
            "wgPageName": "cpp/string/basic_string/find_first_not_of",
            "sample_declaration": "size_type find_first_not_of(\n    const basic_string& str,\n    size_type pos = 0) const;",
            "other_declarations": 11
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::find_first_of",
            "path": "en.cppreference.com/w/cpp/string/basic_string/find_first_of.html",
            "wgPageName": "cpp/string/basic_string/find_first_of",
            "sample_declaration": "size_type find_first_of(\n    const basic_string& str,\n    size_type pos = 0) const;",
            "other_declarations": 11
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::find_last_not_of",
            "path": "en.cppreference.com/w/cpp/string/basic_string/find_last_not_of.html",
            "wgPageName": "cpp/string/basic_string/find_last_not_of",
            "sample_declaration": "size_type find_last_not_of(\n    const basic_string& str,\n    size_type pos = npos) const;",
            "other_declarations": 11
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::find_last_of",
            "path": "en.cppreference.com/w/cpp/string/basic_string/find_last_of.html",
            "wgPageName": "cpp/string/basic_string/find_last_of",
            "sample_declaration": "size_type find_last_of(\n    const basic_string& str,\n    size_type pos = npos) const;",
            "other_declarations": 10
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::find",
            "path": "en.cppreference.com/w/cpp/string/basic_string/find.html",
            "wgPageName": "cpp/string/basic_string/find",
            "sample_declaration": "size_type find(\n    const basic_string& str,\n    size_type pos = 0) const;",
            "other_declarations": 11
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::front",
            "path": "en.cppreference.com/w/cpp/string/basic_string/front.html",
            "wgPageName": "cpp/string/basic_string/front",
            "sample_declaration": "CharT& front();",
            "other_declarations": 3
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::get_allocator",
            "path": "en.cppreference.com/w/cpp/string/basic_string/get_allocator.html",
            "wgPageName": "cpp/string/basic_string/get_allocator",
            "sample_declaration": "allocator_type get_allocator() const;",
            "other_declarations": 1
        },
        {
            "title": "std::getline",
            "path": "en.cppreference.com/w/cpp/string/basic_string/getline.html",
            "wgPageName": "cpp/string/basic_string/getline",
            "headers": [
                "<string>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Allocator>\nstd::basic_istream<CharT, Traits>& getline(\n    std::basic_istream<CharT, Traits>& input,\n    std::basic_string<CharT, Traits, Allocator>&\n        str,\n    CharT delim);",
            "other_declarations": 3
        },
        {
            "title": "std::hash (std::string, std::wstring, std::u16string, std::u32string, std::u8string, std::pmr::string, std::pmr::wstring, std::pmr::u16string, std::pmr::u32string, std::pmr::u8string)",
            "path": "en.cppreference.com/w/cpp/string/basic_string/hash.html",
            "wgPageName": "cpp/string/basic_string/hash",
            "headers": [
                "<string>"
            ],
            "sample_declaration": "template<>\nstruct hash<std::string>;\ntemplate<>\nstruct hash<std::wstring>;\ntemplate<>\nstruct hash<std::u16string>;\ntemplate<>\nstruct hash<std::u32string>;",
            "other_declarations": 2
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::insert",
            "path": "en.cppreference.com/w/cpp/string/basic_string/insert.html",
            "wgPageName": "cpp/string/basic_string/insert",
            "sample_declaration": "basic_string& insert(\n    size_type index,\n    size_type count,\n    CharT ch);",
            "other_declarations": 25
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::max_size",
            "path": "en.cppreference.com/w/cpp/string/basic_string/max_size.html",
            "wgPageName": "cpp/string/basic_string/max_size",
            "sample_declaration": "size_type max_size() const;",
            "other_declarations": 2
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::npos",
            "path": "en.cppreference.com/w/cpp/string/basic_string/npos.html",
            "wgPageName": "cpp/string/basic_string/npos",
            "sample_declaration": "static const size_type npos = -1;"
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::operator[]",
            "path": "en.cppreference.com/w/cpp/string/basic_string/operator_at.html",
            "wgPageName": "cpp/string/basic_string/operator_at",
            "sample_declaration": "reference operator[](size_type pos);",
            "other_declarations": 3
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::operator basic_string_view",
            "path": "en.cppreference.com/w/cpp/string/basic_string/operator_basic_string_view.html",
            "wgPageName": "cpp/string/basic_string/operator_basic_string_view",
            "sample_declaration": "operator std::basic_string_view<CharT, Traits>()\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "operator==,!=,<,<=,>,>=,<=>(std::basic_string)",
            "path": "en.cppreference.com/w/cpp/string/basic_string/operator_cmp.html",
            "wgPageName": "cpp/string/basic_string/operator_cmp",
            "headers": [
                "<string>"
            ],
            "sample_declaration": "template<class CharT, class Traits, class Alloc>\nbool operator==(\n    const std::\n        basic_string<CharT, Traits, Alloc>& lhs,\n    const std::\n        basic_string<CharT, Traits, Alloc>&\n            rhs);",
            "other_declarations": 27
        },
        {
            "title": "operator<<,>>(std::basic_string)",
            "path": "en.cppreference.com/w/cpp/string/basic_string/operator_ltltgtgt.html",
            "wgPageName": "cpp/string/basic_string/operator_ltltgtgt",
            "headers": [
                "<string>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Allocator>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::\n        basic_string<CharT, Traits, Allocator>&\n            str);",
            "other_declarations": 1
        },
        {
            "title": "std::literals::string_literals::operator\"\"s",
            "path": "en.cppreference.com/w/cpp/string/basic_string/operator\"\"s.html",
            "wgPageName": "cpp/string/basic_string/operator\\\"\\\"s",
            "headers": [
                "<string>"
            ],
            "sample_declaration": "std::string operator\"\"s(\n    const char* str,\n    std::size_t len);",
            "other_declarations": 8
        },
        {
            "title": "std::operator+(std::basic_string)",
            "path": "en.cppreference.com/w/cpp/string/basic_string/operator+.html",
            "wgPageName": "cpp/string/basic_string/operator+",
            "headers": [
                "<string>"
            ],
            "sample_declaration": "template<class CharT, class Traits, class Alloc>\nstd::basic_string<CharT, Traits, Alloc>\noperator+(\n    const std::\n        basic_string<CharT, Traits, Alloc>& lhs,\n    const std::\n        basic_string<CharT, Traits, Alloc>&\n            rhs);",
            "other_declarations": 11
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::operator+=",
            "path": "en.cppreference.com/w/cpp/string/basic_string/operator+=.html",
            "wgPageName": "cpp/string/basic_string/operator+=",
            "sample_declaration": "basic_string& operator+=(\n    const basic_string& str);",
            "other_declarations": 9
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::operator=",
            "path": "en.cppreference.com/w/cpp/string/basic_string/operator=.html",
            "wgPageName": "cpp/string/basic_string/operator=",
            "sample_declaration": "basic_string& operator=(\n    const basic_string& str);",
            "other_declarations": 13
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::pop_back",
            "path": "en.cppreference.com/w/cpp/string/basic_string/pop_back.html",
            "wgPageName": "cpp/string/basic_string/pop_back",
            "sample_declaration": "void pop_back();",
            "other_declarations": 1
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::push_back",
            "path": "en.cppreference.com/w/cpp/string/basic_string/push_back.html",
            "wgPageName": "cpp/string/basic_string/push_back",
            "sample_declaration": "void push_back(CharT ch);",
            "other_declarations": 1
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::rbegin, std::basic_string<CharT,Traits,Allocator>::crbegin",
            "path": "en.cppreference.com/w/cpp/string/basic_string/rbegin.html",
            "wgPageName": "cpp/string/basic_string/rbegin",
            "sample_declaration": "reverse_iterator rbegin();",
            "other_declarations": 7
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::rend, std::basic_string<CharT,Traits,Allocator>::crend",
            "path": "en.cppreference.com/w/cpp/string/basic_string/rend.html",
            "wgPageName": "cpp/string/basic_string/rend",
            "sample_declaration": "reverse_iterator rend();",
            "other_declarations": 7
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::replace",
            "path": "en.cppreference.com/w/cpp/string/basic_string/replace.html",
            "wgPageName": "cpp/string/basic_string/replace",
            "sample_declaration": "basic_string& replace(\n    size_type pos,\n    size_type count,\n    const basic_string& str);",
            "other_declarations": 28
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::reserve",
            "path": "en.cppreference.com/w/cpp/string/basic_string/reserve.html",
            "wgPageName": "cpp/string/basic_string/reserve",
            "sample_declaration": "void reserve(size_type new_cap = 0);",
            "other_declarations": 2
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::resize_and_overwrite",
            "path": "en.cppreference.com/w/cpp/string/basic_string/resize_and_overwrite.html",
            "wgPageName": "cpp/string/basic_string/resize_and_overwrite",
            "sample_declaration": "template<class Operation>\nconstexpr void resize_and_overwrite(\n    size_type count,\n    Operation op);"
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::resize",
            "path": "en.cppreference.com/w/cpp/string/basic_string/resize.html",
            "wgPageName": "cpp/string/basic_string/resize",
            "sample_declaration": "void resize(size_type count);",
            "other_declarations": 3
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::rfind",
            "path": "en.cppreference.com/w/cpp/string/basic_string/rfind.html",
            "wgPageName": "cpp/string/basic_string/rfind",
            "sample_declaration": "size_type rfind(\n    const basic_string& str,\n    size_type pos = npos) const;",
            "other_declarations": 11
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::shrink_to_fit",
            "path": "en.cppreference.com/w/cpp/string/basic_string/shrink_to_fit.html",
            "wgPageName": "cpp/string/basic_string/shrink_to_fit",
            "sample_declaration": "void shrink_to_fit();",
            "other_declarations": 1
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::size, std::basic_string<CharT,Traits,Allocator>::length",
            "path": "en.cppreference.com/w/cpp/string/basic_string/size.html",
            "wgPageName": "cpp/string/basic_string/size",
            "sample_declaration": "size_type size() const;",
            "other_declarations": 5
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::starts_with",
            "path": "en.cppreference.com/w/cpp/string/basic_string/starts_with.html",
            "wgPageName": "cpp/string/basic_string/starts_with",
            "sample_declaration": "constexpr bool starts_with(\n    std::basic_string_view<CharT, Traits> sv)\n    const noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::stof, std::stod, std::stold",
            "path": "en.cppreference.com/w/cpp/string/basic_string/stof.html",
            "wgPageName": "cpp/string/basic_string/stof",
            "headers": [
                "<string>"
            ],
            "sample_declaration": "float stof(\n    const std::string& str,\n    std::size_t* pos = nullptr);\nfloat stof(\n    const std::wstring& str,\n    std::size_t* pos = nullptr);",
            "other_declarations": 2
        },
        {
            "title": "std::stoi, std::stol, std::stoll",
            "path": "en.cppreference.com/w/cpp/string/basic_string/stol.html",
            "wgPageName": "cpp/string/basic_string/stol",
            "headers": [
                "<string>"
            ],
            "sample_declaration": "int stoi(\n    const std::string& str,\n    std::size_t* pos = nullptr,\n    int base = 10);\nint stoi(\n    const std::wstring& str,\n    std::size_t* pos = nullptr,\n    int base = 10);",
            "other_declarations": 2
        },
        {
            "title": "std::stoul, std::stoull",
            "path": "en.cppreference.com/w/cpp/string/basic_string/stoul.html",
            "wgPageName": "cpp/string/basic_string/stoul",
            "headers": [
                "<string>"
            ],
            "sample_declaration": "unsigned long stoul(\n    const std::string& str,\n    std::size_t* pos = nullptr,\n    int base = 10);\nunsigned long stoul(\n    const std::wstring& str,\n    std::size_t* pos = nullptr,\n    int base = 10);",
            "other_declarations": 1
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::substr",
            "path": "en.cppreference.com/w/cpp/string/basic_string/substr.html",
            "wgPageName": "cpp/string/basic_string/substr",
            "sample_declaration": "basic_string substr(\n    size_type pos = 0,\n    size_type count = npos) const;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_string<CharT,Traits,Allocator>::swap",
            "path": "en.cppreference.com/w/cpp/string/basic_string/swap.html",
            "wgPageName": "cpp/string/basic_string/swap",
            "sample_declaration": "void swap(basic_string& other);",
            "other_declarations": 2
        },
        {
            "title": "std::swap(std::basic_string)",
            "path": "en.cppreference.com/w/cpp/string/basic_string/swap2.html",
            "wgPageName": "cpp/string/basic_string/swap2",
            "headers": [
                "<string>"
            ],
            "sample_declaration": "template<class CharT, class Traits, class Alloc>\nvoid swap(\n    std::basic_string<CharT, Traits, Alloc>&\n        lhs,\n    std::basic_string<CharT, Traits, Alloc>&\n        rhs);",
            "other_declarations": 2
        },
        {
            "title": "std::to_string",
            "path": "en.cppreference.com/w/cpp/string/basic_string/to_string.html",
            "wgPageName": "cpp/string/basic_string/to_string",
            "headers": [
                "<string>"
            ],
            "sample_declaration": "std::string to_string(int value);",
            "other_declarations": 8
        },
        {
            "title": "std::to_wstring",
            "path": "en.cppreference.com/w/cpp/string/basic_string/to_wstring.html",
            "wgPageName": "cpp/string/basic_string/to_wstring",
            "headers": [
                "<string>"
            ],
            "sample_declaration": "std::wstring to_wstring(int value);",
            "other_declarations": 8
        },
        {
            "title": "Null-terminated byte strings",
            "path": "en.cppreference.com/w/cpp/string/byte.html",
            "wgPageName": "cpp/string/byte"
        },
        {
            "title": "std::atof",
            "path": "en.cppreference.com/w/cpp/string/byte/atof.html",
            "wgPageName": "cpp/string/byte/atof",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "double atof(const char* str);"
        },
        {
            "title": "std::atoi, std::atol, std::atoll",
            "path": "en.cppreference.com/w/cpp/string/byte/atoi.html",
            "wgPageName": "cpp/string/byte/atoi",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "int atoi(const char* str);",
            "other_declarations": 2
        },
        {
            "title": "std::isalnum",
            "path": "en.cppreference.com/w/cpp/string/byte/isalnum.html",
            "wgPageName": "cpp/string/byte/isalnum",
            "headers": [
                "<cctype>"
            ],
            "sample_declaration": "int isalnum(int ch);"
        },
        {
            "title": "std::isalpha",
            "path": "en.cppreference.com/w/cpp/string/byte/isalpha.html",
            "wgPageName": "cpp/string/byte/isalpha",
            "headers": [
                "<cctype>"
            ],
            "sample_declaration": "int isalpha(int ch);"
        },
        {
            "title": "std::isblank",
            "path": "en.cppreference.com/w/cpp/string/byte/isblank.html",
            "wgPageName": "cpp/string/byte/isblank",
            "headers": [
                "<cctype>"
            ],
            "sample_declaration": "int isblank(int ch);"
        },
        {
            "title": "std::iscntrl",
            "path": "en.cppreference.com/w/cpp/string/byte/iscntrl.html",
            "wgPageName": "cpp/string/byte/iscntrl",
            "headers": [
                "<cctype>"
            ],
            "sample_declaration": "int iscntrl(int ch);"
        },
        {
            "title": "std::isdigit",
            "path": "en.cppreference.com/w/cpp/string/byte/isdigit.html",
            "wgPageName": "cpp/string/byte/isdigit",
            "headers": [
                "<cctype>"
            ],
            "sample_declaration": "int isdigit(int ch);"
        },
        {
            "title": "std::isgraph",
            "path": "en.cppreference.com/w/cpp/string/byte/isgraph.html",
            "wgPageName": "cpp/string/byte/isgraph",
            "headers": [
                "<cctype>"
            ],
            "sample_declaration": "int isgraph(int ch);"
        },
        {
            "title": "std::islower",
            "path": "en.cppreference.com/w/cpp/string/byte/islower.html",
            "wgPageName": "cpp/string/byte/islower",
            "headers": [
                "<cctype>"
            ],
            "sample_declaration": "int islower(int ch);"
        },
        {
            "title": "std::isprint",
            "path": "en.cppreference.com/w/cpp/string/byte/isprint.html",
            "wgPageName": "cpp/string/byte/isprint",
            "headers": [
                "<cctype>"
            ],
            "sample_declaration": "int isprint(int ch);"
        },
        {
            "title": "std::ispunct",
            "path": "en.cppreference.com/w/cpp/string/byte/ispunct.html",
            "wgPageName": "cpp/string/byte/ispunct",
            "headers": [
                "<cctype>"
            ],
            "sample_declaration": "int ispunct(int ch);"
        },
        {
            "title": "std::isspace",
            "path": "en.cppreference.com/w/cpp/string/byte/isspace.html",
            "wgPageName": "cpp/string/byte/isspace",
            "headers": [
                "<cctype>"
            ],
            "sample_declaration": "int isspace(int ch);"
        },
        {
            "title": "std::isupper",
            "path": "en.cppreference.com/w/cpp/string/byte/isupper.html",
            "wgPageName": "cpp/string/byte/isupper",
            "headers": [
                "<cctype>"
            ],
            "sample_declaration": "int isupper(int ch);"
        },
        {
            "title": "std::isxdigit",
            "path": "en.cppreference.com/w/cpp/string/byte/isxdigit.html",
            "wgPageName": "cpp/string/byte/isxdigit",
            "headers": [
                "<cctype>"
            ],
            "sample_declaration": "int isxdigit(int ch);"
        },
        {
            "title": "std::memchr",
            "path": "en.cppreference.com/w/cpp/string/byte/memchr.html",
            "wgPageName": "cpp/string/byte/memchr",
            "headers": [
                "<cstring>"
            ],
            "sample_declaration": "const void* memchr(\n    const void* ptr,\n    int ch,\n    std::size_t count);",
            "other_declarations": 1
        },
        {
            "title": "std::memcmp",
            "path": "en.cppreference.com/w/cpp/string/byte/memcmp.html",
            "wgPageName": "cpp/string/byte/memcmp",
            "headers": [
                "<cstring>"
            ],
            "sample_declaration": "int memcmp(\n    const void* lhs,\n    const void* rhs,\n    std::size_t count);"
        },
        {
            "title": "std::memcpy",
            "path": "en.cppreference.com/w/cpp/string/byte/memcpy.html",
            "wgPageName": "cpp/string/byte/memcpy",
            "headers": [
                "<cstring>"
            ],
            "sample_declaration": "void* memcpy(\n    void* dest,\n    const void* src,\n    std::size_t count);"
        },
        {
            "title": "std::memmove",
            "path": "en.cppreference.com/w/cpp/string/byte/memmove.html",
            "wgPageName": "cpp/string/byte/memmove",
            "headers": [
                "<cstring>"
            ],
            "sample_declaration": "void* memmove(\n    void* dest,\n    const void* src,\n    std::size_t count);"
        },
        {
            "title": "std::memset",
            "path": "en.cppreference.com/w/cpp/string/byte/memset.html",
            "wgPageName": "cpp/string/byte/memset",
            "headers": [
                "<cstring>"
            ],
            "sample_declaration": "void* memset(\n    void* dest,\n    int ch,\n    std::size_t count);"
        },
        {
            "title": "std::strcat",
            "path": "en.cppreference.com/w/cpp/string/byte/strcat.html",
            "wgPageName": "cpp/string/byte/strcat",
            "headers": [
                "<cstring>"
            ],
            "sample_declaration": "char* strcat(char* dest, const char* src);"
        },
        {
            "title": "std::strchr",
            "path": "en.cppreference.com/w/cpp/string/byte/strchr.html",
            "wgPageName": "cpp/string/byte/strchr",
            "headers": [
                "<cstring>"
            ],
            "sample_declaration": "const char* strchr(const char* str, int ch);",
            "other_declarations": 1
        },
        {
            "title": "std::strcmp",
            "path": "en.cppreference.com/w/cpp/string/byte/strcmp.html",
            "wgPageName": "cpp/string/byte/strcmp",
            "headers": [
                "<cstring>"
            ],
            "sample_declaration": "int strcmp(const char* lhs, const char* rhs);"
        },
        {
            "title": "std::strcoll",
            "path": "en.cppreference.com/w/cpp/string/byte/strcoll.html",
            "wgPageName": "cpp/string/byte/strcoll",
            "headers": [
                "<cstring>"
            ],
            "sample_declaration": "int strcoll(const char* lhs, const char* rhs);"
        },
        {
            "title": "std::strcpy",
            "path": "en.cppreference.com/w/cpp/string/byte/strcpy.html",
            "wgPageName": "cpp/string/byte/strcpy",
            "headers": [
                "<cstring>"
            ],
            "sample_declaration": "char* strcpy(char* dest, const char* src);"
        },
        {
            "title": "std::strcspn",
            "path": "en.cppreference.com/w/cpp/string/byte/strcspn.html",
            "wgPageName": "cpp/string/byte/strcspn",
            "headers": [
                "<cstring>"
            ],
            "sample_declaration": "size_t strcspn(\n    const char* dest,\n    const char* src);"
        },
        {
            "title": "std::strerror",
            "path": "en.cppreference.com/w/cpp/string/byte/strerror.html",
            "wgPageName": "cpp/string/byte/strerror",
            "headers": [
                "<cstring>"
            ],
            "sample_declaration": "char* strerror(int errnum);"
        },
        {
            "title": "std::strlen",
            "path": "en.cppreference.com/w/cpp/string/byte/strlen.html",
            "wgPageName": "cpp/string/byte/strlen",
            "headers": [
                "<cstring>"
            ],
            "sample_declaration": "std::size_t strlen(const char* str);"
        },
        {
            "title": "std::strncat",
            "path": "en.cppreference.com/w/cpp/string/byte/strncat.html",
            "wgPageName": "cpp/string/byte/strncat",
            "headers": [
                "<cstring>"
            ],
            "sample_declaration": "char* strncat(\n    char* dest,\n    const char* src,\n    std::size_t count);"
        },
        {
            "title": "std::strncmp",
            "path": "en.cppreference.com/w/cpp/string/byte/strncmp.html",
            "wgPageName": "cpp/string/byte/strncmp",
            "headers": [
                "<cstring>"
            ],
            "sample_declaration": "int strncmp(\n    const char* lhs,\n    const char* rhs,\n    std::size_t count);"
        },
        {
            "title": "std::strncpy",
            "path": "en.cppreference.com/w/cpp/string/byte/strncpy.html",
            "wgPageName": "cpp/string/byte/strncpy",
            "headers": [
                "<cstring>"
            ],
            "sample_declaration": "char* strncpy(\n    char* dest,\n    const char* src,\n    std::size_t count);"
        },
        {
            "title": "std::strpbrk",
            "path": "en.cppreference.com/w/cpp/string/byte/strpbrk.html",
            "wgPageName": "cpp/string/byte/strpbrk",
            "headers": [
                "<cstring>"
            ],
            "sample_declaration": "const char* strpbrk(\n    const char* dest,\n    const char* breakset);",
            "other_declarations": 1
        },
        {
            "title": "std::strrchr",
            "path": "en.cppreference.com/w/cpp/string/byte/strrchr.html",
            "wgPageName": "cpp/string/byte/strrchr",
            "headers": [
                "<cstring>"
            ],
            "sample_declaration": "const char* strrchr(const char* str, int ch);",
            "other_declarations": 1
        },
        {
            "title": "std::strspn",
            "path": "en.cppreference.com/w/cpp/string/byte/strspn.html",
            "wgPageName": "cpp/string/byte/strspn",
            "headers": [
                "<cstring>"
            ],
            "sample_declaration": "size_t strspn(\n    const char* dest,\n    const char* src);"
        },
        {
            "title": "std::strstr",
            "path": "en.cppreference.com/w/cpp/string/byte/strstr.html",
            "wgPageName": "cpp/string/byte/strstr",
            "headers": [
                "<cstring>"
            ],
            "sample_declaration": "const char* strstr(\n    const char* haystack,\n    const char* needle);",
            "other_declarations": 1
        },
        {
            "title": "std::strtof, std::strtod, std::strtold",
            "path": "en.cppreference.com/w/cpp/string/byte/strtof.html",
            "wgPageName": "cpp/string/byte/strtof",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "float strtof(const char* str, char** str_end);",
            "other_declarations": 2
        },
        {
            "title": "std::strtoimax, std::strtoumax",
            "path": "en.cppreference.com/w/cpp/string/byte/strtoimax.html",
            "wgPageName": "cpp/string/byte/strtoimax",
            "headers": [
                "<cinttypes>"
            ],
            "sample_declaration": "std::intmax_t strtoimax(\n    const char* nptr,\n    char** endptr,\n    int base);",
            "other_declarations": 1
        },
        {
            "title": "std::strtok",
            "path": "en.cppreference.com/w/cpp/string/byte/strtok.html",
            "wgPageName": "cpp/string/byte/strtok",
            "headers": [
                "<cstring>"
            ],
            "sample_declaration": "char* strtok(char* str, const char* delim);"
        },
        {
            "title": "std::strtol, std::strtoll",
            "path": "en.cppreference.com/w/cpp/string/byte/strtol.html",
            "wgPageName": "cpp/string/byte/strtol",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "long strtol(\n    const char* str,\n    char** str_end,\n    int base);",
            "other_declarations": 1
        },
        {
            "title": "std::strtoul, std::strtoull",
            "path": "en.cppreference.com/w/cpp/string/byte/strtoul.html",
            "wgPageName": "cpp/string/byte/strtoul",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "unsigned long strtoul(\n    const char* str,\n    char** str_end,\n    int base);",
            "other_declarations": 1
        },
        {
            "title": "std::strxfrm",
            "path": "en.cppreference.com/w/cpp/string/byte/strxfrm.html",
            "wgPageName": "cpp/string/byte/strxfrm",
            "headers": [
                "<cstring>"
            ],
            "sample_declaration": "std::size_t strxfrm(\n    char* dest,\n    const char* src,\n    std::size_t count);"
        },
        {
            "title": "std::tolower",
            "path": "en.cppreference.com/w/cpp/string/byte/tolower.html",
            "wgPageName": "cpp/string/byte/tolower",
            "headers": [
                "<cctype>"
            ],
            "sample_declaration": "int tolower(int ch);"
        },
        {
            "title": "std::toupper",
            "path": "en.cppreference.com/w/cpp/string/byte/toupper.html",
            "wgPageName": "cpp/string/byte/toupper",
            "headers": [
                "<cctype>"
            ],
            "sample_declaration": "int toupper(int ch);"
        },
        {
            "title": "std::char_traits",
            "path": "en.cppreference.com/w/cpp/string/char_traits.html",
            "wgPageName": "cpp/string/char_traits",
            "headers": [
                "<string>"
            ],
            "sample_declaration": "template<class CharT>\nclass char_traits;"
        },
        {
            "title": "std::char_traits<CharT>::assign",
            "path": "en.cppreference.com/w/cpp/string/char_traits/assign.html",
            "wgPageName": "cpp/string/char_traits/assign",
            "sample_declaration": "static void assign(\n    char_type& r,\n    const char_type& a);",
            "other_declarations": 4
        },
        {
            "title": "std::char_traits<CharT>::eq, std::char_traits<CharT>::lt",
            "path": "en.cppreference.com/w/cpp/string/char_traits/cmp.html",
            "wgPageName": "cpp/string/char_traits/cmp",
            "sample_declaration": "static bool eq(char_type a, char_type b);",
            "other_declarations": 3
        },
        {
            "title": "std::char_traits<CharT>::compare",
            "path": "en.cppreference.com/w/cpp/string/char_traits/compare.html",
            "wgPageName": "cpp/string/char_traits/compare",
            "sample_declaration": "static int compare(\n    const char_type* s1,\n    const char_type* s2,\n    std::size_t count);",
            "other_declarations": 1
        },
        {
            "title": "std::char_traits<CharT>::copy",
            "path": "en.cppreference.com/w/cpp/string/char_traits/copy.html",
            "wgPageName": "cpp/string/char_traits/copy",
            "sample_declaration": "static char_type* copy(\n    char_type* dest,\n    const char_type* src,\n    std::size_t count);",
            "other_declarations": 1
        },
        {
            "title": "std::char_traits<CharT>::eof",
            "path": "en.cppreference.com/w/cpp/string/char_traits/eof.html",
            "wgPageName": "cpp/string/char_traits/eof",
            "sample_declaration": "static int_type eof();",
            "other_declarations": 1
        },
        {
            "title": "std::char_traits<CharT>::eq_int_type",
            "path": "en.cppreference.com/w/cpp/string/char_traits/eq_int_type.html",
            "wgPageName": "cpp/string/char_traits/eq_int_type",
            "sample_declaration": "static bool eq_int_type(\n    int_type c1,\n    int_type c2);",
            "other_declarations": 1
        },
        {
            "title": "std::char_traits<CharT>::find",
            "path": "en.cppreference.com/w/cpp/string/char_traits/find.html",
            "wgPageName": "cpp/string/char_traits/find",
            "sample_declaration": "static const char_type* find(\n    const char_type* p,\n    std::size_t count,\n    const char_type& ch);",
            "other_declarations": 1
        },
        {
            "title": "std::char_traits<CharT>::length",
            "path": "en.cppreference.com/w/cpp/string/char_traits/length.html",
            "wgPageName": "cpp/string/char_traits/length",
            "sample_declaration": "static std::size_t length(const char_type* s);",
            "other_declarations": 1
        },
        {
            "title": "std::char_traits<CharT>::move",
            "path": "en.cppreference.com/w/cpp/string/char_traits/move.html",
            "wgPageName": "cpp/string/char_traits/move",
            "sample_declaration": "static char_type* move(\n    char_type* dest,\n    const char_type* src,\n    std::size_t count);",
            "other_declarations": 1
        },
        {
            "title": "std::char_traits<CharT>::not_eof",
            "path": "en.cppreference.com/w/cpp/string/char_traits/not_eof.html",
            "wgPageName": "cpp/string/char_traits/not_eof",
            "sample_declaration": "static int_type not_eof(int_type e);",
            "other_declarations": 1
        },
        {
            "title": "std::char_traits<CharT>::to_char_type",
            "path": "en.cppreference.com/w/cpp/string/char_traits/to_char_type.html",
            "wgPageName": "cpp/string/char_traits/to_char_type",
            "sample_declaration": "static char_type to_char_type(int_type c);",
            "other_declarations": 1
        },
        {
            "title": "std::char_traits<CharT>::to_int_type",
            "path": "en.cppreference.com/w/cpp/string/char_traits/to_int_type.html",
            "wgPageName": "cpp/string/char_traits/to_int_type",
            "sample_declaration": "static int_type to_int_type(char_type c);",
            "other_declarations": 1
        },
        {
            "title": "Null-terminated multibyte strings",
            "path": "en.cppreference.com/w/cpp/string/multibyte.html",
            "wgPageName": "cpp/string/multibyte"
        },
        {
            "title": "std::btowc",
            "path": "en.cppreference.com/w/cpp/string/multibyte/btowc.html",
            "wgPageName": "cpp/string/multibyte/btowc",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "std::wint_t btowc(int c);"
        },
        {
            "title": "std::c16rtomb",
            "path": "en.cppreference.com/w/cpp/string/multibyte/c16rtomb.html",
            "wgPageName": "cpp/string/multibyte/c16rtomb",
            "headers": [
                "<cuchar>"
            ],
            "sample_declaration": "std::size_t c16rtomb(\n    char* s,\n    char16_t c16,\n    std::mbstate_t* ps);"
        },
        {
            "title": "std::c32rtomb",
            "path": "en.cppreference.com/w/cpp/string/multibyte/c32rtomb.html",
            "wgPageName": "cpp/string/multibyte/c32rtomb",
            "headers": [
                "<cuchar>"
            ],
            "sample_declaration": "std::size_t c32rtomb(\n    char* s,\n    char32_t c32,\n    std::mbstate_t* ps);"
        },
        {
            "title": "std::c8rtomb",
            "path": "en.cppreference.com/w/cpp/string/multibyte/c8rtomb.html",
            "wgPageName": "cpp/string/multibyte/c8rtomb",
            "headers": [
                "<cuchar>"
            ],
            "sample_declaration": "std::size_t c8rtomb(\n    char* s,\n    char8_t c8,\n    std::mbstate_t* ps);"
        },
        {
            "title": "std::mblen",
            "path": "en.cppreference.com/w/cpp/string/multibyte/mblen.html",
            "wgPageName": "cpp/string/multibyte/mblen",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "int mblen(const char* s, std::size_t n);"
        },
        {
            "title": "std::mbrlen",
            "path": "en.cppreference.com/w/cpp/string/multibyte/mbrlen.html",
            "wgPageName": "cpp/string/multibyte/mbrlen",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "std::size_t mbrlen(\n    const char* s,\n    std::size_t n,\n    std::mbstate_t* ps);"
        },
        {
            "title": "std::mbrtoc16",
            "path": "en.cppreference.com/w/cpp/string/multibyte/mbrtoc16.html",
            "wgPageName": "cpp/string/multibyte/mbrtoc16",
            "headers": [
                "<cuchar>"
            ],
            "sample_declaration": "std::size_t mbrtoc16(\n    char16_t* pc16,\n    const char* s,\n    std::size_t n,\n    std::mbstate_t* ps);"
        },
        {
            "title": "std::mbrtoc32",
            "path": "en.cppreference.com/w/cpp/string/multibyte/mbrtoc32.html",
            "wgPageName": "cpp/string/multibyte/mbrtoc32",
            "headers": [
                "<cuchar>"
            ],
            "sample_declaration": "std::size_t mbrtoc32(\n    char32_t* pc32,\n    const char* s,\n    std::size_t n,\n    std::mbstate_t* ps);"
        },
        {
            "title": "std::mbrtoc8",
            "path": "en.cppreference.com/w/cpp/string/multibyte/mbrtoc8.html",
            "wgPageName": "cpp/string/multibyte/mbrtoc8",
            "headers": [
                "<cuchar>"
            ],
            "sample_declaration": "std::size_t mbrtoc8(\n    char8_t* pc8,\n    const char* s,\n    std::size_t n,\n    std::mbstate_t* ps);"
        },
        {
            "title": "std::mbrtowc",
            "path": "en.cppreference.com/w/cpp/string/multibyte/mbrtowc.html",
            "wgPageName": "cpp/string/multibyte/mbrtowc",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "std::size_t mbrtowc(\n    wchar_t* pwc,\n    const char* s,\n    std::size_t n,\n    std::mbstate_t* ps);"
        },
        {
            "title": "std::mbsinit",
            "path": "en.cppreference.com/w/cpp/string/multibyte/mbsinit.html",
            "wgPageName": "cpp/string/multibyte/mbsinit",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "int mbsinit(const std::mbstate_t* ps);"
        },
        {
            "title": "std::mbsrtowcs",
            "path": "en.cppreference.com/w/cpp/string/multibyte/mbsrtowcs.html",
            "wgPageName": "cpp/string/multibyte/mbsrtowcs",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "std::size_t mbsrtowcs(\n    wchar_t* dst,\n    const char** src,\n    std::size_t len,\n    std::mbstate_t* ps);"
        },
        {
            "title": "std::mbstate_t",
            "path": "en.cppreference.com/w/cpp/string/multibyte/mbstate_t.html",
            "wgPageName": "cpp/string/multibyte/mbstate_t",
            "headers": [
                "<cuchar>",
                "<cwchar>"
            ],
            "sample_declaration": "struct mbstate_t;"
        },
        {
            "title": "std::mbstowcs",
            "path": "en.cppreference.com/w/cpp/string/multibyte/mbstowcs.html",
            "wgPageName": "cpp/string/multibyte/mbstowcs",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "std::size_t mbstowcs(\n    wchar_t* dst,\n    const char* src,\n    std::size_t len);"
        },
        {
            "title": "std::mbtowc",
            "path": "en.cppreference.com/w/cpp/string/multibyte/mbtowc.html",
            "wgPageName": "cpp/string/multibyte/mbtowc",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "int mbtowc(\n    wchar_t* pwc,\n    const char* s,\n    std::size_t n);"
        },
        {
            "title": "std::wcrtomb",
            "path": "en.cppreference.com/w/cpp/string/multibyte/wcrtomb.html",
            "wgPageName": "cpp/string/multibyte/wcrtomb",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "std::size_t wcrtomb(\n    char* s,\n    wchar_t wc,\n    std::mbstate_t* ps);"
        },
        {
            "title": "std::wcsrtombs",
            "path": "en.cppreference.com/w/cpp/string/multibyte/wcsrtombs.html",
            "wgPageName": "cpp/string/multibyte/wcsrtombs",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "std::size_t wcsrtombs(\n    char* dst,\n    const wchar_t** src,\n    std::size_t len,\n    std::mbstate_t* ps);"
        },
        {
            "title": "std::wcstombs",
            "path": "en.cppreference.com/w/cpp/string/multibyte/wcstombs.html",
            "wgPageName": "cpp/string/multibyte/wcstombs",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "std::size_t wcstombs(\n    char* dst,\n    const wchar_t* src,\n    std::size_t len);"
        },
        {
            "title": "std::wctob",
            "path": "en.cppreference.com/w/cpp/string/multibyte/wctob.html",
            "wgPageName": "cpp/string/multibyte/wctob",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "int wctob(std::wint_t c);"
        },
        {
            "title": "std::wctomb",
            "path": "en.cppreference.com/w/cpp/string/multibyte/wctomb.html",
            "wgPageName": "cpp/string/multibyte/wctomb",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "int wctomb(char* s, wchar_t wc);"
        },
        {
            "title": "Null-terminated wide strings",
            "path": "en.cppreference.com/w/cpp/string/wide.html",
            "wgPageName": "cpp/string/wide"
        },
        {
            "title": "std::iswalnum",
            "path": "en.cppreference.com/w/cpp/string/wide/iswalnum.html",
            "wgPageName": "cpp/string/wide/iswalnum",
            "headers": [
                "<cwctype>"
            ],
            "sample_declaration": "int iswalnum(std::wint_t ch);"
        },
        {
            "title": "std::iswalpha",
            "path": "en.cppreference.com/w/cpp/string/wide/iswalpha.html",
            "wgPageName": "cpp/string/wide/iswalpha",
            "headers": [
                "<cwctype>"
            ],
            "sample_declaration": "int iswalpha(std::wint_t ch);"
        },
        {
            "title": "std::iswblank",
            "path": "en.cppreference.com/w/cpp/string/wide/iswblank.html",
            "wgPageName": "cpp/string/wide/iswblank",
            "headers": [
                "<cwctype>"
            ],
            "sample_declaration": "int iswblank(std::wint_t ch);"
        },
        {
            "title": "std::iswcntrl",
            "path": "en.cppreference.com/w/cpp/string/wide/iswcntrl.html",
            "wgPageName": "cpp/string/wide/iswcntrl",
            "headers": [
                "<cwctype>"
            ],
            "sample_declaration": "int iswcntrl(std::wint_t ch);"
        },
        {
            "title": "std::iswctype",
            "path": "en.cppreference.com/w/cpp/string/wide/iswctype.html",
            "wgPageName": "cpp/string/wide/iswctype",
            "headers": [
                "<cwctype>"
            ],
            "sample_declaration": "int iswctype(\n    std::wint_t wc,\n    std::wctype_t desc);"
        },
        {
            "title": "std::iswdigit",
            "path": "en.cppreference.com/w/cpp/string/wide/iswdigit.html",
            "wgPageName": "cpp/string/wide/iswdigit",
            "headers": [
                "<cwctype>"
            ],
            "sample_declaration": "int iswdigit(wint_t ch);"
        },
        {
            "title": "std::iswgraph",
            "path": "en.cppreference.com/w/cpp/string/wide/iswgraph.html",
            "wgPageName": "cpp/string/wide/iswgraph",
            "headers": [
                "<cwctype>"
            ],
            "sample_declaration": "int iswgraph(std::wint_t ch);"
        },
        {
            "title": "std::iswlower",
            "path": "en.cppreference.com/w/cpp/string/wide/iswlower.html",
            "wgPageName": "cpp/string/wide/iswlower",
            "headers": [
                "<cwctype>"
            ],
            "sample_declaration": "int iswlower(std::wint_t ch);"
        },
        {
            "title": "std::iswprint",
            "path": "en.cppreference.com/w/cpp/string/wide/iswprint.html",
            "wgPageName": "cpp/string/wide/iswprint",
            "headers": [
                "<cwctype>"
            ],
            "sample_declaration": "int iswprint(std::wint_t ch);"
        },
        {
            "title": "std::iswpunct",
            "path": "en.cppreference.com/w/cpp/string/wide/iswpunct.html",
            "wgPageName": "cpp/string/wide/iswpunct",
            "headers": [
                "<cwctype>"
            ],
            "sample_declaration": "int iswpunct(std::wint_t ch);"
        },
        {
            "title": "std::iswspace",
            "path": "en.cppreference.com/w/cpp/string/wide/iswspace.html",
            "wgPageName": "cpp/string/wide/iswspace",
            "headers": [
                "<cwctype>"
            ],
            "sample_declaration": "int iswspace(wint_t ch);"
        },
        {
            "title": "std::iswupper",
            "path": "en.cppreference.com/w/cpp/string/wide/iswupper.html",
            "wgPageName": "cpp/string/wide/iswupper",
            "headers": [
                "<cwctype>"
            ],
            "sample_declaration": "int iswupper(std::wint_t ch);"
        },
        {
            "title": "std::iswxdigit",
            "path": "en.cppreference.com/w/cpp/string/wide/iswxdigit.html",
            "wgPageName": "cpp/string/wide/iswxdigit",
            "headers": [
                "<cwctype>"
            ],
            "sample_declaration": "int iswxdigit(wint_t ch);"
        },
        {
            "title": "std::towctrans",
            "path": "en.cppreference.com/w/cpp/string/wide/towctrans.html",
            "wgPageName": "cpp/string/wide/towctrans",
            "headers": [
                "<cwctype>"
            ],
            "sample_declaration": "std::wint_t towctrans(\n    std::wint_t wc,\n    std::wctrans_t desc);"
        },
        {
            "title": "std::towlower",
            "path": "en.cppreference.com/w/cpp/string/wide/towlower.html",
            "wgPageName": "cpp/string/wide/towlower",
            "headers": [
                "<cwctype>"
            ],
            "sample_declaration": "std::wint_t towlower(std::wint_t ch);"
        },
        {
            "title": "std::towupper",
            "path": "en.cppreference.com/w/cpp/string/wide/towupper.html",
            "wgPageName": "cpp/string/wide/towupper",
            "headers": [
                "<cwctype>"
            ],
            "sample_declaration": "std::wint_t towupper(std::wint_t ch);"
        },
        {
            "title": "std::wcscat",
            "path": "en.cppreference.com/w/cpp/string/wide/wcscat.html",
            "wgPageName": "cpp/string/wide/wcscat",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "wchar_t* wcscat(\n    wchar_t* dest,\n    const wchar_t* src);"
        },
        {
            "title": "std::wcschr",
            "path": "en.cppreference.com/w/cpp/string/wide/wcschr.html",
            "wgPageName": "cpp/string/wide/wcschr",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "const wchar_t* wcschr(\n    const wchar_t* str,\n    wchar_t ch);",
            "other_declarations": 1
        },
        {
            "title": "std::wcscmp",
            "path": "en.cppreference.com/w/cpp/string/wide/wcscmp.html",
            "wgPageName": "cpp/string/wide/wcscmp",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "int wcscmp(\n    const wchar_t* lhs,\n    const wchar_t* rhs);"
        },
        {
            "title": "std::wcscoll",
            "path": "en.cppreference.com/w/cpp/string/wide/wcscoll.html",
            "wgPageName": "cpp/string/wide/wcscoll",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "int wcscoll(\n    const wchar_t* lhs,\n    const wchar_t* rhs);"
        },
        {
            "title": "std::wcscpy",
            "path": "en.cppreference.com/w/cpp/string/wide/wcscpy.html",
            "wgPageName": "cpp/string/wide/wcscpy",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "wchar_t* wcscpy(\n    wchar_t* dest,\n    const wchar_t* src);"
        },
        {
            "title": "std::wcscspn",
            "path": "en.cppreference.com/w/cpp/string/wide/wcscspn.html",
            "wgPageName": "cpp/string/wide/wcscspn",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "std::size_t wcscspn(\n    const wchar_t* dest,\n    const wchar_t* src);"
        },
        {
            "title": "std::wcslen",
            "path": "en.cppreference.com/w/cpp/string/wide/wcslen.html",
            "wgPageName": "cpp/string/wide/wcslen",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "std::size_t wcslen(const wchar_t* str);"
        },
        {
            "title": "std::wcsncat",
            "path": "en.cppreference.com/w/cpp/string/wide/wcsncat.html",
            "wgPageName": "cpp/string/wide/wcsncat",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "wchar_t* wcsncat(\n    wchar_t* dest,\n    const wchar_t* src,\n    std::size_t count);"
        },
        {
            "title": "std::wcsncmp",
            "path": "en.cppreference.com/w/cpp/string/wide/wcsncmp.html",
            "wgPageName": "cpp/string/wide/wcsncmp",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "int wcsncmp(\n    const wchar_t* lhs,\n    const wchar_t* rhs,\n    std::size_t count);"
        },
        {
            "title": "std::wcsncpy",
            "path": "en.cppreference.com/w/cpp/string/wide/wcsncpy.html",
            "wgPageName": "cpp/string/wide/wcsncpy",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "wchar_t* wcsncpy(\n    wchar_t* dest,\n    const wchar_t* src,\n    std::size_t count);"
        },
        {
            "title": "std::wcspbrk",
            "path": "en.cppreference.com/w/cpp/string/wide/wcspbrk.html",
            "wgPageName": "cpp/string/wide/wcspbrk",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "const wchar_t* wcspbrk(\n    const wchar_t* dest,\n    const wchar_t* str);",
            "other_declarations": 1
        },
        {
            "title": "std::wcsrchr",
            "path": "en.cppreference.com/w/cpp/string/wide/wcsrchr.html",
            "wgPageName": "cpp/string/wide/wcsrchr",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "const wchar_t* wcsrchr(\n    const wchar_t* str,\n    wchar_t ch);",
            "other_declarations": 1
        },
        {
            "title": "std::wcsspn",
            "path": "en.cppreference.com/w/cpp/string/wide/wcsspn.html",
            "wgPageName": "cpp/string/wide/wcsspn",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "size_t wcsspn(\n    const wchar_t* dest,\n    const wchar_t* src);"
        },
        {
            "title": "std::wcsstr",
            "path": "en.cppreference.com/w/cpp/string/wide/wcsstr.html",
            "wgPageName": "cpp/string/wide/wcsstr",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "const wchar_t* wcsstr(\n    const wchar_t* dest,\n    const wchar_t* src);",
            "other_declarations": 1
        },
        {
            "title": "std::wcstof, std::wcstod, std::wcstold",
            "path": "en.cppreference.com/w/cpp/string/wide/wcstof.html",
            "wgPageName": "cpp/string/wide/wcstof",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "float wcstof(\n    const wchar_t* str,\n    wchar_t** str_end);",
            "other_declarations": 2
        },
        {
            "title": "std::wcstoimax, std::wcstoumax",
            "path": "en.cppreference.com/w/cpp/string/wide/wcstoimax.html",
            "wgPageName": "cpp/string/wide/wcstoimax",
            "headers": [
                "<cinttypes>"
            ],
            "sample_declaration": "std::intmax_t wcstoimax(\n    const wchar_t* nptr,\n    wchar_t** endptr,\n    int base);",
            "other_declarations": 1
        },
        {
            "title": "std::wcstok",
            "path": "en.cppreference.com/w/cpp/string/wide/wcstok.html",
            "wgPageName": "cpp/string/wide/wcstok",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "wchar_t* wcstok(\n    wchar_t* str,\n    const wchar_t* delim,\n    wchar_t** ptr);"
        },
        {
            "title": "std::wcstol, std::wcstoll",
            "path": "en.cppreference.com/w/cpp/string/wide/wcstol.html",
            "wgPageName": "cpp/string/wide/wcstol",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "long wcstol(\n    const wchar_t* str,\n    wchar_t** str_end,\n    int base);",
            "other_declarations": 1
        },
        {
            "title": "std::wcstoul, std::wcstoull",
            "path": "en.cppreference.com/w/cpp/string/wide/wcstoul.html",
            "wgPageName": "cpp/string/wide/wcstoul",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "unsigned long wcstoul(\n    const wchar_t* str,\n    wchar_t** str_end,\n    int base);",
            "other_declarations": 1
        },
        {
            "title": "std::wcsxfrm",
            "path": "en.cppreference.com/w/cpp/string/wide/wcsxfrm.html",
            "wgPageName": "cpp/string/wide/wcsxfrm",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "std::size_t wcsxfrm(\n    wchar_t* dest,\n    const wchar_t* src,\n    std::size_t count);"
        },
        {
            "title": "std::wctrans",
            "path": "en.cppreference.com/w/cpp/string/wide/wctrans.html",
            "wgPageName": "cpp/string/wide/wctrans",
            "headers": [
                "<cwctype>"
            ],
            "sample_declaration": "std::wctrans_t wctrans(const char* str);"
        },
        {
            "title": "std::wctype",
            "path": "en.cppreference.com/w/cpp/string/wide/wctype.html",
            "wgPageName": "cpp/string/wide/wctype",
            "headers": [
                "<cwctype>"
            ],
            "sample_declaration": "std::wctype_t wctype(const char* str);"
        },
        {
            "title": "std::wmemchr",
            "path": "en.cppreference.com/w/cpp/string/wide/wmemchr.html",
            "wgPageName": "cpp/string/wide/wmemchr",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "const wchar_t* wmemchr(\n    const wchar_t* ptr,\n    wchar_t ch,\n    std::size_t count);",
            "other_declarations": 1
        },
        {
            "title": "std::wmemcmp",
            "path": "en.cppreference.com/w/cpp/string/wide/wmemcmp.html",
            "wgPageName": "cpp/string/wide/wmemcmp",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "int wmemcmp(\n    const wchar_t* lhs,\n    const wchar_t* rhs,\n    std::size_t count);"
        },
        {
            "title": "std::wmemcpy",
            "path": "en.cppreference.com/w/cpp/string/wide/wmemcpy.html",
            "wgPageName": "cpp/string/wide/wmemcpy",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "wchar_t* wmemcpy(\n    wchar_t* dest,\n    const wchar_t* src,\n    std::size_t count);"
        },
        {
            "title": "std::wmemmove",
            "path": "en.cppreference.com/w/cpp/string/wide/wmemmove.html",
            "wgPageName": "cpp/string/wide/wmemmove",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "wchar_t* wmemmove(\n    wchar_t* dest,\n    const wchar_t* src,\n    std::size_t count);"
        },
        {
            "title": "std::wmemset",
            "path": "en.cppreference.com/w/cpp/string/wide/wmemset.html",
            "wgPageName": "cpp/string/wide/wmemset",
            "headers": [
                "<cwchar>"
            ],
            "sample_declaration": "wchar_t* wmemset(\n    wchar_t* dest,\n    wchar_t ch,\n    std::size_t count);"
        },
        {
            "title": "std Symbol Index",
            "path": "en.cppreference.com/w/cpp/symbol_index.html",
            "wgPageName": "cpp/symbol_index"
        },
        {
            "title": "std::literals::chrono_literals Symbol Index",
            "path": "en.cppreference.com/w/cpp/symbol_index/chrono_literals.html",
            "wgPageName": "cpp/symbol_index/chrono_literals"
        },
        {
            "title": "std::chrono Symbol Index",
            "path": "en.cppreference.com/w/cpp/symbol_index/chrono.html",
            "wgPageName": "cpp/symbol_index/chrono"
        },
        {
            "title": "std::literals::complex_literals Symbol Index",
            "path": "en.cppreference.com/w/cpp/symbol_index/complex_literals.html",
            "wgPageName": "cpp/symbol_index/complex_literals"
        },
        {
            "title": "std::execution Symbol Index",
            "path": "en.cppreference.com/w/cpp/symbol_index/execution.html",
            "wgPageName": "cpp/symbol_index/execution"
        },
        {
            "title": "std::filesystem Symbol Index",
            "path": "en.cppreference.com/w/cpp/symbol_index/filesystem.html",
            "wgPageName": "cpp/symbol_index/filesystem"
        },
        {
            "title": "std::literals Symbol Index",
            "path": "en.cppreference.com/w/cpp/symbol_index/literals.html",
            "wgPageName": "cpp/symbol_index/literals"
        },
        {
            "title": "Macro Symbol Index",
            "path": "en.cppreference.com/w/cpp/symbol_index/macro.html",
            "wgPageName": "cpp/symbol_index/macro"
        },
        {
            "title": "std::numbers Symbol Index",
            "path": "en.cppreference.com/w/cpp/symbol_index/numbers.html",
            "wgPageName": "cpp/symbol_index/numbers"
        },
        {
            "title": "std::placeholders Symbol Index",
            "path": "en.cppreference.com/w/cpp/symbol_index/placeholders.html",
            "wgPageName": "cpp/symbol_index/placeholders"
        },
        {
            "title": "std::pmr Symbol Index",
            "path": "en.cppreference.com/w/cpp/symbol_index/pmr.html",
            "wgPageName": "cpp/symbol_index/pmr"
        },
        {
            "title": "std::ranges Symbol Index",
            "path": "en.cppreference.com/w/cpp/symbol_index/ranges.html",
            "wgPageName": "cpp/symbol_index/ranges"
        },
        {
            "title": "std::regex_constants Symbol Index",
            "path": "en.cppreference.com/w/cpp/symbol_index/regex_constants.html",
            "wgPageName": "cpp/symbol_index/regex_constants"
        },
        {
            "title": "std::rel_ops Symbol Index",
            "path": "en.cppreference.com/w/cpp/symbol_index/rel_ops.html",
            "wgPageName": "cpp/symbol_index/rel_ops"
        },
        {
            "title": "std::literals::string_literals Symbol Index",
            "path": "en.cppreference.com/w/cpp/symbol_index/string_literals.html",
            "wgPageName": "cpp/symbol_index/string_literals"
        },
        {
            "title": "std::literals::string_view_literals Symbol Index",
            "path": "en.cppreference.com/w/cpp/symbol_index/string_view_literals.html",
            "wgPageName": "cpp/symbol_index/string_view_literals"
        },
        {
            "title": "std::this_thread Symbol Index",
            "path": "en.cppreference.com/w/cpp/symbol_index/this_thread.html",
            "wgPageName": "cpp/symbol_index/this_thread"
        },
        {
            "title": "std::ranges::views Symbol Index",
            "path": "en.cppreference.com/w/cpp/symbol_index/views.html",
            "wgPageName": "cpp/symbol_index/views"
        },
        {
            "title": "Symbol Index (removed)",
            "path": "en.cppreference.com/w/cpp/symbol_index/zombie_names.html",
            "wgPageName": "cpp/symbol_index/zombie_names"
        },
        {
            "title": "Concurrency support library (since C++11)",
            "path": "en.cppreference.com/w/cpp/thread.html",
            "wgPageName": "cpp/thread"
        },
        {
            "title": "std::async",
            "path": "en.cppreference.com/w/cpp/thread/async.html",
            "wgPageName": "cpp/thread/async",
            "headers": [
                "<future>"
            ],
            "sample_declaration": "template<class Function, class... Args>\nstd::future<typename std::result_of<\n    typename std::decay<Function>::type(\n        typename std::decay<Args>::type...)>::\n                type>\nasync(Function&& f, Args&&... args);",
            "other_declarations": 5
        },
        {
            "title": "std::barrier",
            "path": "en.cppreference.com/w/cpp/thread/barrier.html",
            "wgPageName": "cpp/thread/barrier",
            "headers": [
                "<barrier>"
            ],
            "sample_declaration": "template<\n    class CompletionFunction = /* see below */>\nclass barrier;"
        },
        {
            "title": "std::barrier<CompletionFunction>::~barrier",
            "path": "en.cppreference.com/w/cpp/thread/barrier/~barrier.html",
            "wgPageName": "cpp/thread/barrier/~barrier",
            "sample_declaration": "~barrier();"
        },
        {
            "title": "std::barrier<CompletionFunction>::arrive_and_drop",
            "path": "en.cppreference.com/w/cpp/thread/barrier/arrive_and_drop.html",
            "wgPageName": "cpp/thread/barrier/arrive_and_drop",
            "sample_declaration": "void arrive_and_drop();"
        },
        {
            "title": "std::barrier<CompletionFunction>::arrive_and_wait",
            "path": "en.cppreference.com/w/cpp/thread/barrier/arrive_and_wait.html",
            "wgPageName": "cpp/thread/barrier/arrive_and_wait",
            "sample_declaration": "void arrive_and_wait();"
        },
        {
            "title": "std::barrier<CompletionFunction>::arrive",
            "path": "en.cppreference.com/w/cpp/thread/barrier/arrive.html",
            "wgPageName": "cpp/thread/barrier/arrive",
            "sample_declaration": "[[nodiscard]] arrival_token arrive(\n    std::ptrdiff_t n = 1);"
        },
        {
            "title": "std::barrier<CompletionFunction>::barrier",
            "path": "en.cppreference.com/w/cpp/thread/barrier/barrier.html",
            "wgPageName": "cpp/thread/barrier/barrier",
            "sample_declaration": "constexpr explicit barrier(\n    std::ptrdiff_t expected,\n    CompletionFunction f =\n        CompletionFunction());",
            "other_declarations": 1
        },
        {
            "title": "std::barrier<CompletionFunction>::max",
            "path": "en.cppreference.com/w/cpp/thread/barrier/max.html",
            "wgPageName": "cpp/thread/barrier/max",
            "sample_declaration": "static constexpr std::ptrdiff_t max() noexcept;"
        },
        {
            "title": "std::barrier<CompletionFunction>::wait",
            "path": "en.cppreference.com/w/cpp/thread/barrier/wait.html",
            "wgPageName": "cpp/thread/barrier/wait",
            "sample_declaration": "void wait(arrival_token&& arrival) const;"
        },
        {
            "title": "std::call_once",
            "path": "en.cppreference.com/w/cpp/thread/call_once.html",
            "wgPageName": "cpp/thread/call_once",
            "headers": [
                "<mutex>"
            ],
            "sample_declaration": "template<class Callable, class... Args>\nvoid call_once(\n    std::once_flag& flag,\n    Callable&& f,\n    Args&&... args);"
        },
        {
            "title": "std::condition_variable_any",
            "path": "en.cppreference.com/w/cpp/thread/condition_variable_any.html",
            "wgPageName": "cpp/thread/condition_variable_any",
            "headers": [
                "<condition_variable>"
            ],
            "sample_declaration": "class condition_variable_any;"
        },
        {
            "title": "std::condition_variable_any::~condition_variable_any",
            "path": "en.cppreference.com/w/cpp/thread/condition_variable_any/~condition_variable_any.html",
            "wgPageName": "cpp/thread/condition_variable_any/~condition_variable_any",
            "sample_declaration": "~condition_variable_any();"
        },
        {
            "title": "std::condition_variable_any::condition_variable_any",
            "path": "en.cppreference.com/w/cpp/thread/condition_variable_any/condition_variable_any.html",
            "wgPageName": "cpp/thread/condition_variable_any/condition_variable_any",
            "sample_declaration": "condition_variable_any();",
            "other_declarations": 1
        },
        {
            "title": "std::condition_variable_any::notify_all",
            "path": "en.cppreference.com/w/cpp/thread/condition_variable_any/notify_all.html",
            "wgPageName": "cpp/thread/condition_variable_any/notify_all",
            "sample_declaration": "void notify_all() noexcept;"
        },
        {
            "title": "std::condition_variable_any::notify_one",
            "path": "en.cppreference.com/w/cpp/thread/condition_variable_any/notify_one.html",
            "wgPageName": "cpp/thread/condition_variable_any/notify_one",
            "sample_declaration": "void notify_one() noexcept;"
        },
        {
            "title": "std::condition_variable_any::wait_for",
            "path": "en.cppreference.com/w/cpp/thread/condition_variable_any/wait_for.html",
            "wgPageName": "cpp/thread/condition_variable_any/wait_for",
            "sample_declaration": "template<class Lock, class Rep, class Period>\nstd::cv_status wait_for(\n    Lock& lock,\n    const std::chrono::duration<Rep, Period>&\n        rel_time);",
            "other_declarations": 2
        },
        {
            "title": "std::condition_variable_any::wait_until",
            "path": "en.cppreference.com/w/cpp/thread/condition_variable_any/wait_until.html",
            "wgPageName": "cpp/thread/condition_variable_any/wait_until",
            "sample_declaration": "template<\n    class Lock,\n    class Clock,\n    class Duration>\nstd::cv_status wait_until(\n    Lock& lock,\n    const std::chrono::time_point<\n        Clock,\n        Duration>& timeout_time);",
            "other_declarations": 2
        },
        {
            "title": "std::condition_variable_any::wait",
            "path": "en.cppreference.com/w/cpp/thread/condition_variable_any/wait.html",
            "wgPageName": "cpp/thread/condition_variable_any/wait",
            "sample_declaration": "template<class Lock>\nvoid wait(Lock& lock);",
            "other_declarations": 2
        },
        {
            "title": "std::condition_variable",
            "path": "en.cppreference.com/w/cpp/thread/condition_variable.html",
            "wgPageName": "cpp/thread/condition_variable",
            "headers": [
                "<condition_variable>"
            ],
            "sample_declaration": "class condition_variable;"
        },
        {
            "title": "std::condition_variable::~condition_variable",
            "path": "en.cppreference.com/w/cpp/thread/condition_variable/~condition_variable.html",
            "wgPageName": "cpp/thread/condition_variable/~condition_variable",
            "sample_declaration": "~condition_variable();"
        },
        {
            "title": "std::condition_variable::condition_variable",
            "path": "en.cppreference.com/w/cpp/thread/condition_variable/condition_variable.html",
            "wgPageName": "cpp/thread/condition_variable/condition_variable",
            "sample_declaration": "condition_variable();",
            "other_declarations": 1
        },
        {
            "title": "std::condition_variable::native_handle",
            "path": "en.cppreference.com/w/cpp/thread/condition_variable/native_handle.html",
            "wgPageName": "cpp/thread/condition_variable/native_handle",
            "sample_declaration": "native_handle_type native_handle();"
        },
        {
            "title": "std::condition_variable::notify_all",
            "path": "en.cppreference.com/w/cpp/thread/condition_variable/notify_all.html",
            "wgPageName": "cpp/thread/condition_variable/notify_all",
            "sample_declaration": "void notify_all() noexcept;"
        },
        {
            "title": "std::condition_variable::notify_one",
            "path": "en.cppreference.com/w/cpp/thread/condition_variable/notify_one.html",
            "wgPageName": "cpp/thread/condition_variable/notify_one",
            "sample_declaration": "void notify_one() noexcept;"
        },
        {
            "title": "std::condition_variable::wait_for",
            "path": "en.cppreference.com/w/cpp/thread/condition_variable/wait_for.html",
            "wgPageName": "cpp/thread/condition_variable/wait_for",
            "sample_declaration": "template<class Rep, class Period>\nstd::cv_status wait_for(\n    std::unique_lock<std::mutex>& lock,\n    const std::chrono::duration<Rep, Period>&\n        rel_time);",
            "other_declarations": 1
        },
        {
            "title": "std::condition_variable::wait_until",
            "path": "en.cppreference.com/w/cpp/thread/condition_variable/wait_until.html",
            "wgPageName": "cpp/thread/condition_variable/wait_until",
            "sample_declaration": "template<class Clock, class Duration>\nstd::cv_status wait_until(\n    std::unique_lock<std::mutex>& lock,\n    const std::chrono::time_point<\n        Clock,\n        Duration>& timeout_time);",
            "other_declarations": 1
        },
        {
            "title": "std::condition_variable::wait",
            "path": "en.cppreference.com/w/cpp/thread/condition_variable/wait.html",
            "wgPageName": "cpp/thread/condition_variable/wait",
            "sample_declaration": "void wait(std::unique_lock<std::mutex>& lock);",
            "other_declarations": 1
        },
        {
            "title": "std::counting_semaphore, std::binary_semaphore",
            "path": "en.cppreference.com/w/cpp/thread/counting_semaphore.html",
            "wgPageName": "cpp/thread/counting_semaphore",
            "headers": [
                "<semaphore>"
            ],
            "sample_declaration": "template<\n    std::ptrdiff_t LeastMaxValue =\n        /* implementation-defined */>\nclass counting_semaphore;",
            "other_declarations": 1
        },
        {
            "title": "std::counting_semaphore<LeastMaxValue>::~counting_semaphore",
            "path": "en.cppreference.com/w/cpp/thread/counting_semaphore/~counting_semaphore.html",
            "wgPageName": "cpp/thread/counting_semaphore/~counting_semaphore",
            "sample_declaration": "~counting_semaphore();"
        },
        {
            "title": "std::counting_semaphore<LeastMaxValue>::acquire",
            "path": "en.cppreference.com/w/cpp/thread/counting_semaphore/acquire.html",
            "wgPageName": "cpp/thread/counting_semaphore/acquire",
            "sample_declaration": "void acquire();"
        },
        {
            "title": "std::counting_semaphore<LeastMaxValue>::counting_semaphore",
            "path": "en.cppreference.com/w/cpp/thread/counting_semaphore/counting_semaphore.html",
            "wgPageName": "cpp/thread/counting_semaphore/counting_semaphore",
            "sample_declaration": "constexpr explicit counting_semaphore(\n    std::ptrdiff_t desired);",
            "other_declarations": 1
        },
        {
            "title": "std::counting_semaphore<LeastMaxValue>::max",
            "path": "en.cppreference.com/w/cpp/thread/counting_semaphore/max.html",
            "wgPageName": "cpp/thread/counting_semaphore/max",
            "sample_declaration": "constexpr std::ptrdiff_t max() noexcept;"
        },
        {
            "title": "std::counting_semaphore<LeastMaxValue>::release",
            "path": "en.cppreference.com/w/cpp/thread/counting_semaphore/release.html",
            "wgPageName": "cpp/thread/counting_semaphore/release",
            "sample_declaration": "void release(std::ptrdiff_t update = 1);"
        },
        {
            "title": "std::counting_semaphore<LeastMaxValue>::try_acquire_for",
            "path": "en.cppreference.com/w/cpp/thread/counting_semaphore/try_acquire_for.html",
            "wgPageName": "cpp/thread/counting_semaphore/try_acquire_for",
            "sample_declaration": "template<class Rep, class Period>\nbool try_acquire_for(\n    const std::chrono::duration<Rep, Period>&\n        rel_time);"
        },
        {
            "title": "std::counting_semaphore<LeastMaxValue>::try_acquire_until",
            "path": "en.cppreference.com/w/cpp/thread/counting_semaphore/try_acquire_until.html",
            "wgPageName": "cpp/thread/counting_semaphore/try_acquire_until",
            "sample_declaration": "template<class Clock, class Duration>\nbool try_acquire_until(\n    const std::chrono::\n        time_point<Clock, Duration>& abs_time);"
        },
        {
            "title": "std::counting_semaphore<LeastMaxValue>::try_acquire",
            "path": "en.cppreference.com/w/cpp/thread/counting_semaphore/try_acquire.html",
            "wgPageName": "cpp/thread/counting_semaphore/try_acquire",
            "sample_declaration": "bool try_acquire() noexcept;"
        },
        {
            "title": "std::cv_status",
            "path": "en.cppreference.com/w/cpp/thread/cv_status.html",
            "wgPageName": "cpp/thread/cv_status",
            "headers": [
                "<condition_variable>"
            ],
            "sample_declaration": "enum class cv_status { no_timeout, timeout };"
        },
        {
            "title": "std::future_category",
            "path": "en.cppreference.com/w/cpp/thread/future_category.html",
            "wgPageName": "cpp/thread/future_category",
            "headers": [
                "<future>"
            ],
            "sample_declaration": "const std::error_category&\nfuture_category() noexcept;"
        },
        {
            "title": "std::future_errc",
            "path": "en.cppreference.com/w/cpp/thread/future_errc.html",
            "wgPageName": "cpp/thread/future_errc",
            "headers": [
                "<future>"
            ],
            "sample_declaration": "enum class future_errc {\n  broken_promise = /* implementation-defined */,\n  future_already_retrieved =\n      /* implementation-defined */,\n  promise_already_satisfied =\n      /* implementation-defined */,\n  no_state = /* implementation-defined */\n};"
        },
        {
            "title": "std::is_error_code_enum<std::future_errc>",
            "path": "en.cppreference.com/w/cpp/thread/future_errc/is_error_code_enum.html",
            "wgPageName": "cpp/thread/future_errc/is_error_code_enum",
            "headers": [
                "<future>"
            ],
            "sample_declaration": "template<>\nstruct is_error_code_enum<std::future_errc>\n    : std::true_type;"
        },
        {
            "title": "std::make_error_code(std::future_errc)",
            "path": "en.cppreference.com/w/cpp/thread/future_errc/make_error_code.html",
            "wgPageName": "cpp/thread/future_errc/make_error_code",
            "headers": [
                "<future>"
            ],
            "sample_declaration": "std::error_code make_error_code(\n    std::future_errc e);"
        },
        {
            "title": "std::make_error_condition(std::future_errc)",
            "path": "en.cppreference.com/w/cpp/thread/future_errc/make_error_condition.html",
            "wgPageName": "cpp/thread/future_errc/make_error_condition",
            "headers": [
                "<future>"
            ],
            "sample_declaration": "std::error_condition make_error_condition(\n    std::future_errc e);"
        },
        {
            "title": "std::future_error",
            "path": "en.cppreference.com/w/cpp/thread/future_error.html",
            "wgPageName": "cpp/thread/future_error",
            "headers": [
                "<future>"
            ],
            "sample_declaration": "class future_error;"
        },
        {
            "title": "std::future_error::code",
            "path": "en.cppreference.com/w/cpp/thread/future_error/code.html",
            "wgPageName": "cpp/thread/future_error/code",
            "sample_declaration": "const std::error_code& code() const noexcept;"
        },
        {
            "title": "std::future_error::future_error",
            "path": "en.cppreference.com/w/cpp/thread/future_error/future_error.html",
            "wgPageName": "cpp/thread/future_error/future_error",
            "sample_declaration": "future_error(\n    const future_error& other) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::future_error::operator=",
            "path": "en.cppreference.com/w/cpp/thread/future_error/operator=.html",
            "wgPageName": "cpp/thread/future_error/operator=",
            "sample_declaration": "future_error& operator=(\n    const future_error& other) noexcept;"
        },
        {
            "title": "std::future_error::what",
            "path": "en.cppreference.com/w/cpp/thread/future_error/what.html",
            "wgPageName": "cpp/thread/future_error/what",
            "sample_declaration": "virtual const char* what() const noexcept;"
        },
        {
            "title": "std::future_status",
            "path": "en.cppreference.com/w/cpp/thread/future_status.html",
            "wgPageName": "cpp/thread/future_status",
            "headers": [
                "<future>"
            ],
            "sample_declaration": "enum class future_status {\n  ready,\n  timeout,\n  deferred\n};"
        },
        {
            "title": "std::future",
            "path": "en.cppreference.com/w/cpp/thread/future.html",
            "wgPageName": "cpp/thread/future",
            "headers": [
                "<future>"
            ],
            "sample_declaration": "template<class T>\nclass future;",
            "other_declarations": 2
        },
        {
            "title": "std::future<T>::~future",
            "path": "en.cppreference.com/w/cpp/thread/future/~future.html",
            "wgPageName": "cpp/thread/future/~future",
            "sample_declaration": "~future();"
        },
        {
            "title": "std::future_category",
            "path": "en.cppreference.com/w/cpp/thread/future/future_category.html",
            "wgPageName": "cpp/thread/future_category",
            "headers": [
                "<future>"
            ],
            "sample_declaration": "const std::error_category&\nfuture_category() noexcept;"
        },
        {
            "title": "std::future<T>::future",
            "path": "en.cppreference.com/w/cpp/thread/future/future.html",
            "wgPageName": "cpp/thread/future/future",
            "sample_declaration": "future() noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::future<T>::get",
            "path": "en.cppreference.com/w/cpp/thread/future/get.html",
            "wgPageName": "cpp/thread/future/get",
            "sample_declaration": "T get();",
            "other_declarations": 2
        },
        {
            "title": "std::future<T>::operator=",
            "path": "en.cppreference.com/w/cpp/thread/future/operator=.html",
            "wgPageName": "cpp/thread/future/operator=",
            "sample_declaration": "future& operator=(future&& other) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::future<T>::share",
            "path": "en.cppreference.com/w/cpp/thread/future/share.html",
            "wgPageName": "cpp/thread/future/share",
            "sample_declaration": "std::shared_future<T> share() noexcept;"
        },
        {
            "title": "std::future<T>::valid",
            "path": "en.cppreference.com/w/cpp/thread/future/valid.html",
            "wgPageName": "cpp/thread/future/valid",
            "sample_declaration": "bool valid() const noexcept;"
        },
        {
            "title": "std::future<T>::wait_for",
            "path": "en.cppreference.com/w/cpp/thread/future/wait_for.html",
            "wgPageName": "cpp/thread/future/wait_for",
            "sample_declaration": "template<class Rep, class Period>\nstd::future_status wait_for(\n    const std::chrono::duration<Rep, Period>&\n        timeout_duration) const;"
        },
        {
            "title": "std::future<T>::wait_until",
            "path": "en.cppreference.com/w/cpp/thread/future/wait_until.html",
            "wgPageName": "cpp/thread/future/wait_until",
            "sample_declaration": "template<class Clock, class Duration>\nstd::future_status wait_until(\n    const std::chrono::time_point<\n        Clock,\n        Duration>& timeout_time) const;"
        },
        {
            "title": "std::future<T>::wait",
            "path": "en.cppreference.com/w/cpp/thread/future/wait.html",
            "wgPageName": "cpp/thread/future/wait",
            "sample_declaration": "void wait() const;"
        },
        {
            "title": "std::this_thread::get_id",
            "path": "en.cppreference.com/w/cpp/thread/get_id.html",
            "wgPageName": "cpp/thread/get_id",
            "headers": [
                "<thread>"
            ],
            "sample_declaration": "std::thread::id get_id() noexcept;"
        },
        {
            "title": "std::hardware_destructive_interference_size, std::hardware_constructive_interference_size",
            "path": "en.cppreference.com/w/cpp/thread/hardware_destructive_interference_size.html",
            "wgPageName": "cpp/thread/hardware_destructive_interference_size",
            "headers": [
                "<new>"
            ],
            "sample_declaration": "inline constexpr std::size_t\n    hardware_destructive_interference_size =\n    /*implementation-defined*/;",
            "other_declarations": 1
        },
        {
            "title": "std::jthread",
            "path": "en.cppreference.com/w/cpp/thread/jthread.html",
            "wgPageName": "cpp/thread/jthread",
            "headers": [
                "<thread>"
            ],
            "sample_declaration": "class jthread;"
        },
        {
            "title": "std::jthread::~jthread",
            "path": "en.cppreference.com/w/cpp/thread/jthread/~jthread.html",
            "wgPageName": "cpp/thread/jthread/~jthread",
            "sample_declaration": "~jthread();"
        },
        {
            "title": "std::jthread::detach",
            "path": "en.cppreference.com/w/cpp/thread/jthread/detach.html",
            "wgPageName": "cpp/thread/jthread/detach",
            "sample_declaration": "void detach();"
        },
        {
            "title": "std::jthread::get_id",
            "path": "en.cppreference.com/w/cpp/thread/jthread/get_id.html",
            "wgPageName": "cpp/thread/jthread/get_id",
            "sample_declaration": "[[nodiscard]] std::jthread::id get_id()\n    const noexcept;"
        },
        {
            "title": "std::jthread::get_stop_source",
            "path": "en.cppreference.com/w/cpp/thread/jthread/get_stop_source.html",
            "wgPageName": "cpp/thread/jthread/get_stop_source",
            "sample_declaration": "std::stop_source get_stop_source() noexcept;"
        },
        {
            "title": "std::jthread::get_stop_token",
            "path": "en.cppreference.com/w/cpp/thread/jthread/get_stop_token.html",
            "wgPageName": "cpp/thread/jthread/get_stop_token",
            "sample_declaration": "std::stop_token get_stop_token() const noexcept;"
        },
        {
            "title": "std::jthread::hardware_concurrency",
            "path": "en.cppreference.com/w/cpp/thread/jthread/hardware_concurrency.html",
            "wgPageName": "cpp/thread/jthread/hardware_concurrency",
            "sample_declaration": "[[nodiscard]] static unsigned int\nhardware_concurrency() noexcept;"
        },
        {
            "title": "std::jthread::join",
            "path": "en.cppreference.com/w/cpp/thread/jthread/join.html",
            "wgPageName": "cpp/thread/jthread/join",
            "sample_declaration": "void join();"
        },
        {
            "title": "std::jthread::joinable",
            "path": "en.cppreference.com/w/cpp/thread/jthread/joinable.html",
            "wgPageName": "cpp/thread/jthread/joinable",
            "sample_declaration": "[[nodiscard]] bool joinable() const noexcept;"
        },
        {
            "title": "std::jthread::jthread",
            "path": "en.cppreference.com/w/cpp/thread/jthread/jthread.html",
            "wgPageName": "cpp/thread/jthread/jthread",
            "sample_declaration": "jthread() noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::jthread::native_handle",
            "path": "en.cppreference.com/w/cpp/thread/jthread/native_handle.html",
            "wgPageName": "cpp/thread/jthread/native_handle",
            "sample_declaration": "[[nodiscard]] native_handle_type\nnative_handle();"
        },
        {
            "title": "std::jthread::operator=",
            "path": "en.cppreference.com/w/cpp/thread/jthread/operator=.html",
            "wgPageName": "cpp/thread/jthread/operator=",
            "sample_declaration": "std::jthread& operator=(\n    std::jthread&& other) noexcept;"
        },
        {
            "title": "std::jthread::request_stop",
            "path": "en.cppreference.com/w/cpp/thread/jthread/request_stop.html",
            "wgPageName": "cpp/thread/jthread/request_stop",
            "sample_declaration": "bool request_stop() noexcept;"
        },
        {
            "title": "std::jthread::swap",
            "path": "en.cppreference.com/w/cpp/thread/jthread/swap.html",
            "wgPageName": "cpp/thread/jthread/swap",
            "sample_declaration": "void swap(std::jthread& other) noexcept;"
        },
        {
            "title": "swap(std::jthread)",
            "path": "en.cppreference.com/w/cpp/thread/jthread/swap2.html",
            "wgPageName": "cpp/thread/jthread/swap2",
            "sample_declaration": "friend void swap(\n    jthread& lhs,\n    jthread& rhs) noexcept;"
        },
        {
            "title": "std::latch",
            "path": "en.cppreference.com/w/cpp/thread/latch.html",
            "wgPageName": "cpp/thread/latch",
            "headers": [
                "<latch>"
            ],
            "sample_declaration": "class latch;"
        },
        {
            "title": "std::latch::~latch",
            "path": "en.cppreference.com/w/cpp/thread/latch/~latch.html",
            "wgPageName": "cpp/thread/latch/~latch",
            "sample_declaration": "~latch();"
        },
        {
            "title": "std::latch::arrive_and_wait",
            "path": "en.cppreference.com/w/cpp/thread/latch/arrive_and_wait.html",
            "wgPageName": "cpp/thread/latch/arrive_and_wait",
            "sample_declaration": "void arrive_and_wait(std::ptrdiff_t n = 1);"
        },
        {
            "title": "std::latch::count_down",
            "path": "en.cppreference.com/w/cpp/thread/latch/count_down.html",
            "wgPageName": "cpp/thread/latch/count_down",
            "sample_declaration": "void count_down(std::ptrdiff_t n = 1);"
        },
        {
            "title": "std::latch::latch",
            "path": "en.cppreference.com/w/cpp/thread/latch/latch.html",
            "wgPageName": "cpp/thread/latch/latch",
            "sample_declaration": "constexpr explicit latch(\n    std::ptrdiff_t expected);",
            "other_declarations": 1
        },
        {
            "title": "std::latch::max",
            "path": "en.cppreference.com/w/cpp/thread/latch/max.html",
            "wgPageName": "cpp/thread/latch/max",
            "sample_declaration": "static constexpr std::ptrdiff_t max() noexcept;"
        },
        {
            "title": "std::latch::try_wait",
            "path": "en.cppreference.com/w/cpp/thread/latch/try_wait.html",
            "wgPageName": "cpp/thread/latch/try_wait",
            "sample_declaration": "bool try_wait() const noexcept;"
        },
        {
            "title": "std::latch::wait",
            "path": "en.cppreference.com/w/cpp/thread/latch/wait.html",
            "wgPageName": "cpp/thread/latch/wait",
            "sample_declaration": "void wait() const;"
        },
        {
            "title": "std::launch",
            "path": "en.cppreference.com/w/cpp/thread/launch.html",
            "wgPageName": "cpp/thread/launch",
            "headers": [
                "<future>"
            ],
            "sample_declaration": "enum class launch : /* unspecified */ {\n  async = /* unspecified */,\n  deferred = /* unspecified */,\n  /* implementation-defined */\n};"
        },
        {
            "title": "std::lock_guard",
            "path": "en.cppreference.com/w/cpp/thread/lock_guard.html",
            "wgPageName": "cpp/thread/lock_guard",
            "headers": [
                "<mutex>"
            ],
            "sample_declaration": "template<class Mutex>\nclass lock_guard;"
        },
        {
            "title": "std::lock_guard<Mutex>::~lock_guard",
            "path": "en.cppreference.com/w/cpp/thread/lock_guard/~lock_guard.html",
            "wgPageName": "cpp/thread/lock_guard/~lock_guard",
            "sample_declaration": "~lock_guard();"
        },
        {
            "title": "std::lock_guard<Mutex>::lock_guard",
            "path": "en.cppreference.com/w/cpp/thread/lock_guard/lock_guard.html",
            "wgPageName": "cpp/thread/lock_guard/lock_guard",
            "sample_declaration": "explicit lock_guard(mutex_type& m);",
            "other_declarations": 2
        },
        {
            "title": "std::defer_lock_t, std::try_to_lock_t, std::adopt_lock_t",
            "path": "en.cppreference.com/w/cpp/thread/lock_tag_t.html",
            "wgPageName": "cpp/thread/lock_tag_t",
            "headers": [
                "<mutex>"
            ],
            "sample_declaration": "struct defer_lock_t {\n  explicit defer_lock_t() = default;\n};\nstruct try_to_lock_t {\n  explicit try_to_lock_t() = default;\n};\nstruct adopt_lock_t {\n  explicit adopt_lock_t() = default;\n};"
        },
        {
            "title": "std::defer_lock, std::try_to_lock, std::adopt_lock",
            "path": "en.cppreference.com/w/cpp/thread/lock_tag.html",
            "wgPageName": "cpp/thread/lock_tag",
            "headers": [
                "<mutex>"
            ],
            "sample_declaration": "constexpr std::defer_lock_t defer_lock{};",
            "other_declarations": 5
        },
        {
            "title": "std::lock",
            "path": "en.cppreference.com/w/cpp/thread/lock.html",
            "wgPageName": "cpp/thread/lock",
            "headers": [
                "<mutex>"
            ],
            "sample_declaration": "template<\n    class Lockable1,\n    class Lockable2,\n    class... LockableN>\nvoid lock(\n    Lockable1& lock1,\n    Lockable2& lock2,\n    LockableN&... lockn);"
        },
        {
            "title": "std::mutex",
            "path": "en.cppreference.com/w/cpp/thread/mutex.html",
            "wgPageName": "cpp/thread/mutex",
            "headers": [
                "<mutex>"
            ],
            "sample_declaration": "class mutex;"
        },
        {
            "title": "std::mutex::~mutex",
            "path": "en.cppreference.com/w/cpp/thread/mutex/~mutex.html",
            "wgPageName": "cpp/thread/mutex/~mutex",
            "sample_declaration": "~mutex();"
        },
        {
            "title": "std::mutex::lock",
            "path": "en.cppreference.com/w/cpp/thread/mutex/lock.html",
            "wgPageName": "cpp/thread/mutex/lock",
            "sample_declaration": "void lock();"
        },
        {
            "title": "std::mutex::mutex",
            "path": "en.cppreference.com/w/cpp/thread/mutex/mutex.html",
            "wgPageName": "cpp/thread/mutex/mutex",
            "sample_declaration": "constexpr mutex() noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::mutex::native_handle",
            "path": "en.cppreference.com/w/cpp/thread/mutex/native_handle.html",
            "wgPageName": "cpp/thread/mutex/native_handle",
            "sample_declaration": "native_handle_type native_handle();"
        },
        {
            "title": "std::mutex::try_lock",
            "path": "en.cppreference.com/w/cpp/thread/mutex/try_lock.html",
            "wgPageName": "cpp/thread/mutex/try_lock",
            "sample_declaration": "bool try_lock();"
        },
        {
            "title": "std::mutex::unlock",
            "path": "en.cppreference.com/w/cpp/thread/mutex/unlock.html",
            "wgPageName": "cpp/thread/mutex/unlock",
            "sample_declaration": "void unlock();"
        },
        {
            "title": "std::notify_all_at_thread_exit",
            "path": "en.cppreference.com/w/cpp/thread/notify_all_at_thread_exit.html",
            "wgPageName": "cpp/thread/notify_all_at_thread_exit",
            "headers": [
                "<condition_variable>"
            ],
            "sample_declaration": "void notify_all_at_thread_exit(\n    std::condition_variable& cond,\n    std::unique_lock<std::mutex> lk);"
        },
        {
            "title": "std::once_flag",
            "path": "en.cppreference.com/w/cpp/thread/once_flag.html",
            "wgPageName": "cpp/thread/once_flag",
            "headers": [
                "<mutex>"
            ],
            "sample_declaration": "class once_flag;"
        },
        {
            "title": "std::packaged_task",
            "path": "en.cppreference.com/w/cpp/thread/packaged_task.html",
            "wgPageName": "cpp/thread/packaged_task",
            "headers": [
                "<future>"
            ],
            "sample_declaration": "template<class>\nclass packaged_task;  // not defined",
            "other_declarations": 1
        },
        {
            "title": "std::packaged_task<R(Args...)>::~packaged_task",
            "path": "en.cppreference.com/w/cpp/thread/packaged_task/~packaged_task.html",
            "wgPageName": "cpp/thread/packaged_task/~packaged_task",
            "sample_declaration": "~packaged_task();"
        },
        {
            "title": "deduction guides for std::packaged_task",
            "path": "en.cppreference.com/w/cpp/thread/packaged_task/deduction_guides.html",
            "wgPageName": "cpp/thread/packaged_task/deduction_guides",
            "headers": [
                "<future>"
            ],
            "sample_declaration": "template<class R, class... Args>\npackaged_task(R (*)(Args...))\n    -> packaged_task<R(Args...)>;",
            "other_declarations": 3
        },
        {
            "title": "std::packaged_task<R(Args...)>::get_future",
            "path": "en.cppreference.com/w/cpp/thread/packaged_task/get_future.html",
            "wgPageName": "cpp/thread/packaged_task/get_future",
            "sample_declaration": "std::future<R> get_future();"
        },
        {
            "title": "std::packaged_task<R(Args...)>::make_ready_at_thread_exit",
            "path": "en.cppreference.com/w/cpp/thread/packaged_task/make_ready_at_thread_exit.html",
            "wgPageName": "cpp/thread/packaged_task/make_ready_at_thread_exit",
            "sample_declaration": "void make_ready_at_thread_exit(\n    ArgTypes... args);"
        },
        {
            "title": "std::packaged_task<R(Args...)>::operator()",
            "path": "en.cppreference.com/w/cpp/thread/packaged_task/operator().html",
            "wgPageName": "cpp/thread/packaged_task/operator()",
            "sample_declaration": "void operator()(ArgTypes... args);"
        },
        {
            "title": "std::packaged_task<R(Args...)>::operator=",
            "path": "en.cppreference.com/w/cpp/thread/packaged_task/operator=.html",
            "wgPageName": "cpp/thread/packaged_task/operator=",
            "sample_declaration": "packaged_task& operator=(const packaged_task&) =\n    delete;",
            "other_declarations": 1
        },
        {
            "title": "std::packaged_task<R(Args...)>::packaged_task",
            "path": "en.cppreference.com/w/cpp/thread/packaged_task/packaged_task.html",
            "wgPageName": "cpp/thread/packaged_task/packaged_task",
            "sample_declaration": "packaged_task() noexcept;",
            "other_declarations": 4
        },
        {
            "title": "std::packaged_task<R(Args...)>::reset",
            "path": "en.cppreference.com/w/cpp/thread/packaged_task/reset.html",
            "wgPageName": "cpp/thread/packaged_task/reset",
            "sample_declaration": "void reset();"
        },
        {
            "title": "std::packaged_task<R(Args...)>::swap",
            "path": "en.cppreference.com/w/cpp/thread/packaged_task/swap.html",
            "wgPageName": "cpp/thread/packaged_task/swap",
            "sample_declaration": "void swap(packaged_task& other) noexcept;"
        },
        {
            "title": "std::swap(std::packaged_task)",
            "path": "en.cppreference.com/w/cpp/thread/packaged_task/swap2.html",
            "wgPageName": "cpp/thread/packaged_task/swap2",
            "sample_declaration": "template<class Function, class... Args>\nvoid swap(\n    packaged_task<Function(Args...)>& lhs,\n    packaged_task<Function(Args...)>&\n        rhs) noexcept;"
        },
        {
            "title": "std::uses_allocator<std::packaged_task>",
            "path": "en.cppreference.com/w/cpp/thread/packaged_task/uses_allocator.html",
            "wgPageName": "cpp/thread/packaged_task/uses_allocator",
            "sample_declaration": "template<class R, class Alloc>\nstruct uses_allocator<\n    std::packaged_task<R>,\n    Alloc> : true_type {};"
        },
        {
            "title": "std::packaged_task<R(Args...)>::valid",
            "path": "en.cppreference.com/w/cpp/thread/packaged_task/valid.html",
            "wgPageName": "cpp/thread/packaged_task/valid",
            "sample_declaration": "bool valid() const noexcept;"
        },
        {
            "title": "std::promise",
            "path": "en.cppreference.com/w/cpp/thread/promise.html",
            "wgPageName": "cpp/thread/promise",
            "headers": [
                "<future>"
            ],
            "sample_declaration": "template<class R>\nclass promise;",
            "other_declarations": 2
        },
        {
            "title": "std::promise<R>::~promise",
            "path": "en.cppreference.com/w/cpp/thread/promise/~promise.html",
            "wgPageName": "cpp/thread/promise/~promise",
            "sample_declaration": "~promise();"
        },
        {
            "title": "std::promise<R>::get_future",
            "path": "en.cppreference.com/w/cpp/thread/promise/get_future.html",
            "wgPageName": "cpp/thread/promise/get_future",
            "sample_declaration": "std::future<R> get_future();"
        },
        {
            "title": "std::promise<R>::operator=",
            "path": "en.cppreference.com/w/cpp/thread/promise/operator=.html",
            "wgPageName": "cpp/thread/promise/operator=",
            "sample_declaration": "promise& operator=(promise&& other) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::promise<R>::promise",
            "path": "en.cppreference.com/w/cpp/thread/promise/promise.html",
            "wgPageName": "cpp/thread/promise/promise",
            "sample_declaration": "promise();",
            "other_declarations": 3
        },
        {
            "title": "std::promise<R>::set_exception_at_thread_exit",
            "path": "en.cppreference.com/w/cpp/thread/promise/set_exception_at_thread_exit.html",
            "wgPageName": "cpp/thread/promise/set_exception_at_thread_exit",
            "sample_declaration": "void set_exception_at_thread_exit(\n    std::exception_ptr p);"
        },
        {
            "title": "std::promise<R>::set_exception",
            "path": "en.cppreference.com/w/cpp/thread/promise/set_exception.html",
            "wgPageName": "cpp/thread/promise/set_exception",
            "sample_declaration": "void set_exception(std::exception_ptr p);"
        },
        {
            "title": "std::promise<R>::set_value_at_thread_exit",
            "path": "en.cppreference.com/w/cpp/thread/promise/set_value_at_thread_exit.html",
            "wgPageName": "cpp/thread/promise/set_value_at_thread_exit",
            "sample_declaration": "void set_value_at_thread_exit(const R& value);",
            "other_declarations": 3
        },
        {
            "title": "std::promise<R>::set_value",
            "path": "en.cppreference.com/w/cpp/thread/promise/set_value.html",
            "wgPageName": "cpp/thread/promise/set_value",
            "sample_declaration": "void set_value(const R& value);",
            "other_declarations": 3
        },
        {
            "title": "std::promise<R>::swap",
            "path": "en.cppreference.com/w/cpp/thread/promise/swap.html",
            "wgPageName": "cpp/thread/promise/swap",
            "sample_declaration": "void swap(promise& other) noexcept;"
        },
        {
            "title": "std::swap(std::promise)",
            "path": "en.cppreference.com/w/cpp/thread/promise/swap2.html",
            "wgPageName": "cpp/thread/promise/swap2",
            "headers": [
                "<future>"
            ],
            "sample_declaration": "template<class R>\nvoid swap(\n    promise<R>& lhs,\n    promise<R>& rhs) noexcept;"
        },
        {
            "title": "std::uses_allocator<std::promise>",
            "path": "en.cppreference.com/w/cpp/thread/promise/uses_allocator.html",
            "wgPageName": "cpp/thread/promise/uses_allocator",
            "sample_declaration": "template<class R, class Alloc>\nstruct uses_allocator<std::promise<R>, Alloc>\n    : std::true_type {};"
        },
        {
            "title": "std::recursive_mutex",
            "path": "en.cppreference.com/w/cpp/thread/recursive_mutex.html",
            "wgPageName": "cpp/thread/recursive_mutex",
            "headers": [
                "<mutex>"
            ],
            "sample_declaration": "class recursive_mutex;"
        },
        {
            "title": "std::recursive_mutex::~recursive_mutex",
            "path": "en.cppreference.com/w/cpp/thread/recursive_mutex/~recursive_mutex.html",
            "wgPageName": "cpp/thread/recursive_mutex/~recursive_mutex",
            "sample_declaration": "~recursive_mutex();"
        },
        {
            "title": "std::recursive_mutex::lock",
            "path": "en.cppreference.com/w/cpp/thread/recursive_mutex/lock.html",
            "wgPageName": "cpp/thread/recursive_mutex/lock",
            "sample_declaration": "void lock();"
        },
        {
            "title": "std::recursive_mutex::native_handle",
            "path": "en.cppreference.com/w/cpp/thread/recursive_mutex/native_handle.html",
            "wgPageName": "cpp/thread/recursive_mutex/native_handle",
            "sample_declaration": "native_handle_type native_handle();"
        },
        {
            "title": "std::recursive_mutex::recursive_mutex",
            "path": "en.cppreference.com/w/cpp/thread/recursive_mutex/recursive_mutex.html",
            "wgPageName": "cpp/thread/recursive_mutex/recursive_mutex",
            "sample_declaration": "recursive_mutex();",
            "other_declarations": 1
        },
        {
            "title": "std::recursive_mutex::try_lock",
            "path": "en.cppreference.com/w/cpp/thread/recursive_mutex/try_lock.html",
            "wgPageName": "cpp/thread/recursive_mutex/try_lock",
            "sample_declaration": "bool try_lock();"
        },
        {
            "title": "std::recursive_mutex::unlock",
            "path": "en.cppreference.com/w/cpp/thread/recursive_mutex/unlock.html",
            "wgPageName": "cpp/thread/recursive_mutex/unlock",
            "sample_declaration": "void unlock();"
        },
        {
            "title": "std::recursive_timed_mutex",
            "path": "en.cppreference.com/w/cpp/thread/recursive_timed_mutex.html",
            "wgPageName": "cpp/thread/recursive_timed_mutex",
            "headers": [
                "<mutex>"
            ],
            "sample_declaration": "class recursive_timed_mutex;"
        },
        {
            "title": "std::recursive_timed_mutex::~recursive_timed_mutex",
            "path": "en.cppreference.com/w/cpp/thread/recursive_timed_mutex/~recursive_timed_mutex.html",
            "wgPageName": "cpp/thread/recursive_timed_mutex/~recursive_timed_mutex",
            "sample_declaration": "~recursive_timed_mutex();"
        },
        {
            "title": "std::recursive_timed_mutex::lock",
            "path": "en.cppreference.com/w/cpp/thread/recursive_timed_mutex/lock.html",
            "wgPageName": "cpp/thread/recursive_timed_mutex/lock",
            "sample_declaration": "void lock();"
        },
        {
            "title": "std::recursive_timed_mutex::native_handle",
            "path": "en.cppreference.com/w/cpp/thread/recursive_timed_mutex/native_handle.html",
            "wgPageName": "cpp/thread/recursive_timed_mutex/native_handle",
            "sample_declaration": "native_handle_type native_handle();"
        },
        {
            "title": "std::recursive_timed_mutex::recursive_timed_mutex",
            "path": "en.cppreference.com/w/cpp/thread/recursive_timed_mutex/recursive_timed_mutex.html",
            "wgPageName": "cpp/thread/recursive_timed_mutex/recursive_timed_mutex",
            "sample_declaration": "recursive_timed_mutex();",
            "other_declarations": 1
        },
        {
            "title": "std::recursive_timed_mutex::try_lock_for",
            "path": "en.cppreference.com/w/cpp/thread/recursive_timed_mutex/try_lock_for.html",
            "wgPageName": "cpp/thread/recursive_timed_mutex/try_lock_for",
            "sample_declaration": "template<class Rep, class Period>\nbool try_lock_for(\n    const std::chrono::duration<Rep, Period>&\n        timeout_duration);"
        },
        {
            "title": "std::recursive_timed_mutex::try_lock_until",
            "path": "en.cppreference.com/w/cpp/thread/recursive_timed_mutex/try_lock_until.html",
            "wgPageName": "cpp/thread/recursive_timed_mutex/try_lock_until",
            "sample_declaration": "template<class Clock, class Duration>\nbool try_lock_until(\n    const std::chrono::time_point<\n        Clock,\n        Duration>& timeout_time);"
        },
        {
            "title": "std::recursive_timed_mutex::try_lock",
            "path": "en.cppreference.com/w/cpp/thread/recursive_timed_mutex/try_lock.html",
            "wgPageName": "cpp/thread/recursive_timed_mutex/try_lock",
            "sample_declaration": "bool try_lock();"
        },
        {
            "title": "std::recursive_timed_mutex::unlock",
            "path": "en.cppreference.com/w/cpp/thread/recursive_timed_mutex/unlock.html",
            "wgPageName": "cpp/thread/recursive_timed_mutex/unlock",
            "sample_declaration": "void unlock();"
        },
        {
            "title": "std::scoped_lock",
            "path": "en.cppreference.com/w/cpp/thread/scoped_lock.html",
            "wgPageName": "cpp/thread/scoped_lock",
            "headers": [
                "<mutex>"
            ],
            "sample_declaration": "template<class... MutexTypes>\nclass scoped_lock;"
        },
        {
            "title": "std::scoped_lock<MutexTypes...>::~scoped_lock",
            "path": "en.cppreference.com/w/cpp/thread/scoped_lock/~scoped_lock.html",
            "wgPageName": "cpp/thread/scoped_lock/~scoped_lock",
            "sample_declaration": "~scoped_lock();"
        },
        {
            "title": "std::scoped_lock<MutexTypes...>::scoped_lock",
            "path": "en.cppreference.com/w/cpp/thread/scoped_lock/scoped_lock.html",
            "wgPageName": "cpp/thread/scoped_lock/scoped_lock",
            "sample_declaration": "explicit scoped_lock(MutexTypes&... m);",
            "other_declarations": 2
        },
        {
            "title": "std::shared_future",
            "path": "en.cppreference.com/w/cpp/thread/shared_future.html",
            "wgPageName": "cpp/thread/shared_future",
            "headers": [
                "<future>"
            ],
            "sample_declaration": "template<class T>\nclass shared_future;",
            "other_declarations": 2
        },
        {
            "title": "std::shared_future<T>::~shared_future",
            "path": "en.cppreference.com/w/cpp/thread/shared_future/~shared_future.html",
            "wgPageName": "cpp/thread/shared_future/~shared_future",
            "sample_declaration": "~shared_future();"
        },
        {
            "title": "std::shared_future<T>::get",
            "path": "en.cppreference.com/w/cpp/thread/shared_future/get.html",
            "wgPageName": "cpp/thread/shared_future/get",
            "sample_declaration": "const T& get() const;",
            "other_declarations": 2
        },
        {
            "title": "std::shared_future<T>::operator=",
            "path": "en.cppreference.com/w/cpp/thread/shared_future/operator=.html",
            "wgPageName": "cpp/thread/shared_future/operator=",
            "sample_declaration": "shared_future& operator=(\n    const shared_future& other);",
            "other_declarations": 2
        },
        {
            "title": "std::shared_future<T>::shared_future",
            "path": "en.cppreference.com/w/cpp/thread/shared_future/shared_future.html",
            "wgPageName": "cpp/thread/shared_future/shared_future",
            "sample_declaration": "shared_future() noexcept;",
            "other_declarations": 4
        },
        {
            "title": "std::shared_future<T>::valid",
            "path": "en.cppreference.com/w/cpp/thread/shared_future/valid.html",
            "wgPageName": "cpp/thread/shared_future/valid",
            "sample_declaration": "bool valid() const noexcept;"
        },
        {
            "title": "std::shared_future<T>::wait_for",
            "path": "en.cppreference.com/w/cpp/thread/shared_future/wait_for.html",
            "wgPageName": "cpp/thread/shared_future/wait_for",
            "sample_declaration": "template<class Rep, class Period>\nstd::future_status wait_for(\n    const std::chrono::duration<Rep, Period>&\n        timeout_duration) const;"
        },
        {
            "title": "std::shared_future<T>::wait_until",
            "path": "en.cppreference.com/w/cpp/thread/shared_future/wait_until.html",
            "wgPageName": "cpp/thread/shared_future/wait_until",
            "sample_declaration": "template<class Clock, class Duration>\nstd::future_status wait_until(\n    const std::chrono::time_point<\n        Clock,\n        Duration>& timeout_time) const;"
        },
        {
            "title": "std::shared_future<T>::wait",
            "path": "en.cppreference.com/w/cpp/thread/shared_future/wait.html",
            "wgPageName": "cpp/thread/shared_future/wait",
            "sample_declaration": "void wait() const;"
        },
        {
            "title": "std::shared_lock",
            "path": "en.cppreference.com/w/cpp/thread/shared_lock.html",
            "wgPageName": "cpp/thread/shared_lock",
            "headers": [
                "<shared_mutex>"
            ],
            "sample_declaration": "template<class Mutex>\nclass shared_lock;"
        },
        {
            "title": "std::shared_lock<Mutex>::~shared_lock",
            "path": "en.cppreference.com/w/cpp/thread/shared_lock/~shared_lock.html",
            "wgPageName": "cpp/thread/shared_lock/~shared_lock",
            "sample_declaration": "~shared_lock();"
        },
        {
            "title": "std::shared_lock<Mutex>::lock",
            "path": "en.cppreference.com/w/cpp/thread/shared_lock/lock.html",
            "wgPageName": "cpp/thread/shared_lock/lock",
            "sample_declaration": "void lock();"
        },
        {
            "title": "std::shared_lock<Mutex>::mutex",
            "path": "en.cppreference.com/w/cpp/thread/shared_lock/mutex.html",
            "wgPageName": "cpp/thread/shared_lock/mutex",
            "sample_declaration": "mutex_type* mutex() const noexcept;"
        },
        {
            "title": "std::shared_lock<Mutex>::operator bool",
            "path": "en.cppreference.com/w/cpp/thread/shared_lock/operator_bool.html",
            "wgPageName": "cpp/thread/shared_lock/operator_bool",
            "sample_declaration": "explicit operator bool() const noexcept;"
        },
        {
            "title": "std::shared_lock<Mutex>::operator=",
            "path": "en.cppreference.com/w/cpp/thread/shared_lock/operator=.html",
            "wgPageName": "cpp/thread/shared_lock/operator=",
            "sample_declaration": "shared_lock& operator=(\n    shared_lock&& other) noexcept;"
        },
        {
            "title": "std::shared_lock<Mutex>::owns_lock",
            "path": "en.cppreference.com/w/cpp/thread/shared_lock/owns_lock.html",
            "wgPageName": "cpp/thread/shared_lock/owns_lock",
            "sample_declaration": "bool owns_lock() const noexcept;"
        },
        {
            "title": "std::shared_lock<Mutex>::release",
            "path": "en.cppreference.com/w/cpp/thread/shared_lock/release.html",
            "wgPageName": "cpp/thread/shared_lock/release",
            "sample_declaration": "mutex_type* release() noexcept;"
        },
        {
            "title": "std::shared_lock<Mutex>::shared_lock",
            "path": "en.cppreference.com/w/cpp/thread/shared_lock/shared_lock.html",
            "wgPageName": "cpp/thread/shared_lock/shared_lock",
            "sample_declaration": "shared_lock() noexcept;",
            "other_declarations": 7
        },
        {
            "title": "std::shared_lock<Mutex>::swap",
            "path": "en.cppreference.com/w/cpp/thread/shared_lock/swap.html",
            "wgPageName": "cpp/thread/shared_lock/swap",
            "sample_declaration": "template<class Mutex>\nvoid swap(shared_lock<Mutex>& other) noexcept;"
        },
        {
            "title": "std::swap(std::shared_lock)",
            "path": "en.cppreference.com/w/cpp/thread/shared_lock/swap2.html",
            "wgPageName": "cpp/thread/shared_lock/swap2",
            "sample_declaration": "template<class Mutex>\nvoid swap(\n    shared_lock<Mutex>& lhs,\n    shared_lock<Mutex>& rhs) noexcept;"
        },
        {
            "title": "std::shared_lock<Mutex>::try_lock_for",
            "path": "en.cppreference.com/w/cpp/thread/shared_lock/try_lock_for.html",
            "wgPageName": "cpp/thread/shared_lock/try_lock_for",
            "sample_declaration": "template<class Rep, class Period>\nbool try_lock_for(\n    const std::chrono::duration<Rep, Period>&\n        timeout_duration);"
        },
        {
            "title": "std::shared_lock<Mutex>::try_lock_until",
            "path": "en.cppreference.com/w/cpp/thread/shared_lock/try_lock_until.html",
            "wgPageName": "cpp/thread/shared_lock/try_lock_until",
            "sample_declaration": "template<class Clock, class Duration>\nbool try_lock_until(\n    const std::chrono::time_point<\n        Clock,\n        Duration>& timeout_time);"
        },
        {
            "title": "std::shared_lock<Mutex>::try_lock",
            "path": "en.cppreference.com/w/cpp/thread/shared_lock/try_lock.html",
            "wgPageName": "cpp/thread/shared_lock/try_lock",
            "sample_declaration": "bool try_lock();"
        },
        {
            "title": "std::shared_lock<Mutex>::unlock",
            "path": "en.cppreference.com/w/cpp/thread/shared_lock/unlock.html",
            "wgPageName": "cpp/thread/shared_lock/unlock",
            "sample_declaration": "void unlock();"
        },
        {
            "title": "std::shared_mutex",
            "path": "en.cppreference.com/w/cpp/thread/shared_mutex.html",
            "wgPageName": "cpp/thread/shared_mutex",
            "headers": [
                "<shared_mutex>"
            ],
            "sample_declaration": "class shared_mutex;"
        },
        {
            "title": "std::shared_mutex::~shared_mutex",
            "path": "en.cppreference.com/w/cpp/thread/shared_mutex/~shared_mutex.html",
            "wgPageName": "cpp/thread/shared_mutex/~shared_mutex",
            "sample_declaration": "~shared_mutex();"
        },
        {
            "title": "std::shared_mutex::lock_shared",
            "path": "en.cppreference.com/w/cpp/thread/shared_mutex/lock_shared.html",
            "wgPageName": "cpp/thread/shared_mutex/lock_shared",
            "sample_declaration": "void lock_shared();"
        },
        {
            "title": "std::shared_mutex::lock",
            "path": "en.cppreference.com/w/cpp/thread/shared_mutex/lock.html",
            "wgPageName": "cpp/thread/shared_mutex/lock",
            "sample_declaration": "void lock();"
        },
        {
            "title": "std::shared_mutex::native_handle",
            "path": "en.cppreference.com/w/cpp/thread/shared_mutex/native_handle.html",
            "wgPageName": "cpp/thread/shared_mutex/native_handle",
            "sample_declaration": "native_handle_type native_handle();"
        },
        {
            "title": "std::shared_mutex::shared_mutex",
            "path": "en.cppreference.com/w/cpp/thread/shared_mutex/shared_mutex.html",
            "wgPageName": "cpp/thread/shared_mutex/shared_mutex",
            "sample_declaration": "shared_mutex();",
            "other_declarations": 1
        },
        {
            "title": "std::shared_mutex::try_lock_shared",
            "path": "en.cppreference.com/w/cpp/thread/shared_mutex/try_lock_shared.html",
            "wgPageName": "cpp/thread/shared_mutex/try_lock_shared",
            "sample_declaration": "bool try_lock_shared();"
        },
        {
            "title": "std::shared_mutex::try_lock",
            "path": "en.cppreference.com/w/cpp/thread/shared_mutex/try_lock.html",
            "wgPageName": "cpp/thread/shared_mutex/try_lock",
            "sample_declaration": "bool try_lock();"
        },
        {
            "title": "std::shared_mutex::unlock_shared",
            "path": "en.cppreference.com/w/cpp/thread/shared_mutex/unlock_shared.html",
            "wgPageName": "cpp/thread/shared_mutex/unlock_shared",
            "sample_declaration": "void unlock_shared();"
        },
        {
            "title": "std::shared_mutex::unlock",
            "path": "en.cppreference.com/w/cpp/thread/shared_mutex/unlock.html",
            "wgPageName": "cpp/thread/shared_mutex/unlock",
            "sample_declaration": "void unlock();"
        },
        {
            "title": "std::shared_timed_mutex",
            "path": "en.cppreference.com/w/cpp/thread/shared_timed_mutex.html",
            "wgPageName": "cpp/thread/shared_timed_mutex",
            "headers": [
                "<shared_mutex>"
            ],
            "sample_declaration": "class shared_timed_mutex;"
        },
        {
            "title": "std::shared_timed_mutex::~shared_timed_mutex",
            "path": "en.cppreference.com/w/cpp/thread/shared_timed_mutex/~shared_timed_mutex.html",
            "wgPageName": "cpp/thread/shared_timed_mutex/~shared_timed_mutex",
            "sample_declaration": "~shared_timed_mutex();"
        },
        {
            "title": "std::shared_timed_mutex::lock_shared",
            "path": "en.cppreference.com/w/cpp/thread/shared_timed_mutex/lock_shared.html",
            "wgPageName": "cpp/thread/shared_timed_mutex/lock_shared",
            "sample_declaration": "void lock_shared();"
        },
        {
            "title": "std::shared_timed_mutex::lock",
            "path": "en.cppreference.com/w/cpp/thread/shared_timed_mutex/lock.html",
            "wgPageName": "cpp/thread/shared_timed_mutex/lock",
            "sample_declaration": "void lock();"
        },
        {
            "title": "std::shared_timed_mutex::shared_timed_mutex",
            "path": "en.cppreference.com/w/cpp/thread/shared_timed_mutex/shared_timed_mutex.html",
            "wgPageName": "cpp/thread/shared_timed_mutex/shared_timed_mutex",
            "sample_declaration": "shared_timed_mutex();",
            "other_declarations": 1
        },
        {
            "title": "std::shared_timed_mutex::try_lock_for",
            "path": "en.cppreference.com/w/cpp/thread/shared_timed_mutex/try_lock_for.html",
            "wgPageName": "cpp/thread/shared_timed_mutex/try_lock_for",
            "sample_declaration": "template<class Rep, class Period>\nbool try_lock_for(\n    const std::chrono::duration<Rep, Period>&\n        timeout_duration);"
        },
        {
            "title": "std::shared_timed_mutex::try_lock_shared_for",
            "path": "en.cppreference.com/w/cpp/thread/shared_timed_mutex/try_lock_shared_for.html",
            "wgPageName": "cpp/thread/shared_timed_mutex/try_lock_shared_for",
            "sample_declaration": "template<class Rep, class Period>\nbool try_lock_shared_for(\n    const std::chrono::duration<Rep, Period>&\n        timeout_duration);"
        },
        {
            "title": "std::shared_timed_mutex::try_lock_shared_until",
            "path": "en.cppreference.com/w/cpp/thread/shared_timed_mutex/try_lock_shared_until.html",
            "wgPageName": "cpp/thread/shared_timed_mutex/try_lock_shared_until",
            "sample_declaration": "template<class Clock, class Duration>\nbool try_lock_shared_until(\n    const std::chrono::time_point<\n        Clock,\n        Duration>& timeout_time);"
        },
        {
            "title": "std::shared_timed_mutex::try_lock_shared",
            "path": "en.cppreference.com/w/cpp/thread/shared_timed_mutex/try_lock_shared.html",
            "wgPageName": "cpp/thread/shared_timed_mutex/try_lock_shared",
            "sample_declaration": "bool try_lock_shared();"
        },
        {
            "title": "std::shared_timed_mutex::try_lock_until",
            "path": "en.cppreference.com/w/cpp/thread/shared_timed_mutex/try_lock_until.html",
            "wgPageName": "cpp/thread/shared_timed_mutex/try_lock_until",
            "sample_declaration": "template<class Clock, class Duration>\nbool try_lock_until(\n    const std::chrono::time_point<\n        Clock,\n        Duration>& timeout_time);"
        },
        {
            "title": "std::shared_timed_mutex::try_lock",
            "path": "en.cppreference.com/w/cpp/thread/shared_timed_mutex/try_lock.html",
            "wgPageName": "cpp/thread/shared_timed_mutex/try_lock",
            "sample_declaration": "bool try_lock();"
        },
        {
            "title": "std::shared_timed_mutex::unlock_shared",
            "path": "en.cppreference.com/w/cpp/thread/shared_timed_mutex/unlock_shared.html",
            "wgPageName": "cpp/thread/shared_timed_mutex/unlock_shared",
            "sample_declaration": "void unlock_shared();"
        },
        {
            "title": "std::shared_timed_mutex::unlock",
            "path": "en.cppreference.com/w/cpp/thread/shared_timed_mutex/unlock.html",
            "wgPageName": "cpp/thread/shared_timed_mutex/unlock",
            "sample_declaration": "void unlock();"
        },
        {
            "title": "std::this_thread::sleep_for",
            "path": "en.cppreference.com/w/cpp/thread/sleep_for.html",
            "wgPageName": "cpp/thread/sleep_for",
            "headers": [
                "<thread>"
            ],
            "sample_declaration": "template<class Rep, class Period>\nvoid sleep_for(\n    const std::chrono::duration<Rep, Period>&\n        sleep_duration);"
        },
        {
            "title": "std::this_thread::sleep_until",
            "path": "en.cppreference.com/w/cpp/thread/sleep_until.html",
            "wgPageName": "cpp/thread/sleep_until",
            "headers": [
                "<thread>"
            ],
            "sample_declaration": "template<class Clock, class Duration>\nvoid sleep_until(const std::chrono::time_point<\n                 Clock,\n                 Duration>& sleep_time);"
        },
        {
            "title": "std::stop_callback",
            "path": "en.cppreference.com/w/cpp/thread/stop_callback.html",
            "wgPageName": "cpp/thread/stop_callback",
            "headers": [
                "<stop_token>"
            ],
            "sample_declaration": "template<class Callback>\nclass stop_callback;"
        },
        {
            "title": "std::stop_callback<Callback>::~stop_callback",
            "path": "en.cppreference.com/w/cpp/thread/stop_callback/~stop_callback.html",
            "wgPageName": "cpp/thread/stop_callback/~stop_callback",
            "sample_declaration": "~stop_callback();"
        },
        {
            "title": "deduction guides for std::stop_callback",
            "path": "en.cppreference.com/w/cpp/thread/stop_callback/deduction_guides.html",
            "wgPageName": "cpp/thread/stop_callback/deduction_guides",
            "headers": [
                "<stop_token>"
            ],
            "sample_declaration": "template<class Callback>\nstop_callback(std::stop_token, Callback)\n    -> stop_callback<Callback>;"
        },
        {
            "title": "std::stop_callback<Callback>::stop_callback",
            "path": "en.cppreference.com/w/cpp/thread/stop_callback/stop_callback.html",
            "wgPageName": "cpp/thread/stop_callback/stop_callback",
            "sample_declaration": "template<class C>\nexplicit stop_callback(\n    const std::stop_token& st,\n    C&& cb) noexcept(/*see below*/);",
            "other_declarations": 3
        },
        {
            "title": "std::stop_source",
            "path": "en.cppreference.com/w/cpp/thread/stop_source.html",
            "wgPageName": "cpp/thread/stop_source",
            "headers": [
                "<stop_token>"
            ],
            "sample_declaration": "class stop_source;"
        },
        {
            "title": "std::stop_source::~stop_source",
            "path": "en.cppreference.com/w/cpp/thread/stop_source/~stop_source.html",
            "wgPageName": "cpp/thread/stop_source/~stop_source",
            "sample_declaration": "~stop_source();"
        },
        {
            "title": "std::stop_source::get_token",
            "path": "en.cppreference.com/w/cpp/thread/stop_source/get_token.html",
            "wgPageName": "cpp/thread/stop_source/get_token",
            "sample_declaration": "[[nodiscard]] std::stop_token get_token()\n    const noexcept;"
        },
        {
            "title": "std::nostopstate_t",
            "path": "en.cppreference.com/w/cpp/thread/stop_source/nostopstate_t.html",
            "wgPageName": "cpp/thread/stop_source/nostopstate_t",
            "headers": [
                "<stop_token>"
            ],
            "sample_declaration": "struct nostopstate_t {\n  explicit nostopstate_t() = default;\n};"
        },
        {
            "title": "std::nostopstate",
            "path": "en.cppreference.com/w/cpp/thread/stop_source/nostopstate.html",
            "wgPageName": "cpp/thread/stop_source/nostopstate",
            "headers": [
                "<stop_token>"
            ],
            "sample_declaration": "inline constexpr std::nostopstate_t\n    nostopstate{};"
        },
        {
            "title": "operator==(std::stop_source)",
            "path": "en.cppreference.com/w/cpp/thread/stop_source/operator_cmp.html",
            "wgPageName": "cpp/thread/stop_source/operator_cmp",
            "sample_declaration": "[[nodiscard]] friend bool operator==(\n    const stop_source& lhs,\n    const stop_source& rhs) noexcept;"
        },
        {
            "title": "std::stop_source::operator=",
            "path": "en.cppreference.com/w/cpp/thread/stop_source/operator=.html",
            "wgPageName": "cpp/thread/stop_source/operator=",
            "sample_declaration": "std::stop_source& operator=(\n    const std::stop_source& other) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::stop_source::request_stop",
            "path": "en.cppreference.com/w/cpp/thread/stop_source/request_stop.html",
            "wgPageName": "cpp/thread/stop_source/request_stop",
            "sample_declaration": "bool request_stop() noexcept;"
        },
        {
            "title": "std::stop_source::stop_possible",
            "path": "en.cppreference.com/w/cpp/thread/stop_source/stop_possible.html",
            "wgPageName": "cpp/thread/stop_source/stop_possible",
            "sample_declaration": "[[nodiscard]] bool stop_possible()\n    const noexcept;"
        },
        {
            "title": "std::stop_source::stop_requested",
            "path": "en.cppreference.com/w/cpp/thread/stop_source/stop_requested.html",
            "wgPageName": "cpp/thread/stop_source/stop_requested",
            "sample_declaration": "[[nodiscard]] bool stop_requested()\n    const noexcept;"
        },
        {
            "title": "std::stop_source::stop_source",
            "path": "en.cppreference.com/w/cpp/thread/stop_source/stop_source.html",
            "wgPageName": "cpp/thread/stop_source/stop_source",
            "sample_declaration": "stop_source();",
            "other_declarations": 3
        },
        {
            "title": "std::stop_source::swap",
            "path": "en.cppreference.com/w/cpp/thread/stop_source/swap.html",
            "wgPageName": "cpp/thread/stop_source/swap",
            "sample_declaration": "void swap(std::stop_source& other) noexcept;"
        },
        {
            "title": "swap(std::stop_source)",
            "path": "en.cppreference.com/w/cpp/thread/stop_source/swap2.html",
            "wgPageName": "cpp/thread/stop_source/swap2",
            "sample_declaration": "friend void swap(\n    stop_source& lhs,\n    stop_source& rhs) noexcept;"
        },
        {
            "title": "std::stop_token",
            "path": "en.cppreference.com/w/cpp/thread/stop_token.html",
            "wgPageName": "cpp/thread/stop_token",
            "headers": [
                "<stop_token>"
            ],
            "sample_declaration": "class stop_token;"
        },
        {
            "title": "std::stop_token::~stop_token",
            "path": "en.cppreference.com/w/cpp/thread/stop_token/~stop_token.html",
            "wgPageName": "cpp/thread/stop_token/~stop_token",
            "sample_declaration": "~stop_token();"
        },
        {
            "title": "operator==(std::stop_token)",
            "path": "en.cppreference.com/w/cpp/thread/stop_token/operator_cmp.html",
            "wgPageName": "cpp/thread/stop_token/operator_cmp",
            "sample_declaration": "[[nodiscard]] friend bool operator==(\n    const stop_token& lhs,\n    const stop_token& rhs) noexcept;"
        },
        {
            "title": "std::stop_token::operator=",
            "path": "en.cppreference.com/w/cpp/thread/stop_token/operator=.html",
            "wgPageName": "cpp/thread/stop_token/operator=",
            "sample_declaration": "std::stop_token& operator=(\n    const std::stop_token& other) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::stop_token::stop_possible",
            "path": "en.cppreference.com/w/cpp/thread/stop_token/stop_possible.html",
            "wgPageName": "cpp/thread/stop_token/stop_possible",
            "sample_declaration": "[[nodiscard]] bool stop_possible()\n    const noexcept;"
        },
        {
            "title": "std::stop_token::stop_requested",
            "path": "en.cppreference.com/w/cpp/thread/stop_token/stop_requested.html",
            "wgPageName": "cpp/thread/stop_token/stop_requested",
            "sample_declaration": "[[nodiscard]] bool stop_requested()\n    const noexcept;"
        },
        {
            "title": "std::stop_token::stop_token",
            "path": "en.cppreference.com/w/cpp/thread/stop_token/stop_token.html",
            "wgPageName": "cpp/thread/stop_token/stop_token",
            "sample_declaration": "stop_token() noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::stop_token::swap",
            "path": "en.cppreference.com/w/cpp/thread/stop_token/swap.html",
            "wgPageName": "cpp/thread/stop_token/swap",
            "sample_declaration": "void swap(std::stop_token& other) noexcept;"
        },
        {
            "title": "swap(std::stop_token)",
            "path": "en.cppreference.com/w/cpp/thread/stop_token/swap2.html",
            "wgPageName": "cpp/thread/stop_token/swap2",
            "sample_declaration": "friend void swap(\n    stop_token& lhs,\n    stop_token& rhs) noexcept;"
        },
        {
            "title": "std::thread",
            "path": "en.cppreference.com/w/cpp/thread/thread.html",
            "wgPageName": "cpp/thread/thread",
            "headers": [
                "<thread>"
            ],
            "sample_declaration": "class thread;"
        },
        {
            "title": "std::thread::~thread",
            "path": "en.cppreference.com/w/cpp/thread/thread/~thread.html",
            "wgPageName": "cpp/thread/thread/~thread",
            "sample_declaration": "~thread();"
        },
        {
            "title": "std::thread::detach",
            "path": "en.cppreference.com/w/cpp/thread/thread/detach.html",
            "wgPageName": "cpp/thread/thread/detach",
            "sample_declaration": "void detach();"
        },
        {
            "title": "std::thread::get_id",
            "path": "en.cppreference.com/w/cpp/thread/thread/get_id.html",
            "wgPageName": "cpp/thread/thread/get_id",
            "sample_declaration": "std::thread::id get_id() const noexcept;"
        },
        {
            "title": "std::thread::hardware_concurrency",
            "path": "en.cppreference.com/w/cpp/thread/thread/hardware_concurrency.html",
            "wgPageName": "cpp/thread/thread/hardware_concurrency",
            "sample_declaration": "static unsigned int\nhardware_concurrency() noexcept;"
        },
        {
            "title": "std::thread::id",
            "path": "en.cppreference.com/w/cpp/thread/thread/id.html",
            "wgPageName": "cpp/thread/thread/id",
            "headers": [
                "<thread>"
            ],
            "sample_declaration": "class thread::id;"
        },
        {
            "title": "std::hash<std::thread::id>",
            "path": "en.cppreference.com/w/cpp/thread/thread/id/hash.html",
            "wgPageName": "cpp/thread/thread/id/hash",
            "headers": [
                "<thread>"
            ],
            "sample_declaration": "template<>\nstruct hash<std::thread::id>;"
        },
        {
            "title": "std::thread::id::id",
            "path": "en.cppreference.com/w/cpp/thread/thread/id/id.html",
            "wgPageName": "cpp/thread/thread/id/id",
            "sample_declaration": "id() noexcept;"
        },
        {
            "title": "operator==,!=,<,<=,>,>=,<=>(std::thread::id)",
            "path": "en.cppreference.com/w/cpp/thread/thread/id/operator_cmp.html",
            "wgPageName": "cpp/thread/thread/id/operator_cmp",
            "headers": [
                "<thread>"
            ],
            "sample_declaration": "bool operator==(\n    std::thread::id lhs,\n    std::thread::id rhs) noexcept;",
            "other_declarations": 6
        },
        {
            "title": "operator<<(std::thread::id)",
            "path": "en.cppreference.com/w/cpp/thread/thread/id/operator_ltlt.html",
            "wgPageName": "cpp/thread/thread/id/operator_ltlt",
            "headers": [
                "<thread>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& ost,\n    std::thread::id id);"
        },
        {
            "title": "std::thread::join",
            "path": "en.cppreference.com/w/cpp/thread/thread/join.html",
            "wgPageName": "cpp/thread/thread/join",
            "sample_declaration": "void join();"
        },
        {
            "title": "std::thread::joinable",
            "path": "en.cppreference.com/w/cpp/thread/thread/joinable.html",
            "wgPageName": "cpp/thread/thread/joinable",
            "sample_declaration": "bool joinable() const noexcept;"
        },
        {
            "title": "std::thread::native_handle",
            "path": "en.cppreference.com/w/cpp/thread/thread/native_handle.html",
            "wgPageName": "cpp/thread/thread/native_handle",
            "sample_declaration": "native_handle_type native_handle();"
        },
        {
            "title": "std::thread::operator=",
            "path": "en.cppreference.com/w/cpp/thread/thread/operator=.html",
            "wgPageName": "cpp/thread/thread/operator=",
            "sample_declaration": "thread& operator=(thread&& other) noexcept;"
        },
        {
            "title": "std::thread::swap",
            "path": "en.cppreference.com/w/cpp/thread/thread/swap.html",
            "wgPageName": "cpp/thread/thread/swap",
            "sample_declaration": "void swap(std::thread& other) noexcept;"
        },
        {
            "title": "std::swap(std::thread)",
            "path": "en.cppreference.com/w/cpp/thread/thread/swap2.html",
            "wgPageName": "cpp/thread/thread/swap2",
            "sample_declaration": "void swap(\n    std::thread& lhs,\n    std::thread& rhs) noexcept;"
        },
        {
            "title": "std::thread::thread",
            "path": "en.cppreference.com/w/cpp/thread/thread/thread.html",
            "wgPageName": "cpp/thread/thread/thread",
            "sample_declaration": "thread() noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::timed_mutex",
            "path": "en.cppreference.com/w/cpp/thread/timed_mutex.html",
            "wgPageName": "cpp/thread/timed_mutex",
            "headers": [
                "<mutex>"
            ],
            "sample_declaration": "class timed_mutex;"
        },
        {
            "title": "std::timed_mutex::~timed_mutex",
            "path": "en.cppreference.com/w/cpp/thread/timed_mutex/~timed_mutex.html",
            "wgPageName": "cpp/thread/timed_mutex/~timed_mutex",
            "sample_declaration": "~timed_mutex();"
        },
        {
            "title": "std::timed_mutex::lock",
            "path": "en.cppreference.com/w/cpp/thread/timed_mutex/lock.html",
            "wgPageName": "cpp/thread/timed_mutex/lock",
            "sample_declaration": "void lock();"
        },
        {
            "title": "std::timed_mutex::native_handle",
            "path": "en.cppreference.com/w/cpp/thread/timed_mutex/native_handle.html",
            "wgPageName": "cpp/thread/timed_mutex/native_handle",
            "sample_declaration": "native_handle_type native_handle();"
        },
        {
            "title": "std::timed_mutex::timed_mutex",
            "path": "en.cppreference.com/w/cpp/thread/timed_mutex/timed_mutex.html",
            "wgPageName": "cpp/thread/timed_mutex/timed_mutex",
            "sample_declaration": "timed_mutex();",
            "other_declarations": 1
        },
        {
            "title": "std::timed_mutex::try_lock_for",
            "path": "en.cppreference.com/w/cpp/thread/timed_mutex/try_lock_for.html",
            "wgPageName": "cpp/thread/timed_mutex/try_lock_for",
            "sample_declaration": "template<class Rep, class Period>\nbool try_lock_for(\n    const std::chrono::duration<Rep, Period>&\n        timeout_duration);"
        },
        {
            "title": "std::timed_mutex::try_lock_until",
            "path": "en.cppreference.com/w/cpp/thread/timed_mutex/try_lock_until.html",
            "wgPageName": "cpp/thread/timed_mutex/try_lock_until",
            "sample_declaration": "template<class Clock, class Duration>\nbool try_lock_until(\n    const std::chrono::time_point<\n        Clock,\n        Duration>& timeout_time);"
        },
        {
            "title": "std::timed_mutex::try_lock",
            "path": "en.cppreference.com/w/cpp/thread/timed_mutex/try_lock.html",
            "wgPageName": "cpp/thread/timed_mutex/try_lock",
            "sample_declaration": "bool try_lock();"
        },
        {
            "title": "std::timed_mutex::unlock",
            "path": "en.cppreference.com/w/cpp/thread/timed_mutex/unlock.html",
            "wgPageName": "cpp/thread/timed_mutex/unlock",
            "sample_declaration": "void unlock();"
        },
        {
            "title": "std::try_lock",
            "path": "en.cppreference.com/w/cpp/thread/try_lock.html",
            "wgPageName": "cpp/thread/try_lock",
            "headers": [
                "<mutex>"
            ],
            "sample_declaration": "template<\n    class Lockable1,\n    class Lockable2,\n    class... LockableN>\nint try_lock(\n    Lockable1& lock1,\n    Lockable2& lock2,\n    LockableN&... lockn);"
        },
        {
            "title": "std::unique_lock",
            "path": "en.cppreference.com/w/cpp/thread/unique_lock.html",
            "wgPageName": "cpp/thread/unique_lock",
            "headers": [
                "<mutex>"
            ],
            "sample_declaration": "template<class Mutex>\nclass unique_lock;"
        },
        {
            "title": "std::unique_lock<Mutex>::~unique_lock",
            "path": "en.cppreference.com/w/cpp/thread/unique_lock/~unique_lock.html",
            "wgPageName": "cpp/thread/unique_lock/~unique_lock",
            "sample_declaration": "~unique_lock();"
        },
        {
            "title": "std::unique_lock<Mutex>::lock",
            "path": "en.cppreference.com/w/cpp/thread/unique_lock/lock.html",
            "wgPageName": "cpp/thread/unique_lock/lock",
            "sample_declaration": "void lock();"
        },
        {
            "title": "std::unique_lock<Mutex>::mutex",
            "path": "en.cppreference.com/w/cpp/thread/unique_lock/mutex.html",
            "wgPageName": "cpp/thread/unique_lock/mutex",
            "sample_declaration": "mutex_type* mutex() const noexcept;"
        },
        {
            "title": "std::unique_lock<Mutex>::operator bool",
            "path": "en.cppreference.com/w/cpp/thread/unique_lock/operator_bool.html",
            "wgPageName": "cpp/thread/unique_lock/operator_bool",
            "sample_declaration": "explicit operator bool() const noexcept;"
        },
        {
            "title": "std::unique_lock<Mutex>::operator=",
            "path": "en.cppreference.com/w/cpp/thread/unique_lock/operator=.html",
            "wgPageName": "cpp/thread/unique_lock/operator=",
            "sample_declaration": "unique_lock& operator=(unique_lock&& other);"
        },
        {
            "title": "std::unique_lock<Mutex>::owns_lock",
            "path": "en.cppreference.com/w/cpp/thread/unique_lock/owns_lock.html",
            "wgPageName": "cpp/thread/unique_lock/owns_lock",
            "sample_declaration": "bool owns_lock() const noexcept;"
        },
        {
            "title": "std::unique_lock<Mutex>::release",
            "path": "en.cppreference.com/w/cpp/thread/unique_lock/release.html",
            "wgPageName": "cpp/thread/unique_lock/release",
            "sample_declaration": "mutex_type* release() noexcept;"
        },
        {
            "title": "std::unique_lock<Mutex>::swap",
            "path": "en.cppreference.com/w/cpp/thread/unique_lock/swap.html",
            "wgPageName": "cpp/thread/unique_lock/swap",
            "sample_declaration": "void swap(unique_lock& other) noexcept;"
        },
        {
            "title": "std::swap(std::unique_lock)",
            "path": "en.cppreference.com/w/cpp/thread/unique_lock/swap2.html",
            "wgPageName": "cpp/thread/unique_lock/swap2",
            "sample_declaration": "template<class Mutex>\nvoid swap(\n    unique_lock<Mutex>& lhs,\n    unique_lock<Mutex>& rhs) noexcept;"
        },
        {
            "title": "std::unique_lock<Mutex>::try_lock_for",
            "path": "en.cppreference.com/w/cpp/thread/unique_lock/try_lock_for.html",
            "wgPageName": "cpp/thread/unique_lock/try_lock_for",
            "sample_declaration": "template<class Rep, class Period>\nbool try_lock_for(\n    const std::chrono::duration<Rep, Period>&\n        timeout_duration);"
        },
        {
            "title": "std::unique_lock<Mutex>::try_lock_until",
            "path": "en.cppreference.com/w/cpp/thread/unique_lock/try_lock_until.html",
            "wgPageName": "cpp/thread/unique_lock/try_lock_until",
            "sample_declaration": "template<class Clock, class Duration>\nbool try_lock_until(\n    const std::chrono::time_point<\n        Clock,\n        Duration>& timeout_time);"
        },
        {
            "title": "std::unique_lock<Mutex>::try_lock",
            "path": "en.cppreference.com/w/cpp/thread/unique_lock/try_lock.html",
            "wgPageName": "cpp/thread/unique_lock/try_lock",
            "sample_declaration": "bool try_lock();"
        },
        {
            "title": "std::unique_lock<Mutex>::unique_lock",
            "path": "en.cppreference.com/w/cpp/thread/unique_lock/unique_lock.html",
            "wgPageName": "cpp/thread/unique_lock/unique_lock",
            "sample_declaration": "unique_lock() noexcept;",
            "other_declarations": 7
        },
        {
            "title": "std::unique_lock<Mutex>::unlock",
            "path": "en.cppreference.com/w/cpp/thread/unique_lock/unlock.html",
            "wgPageName": "cpp/thread/unique_lock/unlock",
            "sample_declaration": "void unlock();"
        },
        {
            "title": "std::this_thread::yield",
            "path": "en.cppreference.com/w/cpp/thread/yield.html",
            "wgPageName": "cpp/thread/yield",
            "headers": [
                "<thread>"
            ],
            "sample_declaration": "void yield() noexcept;"
        },
        {
            "title": "Type support (basic types, RTTI)",
            "path": "en.cppreference.com/w/cpp/types.html",
            "wgPageName": "cpp/types"
        },
        {
            "title": "std::add_cv, std::add_const, std::add_volatile",
            "path": "en.cppreference.com/w/cpp/types/add_cv.html",
            "wgPageName": "cpp/types/add_cv",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct add_cv;",
            "other_declarations": 2
        },
        {
            "title": "std::add_pointer",
            "path": "en.cppreference.com/w/cpp/types/add_pointer.html",
            "wgPageName": "cpp/types/add_pointer",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct add_pointer;"
        },
        {
            "title": "std::add_lvalue_reference, std::add_rvalue_reference",
            "path": "en.cppreference.com/w/cpp/types/add_reference.html",
            "wgPageName": "cpp/types/add_reference",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct add_lvalue_reference;",
            "other_declarations": 1
        },
        {
            "title": "std::aligned_storage",
            "path": "en.cppreference.com/w/cpp/types/aligned_storage.html",
            "wgPageName": "cpp/types/aligned_storage",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<\n    std::size_t Len,\n    std::size_t Align = /*default-alignment*/>\nstruct aligned_storage;"
        },
        {
            "title": "std::aligned_union",
            "path": "en.cppreference.com/w/cpp/types/aligned_union.html",
            "wgPageName": "cpp/types/aligned_union",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<std::size_t Len, class... Types>\nstruct aligned_union;"
        },
        {
            "title": "std::alignment_of",
            "path": "en.cppreference.com/w/cpp/types/alignment_of.html",
            "wgPageName": "cpp/types/alignment_of",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct alignment_of;"
        },
        {
            "title": "std::bad_cast",
            "path": "en.cppreference.com/w/cpp/types/bad_cast.html",
            "wgPageName": "cpp/types/bad_cast",
            "headers": [
                "<typeinfo>"
            ],
            "sample_declaration": "class bad_cast : public std::exception;"
        },
        {
            "title": "std::bad_typeid",
            "path": "en.cppreference.com/w/cpp/types/bad_typeid.html",
            "wgPageName": "cpp/types/bad_typeid",
            "headers": [
                "<typeinfo>"
            ],
            "sample_declaration": "class bad_typeid : public std::exception;"
        },
        {
            "title": "std::byte",
            "path": "en.cppreference.com/w/cpp/types/byte.html",
            "wgPageName": "cpp/types/byte",
            "headers": [
                "<cstddef>"
            ],
            "sample_declaration": "enum class byte : unsigned char {};"
        },
        {
            "title": "C numeric limits interface",
            "path": "en.cppreference.com/w/cpp/types/climits.html",
            "wgPageName": "cpp/types/climits"
        },
        {
            "title": "FLT_EVAL_METHOD",
            "path": "en.cppreference.com/w/cpp/types/climits/FLT_EVAL_METHOD.html",
            "wgPageName": "cpp/types/climits/FLT_EVAL_METHOD",
            "headers": [
                "<cfloat>"
            ],
            "sample_declaration": "#define FLT_EVAL_METHOD /* implementation \\\n                           defined */"
        },
        {
            "title": "FLT_ROUNDS",
            "path": "en.cppreference.com/w/cpp/types/climits/FLT_ROUNDS.html",
            "wgPageName": "cpp/types/climits/FLT_ROUNDS",
            "headers": [
                "<cfloat>"
            ],
            "sample_declaration": "#define FLT_ROUNDS /* implementation defined \\\n                    */"
        },
        {
            "title": "std::common_reference",
            "path": "en.cppreference.com/w/cpp/types/common_reference.html",
            "wgPageName": "cpp/types/common_reference",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class... T>\nstruct common_reference;"
        },
        {
            "title": "std::common_type",
            "path": "en.cppreference.com/w/cpp/types/common_type.html",
            "wgPageName": "cpp/types/common_type",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class... T>\nstruct common_type;"
        },
        {
            "title": "std::conditional",
            "path": "en.cppreference.com/w/cpp/types/conditional.html",
            "wgPageName": "cpp/types/conditional",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<bool B, class T, class F>\nstruct conditional;"
        },
        {
            "title": "std::conjunction",
            "path": "en.cppreference.com/w/cpp/types/conjunction.html",
            "wgPageName": "cpp/types/conjunction",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class... B>\nstruct conjunction;"
        },
        {
            "title": "std::decay",
            "path": "en.cppreference.com/w/cpp/types/decay.html",
            "wgPageName": "cpp/types/decay",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct decay;"
        },
        {
            "title": "std::disjunction",
            "path": "en.cppreference.com/w/cpp/types/disjunction.html",
            "wgPageName": "cpp/types/disjunction",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class... B>\nstruct disjunction;"
        },
        {
            "title": "std::enable_if",
            "path": "en.cppreference.com/w/cpp/types/enable_if.html",
            "wgPageName": "cpp/types/enable_if",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<bool B, class T = void>\nstruct enable_if;"
        },
        {
            "title": "std::endian",
            "path": "en.cppreference.com/w/cpp/types/endian.html",
            "wgPageName": "cpp/types/endian",
            "headers": [
                "<bit>"
            ],
            "sample_declaration": "enum class endian {\n  little = /*implementation-defined*/,\n  big = /*implementation-defined*/,\n  native = /*implementation-defined*/\n};"
        },
        {
            "title": "std::extent",
            "path": "en.cppreference.com/w/cpp/types/extent.html",
            "wgPageName": "cpp/types/extent",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T, unsigned N = 0>\nstruct extent;"
        },
        {
            "title": "Fixed width floating-point types (since C++23)",
            "path": "en.cppreference.com/w/cpp/types/floating-point.html",
            "wgPageName": "cpp/types/floating-point"
        },
        {
            "title": "std::has_unique_object_representations",
            "path": "en.cppreference.com/w/cpp/types/has_unique_object_representations.html",
            "wgPageName": "cpp/types/has_unique_object_representations",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct has_unique_object_representations;"
        },
        {
            "title": "std::has_virtual_destructor",
            "path": "en.cppreference.com/w/cpp/types/has_virtual_destructor.html",
            "wgPageName": "cpp/types/has_virtual_destructor",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct has_virtual_destructor;"
        },
        {
            "title": "Fixed width integer types (since C++11)",
            "path": "en.cppreference.com/w/cpp/types/integer.html",
            "wgPageName": "cpp/types/integer"
        },
        {
            "title": "std::integral_constant",
            "path": "en.cppreference.com/w/cpp/types/integral_constant.html",
            "wgPageName": "cpp/types/integral_constant",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T, T v>\nstruct integral_constant;"
        },
        {
            "title": "std::is_abstract",
            "path": "en.cppreference.com/w/cpp/types/is_abstract.html",
            "wgPageName": "cpp/types/is_abstract",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_abstract;"
        },
        {
            "title": "std::is_aggregate",
            "path": "en.cppreference.com/w/cpp/types/is_aggregate.html",
            "wgPageName": "cpp/types/is_aggregate",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_aggregate;"
        },
        {
            "title": "std::is_arithmetic",
            "path": "en.cppreference.com/w/cpp/types/is_arithmetic.html",
            "wgPageName": "cpp/types/is_arithmetic",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_arithmetic;"
        },
        {
            "title": "std::is_array",
            "path": "en.cppreference.com/w/cpp/types/is_array.html",
            "wgPageName": "cpp/types/is_array",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_array;"
        },
        {
            "title": "std::is_assignable, std::is_trivially_assignable, std::is_nothrow_assignable",
            "path": "en.cppreference.com/w/cpp/types/is_assignable.html",
            "wgPageName": "cpp/types/is_assignable",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T, class U>\nstruct is_assignable;",
            "other_declarations": 2
        },
        {
            "title": "std::is_base_of",
            "path": "en.cppreference.com/w/cpp/types/is_base_of.html",
            "wgPageName": "cpp/types/is_base_of",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class Base, class Derived>\nstruct is_base_of;"
        },
        {
            "title": "std::is_bounded_array",
            "path": "en.cppreference.com/w/cpp/types/is_bounded_array.html",
            "wgPageName": "cpp/types/is_bounded_array",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_bounded_array;"
        },
        {
            "title": "std::is_class",
            "path": "en.cppreference.com/w/cpp/types/is_class.html",
            "wgPageName": "cpp/types/is_class",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_class;"
        },
        {
            "title": "std::is_compound",
            "path": "en.cppreference.com/w/cpp/types/is_compound.html",
            "wgPageName": "cpp/types/is_compound",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_compound;"
        },
        {
            "title": "std::is_const",
            "path": "en.cppreference.com/w/cpp/types/is_const.html",
            "wgPageName": "cpp/types/is_const",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_const;"
        },
        {
            "title": "std::is_constant_evaluated",
            "path": "en.cppreference.com/w/cpp/types/is_constant_evaluated.html",
            "wgPageName": "cpp/types/is_constant_evaluated",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "constexpr bool is_constant_evaluated() noexcept;"
        },
        {
            "title": "std::is_constructible, std::is_trivially_constructible, std::is_nothrow_constructible",
            "path": "en.cppreference.com/w/cpp/types/is_constructible.html",
            "wgPageName": "cpp/types/is_constructible",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T, class... Args>\nstruct is_constructible;",
            "other_declarations": 2
        },
        {
            "title": "std::is_convertible, std::is_nothrow_convertible",
            "path": "en.cppreference.com/w/cpp/types/is_convertible.html",
            "wgPageName": "cpp/types/is_convertible",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class From, class To>\nstruct is_convertible;",
            "other_declarations": 1
        },
        {
            "title": "std::is_copy_assignable, std::is_trivially_copy_assignable, std::is_nothrow_copy_assignable",
            "path": "en.cppreference.com/w/cpp/types/is_copy_assignable.html",
            "wgPageName": "cpp/types/is_copy_assignable",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_copy_assignable;",
            "other_declarations": 2
        },
        {
            "title": "std::is_copy_constructible, std::is_trivially_copy_constructible, std::is_nothrow_copy_constructible",
            "path": "en.cppreference.com/w/cpp/types/is_copy_constructible.html",
            "wgPageName": "cpp/types/is_copy_constructible",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_copy_constructible;",
            "other_declarations": 2
        },
        {
            "title": "std::is_corresponding_member",
            "path": "en.cppreference.com/w/cpp/types/is_corresponding_member.html",
            "wgPageName": "cpp/types/is_corresponding_member",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class S1, class S2, class M1, class M2>\nconstexpr bool is_corresponding_member(\n    M1 S1::*mp,\n    M2 S2::*mq) noexcept;"
        },
        {
            "title": "std::is_default_constructible, std::is_trivially_default_constructible, std::is_nothrow_default_constructible",
            "path": "en.cppreference.com/w/cpp/types/is_default_constructible.html",
            "wgPageName": "cpp/types/is_default_constructible",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_default_constructible;",
            "other_declarations": 2
        },
        {
            "title": "std::is_destructible, std::is_trivially_destructible, std::is_nothrow_destructible",
            "path": "en.cppreference.com/w/cpp/types/is_destructible.html",
            "wgPageName": "cpp/types/is_destructible",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_destructible;",
            "other_declarations": 2
        },
        {
            "title": "std::is_empty",
            "path": "en.cppreference.com/w/cpp/types/is_empty.html",
            "wgPageName": "cpp/types/is_empty",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_empty;"
        },
        {
            "title": "std::is_enum",
            "path": "en.cppreference.com/w/cpp/types/is_enum.html",
            "wgPageName": "cpp/types/is_enum",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_enum;"
        },
        {
            "title": "std::is_final",
            "path": "en.cppreference.com/w/cpp/types/is_final.html",
            "wgPageName": "cpp/types/is_final",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_final;"
        },
        {
            "title": "std::is_floating_point",
            "path": "en.cppreference.com/w/cpp/types/is_floating_point.html",
            "wgPageName": "cpp/types/is_floating_point",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_floating_point;"
        },
        {
            "title": "std::is_function",
            "path": "en.cppreference.com/w/cpp/types/is_function.html",
            "wgPageName": "cpp/types/is_function",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_function;"
        },
        {
            "title": "std::is_fundamental",
            "path": "en.cppreference.com/w/cpp/types/is_fundamental.html",
            "wgPageName": "cpp/types/is_fundamental",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_fundamental;"
        },
        {
            "title": "std::is_integral",
            "path": "en.cppreference.com/w/cpp/types/is_integral.html",
            "wgPageName": "cpp/types/is_integral",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_integral;"
        },
        {
            "title": "std::is_invocable, std::is_invocable_r, std::is_nothrow_invocable, std::is_nothrow_invocable_r",
            "path": "en.cppreference.com/w/cpp/types/is_invocable.html",
            "wgPageName": "cpp/types/is_invocable",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class Fn, class... ArgTypes>\nstruct is_invocable;",
            "other_declarations": 3
        },
        {
            "title": "std::is_layout_compatible",
            "path": "en.cppreference.com/w/cpp/types/is_layout_compatible.html",
            "wgPageName": "cpp/types/is_layout_compatible",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T, class U>\nstruct is_layout_compatible;"
        },
        {
            "title": "std::is_literal_type",
            "path": "en.cppreference.com/w/cpp/types/is_literal_type.html",
            "wgPageName": "cpp/types/is_literal_type",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_literal_type;"
        },
        {
            "title": "std::is_lvalue_reference",
            "path": "en.cppreference.com/w/cpp/types/is_lvalue_reference.html",
            "wgPageName": "cpp/types/is_lvalue_reference",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_lvalue_reference;"
        },
        {
            "title": "std::is_member_function_pointer",
            "path": "en.cppreference.com/w/cpp/types/is_member_function_pointer.html",
            "wgPageName": "cpp/types/is_member_function_pointer",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_member_function_pointer;"
        },
        {
            "title": "std::is_member_object_pointer",
            "path": "en.cppreference.com/w/cpp/types/is_member_object_pointer.html",
            "wgPageName": "cpp/types/is_member_object_pointer",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_member_object_pointer;"
        },
        {
            "title": "std::is_member_pointer",
            "path": "en.cppreference.com/w/cpp/types/is_member_pointer.html",
            "wgPageName": "cpp/types/is_member_pointer",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_member_pointer;"
        },
        {
            "title": "std::is_move_assignable, std::is_trivially_move_assignable, std::is_nothrow_move_assignable",
            "path": "en.cppreference.com/w/cpp/types/is_move_assignable.html",
            "wgPageName": "cpp/types/is_move_assignable",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_move_assignable;",
            "other_declarations": 2
        },
        {
            "title": "std::is_move_constructible, std::is_trivially_move_constructible, std::is_nothrow_move_constructible",
            "path": "en.cppreference.com/w/cpp/types/is_move_constructible.html",
            "wgPageName": "cpp/types/is_move_constructible",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_move_constructible;",
            "other_declarations": 2
        },
        {
            "title": "std::is_null_pointer",
            "path": "en.cppreference.com/w/cpp/types/is_null_pointer.html",
            "wgPageName": "cpp/types/is_null_pointer",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_null_pointer;"
        },
        {
            "title": "std::is_object",
            "path": "en.cppreference.com/w/cpp/types/is_object.html",
            "wgPageName": "cpp/types/is_object",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_object;"
        },
        {
            "title": "std::is_pod",
            "path": "en.cppreference.com/w/cpp/types/is_pod.html",
            "wgPageName": "cpp/types/is_pod",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_pod;"
        },
        {
            "title": "std::is_pointer_interconvertible_base_of",
            "path": "en.cppreference.com/w/cpp/types/is_pointer_interconvertible_base_of.html",
            "wgPageName": "cpp/types/is_pointer_interconvertible_base_of",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class Base, class Derived>\nstruct is_pointer_interconvertible_base_of;"
        },
        {
            "title": "std::is_pointer_interconvertible_with_class",
            "path": "en.cppreference.com/w/cpp/types/is_pointer_interconvertible_with_class.html",
            "wgPageName": "cpp/types/is_pointer_interconvertible_with_class",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class S, class M>\nconstexpr bool\nis_pointer_interconvertible_with_class(\n    M S::*mp) noexcept;"
        },
        {
            "title": "std::is_pointer",
            "path": "en.cppreference.com/w/cpp/types/is_pointer.html",
            "wgPageName": "cpp/types/is_pointer",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_pointer;"
        },
        {
            "title": "std::is_polymorphic",
            "path": "en.cppreference.com/w/cpp/types/is_polymorphic.html",
            "wgPageName": "cpp/types/is_polymorphic",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_polymorphic;"
        },
        {
            "title": "std::is_reference",
            "path": "en.cppreference.com/w/cpp/types/is_reference.html",
            "wgPageName": "cpp/types/is_reference",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_reference;"
        },
        {
            "title": "std::is_rvalue_reference",
            "path": "en.cppreference.com/w/cpp/types/is_rvalue_reference.html",
            "wgPageName": "cpp/types/is_rvalue_reference",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_rvalue_reference;"
        },
        {
            "title": "std::is_same",
            "path": "en.cppreference.com/w/cpp/types/is_same.html",
            "wgPageName": "cpp/types/is_same",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T, class U>\nstruct is_same;"
        },
        {
            "title": "std::is_scalar",
            "path": "en.cppreference.com/w/cpp/types/is_scalar.html",
            "wgPageName": "cpp/types/is_scalar",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_scalar;"
        },
        {
            "title": "std::is_scoped_enum",
            "path": "en.cppreference.com/w/cpp/types/is_scoped_enum.html",
            "wgPageName": "cpp/types/is_scoped_enum",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_scoped_enum;"
        },
        {
            "title": "std::is_signed",
            "path": "en.cppreference.com/w/cpp/types/is_signed.html",
            "wgPageName": "cpp/types/is_signed",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_signed;"
        },
        {
            "title": "std::is_standard_layout",
            "path": "en.cppreference.com/w/cpp/types/is_standard_layout.html",
            "wgPageName": "cpp/types/is_standard_layout",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_standard_layout;"
        },
        {
            "title": "std::is_swappable_with, std::is_swappable, std::is_nothrow_swappable_with, std::is_nothrow_swappable",
            "path": "en.cppreference.com/w/cpp/types/is_swappable.html",
            "wgPageName": "cpp/types/is_swappable",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T, class U>\nstruct is_swappable_with;",
            "other_declarations": 3
        },
        {
            "title": "std::is_trivial",
            "path": "en.cppreference.com/w/cpp/types/is_trivial.html",
            "wgPageName": "cpp/types/is_trivial",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_trivial;"
        },
        {
            "title": "std::is_trivially_copyable",
            "path": "en.cppreference.com/w/cpp/types/is_trivially_copyable.html",
            "wgPageName": "cpp/types/is_trivially_copyable",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_trivially_copyable;"
        },
        {
            "title": "std::is_unbounded_array",
            "path": "en.cppreference.com/w/cpp/types/is_unbounded_array.html",
            "wgPageName": "cpp/types/is_unbounded_array",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_unbounded_array;"
        },
        {
            "title": "std::is_union",
            "path": "en.cppreference.com/w/cpp/types/is_union.html",
            "wgPageName": "cpp/types/is_union",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_union;"
        },
        {
            "title": "std::is_unsigned",
            "path": "en.cppreference.com/w/cpp/types/is_unsigned.html",
            "wgPageName": "cpp/types/is_unsigned",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_unsigned;"
        },
        {
            "title": "std::is_void",
            "path": "en.cppreference.com/w/cpp/types/is_void.html",
            "wgPageName": "cpp/types/is_void",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_void;"
        },
        {
            "title": "std::is_volatile",
            "path": "en.cppreference.com/w/cpp/types/is_volatile.html",
            "wgPageName": "cpp/types/is_volatile",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct is_volatile;"
        },
        {
            "title": "std::make_signed",
            "path": "en.cppreference.com/w/cpp/types/make_signed.html",
            "wgPageName": "cpp/types/make_signed",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct make_signed;"
        },
        {
            "title": "std::make_unsigned",
            "path": "en.cppreference.com/w/cpp/types/make_unsigned.html",
            "wgPageName": "cpp/types/make_unsigned",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct make_unsigned;"
        },
        {
            "title": "std::max_align_t",
            "path": "en.cppreference.com/w/cpp/types/max_align_t.html",
            "wgPageName": "cpp/types/max_align_t",
            "headers": [
                "<cstddef>"
            ],
            "sample_declaration": "typedef /*implementation-defined*/ max_align_t;"
        },
        {
            "title": "std::negation",
            "path": "en.cppreference.com/w/cpp/types/negation.html",
            "wgPageName": "cpp/types/negation",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class B>\nstruct negation;"
        },
        {
            "title": "NULL",
            "path": "en.cppreference.com/w/cpp/types/NULL.html",
            "wgPageName": "cpp/types/NULL",
            "headers": [
                "<clocale>",
                "<cstddef>",
                "<cstdio>",
                "<cstdlib>",
                "<cstring>",
                "<ctime>",
                "<cwchar>"
            ],
            "sample_declaration": "#define NULL /*implementation-defined*/"
        },
        {
            "title": "std::nullptr_t",
            "path": "en.cppreference.com/w/cpp/types/nullptr_t.html",
            "wgPageName": "cpp/types/nullptr_t",
            "headers": [
                "<cstddef>"
            ],
            "sample_declaration": "using nullptr_t = decltype(nullptr);"
        },
        {
            "title": "std::numeric_limits",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits.html",
            "wgPageName": "cpp/types/numeric_limits",
            "headers": [
                "<limits>"
            ],
            "sample_declaration": "template<class T>\nclass numeric_limits;"
        },
        {
            "title": "std::numeric_limits<T>::denorm_min",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/denorm_min.html",
            "wgPageName": "cpp/types/numeric_limits/denorm_min",
            "sample_declaration": "static T denorm_min() throw();",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::digits",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/digits.html",
            "wgPageName": "cpp/types/numeric_limits/digits",
            "sample_declaration": "static const int digits;",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::digits10",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/digits10.html",
            "wgPageName": "cpp/types/numeric_limits/digits10",
            "sample_declaration": "static const int digits10;",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::epsilon",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/epsilon.html",
            "wgPageName": "cpp/types/numeric_limits/epsilon",
            "sample_declaration": "static T epsilon() throw();",
            "other_declarations": 1
        },
        {
            "title": "std::float_denorm_style",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/float_denorm_style.html",
            "wgPageName": "cpp/types/numeric_limits/float_denorm_style",
            "headers": [
                "<limits>"
            ],
            "sample_declaration": "enum float_denorm_style {\n  denorm_indeterminate = -1,\n  denorm_absent = 0,\n  denorm_present = 1\n};"
        },
        {
            "title": "std::float_round_style",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/float_round_style.html",
            "wgPageName": "cpp/types/numeric_limits/float_round_style",
            "headers": [
                "<limits>"
            ],
            "sample_declaration": "enum float_round_style {\n  round_indeterminate = -1,\n  round_toward_zero = 0,\n  round_to_nearest = 1,\n  round_toward_infinity = 2,\n  round_toward_neg_infinity = 3\n};"
        },
        {
            "title": "std::numeric_limits<T>::has_denorm_loss",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/has_denorm_loss.html",
            "wgPageName": "cpp/types/numeric_limits/has_denorm_loss",
            "sample_declaration": "static const bool has_denorm_loss;",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::has_denorm",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/has_denorm.html",
            "wgPageName": "cpp/types/numeric_limits/has_denorm",
            "sample_declaration": "static const std::float_denorm_style has_denorm;",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::has_infinity",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/has_infinity.html",
            "wgPageName": "cpp/types/numeric_limits/has_infinity",
            "sample_declaration": "static const bool has_infinity;",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::has_quiet_NaN",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/has_quiet_NaN.html",
            "wgPageName": "cpp/types/numeric_limits/has_quiet_NaN",
            "sample_declaration": "static const bool has_quiet_NaN;",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::has_signaling_NaN",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/has_signaling_NaN.html",
            "wgPageName": "cpp/types/numeric_limits/has_signaling_NaN",
            "sample_declaration": "static const bool has_signaling_NaN;",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::infinity",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/infinity.html",
            "wgPageName": "cpp/types/numeric_limits/infinity",
            "sample_declaration": "static T infinity() throw();",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::is_bounded",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/is_bounded.html",
            "wgPageName": "cpp/types/numeric_limits/is_bounded",
            "sample_declaration": "static const bool is_bounded;",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::is_exact",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/is_exact.html",
            "wgPageName": "cpp/types/numeric_limits/is_exact",
            "sample_declaration": "static const bool is_exact;",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::is_iec559",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/is_iec559.html",
            "wgPageName": "cpp/types/numeric_limits/is_iec559",
            "sample_declaration": "static const bool is_iec559;",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::is_integer",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/is_integer.html",
            "wgPageName": "cpp/types/numeric_limits/is_integer",
            "sample_declaration": "static const bool is_integer;",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::is_modulo",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/is_modulo.html",
            "wgPageName": "cpp/types/numeric_limits/is_modulo",
            "sample_declaration": "static const bool is_modulo;",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::is_signed",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/is_signed.html",
            "wgPageName": "cpp/types/numeric_limits/is_signed",
            "sample_declaration": "static const bool is_signed;",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::is_specialized",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/is_specialized.html",
            "wgPageName": "cpp/types/numeric_limits/is_specialized",
            "sample_declaration": "static const bool is_specialized;",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::lowest",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/lowest.html",
            "wgPageName": "cpp/types/numeric_limits/lowest",
            "sample_declaration": "static constexpr T lowest() noexcept;"
        },
        {
            "title": "std::numeric_limits<T>::max_digits10",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/max_digits10.html",
            "wgPageName": "cpp/types/numeric_limits/max_digits10",
            "sample_declaration": "static constexpr int max_digits10"
        },
        {
            "title": "std::numeric_limits<T>::max_exponent",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/max_exponent.html",
            "wgPageName": "cpp/types/numeric_limits/max_exponent",
            "sample_declaration": "static const int max_exponent;",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::max_exponent10",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/max_exponent10.html",
            "wgPageName": "cpp/types/numeric_limits/max_exponent10",
            "sample_declaration": "static const int max_exponent10;",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::max",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/max.html",
            "wgPageName": "cpp/types/numeric_limits/max",
            "headers": [
                "<limits>"
            ],
            "sample_declaration": "static T max() throw();",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::min_exponent",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/min_exponent.html",
            "wgPageName": "cpp/types/numeric_limits/min_exponent",
            "sample_declaration": "static const int min_exponent;",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::min_exponent10",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/min_exponent10.html",
            "wgPageName": "cpp/types/numeric_limits/min_exponent10",
            "sample_declaration": "static const int min_exponent10;",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::min",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/min.html",
            "wgPageName": "cpp/types/numeric_limits/min",
            "headers": [
                "<limits>"
            ],
            "sample_declaration": "static T min() throw();",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::quiet_NaN",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/quiet_NaN.html",
            "wgPageName": "cpp/types/numeric_limits/quiet_NaN",
            "sample_declaration": "static T quiet_NaN() throw();",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::radix",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/radix.html",
            "wgPageName": "cpp/types/numeric_limits/radix",
            "sample_declaration": "static const int radix;",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::round_error",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/round_error.html",
            "wgPageName": "cpp/types/numeric_limits/round_error",
            "sample_declaration": "static T round_error() throw();",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::round_style",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/round_style.html",
            "wgPageName": "cpp/types/numeric_limits/round_style",
            "sample_declaration": "static const std::float_round_style round_style;",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::signaling_NaN",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/signaling_NaN.html",
            "wgPageName": "cpp/types/numeric_limits/signaling_NaN",
            "sample_declaration": "static T signaling_NaN() throw();",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::tinyness_before",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/tinyness_before.html",
            "wgPageName": "cpp/types/numeric_limits/tinyness_before",
            "sample_declaration": "static const bool tinyness_before;",
            "other_declarations": 1
        },
        {
            "title": "std::numeric_limits<T>::traps",
            "path": "en.cppreference.com/w/cpp/types/numeric_limits/traps.html",
            "wgPageName": "cpp/types/numeric_limits/traps",
            "sample_declaration": "static const bool traps;",
            "other_declarations": 1
        },
        {
            "title": "offsetof",
            "path": "en.cppreference.com/w/cpp/types/offsetof.html",
            "wgPageName": "cpp/types/offsetof",
            "headers": [
                "<cstddef>"
            ],
            "sample_declaration": "#define offsetof( \\\n    type, member) /*implementation-defined*/"
        },
        {
            "title": "std::ptrdiff_t",
            "path": "en.cppreference.com/w/cpp/types/ptrdiff_t.html",
            "wgPageName": "cpp/types/ptrdiff_t",
            "headers": [
                "<cstddef>"
            ],
            "sample_declaration": "typedef /*implementation-defined*/ ptrdiff_t;"
        },
        {
            "title": "std::rank",
            "path": "en.cppreference.com/w/cpp/types/rank.html",
            "wgPageName": "cpp/types/rank",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct rank;"
        },
        {
            "title": "std::reference_constructs_from_temporary",
            "path": "en.cppreference.com/w/cpp/types/reference_constructs_from_temporary.html",
            "wgPageName": "cpp/types/reference_constructs_from_temporary",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T, class U>\nstruct reference_constructs_from_temporary;"
        },
        {
            "title": "std::reference_converts_from_temporary",
            "path": "en.cppreference.com/w/cpp/types/reference_converts_from_temporary.html",
            "wgPageName": "cpp/types/reference_converts_from_temporary",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T, class U>\nstruct reference_converts_from_temporary;"
        },
        {
            "title": "std::remove_all_extents",
            "path": "en.cppreference.com/w/cpp/types/remove_all_extents.html",
            "wgPageName": "cpp/types/remove_all_extents",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct remove_all_extents;"
        },
        {
            "title": "std::remove_cv, std::remove_const, std::remove_volatile",
            "path": "en.cppreference.com/w/cpp/types/remove_cv.html",
            "wgPageName": "cpp/types/remove_cv",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct remove_cv;",
            "other_declarations": 2
        },
        {
            "title": "std::remove_cvref",
            "path": "en.cppreference.com/w/cpp/types/remove_cvref.html",
            "wgPageName": "cpp/types/remove_cvref",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct remove_cvref;"
        },
        {
            "title": "std::remove_extent",
            "path": "en.cppreference.com/w/cpp/types/remove_extent.html",
            "wgPageName": "cpp/types/remove_extent",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct remove_extent;"
        },
        {
            "title": "std::remove_pointer",
            "path": "en.cppreference.com/w/cpp/types/remove_pointer.html",
            "wgPageName": "cpp/types/remove_pointer",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct remove_pointer;"
        },
        {
            "title": "std::remove_reference",
            "path": "en.cppreference.com/w/cpp/types/remove_reference.html",
            "wgPageName": "cpp/types/remove_reference",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct remove_reference;"
        },
        {
            "title": "std::result_of, std::invoke_result",
            "path": "en.cppreference.com/w/cpp/types/result_of.html",
            "wgPageName": "cpp/types/result_of",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class>\nclass result_of;  // not defined template< class\n                  // F, class... ArgTypes >\n                  // class\n                  // result_of<F(ArgTypes...)>;",
            "other_declarations": 1
        },
        {
            "title": "std::size_t",
            "path": "en.cppreference.com/w/cpp/types/size_t.html",
            "wgPageName": "cpp/types/size_t",
            "headers": [
                "<cstddef>",
                "<cstdio>",
                "<cstdlib>",
                "<cstring>",
                "<ctime>",
                "<cuchar>",
                "<cwchar>"
            ],
            "sample_declaration": "typedef /*implementation-defined*/ size_t;"
        },
        {
            "title": "std::type_identity",
            "path": "en.cppreference.com/w/cpp/types/type_identity.html",
            "wgPageName": "cpp/types/type_identity",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct type_identity;"
        },
        {
            "title": "std::type_index",
            "path": "en.cppreference.com/w/cpp/types/type_index.html",
            "wgPageName": "cpp/types/type_index",
            "headers": [
                "<typeindex>"
            ],
            "sample_declaration": "class type_index;"
        },
        {
            "title": "std::type_index::hash_code",
            "path": "en.cppreference.com/w/cpp/types/type_index/hash_code.html",
            "wgPageName": "cpp/types/type_index/hash_code",
            "sample_declaration": "std::size_t hash_code() const noexcept;"
        },
        {
            "title": "std::hash<std::type_index>",
            "path": "en.cppreference.com/w/cpp/types/type_index/hash.html",
            "wgPageName": "cpp/types/type_index/hash",
            "headers": [
                "<typeindex>"
            ],
            "sample_declaration": "template<>\nstruct hash<type_index>;"
        },
        {
            "title": "std::type_index::name",
            "path": "en.cppreference.com/w/cpp/types/type_index/name.html",
            "wgPageName": "cpp/types/type_index/name",
            "sample_declaration": "const char* name() const noexcept;"
        },
        {
            "title": "std::type_index::operator==,!=,<,<=,>,>=,<=>",
            "path": "en.cppreference.com/w/cpp/types/type_index/operator_cmp.html",
            "wgPageName": "cpp/types/type_index/operator_cmp",
            "sample_declaration": "bool operator==(\n    const type_index& rhs) const noexcept;",
            "other_declarations": 6
        },
        {
            "title": "std::type_index::type_index",
            "path": "en.cppreference.com/w/cpp/types/type_index/type_index.html",
            "wgPageName": "cpp/types/type_index/type_index",
            "sample_declaration": "type_index(const std::type_info& info) noexcept;"
        },
        {
            "title": "std::type_info",
            "path": "en.cppreference.com/w/cpp/types/type_info.html",
            "wgPageName": "cpp/types/type_info",
            "headers": [
                "<typeinfo>"
            ],
            "sample_declaration": "class type_info;"
        },
        {
            "title": "std::type_info::~type_info",
            "path": "en.cppreference.com/w/cpp/types/type_info/~type_info.html",
            "wgPageName": "cpp/types/type_info/~type_info",
            "sample_declaration": "virtual ~type_info();"
        },
        {
            "title": "std::type_info::before",
            "path": "en.cppreference.com/w/cpp/types/type_info/before.html",
            "wgPageName": "cpp/types/type_info/before",
            "sample_declaration": "bool before(const type_info& rhs) const;",
            "other_declarations": 1
        },
        {
            "title": "std::type_info::hash_code",
            "path": "en.cppreference.com/w/cpp/types/type_info/hash_code.html",
            "wgPageName": "cpp/types/type_info/hash_code",
            "sample_declaration": "std::size_t hash_code() const noexcept;"
        },
        {
            "title": "std::type_info::name",
            "path": "en.cppreference.com/w/cpp/types/type_info/name.html",
            "wgPageName": "cpp/types/type_info/name",
            "sample_declaration": "const char* name() const;",
            "other_declarations": 1
        },
        {
            "title": "std::type_info::operator==, std::type_info::operator!=",
            "path": "en.cppreference.com/w/cpp/types/type_info/operator_cmp.html",
            "wgPageName": "cpp/types/type_info/operator_cmp",
            "sample_declaration": "bool operator==(const type_info& rhs) const;",
            "other_declarations": 4
        },
        {
            "title": "std::underlying_type",
            "path": "en.cppreference.com/w/cpp/types/underlying_type.html",
            "wgPageName": "cpp/types/underlying_type",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class T>\nstruct underlying_type;"
        },
        {
            "title": "std::void_t",
            "path": "en.cppreference.com/w/cpp/types/void_t.html",
            "wgPageName": "cpp/types/void_t",
            "headers": [
                "<type_traits>"
            ],
            "sample_declaration": "template<class...>\nusing void_t = void;"
        },
        {
            "title": "Utility library",
            "path": "en.cppreference.com/w/cpp/utility.html",
            "wgPageName": "cpp/utility"
        },
        {
            "title": "std::any",
            "path": "en.cppreference.com/w/cpp/utility/any.html",
            "wgPageName": "cpp/utility/any",
            "headers": [
                "<any>"
            ],
            "sample_declaration": "class any;"
        },
        {
            "title": "std::any::~any",
            "path": "en.cppreference.com/w/cpp/utility/any/~any.html",
            "wgPageName": "cpp/utility/any/~any",
            "sample_declaration": "~any();"
        },
        {
            "title": "std::any_cast",
            "path": "en.cppreference.com/w/cpp/utility/any/any_cast.html",
            "wgPageName": "cpp/utility/any/any_cast",
            "sample_declaration": "template<class T>\nT any_cast(const any& operand);",
            "other_declarations": 4
        },
        {
            "title": "std::any::any",
            "path": "en.cppreference.com/w/cpp/utility/any/any.html",
            "wgPageName": "cpp/utility/any/any",
            "sample_declaration": "constexpr any() noexcept;",
            "other_declarations": 5
        },
        {
            "title": "std::bad_any_cast",
            "path": "en.cppreference.com/w/cpp/utility/any/bad_any_cast.html",
            "wgPageName": "cpp/utility/any/bad_any_cast",
            "headers": [
                "<any>"
            ],
            "sample_declaration": "class bad_any_cast : public std::bad_cast;"
        },
        {
            "title": "std::any::emplace",
            "path": "en.cppreference.com/w/cpp/utility/any/emplace.html",
            "wgPageName": "cpp/utility/any/emplace",
            "sample_declaration": "template<class ValueType, class... Args>\nstd::decay_t<ValueType>& emplace(\n    Args&&... args);",
            "other_declarations": 1
        },
        {
            "title": "std::any::has_value",
            "path": "en.cppreference.com/w/cpp/utility/any/has_value.html",
            "wgPageName": "cpp/utility/any/has_value",
            "sample_declaration": "bool has_value() const noexcept;"
        },
        {
            "title": "std::make_any",
            "path": "en.cppreference.com/w/cpp/utility/any/make_any.html",
            "wgPageName": "cpp/utility/any/make_any",
            "sample_declaration": "template<class T, class... Args>\nstd::any make_any(Args&&... args);",
            "other_declarations": 1
        },
        {
            "title": "std::any::operator=",
            "path": "en.cppreference.com/w/cpp/utility/any/operator=.html",
            "wgPageName": "cpp/utility/any/operator=",
            "sample_declaration": "any& operator=(const any& rhs);",
            "other_declarations": 2
        },
        {
            "title": "std::any::reset",
            "path": "en.cppreference.com/w/cpp/utility/any/reset.html",
            "wgPageName": "cpp/utility/any/reset",
            "sample_declaration": "void reset() noexcept;"
        },
        {
            "title": "std::any::swap",
            "path": "en.cppreference.com/w/cpp/utility/any/swap.html",
            "wgPageName": "cpp/utility/any/swap",
            "sample_declaration": "void swap(any& other) noexcept;"
        },
        {
            "title": "std::swap(std::any)",
            "path": "en.cppreference.com/w/cpp/utility/any/swap2.html",
            "wgPageName": "cpp/utility/any/swap2",
            "sample_declaration": "void swap(any& lhs, any& rhs) noexcept;"
        },
        {
            "title": "std::any::type",
            "path": "en.cppreference.com/w/cpp/utility/any/type.html",
            "wgPageName": "cpp/utility/any/type",
            "sample_declaration": "const std::type_info& type() const noexcept;"
        },
        {
            "title": "std::apply",
            "path": "en.cppreference.com/w/cpp/utility/apply.html",
            "wgPageName": "cpp/utility/apply",
            "headers": [
                "<tuple>"
            ],
            "sample_declaration": "template<class F, class Tuple>\nconstexpr decltype(auto) apply(\n    F&& f,\n    Tuple&& t);",
            "other_declarations": 1
        },
        {
            "title": "std::as_const",
            "path": "en.cppreference.com/w/cpp/utility/as_const.html",
            "wgPageName": "cpp/utility/as_const",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "template<class T>\nconstexpr std::add_const_t<T>& as_const(\n    T& t) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_stacktrace",
            "path": "en.cppreference.com/w/cpp/utility/basic_stacktrace.html",
            "wgPageName": "cpp/utility/basic_stacktrace",
            "headers": [
                "<stacktrace>"
            ],
            "sample_declaration": "template<class Allocator>\nclass basic_stacktrace;",
            "other_declarations": 2
        },
        {
            "title": "std::basic_stacktrace<Allocator>::~basic_stacktrace",
            "path": "en.cppreference.com/w/cpp/utility/basic_stacktrace/~basic_stacktrace.html",
            "wgPageName": "cpp/utility/basic_stacktrace/~basic_stacktrace",
            "sample_declaration": "~basic_stacktrace();"
        },
        {
            "title": "std::basic_stacktrace<Allocator>::at",
            "path": "en.cppreference.com/w/cpp/utility/basic_stacktrace/at.html",
            "wgPageName": "cpp/utility/basic_stacktrace/at",
            "sample_declaration": "const_reference at(size_type pos) const;"
        },
        {
            "title": "std::basic_stacktrace<Allocator>::basic_stacktrace",
            "path": "en.cppreference.com/w/cpp/utility/basic_stacktrace/basic_stacktrace.html",
            "wgPageName": "cpp/utility/basic_stacktrace/basic_stacktrace",
            "sample_declaration": "basic_stacktrace() noexcept(/* see below */);",
            "other_declarations": 5
        },
        {
            "title": "std::basic_stacktrace<Allocator>::begin, std::basic_stacktrace<Allocator>::cbegin",
            "path": "en.cppreference.com/w/cpp/utility/basic_stacktrace/begin.html",
            "wgPageName": "cpp/utility/basic_stacktrace/begin",
            "sample_declaration": "const_iterator begin() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_stacktrace<Allocator>::current",
            "path": "en.cppreference.com/w/cpp/utility/basic_stacktrace/current.html",
            "wgPageName": "cpp/utility/basic_stacktrace/current",
            "sample_declaration": "static basic_stacktrace current(\n    const allocator_type& alloc =\n        allocator_type()) noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::basic_stacktrace<Allocator>::empty",
            "path": "en.cppreference.com/w/cpp/utility/basic_stacktrace/empty.html",
            "wgPageName": "cpp/utility/basic_stacktrace/empty",
            "sample_declaration": "[[nodiscard]] bool empty() const noexcept;"
        },
        {
            "title": "std::basic_stacktrace<Allocator>::end, std::basic_stacktrace<Allocator>::cend",
            "path": "en.cppreference.com/w/cpp/utility/basic_stacktrace/end.html",
            "wgPageName": "cpp/utility/basic_stacktrace/end",
            "sample_declaration": "const_iterator end() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_stacktrace<Allocator>::get_allocator",
            "path": "en.cppreference.com/w/cpp/utility/basic_stacktrace/get_allocator.html",
            "wgPageName": "cpp/utility/basic_stacktrace/get_allocator",
            "sample_declaration": "allocator_type get_allocator() const noexcept;"
        },
        {
            "title": "std::hash(std::basic_stacktrace)",
            "path": "en.cppreference.com/w/cpp/utility/basic_stacktrace/hash.html",
            "wgPageName": "cpp/utility/basic_stacktrace/hash",
            "headers": [
                "<stacktrace>"
            ],
            "sample_declaration": "template<class Allocator>\nstruct hash<std::basic_stacktrace<Allocator>>;"
        },
        {
            "title": "std::basic_stacktrace<Allocator>::max_size",
            "path": "en.cppreference.com/w/cpp/utility/basic_stacktrace/max_size.html",
            "wgPageName": "cpp/utility/basic_stacktrace/max_size",
            "sample_declaration": "size_type max_size() const noexcept;"
        },
        {
            "title": "std::basic_stacktrace<Allocator>::operator[]",
            "path": "en.cppreference.com/w/cpp/utility/basic_stacktrace/operator_at.html",
            "wgPageName": "cpp/utility/basic_stacktrace/operator_at",
            "sample_declaration": "const_reference operator[](size_type pos) const;"
        },
        {
            "title": "operator==, operator<=>(std::basic_stacktrace)",
            "path": "en.cppreference.com/w/cpp/utility/basic_stacktrace/operator_cmp.html",
            "wgPageName": "cpp/utility/basic_stacktrace/operator_cmp",
            "sample_declaration": "template<class Allocator2>\nfriend bool operator==(\n    const basic_stacktrace& lhs,\n    const basic_stacktrace<Allocator2>&\n        rhs) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::operator<<(std::basic_stacktrace)",
            "path": "en.cppreference.com/w/cpp/utility/basic_stacktrace/operator_ltlt.html",
            "wgPageName": "cpp/utility/basic_stacktrace/operator_ltlt",
            "headers": [
                "<stacktrace>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    class Allocator>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::basic_stacktrace<Allocator>& st);"
        },
        {
            "title": "std::basic_stacktrace<Allocator>::operator=",
            "path": "en.cppreference.com/w/cpp/utility/basic_stacktrace/operator=.html",
            "wgPageName": "cpp/utility/basic_stacktrace/operator=",
            "sample_declaration": "basic_stacktrace& operator=(\n    const basic_stacktrace& other);",
            "other_declarations": 1
        },
        {
            "title": "std::basic_stacktrace<Allocator>::rbegin, std::basic_stacktrace<Allocator>::crbegin",
            "path": "en.cppreference.com/w/cpp/utility/basic_stacktrace/rbegin.html",
            "wgPageName": "cpp/utility/basic_stacktrace/rbegin",
            "sample_declaration": "const_reverse_iterator rbegin() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_stacktrace<Allocator>::rend, std::basic_stacktrace<Allocator>::crend",
            "path": "en.cppreference.com/w/cpp/utility/basic_stacktrace/rend.html",
            "wgPageName": "cpp/utility/basic_stacktrace/rend",
            "sample_declaration": "const_reverse_iterator rend() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::basic_stacktrace<Allocator>::size",
            "path": "en.cppreference.com/w/cpp/utility/basic_stacktrace/size.html",
            "wgPageName": "cpp/utility/basic_stacktrace/size",
            "sample_declaration": "size_type size() const noexcept;"
        },
        {
            "title": "std::basic_stacktrace<Allocator>::swap",
            "path": "en.cppreference.com/w/cpp/utility/basic_stacktrace/swap.html",
            "wgPageName": "cpp/utility/basic_stacktrace/swap",
            "sample_declaration": "void swap(basic_stacktrace& other) noexcept(\n    /* see below */);"
        },
        {
            "title": "std::swap(std::basic_stacktrace)",
            "path": "en.cppreference.com/w/cpp/utility/basic_stacktrace/swap2.html",
            "wgPageName": "cpp/utility/basic_stacktrace/swap2",
            "headers": [
                "<stacktrace>"
            ],
            "sample_declaration": "template<class Allocator>\nvoid swap(\n    std::basic_stacktrace<Allocator>& lhs,\n    std::basic_stacktrace<Allocator>&\n        rhs) noexcept(noexcept(lhs.swap(rhs)));"
        },
        {
            "title": "std::to_string",
            "path": "en.cppreference.com/w/cpp/utility/basic_stacktrace/to_string.html",
            "wgPageName": "cpp/utility/basic_stacktrace/to_string",
            "headers": [
                "<stacktrace>"
            ],
            "sample_declaration": "template<class Allocator>\nstd::string to_string(\n    const std::basic_stacktrace<Allocator>& st);"
        },
        {
            "title": "std::bitset",
            "path": "en.cppreference.com/w/cpp/utility/bitset.html",
            "wgPageName": "cpp/utility/bitset",
            "headers": [
                "<bitset>"
            ],
            "sample_declaration": "template<std::size_t N>\nclass bitset;"
        },
        {
            "title": "std::bitset<N>::all, std::bitset<N>::any, std::bitset<N>::none",
            "path": "en.cppreference.com/w/cpp/utility/bitset/all_any_none.html",
            "wgPageName": "cpp/utility/bitset/all_any_none",
            "sample_declaration": "bool all() const noexcept;",
            "other_declarations": 7
        },
        {
            "title": "std::bitset<N>::bitset",
            "path": "en.cppreference.com/w/cpp/utility/bitset/bitset.html",
            "wgPageName": "cpp/utility/bitset/bitset",
            "sample_declaration": "bitset();",
            "other_declarations": 6
        },
        {
            "title": "std::bitset<N>::count",
            "path": "en.cppreference.com/w/cpp/utility/bitset/count.html",
            "wgPageName": "cpp/utility/bitset/count",
            "sample_declaration": "std::size_t count() const;",
            "other_declarations": 2
        },
        {
            "title": "std::bitset<N>::flip",
            "path": "en.cppreference.com/w/cpp/utility/bitset/flip.html",
            "wgPageName": "cpp/utility/bitset/flip",
            "sample_declaration": "bitset& flip();",
            "other_declarations": 4
        },
        {
            "title": "std::hash(std::bitset)",
            "path": "en.cppreference.com/w/cpp/utility/bitset/hash.html",
            "wgPageName": "cpp/utility/bitset/hash",
            "headers": [
                "<bitset>"
            ],
            "sample_declaration": "template<std::size_t N>\nstruct hash<std::bitset<N>>;"
        },
        {
            "title": "std::bitset<N>::operator[]",
            "path": "en.cppreference.com/w/cpp/utility/bitset/operator_at.html",
            "wgPageName": "cpp/utility/bitset/operator_at",
            "sample_declaration": "bool operator[](std::size_t pos) const;",
            "other_declarations": 3
        },
        {
            "title": "std::bitset<N>::operator==, std::bitset<N>::operator!=",
            "path": "en.cppreference.com/w/cpp/utility/bitset/operator_cmp.html",
            "wgPageName": "cpp/utility/bitset/operator_cmp",
            "sample_declaration": "bool operator==(const bitset& rhs) const;",
            "other_declarations": 4
        },
        {
            "title": "std::bitset<N>::operator&=,|=,^=,~",
            "path": "en.cppreference.com/w/cpp/utility/bitset/operator_logic.html",
            "wgPageName": "cpp/utility/bitset/operator_logic",
            "sample_declaration": "bitset& operator&=(const bitset& other);",
            "other_declarations": 11
        },
        {
            "title": "operator&,|,^(std::bitset)",
            "path": "en.cppreference.com/w/cpp/utility/bitset/operator_logic2.html",
            "wgPageName": "cpp/utility/bitset/operator_logic2",
            "headers": [
                "<bitset>"
            ],
            "sample_declaration": "template<std::size_t N>\nstd::bitset<N> operator&(\n    const std::bitset<N>& lhs,\n    const std::bitset<N>& rhs);",
            "other_declarations": 8
        },
        {
            "title": "std::bitset<N>::operator<<,<<=,>>,>>=",
            "path": "en.cppreference.com/w/cpp/utility/bitset/operator_ltltgtgt.html",
            "wgPageName": "cpp/utility/bitset/operator_ltltgtgt",
            "sample_declaration": "bitset operator<<(std::size_t pos) const;",
            "other_declarations": 11
        },
        {
            "title": "operator<<,>>(std::bitset)",
            "path": "en.cppreference.com/w/cpp/utility/bitset/operator_ltltgtgt2.html",
            "wgPageName": "cpp/utility/bitset/operator_ltltgtgt2",
            "headers": [
                "<bitset>"
            ],
            "sample_declaration": "template<\n    class CharT,\n    class Traits,\n    std::size_t N>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::bitset<N>& x);",
            "other_declarations": 1
        },
        {
            "title": "std::bitset<N>::reference",
            "path": "en.cppreference.com/w/cpp/utility/bitset/reference.html",
            "wgPageName": "cpp/utility/bitset/reference",
            "sample_declaration": "class reference;"
        },
        {
            "title": "std::bitset<N>::reset",
            "path": "en.cppreference.com/w/cpp/utility/bitset/reset.html",
            "wgPageName": "cpp/utility/bitset/reset",
            "sample_declaration": "bitset& reset();",
            "other_declarations": 4
        },
        {
            "title": "std::bitset<N>::set",
            "path": "en.cppreference.com/w/cpp/utility/bitset/set.html",
            "wgPageName": "cpp/utility/bitset/set",
            "sample_declaration": "bitset& set();",
            "other_declarations": 4
        },
        {
            "title": "std::bitset<N>::size",
            "path": "en.cppreference.com/w/cpp/utility/bitset/size.html",
            "wgPageName": "cpp/utility/bitset/size",
            "sample_declaration": "std::size_t size() const;",
            "other_declarations": 1
        },
        {
            "title": "std::bitset<N>::test",
            "path": "en.cppreference.com/w/cpp/utility/bitset/test.html",
            "wgPageName": "cpp/utility/bitset/test",
            "sample_declaration": "bool test(std::size_t pos) const;",
            "other_declarations": 1
        },
        {
            "title": "std::bitset<N>::to_string",
            "path": "en.cppreference.com/w/cpp/utility/bitset/to_string.html",
            "wgPageName": "cpp/utility/bitset/to_string",
            "sample_declaration": "template<class CharT, class Traits, class Alloc>\nstd::basic_string<CharT, Traits, Allocator>\nto_string() const;",
            "other_declarations": 2
        },
        {
            "title": "std::bitset<N>::to_ullong",
            "path": "en.cppreference.com/w/cpp/utility/bitset/to_ullong.html",
            "wgPageName": "cpp/utility/bitset/to_ullong",
            "sample_declaration": "unsigned long long to_ullong() const",
            "other_declarations": 1
        },
        {
            "title": "std::bitset<N>::to_ulong",
            "path": "en.cppreference.com/w/cpp/utility/bitset/to_ulong.html",
            "wgPageName": "cpp/utility/bitset/to_ulong",
            "sample_declaration": "unsigned long to_ulong() const",
            "other_declarations": 1
        },
        {
            "title": "std::chars_format",
            "path": "en.cppreference.com/w/cpp/utility/chars_format.html",
            "wgPageName": "cpp/utility/chars_format",
            "headers": [
                "<charconv>"
            ],
            "sample_declaration": "enum class chars_format {\n  scientific = /*unspecified*/,\n  fixed = /*unspecified*/,\n  hex = /*unspecified*/,\n  general = fixed | scientific\n};"
        },
        {
            "title": "std::common_comparison_category",
            "path": "en.cppreference.com/w/cpp/utility/compare/common_comparison_category.html",
            "wgPageName": "cpp/utility/compare/common_comparison_category",
            "headers": [
                "<compare>"
            ],
            "sample_declaration": "template<class... Ts>\nstruct common_comparison_category {\n  using type = /*see below*/;\n};"
        },
        {
            "title": "std::compare_partial_order_fallback",
            "path": "en.cppreference.com/w/cpp/utility/compare/compare_partial_order_fallback.html",
            "wgPageName": "cpp/utility/compare/compare_partial_order_fallback",
            "headers": [
                "<compare>"
            ],
            "sample_declaration": "inline namespace /* unspecified */ {\ninline constexpr /* unspecified */\n    compare_partial_order_fallback =\n    /* unspecified */;\n}",
            "other_declarations": 1
        },
        {
            "title": "std::compare_strong_order_fallback",
            "path": "en.cppreference.com/w/cpp/utility/compare/compare_strong_order_fallback.html",
            "wgPageName": "cpp/utility/compare/compare_strong_order_fallback",
            "headers": [
                "<compare>"
            ],
            "sample_declaration": "inline namespace /* unspecified */ {\ninline constexpr /* unspecified */\n    compare_strong_order_fallback =\n    /* unspecified */;\n}",
            "other_declarations": 1
        },
        {
            "title": "std::compare_three_way_result",
            "path": "en.cppreference.com/w/cpp/utility/compare/compare_three_way_result.html",
            "wgPageName": "cpp/utility/compare/compare_three_way_result",
            "headers": [
                "<compare>"
            ],
            "sample_declaration": "template<class T, class U = T>\nstruct compare_three_way_result;"
        },
        {
            "title": "std::compare_three_way",
            "path": "en.cppreference.com/w/cpp/utility/compare/compare_three_way.html",
            "wgPageName": "cpp/utility/compare/compare_three_way",
            "headers": [
                "<compare>",
                "<functional>"
            ],
            "sample_declaration": "struct compare_three_way;"
        },
        {
            "title": "std::compare_weak_order_fallback",
            "path": "en.cppreference.com/w/cpp/utility/compare/compare_weak_order_fallback.html",
            "wgPageName": "cpp/utility/compare/compare_weak_order_fallback",
            "headers": [
                "<compare>"
            ],
            "sample_declaration": "inline namespace /* unspecified */ {\ninline constexpr /* unspecified */\n    compare_weak_order_fallback =\n    /* unspecified */;\n}",
            "other_declarations": 1
        },
        {
            "title": "std::is_eq, std::is_neq, std::is_lt, std::is_gt, std::is_lteq, std::is_gteq",
            "path": "en.cppreference.com/w/cpp/utility/compare/named_comparison_functions.html",
            "wgPageName": "cpp/utility/compare/named_comparison_functions",
            "headers": [
                "<compare>"
            ],
            "sample_declaration": "constexpr bool is_eq(\n    std::partial_ordering cmp) noexcept;",
            "other_declarations": 5
        },
        {
            "title": "std::partial_order",
            "path": "en.cppreference.com/w/cpp/utility/compare/partial_order.html",
            "wgPageName": "cpp/utility/compare/partial_order",
            "headers": [
                "<compare>"
            ],
            "sample_declaration": "inline namespace /* unspecified */ {\ninline constexpr /* unspecified */\n    partial_order = /* unspecified */;\n}",
            "other_declarations": 1
        },
        {
            "title": "std::partial_ordering",
            "path": "en.cppreference.com/w/cpp/utility/compare/partial_ordering.html",
            "wgPageName": "cpp/utility/compare/partial_ordering",
            "headers": [
                "<compare>"
            ],
            "sample_declaration": "class partial_ordering;"
        },
        {
            "title": "std::strong_order",
            "path": "en.cppreference.com/w/cpp/utility/compare/strong_order.html",
            "wgPageName": "cpp/utility/compare/strong_order",
            "headers": [
                "<compare>"
            ],
            "sample_declaration": "inline namespace /* unspecified */ {\ninline constexpr /* unspecified */\n    strong_order = /* unspecified */;\n}",
            "other_declarations": 1
        },
        {
            "title": "std::strong_ordering",
            "path": "en.cppreference.com/w/cpp/utility/compare/strong_ordering.html",
            "wgPageName": "cpp/utility/compare/strong_ordering",
            "headers": [
                "<compare>"
            ],
            "sample_declaration": "class strong_ordering;"
        },
        {
            "title": "std::three_way_comparable, std::three_way_comparable_with",
            "path": "en.cppreference.com/w/cpp/utility/compare/three_way_comparable.html",
            "wgPageName": "cpp/utility/compare/three_way_comparable",
            "headers": [
                "<compare>"
            ],
            "sample_declaration": "template<\n    class T,\n    class Cat = std::partial_ordering>\nconcept three_way_comparable =\n    __WeaklyEqualityComparableWith<T, T> &&\n    __PartiallyOrderedWith<T, T> && requires(\n        const std::remove_reference_t<T>& a,\n        const std::remove_reference_t<T>& b) {\n  { a <=> b } -> __ComparesAs<Cat>;\n};",
            "other_declarations": 2
        },
        {
            "title": "std::weak_order",
            "path": "en.cppreference.com/w/cpp/utility/compare/weak_order.html",
            "wgPageName": "cpp/utility/compare/weak_order",
            "headers": [
                "<compare>"
            ],
            "sample_declaration": "inline namespace /* unspecified */ {\ninline constexpr /* unspecified */ weak_order =\n    /* unspecified */;\n}",
            "other_declarations": 1
        },
        {
            "title": "std::weak_ordering",
            "path": "en.cppreference.com/w/cpp/utility/compare/weak_ordering.html",
            "wgPageName": "cpp/utility/compare/weak_ordering",
            "headers": [
                "<compare>"
            ],
            "sample_declaration": "class weak_ordering;"
        },
        {
            "title": "std::declval",
            "path": "en.cppreference.com/w/cpp/utility/declval.html",
            "wgPageName": "cpp/utility/declval",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "template<class T>\ntypename std::add_rvalue_reference<T>::type\ndeclval() noexcept;"
        },
        {
            "title": "std::exchange",
            "path": "en.cppreference.com/w/cpp/utility/exchange.html",
            "wgPageName": "cpp/utility/exchange",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "template<class T, class U = T>\nT exchange(T& obj, U&& new_value);",
            "other_declarations": 2
        },
        {
            "title": "std::expected",
            "path": "en.cppreference.com/w/cpp/utility/expected.html",
            "wgPageName": "cpp/utility/expected",
            "headers": [
                "<expected>"
            ],
            "sample_declaration": "template<class T, class E>\nclass expected;"
        },
        {
            "title": "std::expected<T,E>::~expected",
            "path": "en.cppreference.com/w/cpp/utility/expected/~expected.html",
            "wgPageName": "cpp/utility/expected/~expected",
            "sample_declaration": "constexpr ~expected();"
        },
        {
            "title": "std::bad_expected_access",
            "path": "en.cppreference.com/w/cpp/utility/expected/bad_expected_access.html",
            "wgPageName": "cpp/utility/expected/bad_expected_access",
            "headers": [
                "<expected>"
            ],
            "sample_declaration": "template<class E>\nclass bad_expected_access\n    : bad_expected_access<void>",
            "other_declarations": 1
        },
        {
            "title": "std::expected<T,E>::emplace",
            "path": "en.cppreference.com/w/cpp/utility/expected/emplace.html",
            "wgPageName": "cpp/utility/expected/emplace",
            "sample_declaration": "template<class... Args>\nconstexpr T& emplace(Args&&... args) noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::expected<T,E>::error",
            "path": "en.cppreference.com/w/cpp/utility/expected/error.html",
            "wgPageName": "cpp/utility/expected/error",
            "sample_declaration": "constexpr const E& error() const& noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::expected<T,E>::expected",
            "path": "en.cppreference.com/w/cpp/utility/expected/expected.html",
            "wgPageName": "cpp/utility/expected/expected",
            "sample_declaration": "constexpr expected() noexcept(/*see below*/);",
            "other_declarations": 12
        },
        {
            "title": "std::expected<T,E>::operator bool, std::expected<T,E>::has_value",
            "path": "en.cppreference.com/w/cpp/utility/expected/operator_bool.html",
            "wgPageName": "cpp/utility/expected/operator_bool",
            "sample_declaration": "constexpr explicit operator bool()\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "operator==(std::expected)",
            "path": "en.cppreference.com/w/cpp/utility/expected/operator_cmp.html",
            "wgPageName": "cpp/utility/expected/operator_cmp",
            "sample_declaration": "template<class T2, class E2>\nrequires(\n    !std::is_void_v<T2>) friend constexpr bool\noperator==(\n    const expected& lhs,\n    const std::expected<T2, E2>& rhs);",
            "other_declarations": 3
        },
        {
            "title": "std::expected<T,E>::operator->, std::expected<T,E>::operator*",
            "path": "en.cppreference.com/w/cpp/utility/expected/operator*.html",
            "wgPageName": "cpp/utility/expected/operator*",
            "sample_declaration": "constexpr const T* operator->() const noexcept;",
            "other_declarations": 6
        },
        {
            "title": "std::expected<T,E>::operator=",
            "path": "en.cppreference.com/w/cpp/utility/expected/operator=.html",
            "wgPageName": "cpp/utility/expected/operator=",
            "sample_declaration": "constexpr expected& operator=(\n    const expected& other);",
            "other_declarations": 4
        },
        {
            "title": "std::expected<T,E>::swap",
            "path": "en.cppreference.com/w/cpp/utility/expected/swap.html",
            "wgPageName": "cpp/utility/expected/swap",
            "sample_declaration": "constexpr void swap(expected& other) noexcept(\n    /*see below*/);"
        },
        {
            "title": "swap(std::expected)",
            "path": "en.cppreference.com/w/cpp/utility/expected/swap2.html",
            "wgPageName": "cpp/utility/expected/swap2",
            "sample_declaration": "friend constexpr void swap(\n    expected& lhs,\n    expected& rhs) noexcept(/*see below*/);"
        },
        {
            "title": "std::unexpect_t, std::unexpect",
            "path": "en.cppreference.com/w/cpp/utility/expected/unexpect_t.html",
            "wgPageName": "cpp/utility/expected/unexpect_t",
            "headers": [
                "<expected>"
            ],
            "sample_declaration": "struct unexpect_t {\n  explicit unexpect_t() = default;\n};",
            "other_declarations": 1
        },
        {
            "title": "std::unexpected",
            "path": "en.cppreference.com/w/cpp/utility/expected/unexpected.html",
            "wgPageName": "cpp/utility/expected/unexpected",
            "headers": [
                "<expected>"
            ],
            "sample_declaration": "template<class E>\nclass unexpected;"
        },
        {
            "title": "std::expected<T,E>::value_or",
            "path": "en.cppreference.com/w/cpp/utility/expected/value_or.html",
            "wgPageName": "cpp/utility/expected/value_or",
            "sample_declaration": "template<class U>\nconstexpr T value_or(U&& default_value) const&;",
            "other_declarations": 1
        },
        {
            "title": "std::expected<T,E>::value",
            "path": "en.cppreference.com/w/cpp/utility/expected/value.html",
            "wgPageName": "cpp/utility/expected/value",
            "sample_declaration": "constexpr T& value() &;",
            "other_declarations": 5
        },
        {
            "title": "Library feature-test macros (since C++20)",
            "path": "en.cppreference.com/w/cpp/utility/feature_test.html",
            "wgPageName": "cpp/utility/feature_test"
        },
        {
            "title": "Formatting library (since C++20)",
            "path": "en.cppreference.com/w/cpp/utility/format.html",
            "wgPageName": "cpp/utility/format"
        },
        {
            "title": "std::basic_format_arg",
            "path": "en.cppreference.com/w/cpp/utility/format/basic_format_arg.html",
            "wgPageName": "cpp/utility/format/basic_format_arg",
            "headers": [
                "<format>"
            ],
            "sample_declaration": "template<class Context>\nclass basic_format_arg;"
        },
        {
            "title": "std::basic_format_args",
            "path": "en.cppreference.com/w/cpp/utility/format/basic_format_args.html",
            "wgPageName": "cpp/utility/format/basic_format_args",
            "headers": [
                "<format>"
            ],
            "sample_declaration": "template<class Context>\nclass basic_format_args;",
            "other_declarations": 2
        },
        {
            "title": "std::basic_format_context",
            "path": "en.cppreference.com/w/cpp/utility/format/basic_format_context.html",
            "wgPageName": "cpp/utility/format/basic_format_context",
            "headers": [
                "<format>"
            ],
            "sample_declaration": "template<class OutputIt, class CharT>\nclass basic_format_context;",
            "other_declarations": 2
        },
        {
            "title": "std::basic_format_parse_context",
            "path": "en.cppreference.com/w/cpp/utility/format/basic_format_parse_context.html",
            "wgPageName": "cpp/utility/format/basic_format_parse_context",
            "headers": [
                "<format>"
            ],
            "sample_declaration": "template<class CharT>\nclass basic_format_parse_context;",
            "other_declarations": 2
        },
        {
            "title": "std::basic_format_string, std::format_string, std::wformat_string",
            "path": "en.cppreference.com/w/cpp/utility/format/basic_format_string.html",
            "wgPageName": "cpp/utility/format/basic_format_string",
            "headers": [
                "<format>"
            ],
            "sample_declaration": "template<class CharT, class... Args>\nstruct basic_format_string;",
            "other_declarations": 2
        },
        {
            "title": "std::format_error",
            "path": "en.cppreference.com/w/cpp/utility/format/format_error.html",
            "wgPageName": "cpp/utility/format/format_error",
            "headers": [
                "<format>"
            ],
            "sample_declaration": "class format_error;"
        },
        {
            "title": "std::format_to_n, std::format_to_n_result",
            "path": "en.cppreference.com/w/cpp/utility/format/format_to_n.html",
            "wgPageName": "cpp/utility/format/format_to_n",
            "headers": [
                "<format>"
            ],
            "sample_declaration": "template<class OutputIt, class... Args>\nstd::format_to_n_result<OutputIt> format_to_n(\n    OutputIt out,\n    std::iter_difference_t<OutputIt> n,\n    std::format_string<Args...> fmt,\n    Args&&... args);",
            "other_declarations": 4
        },
        {
            "title": "std::format_to",
            "path": "en.cppreference.com/w/cpp/utility/format/format_to.html",
            "wgPageName": "cpp/utility/format/format_to",
            "headers": [
                "<format>"
            ],
            "sample_declaration": "template<class OutputIt, class... Args>\nOutputIt format_to(\n    OutputIt out,\n    std::format_string<Args...> fmt,\n    Args&&... args);",
            "other_declarations": 3
        },
        {
            "title": "std::format",
            "path": "en.cppreference.com/w/cpp/utility/format/format.html",
            "wgPageName": "cpp/utility/format/format",
            "headers": [
                "<format>"
            ],
            "sample_declaration": "template<class... Args>\nstd::string format(\n    std::format_string<Args...> fmt,\n    Args&&... args);",
            "other_declarations": 3
        },
        {
            "title": "std::formatted_size",
            "path": "en.cppreference.com/w/cpp/utility/format/formatted_size.html",
            "wgPageName": "cpp/utility/format/formatted_size",
            "headers": [
                "<format>"
            ],
            "sample_declaration": "template<class... Args>\nstd::size_t formatted_size(\n    std::format_string<Args...> fmt,\n    Args&&... args);",
            "other_declarations": 3
        },
        {
            "title": "std::formatter",
            "path": "en.cppreference.com/w/cpp/utility/format/formatter.html",
            "wgPageName": "cpp/utility/format/formatter",
            "headers": [
                "<format>"
            ],
            "sample_declaration": "template<class T, class CharT = char>\nstruct formatter;"
        },
        {
            "title": "std::make_format_args, std::make_wformat_args",
            "path": "en.cppreference.com/w/cpp/utility/format/make_format_args.html",
            "wgPageName": "cpp/utility/format/make_format_args",
            "headers": [
                "<format>"
            ],
            "sample_declaration": "template<\n    class Context = std::format_context,\n    class... Args>\n/*format-arg-store*/<Context, Args...>\nmake_format_args(Args&&... args);",
            "other_declarations": 1
        },
        {
            "title": "std::vformat_to",
            "path": "en.cppreference.com/w/cpp/utility/format/vformat_to.html",
            "wgPageName": "cpp/utility/format/vformat_to",
            "headers": [
                "<format>"
            ],
            "sample_declaration": "template<class OutputIt>\nOutputIt vformat_to(\n    OutputIt out,\n    std::string_view fmt,\n    std::format_args args);",
            "other_declarations": 3
        },
        {
            "title": "std::vformat",
            "path": "en.cppreference.com/w/cpp/utility/format/vformat.html",
            "wgPageName": "cpp/utility/format/vformat",
            "headers": [
                "<format>"
            ],
            "sample_declaration": "std::string vformat(\n    std::string_view fmt,\n    std::format_args args);",
            "other_declarations": 3
        },
        {
            "title": "std::visit_format_arg",
            "path": "en.cppreference.com/w/cpp/utility/format/visit_format_arg.html",
            "wgPageName": "cpp/utility/format/visit_format_arg",
            "headers": [
                "<format>"
            ],
            "sample_declaration": "template<class Visitor, class Context>\n/* see below */ visit_format_arg(\n    Visitor&& vis,\n    std::basic_format_arg<Context> arg);"
        },
        {
            "title": "std::forward_like",
            "path": "en.cppreference.com/w/cpp/utility/forward_like.html",
            "wgPageName": "cpp/utility/forward_like",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "template<class T, class U>\n[[nodiscard]] constexpr auto&& forward_like(\n    U&& x) noexcept;"
        },
        {
            "title": "std::forward",
            "path": "en.cppreference.com/w/cpp/utility/forward.html",
            "wgPageName": "cpp/utility/forward",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "template<class T>\nT&& forward(\n    typename std::remove_reference<T>::type&\n        t) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::from_chars, std::from_chars_result",
            "path": "en.cppreference.com/w/cpp/utility/from_chars.html",
            "wgPageName": "cpp/utility/from_chars",
            "headers": [
                "<charconv>"
            ],
            "sample_declaration": "std::from_chars_result from_chars(\n    const char* first,\n    const char* last,\n    /*see below*/ &value,\n    int base = 10);",
            "other_declarations": 5
        },
        {
            "title": "Function objects",
            "path": "en.cppreference.com/w/cpp/utility/functional.html",
            "wgPageName": "cpp/utility/functional"
        },
        {
            "title": "std::bad_function_call",
            "path": "en.cppreference.com/w/cpp/utility/functional/bad_function_call.html",
            "wgPageName": "cpp/utility/functional/bad_function_call",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "class bad_function_call;"
        },
        {
            "title": "std::binary_function",
            "path": "en.cppreference.com/w/cpp/utility/functional/binary_function.html",
            "wgPageName": "cpp/utility/functional/binary_function",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class Arg1, class Arg2, class Result>\nstruct binary_function;"
        },
        {
            "title": "std::binary_negate",
            "path": "en.cppreference.com/w/cpp/utility/functional/binary_negate.html",
            "wgPageName": "cpp/utility/functional/binary_negate",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class Predicate>\nstruct binary_negate\n    : public std::binary_function<\n          Predicate::first_argument_type,\n          Predicate::second_argument_type,\n          bool>;",
            "other_declarations": 1
        },
        {
            "title": "std::bind_front, std::bind_back",
            "path": "en.cppreference.com/w/cpp/utility/functional/bind_front.html",
            "wgPageName": "cpp/utility/functional/bind_front",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class F, class... Args>\nconstexpr /*unspecified*/ bind_front(\n    F&& f,\n    Args&&... args);",
            "other_declarations": 1
        },
        {
            "title": "std::bind",
            "path": "en.cppreference.com/w/cpp/utility/functional/bind.html",
            "wgPageName": "cpp/utility/functional/bind",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class F, class... Args>\n/*unspecified*/ bind(F&& f, Args&&... args);",
            "other_declarations": 3
        },
        {
            "title": "std::bind1st, std::bind2nd",
            "path": "en.cppreference.com/w/cpp/utility/functional/bind12.html",
            "wgPageName": "cpp/utility/functional/bind12",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class F, class T>\nstd::binder1st<F> bind1st(\n    const F& f,\n    const T& x);",
            "other_declarations": 1
        },
        {
            "title": "std::binder1st, std::binder2nd",
            "path": "en.cppreference.com/w/cpp/utility/functional/binder12.html",
            "wgPageName": "cpp/utility/functional/binder12",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class Fn>\nclass binder1st\n    : public std::unary_function<\n          typename Fn::second_argument_type,\n          typename Fn::result_type> {\n protected:\n  Fn op;\n  typename Fn::first_argument_type value;\n\n public:\n  binder1st(\n      const Fn& fn,\n      const typename Fn::first_argument_type&\n          value);\n  typename Fn::result_type operator()(\n      const typename Fn::second_argument_type&\n          x) const;\n  typename Fn::result_type operator()(\n      typename Fn::second_argument_type& x)\n      const;\n};",
            "other_declarations": 1
        },
        {
            "title": "std::bit_and<void>",
            "path": "en.cppreference.com/w/cpp/utility/functional/bit_and_void.html",
            "wgPageName": "cpp/utility/functional/bit_and_void",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<>\nclass bit_and<void>;"
        },
        {
            "title": "std::bit_and",
            "path": "en.cppreference.com/w/cpp/utility/functional/bit_and.html",
            "wgPageName": "cpp/utility/functional/bit_and",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class T>\nstruct bit_and;",
            "other_declarations": 1
        },
        {
            "title": "std::bit_not<void>",
            "path": "en.cppreference.com/w/cpp/utility/functional/bit_not_void.html",
            "wgPageName": "cpp/utility/functional/bit_not_void",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<>\nclass bit_not<void>;"
        },
        {
            "title": "std::bit_not",
            "path": "en.cppreference.com/w/cpp/utility/functional/bit_not.html",
            "wgPageName": "cpp/utility/functional/bit_not",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class T = void>\nstruct bit_not;"
        },
        {
            "title": "std::bit_or<void>",
            "path": "en.cppreference.com/w/cpp/utility/functional/bit_or_void.html",
            "wgPageName": "cpp/utility/functional/bit_or_void",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<>\nclass bit_or<void>;"
        },
        {
            "title": "std::bit_or",
            "path": "en.cppreference.com/w/cpp/utility/functional/bit_or.html",
            "wgPageName": "cpp/utility/functional/bit_or",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class T>\nstruct bit_or;",
            "other_declarations": 1
        },
        {
            "title": "std::bit_xor<void>",
            "path": "en.cppreference.com/w/cpp/utility/functional/bit_xor_void.html",
            "wgPageName": "cpp/utility/functional/bit_xor_void",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<>\nclass bit_xor<void>;"
        },
        {
            "title": "std::bit_xor",
            "path": "en.cppreference.com/w/cpp/utility/functional/bit_xor.html",
            "wgPageName": "cpp/utility/functional/bit_xor",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class T>\nstruct bit_xor;",
            "other_declarations": 1
        },
        {
            "title": "std::boyer_moore_horspool_searcher",
            "path": "en.cppreference.com/w/cpp/utility/functional/boyer_moore_horspool_searcher.html",
            "wgPageName": "cpp/utility/functional/boyer_moore_horspool_searcher",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<\n    class RandomIt1,\n    class Hash =\n        std::hash<typename std::iterator_traits<\n            RandomIt1>::value_type>,\n    class BinaryPredicate = std::equal_to<> >\nclass boyer_moore_horspool_searcher;"
        },
        {
            "title": "std::boyer_moore_searcher",
            "path": "en.cppreference.com/w/cpp/utility/functional/boyer_moore_searcher.html",
            "wgPageName": "cpp/utility/functional/boyer_moore_searcher",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<\n    class RandomIt1,\n    class Hash =\n        std::hash<typename std::iterator_traits<\n            RandomIt1>::value_type>,\n    class BinaryPredicate = std::equal_to<> >\nclass boyer_moore_searcher;"
        },
        {
            "title": "std::default_searcher",
            "path": "en.cppreference.com/w/cpp/utility/functional/default_searcher.html",
            "wgPageName": "cpp/utility/functional/default_searcher",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<\n    class ForwardIt,\n    class BinaryPredicate = std::equal_to<> >\nclass default_searcher;"
        },
        {
            "title": "std::divides<void>",
            "path": "en.cppreference.com/w/cpp/utility/functional/divides_void.html",
            "wgPageName": "cpp/utility/functional/divides_void",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<>\nclass divides<void>;"
        },
        {
            "title": "std::divides",
            "path": "en.cppreference.com/w/cpp/utility/functional/divides.html",
            "wgPageName": "cpp/utility/functional/divides",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class T>\nstruct divides;",
            "other_declarations": 1
        },
        {
            "title": "std::equal_to<void>",
            "path": "en.cppreference.com/w/cpp/utility/functional/equal_to_void.html",
            "wgPageName": "cpp/utility/functional/equal_to_void",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<>\nclass equal_to<void>;"
        },
        {
            "title": "std::equal_to",
            "path": "en.cppreference.com/w/cpp/utility/functional/equal_to.html",
            "wgPageName": "cpp/utility/functional/equal_to",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class T>\nstruct equal_to;",
            "other_declarations": 1
        },
        {
            "title": "std::function",
            "path": "en.cppreference.com/w/cpp/utility/functional/function.html",
            "wgPageName": "cpp/utility/functional/function",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class>\nclass function; /* undefined */",
            "other_declarations": 1
        },
        {
            "title": "std::function<R(Args...)>::~function",
            "path": "en.cppreference.com/w/cpp/utility/functional/function/~function.html",
            "wgPageName": "cpp/utility/functional/function/~function",
            "sample_declaration": "~function();"
        },
        {
            "title": "std::function<R(Args...)>::assign",
            "path": "en.cppreference.com/w/cpp/utility/functional/function/assign.html",
            "wgPageName": "cpp/utility/functional/function/assign",
            "sample_declaration": "template<class F, class Alloc>\nvoid assign(F&& f, const Alloc& alloc);"
        },
        {
            "title": "deduction guides for std::function",
            "path": "en.cppreference.com/w/cpp/utility/functional/function/deduction_guides.html",
            "wgPageName": "cpp/utility/functional/function/deduction_guides",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class R, class... ArgTypes>\nfunction(R (*)(ArgTypes...))\n    -> function<R(ArgTypes...)>;",
            "other_declarations": 3
        },
        {
            "title": "std::function<R(Args...)>::function",
            "path": "en.cppreference.com/w/cpp/utility/functional/function/function.html",
            "wgPageName": "cpp/utility/functional/function/function",
            "sample_declaration": "function() noexcept;",
            "other_declarations": 10
        },
        {
            "title": "std::function<R(Args...)>::operator bool",
            "path": "en.cppreference.com/w/cpp/utility/functional/function/operator_bool.html",
            "wgPageName": "cpp/utility/functional/function/operator_bool",
            "sample_declaration": "explicit operator bool() const noexcept;"
        },
        {
            "title": "operator==,!=(std::function)",
            "path": "en.cppreference.com/w/cpp/utility/functional/function/operator_cmp.html",
            "wgPageName": "cpp/utility/functional/function/operator_cmp",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class R, class... ArgTypes>\nbool operator==(\n    const std::function<R(ArgTypes...)>& f,\n    std::nullptr_t) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::function<R(Args...)>::operator()",
            "path": "en.cppreference.com/w/cpp/utility/functional/function/operator().html",
            "wgPageName": "cpp/utility/functional/function/operator()",
            "sample_declaration": "R operator()(Args... args) const;"
        },
        {
            "title": "std::function<R(Args...)>::operator=",
            "path": "en.cppreference.com/w/cpp/utility/functional/function/operator=.html",
            "wgPageName": "cpp/utility/functional/function/operator=",
            "sample_declaration": "function& operator=(const function& other);",
            "other_declarations": 4
        },
        {
            "title": "std::function<R(Args...)>::swap",
            "path": "en.cppreference.com/w/cpp/utility/functional/function/swap.html",
            "wgPageName": "cpp/utility/functional/function/swap",
            "sample_declaration": "void swap(function& other) noexcept;"
        },
        {
            "title": "std::swap(std::function)",
            "path": "en.cppreference.com/w/cpp/utility/functional/function/swap2.html",
            "wgPageName": "cpp/utility/functional/function/swap2",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class R, class... Args>\nvoid swap(\n    std::function<R(Args...)>& lhs,\n    std::function<R(Args...)>& rhs) noexcept;"
        },
        {
            "title": "std::function<R(Args...)>::target_type",
            "path": "en.cppreference.com/w/cpp/utility/functional/function/target_type.html",
            "wgPageName": "cpp/utility/functional/function/target_type",
            "sample_declaration": "const std::type_info& target_type()\n    const noexcept;"
        },
        {
            "title": "std::function<R(Args...)>::target",
            "path": "en.cppreference.com/w/cpp/utility/functional/function/target.html",
            "wgPageName": "cpp/utility/functional/function/target",
            "sample_declaration": "template<class T>\nT* target() noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::uses_allocator<std::function>",
            "path": "en.cppreference.com/w/cpp/utility/functional/function/uses_allocator.html",
            "wgPageName": "cpp/utility/functional/function/uses_allocator",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<\n    class R,\n    class... ArgTypes,\n    class Alloc>\nstruct uses_allocator<\n    std::function<R(ArgTypes...)>,\n    Alloc> : std::true_type {};"
        },
        {
            "title": "std::greater_equal<void>",
            "path": "en.cppreference.com/w/cpp/utility/functional/greater_equal_void.html",
            "wgPageName": "cpp/utility/functional/greater_equal_void",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<>\nclass greater_equal<void>;"
        },
        {
            "title": "std::greater_equal",
            "path": "en.cppreference.com/w/cpp/utility/functional/greater_equal.html",
            "wgPageName": "cpp/utility/functional/greater_equal",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class T>\nstruct greater_equal;",
            "other_declarations": 1
        },
        {
            "title": "std::greater<void>",
            "path": "en.cppreference.com/w/cpp/utility/functional/greater_void.html",
            "wgPageName": "cpp/utility/functional/greater_void",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<>\nclass greater<void>;"
        },
        {
            "title": "std::greater",
            "path": "en.cppreference.com/w/cpp/utility/functional/greater.html",
            "wgPageName": "cpp/utility/functional/greater",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class T>\nstruct greater;",
            "other_declarations": 1
        },
        {
            "title": "std::identity",
            "path": "en.cppreference.com/w/cpp/utility/functional/identity.html",
            "wgPageName": "cpp/utility/functional/identity",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "struct identity;"
        },
        {
            "title": "std::invoke, std::invoke_r",
            "path": "en.cppreference.com/w/cpp/utility/functional/invoke.html",
            "wgPageName": "cpp/utility/functional/invoke",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class F, class... Args>\nstd::invoke_result_t<F, Args...> invoke(\n    F&& f,\n    Args&&... args) noexcept(/* see below */);",
            "other_declarations": 2
        },
        {
            "title": "std::is_bind_expression",
            "path": "en.cppreference.com/w/cpp/utility/functional/is_bind_expression.html",
            "wgPageName": "cpp/utility/functional/is_bind_expression",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class T>\nstruct is_bind_expression;"
        },
        {
            "title": "std::is_placeholder",
            "path": "en.cppreference.com/w/cpp/utility/functional/is_placeholder.html",
            "wgPageName": "cpp/utility/functional/is_placeholder",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class T>\nstruct is_placeholder;"
        },
        {
            "title": "std::less_equal<void>",
            "path": "en.cppreference.com/w/cpp/utility/functional/less_equal_void.html",
            "wgPageName": "cpp/utility/functional/less_equal_void",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<>\nclass less_equal<void>;"
        },
        {
            "title": "std::less_equal",
            "path": "en.cppreference.com/w/cpp/utility/functional/less_equal.html",
            "wgPageName": "cpp/utility/functional/less_equal",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class T>\nstruct less_equal;",
            "other_declarations": 1
        },
        {
            "title": "std::less<void>",
            "path": "en.cppreference.com/w/cpp/utility/functional/less_void.html",
            "wgPageName": "cpp/utility/functional/less_void",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<>\nclass less<void>;"
        },
        {
            "title": "std::less",
            "path": "en.cppreference.com/w/cpp/utility/functional/less.html",
            "wgPageName": "cpp/utility/functional/less",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class T>\nstruct less;",
            "other_declarations": 1
        },
        {
            "title": "std::logical_and<void>",
            "path": "en.cppreference.com/w/cpp/utility/functional/logical_and_void.html",
            "wgPageName": "cpp/utility/functional/logical_and_void",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<>\nclass logical_and<void>;"
        },
        {
            "title": "std::logical_and",
            "path": "en.cppreference.com/w/cpp/utility/functional/logical_and.html",
            "wgPageName": "cpp/utility/functional/logical_and",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class T>\nstruct logical_and;",
            "other_declarations": 1
        },
        {
            "title": "std::logical_not<void>",
            "path": "en.cppreference.com/w/cpp/utility/functional/logical_not_void.html",
            "wgPageName": "cpp/utility/functional/logical_not_void",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<>\nclass logical_not<void>;"
        },
        {
            "title": "std::logical_not",
            "path": "en.cppreference.com/w/cpp/utility/functional/logical_not.html",
            "wgPageName": "cpp/utility/functional/logical_not",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class T>\nstruct logical_not;",
            "other_declarations": 1
        },
        {
            "title": "std::logical_or<void>",
            "path": "en.cppreference.com/w/cpp/utility/functional/logical_or_void.html",
            "wgPageName": "cpp/utility/functional/logical_or_void",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<>\nclass logical_or<void>;"
        },
        {
            "title": "std::logical_or",
            "path": "en.cppreference.com/w/cpp/utility/functional/logical_or.html",
            "wgPageName": "cpp/utility/functional/logical_or",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class T>\nstruct logical_or;",
            "other_declarations": 1
        },
        {
            "title": "std::mem_fn",
            "path": "en.cppreference.com/w/cpp/utility/functional/mem_fn.html",
            "wgPageName": "cpp/utility/functional/mem_fn",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class M, class T>\n/*unspecified*/ mem_fn(M T::*pm) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::mem_fun_ref_t, std::mem_fun1_ref_t, std::const_mem_fun_ref_t, std::const_mem_fun1_ref_t",
            "path": "en.cppreference.com/w/cpp/utility/functional/mem_fun_ref_t.html",
            "wgPageName": "cpp/utility/functional/mem_fun_ref_t",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class S, class T>\nclass mem_fun_ref_t\n    : public unary_function<T, S> {\n public:\n  explicit mem_fun_ref_t(S (T::*p)());\n  S operator()(T& p) const;\n};",
            "other_declarations": 3
        },
        {
            "title": "std::mem_fun_ref",
            "path": "en.cppreference.com/w/cpp/utility/functional/mem_fun_ref.html",
            "wgPageName": "cpp/utility/functional/mem_fun_ref",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class Res, class T>\nstd::mem_fun_ref_t<Res, T> mem_fun_ref(\n    Res (T::*f)());",
            "other_declarations": 3
        },
        {
            "title": "std::mem_fun_t, std::mem_fun1_t, std::const_mem_fun_t, std::const_mem_fun1_t",
            "path": "en.cppreference.com/w/cpp/utility/functional/mem_fun_t.html",
            "wgPageName": "cpp/utility/functional/mem_fun_t",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class S, class T>\nclass mem_fun_t : public unary_function<T*, S> {\n public:\n  explicit mem_fun_t(S (T::*p)());\n  S operator()(T* p) const;\n};",
            "other_declarations": 3
        },
        {
            "title": "std::mem_fun",
            "path": "en.cppreference.com/w/cpp/utility/functional/mem_fun.html",
            "wgPageName": "cpp/utility/functional/mem_fun",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class Res, class T>\nstd::mem_fun_t<Res, T> mem_fun(Res (T::*f)());",
            "other_declarations": 3
        },
        {
            "title": "std::minus<void>",
            "path": "en.cppreference.com/w/cpp/utility/functional/minus_void.html",
            "wgPageName": "cpp/utility/functional/minus_void",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<>\nclass minus<void>;"
        },
        {
            "title": "std::minus",
            "path": "en.cppreference.com/w/cpp/utility/functional/minus.html",
            "wgPageName": "cpp/utility/functional/minus",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class T>\nstruct minus;",
            "other_declarations": 1
        },
        {
            "title": "std::modulus<void>",
            "path": "en.cppreference.com/w/cpp/utility/functional/modulus_void.html",
            "wgPageName": "cpp/utility/functional/modulus_void",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<>\nclass modulus<void>;"
        },
        {
            "title": "std::modulus",
            "path": "en.cppreference.com/w/cpp/utility/functional/modulus.html",
            "wgPageName": "cpp/utility/functional/modulus",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class T>\nstruct modulus;",
            "other_declarations": 1
        },
        {
            "title": "std::move_only_function",
            "path": "en.cppreference.com/w/cpp/utility/functional/move_only_function.html",
            "wgPageName": "cpp/utility/functional/move_only_function",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class...>\nclass move_only_function;  // not defined",
            "other_declarations": 1
        },
        {
            "title": "std::move_only_function::~move_only_function",
            "path": "en.cppreference.com/w/cpp/utility/functional/move_only_function/~move_only_function.html",
            "wgPageName": "cpp/utility/functional/move_only_function/~move_only_function",
            "sample_declaration": "~move_only_function();"
        },
        {
            "title": "std::move_only_function::move_only_function",
            "path": "en.cppreference.com/w/cpp/utility/functional/move_only_function/move_only_function.html",
            "wgPageName": "cpp/utility/functional/move_only_function/move_only_function",
            "sample_declaration": "move_only_function() noexcept;",
            "other_declarations": 6
        },
        {
            "title": "std::move_only_function::operator bool",
            "path": "en.cppreference.com/w/cpp/utility/functional/move_only_function/operator_bool.html",
            "wgPageName": "cpp/utility/functional/move_only_function/operator_bool",
            "sample_declaration": "explicit operator bool() const noexcept;"
        },
        {
            "title": "std::move_only_function::operator()",
            "path": "en.cppreference.com/w/cpp/utility/functional/move_only_function/operator().html",
            "wgPageName": "cpp/utility/functional/move_only_function/operator()",
            "sample_declaration": "R operator()(Args... args) /*cv*/ /*ref*/\n    noexcept(/*noex*/);"
        },
        {
            "title": "std::move_only_function::operator=",
            "path": "en.cppreference.com/w/cpp/utility/functional/move_only_function/operator=.html",
            "wgPageName": "cpp/utility/functional/move_only_function/operator=",
            "sample_declaration": "move_only_function& operator=(\n    move_only_function&& other);",
            "other_declarations": 3
        },
        {
            "title": "operator==(std::move_only_function)",
            "path": "en.cppreference.com/w/cpp/utility/functional/move_only_function/operator==.html",
            "wgPageName": "cpp/utility/functional/move_only_function/operator==",
            "sample_declaration": "friend bool operator==(\n    const move_only_function& f,\n    std::nullptr_t) noexcept;"
        },
        {
            "title": "std::move_only_function::swap",
            "path": "en.cppreference.com/w/cpp/utility/functional/move_only_function/swap.html",
            "wgPageName": "cpp/utility/functional/move_only_function/swap",
            "sample_declaration": "void swap(move_only_function& other) noexcept;"
        },
        {
            "title": "swap(std::move_only_function)",
            "path": "en.cppreference.com/w/cpp/utility/functional/move_only_function/swap2.html",
            "wgPageName": "cpp/utility/functional/move_only_function/swap2",
            "sample_declaration": "friend void swap(\n    move_only_function& lhs,\n    move_only_function& rhs) noexcept;"
        },
        {
            "title": "std::multiplies<void>",
            "path": "en.cppreference.com/w/cpp/utility/functional/multiplies_void.html",
            "wgPageName": "cpp/utility/functional/multiplies_void",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<>\nclass multiplies<void>;"
        },
        {
            "title": "std::multiplies",
            "path": "en.cppreference.com/w/cpp/utility/functional/multiplies.html",
            "wgPageName": "cpp/utility/functional/multiplies",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class T>\nstruct multiplies;",
            "other_declarations": 1
        },
        {
            "title": "std::negate<void>",
            "path": "en.cppreference.com/w/cpp/utility/functional/negate_void.html",
            "wgPageName": "cpp/utility/functional/negate_void",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<>\nclass negate<void>;"
        },
        {
            "title": "std::negate",
            "path": "en.cppreference.com/w/cpp/utility/functional/negate.html",
            "wgPageName": "cpp/utility/functional/negate",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class T>\nstruct negate;",
            "other_declarations": 1
        },
        {
            "title": "std::not_equal_to<void>",
            "path": "en.cppreference.com/w/cpp/utility/functional/not_equal_to_void.html",
            "wgPageName": "cpp/utility/functional/not_equal_to_void",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<>\nclass not_equal_to<void>;"
        },
        {
            "title": "std::not_equal_to",
            "path": "en.cppreference.com/w/cpp/utility/functional/not_equal_to.html",
            "wgPageName": "cpp/utility/functional/not_equal_to",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class T>\nstruct not_equal_to;",
            "other_declarations": 1
        },
        {
            "title": "std::not_fn",
            "path": "en.cppreference.com/w/cpp/utility/functional/not_fn.html",
            "wgPageName": "cpp/utility/functional/not_fn",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class F> /*unspecified*/ not_fn(F&& f);",
            "other_declarations": 1
        },
        {
            "title": "std::not1",
            "path": "en.cppreference.com/w/cpp/utility/functional/not1.html",
            "wgPageName": "cpp/utility/functional/not1",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class Predicate>\nstd::unary_negate<Predicate> not1(\n    const Predicate& pred);",
            "other_declarations": 1
        },
        {
            "title": "std::not2",
            "path": "en.cppreference.com/w/cpp/utility/functional/not2.html",
            "wgPageName": "cpp/utility/functional/not2",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class Predicate>\nstd::binary_negate<Predicate> not2(\n    const Predicate& pred);",
            "other_declarations": 1
        },
        {
            "title": "std::placeholders::_1, std::placeholders::_2, ..., std::placeholders::_N",
            "path": "en.cppreference.com/w/cpp/utility/functional/placeholders.html",
            "wgPageName": "cpp/utility/functional/placeholders",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "/*see below*/ _1; /*see below*/\n_2;\n../*see below*/ _N;"
        },
        {
            "title": "std::plus<void>",
            "path": "en.cppreference.com/w/cpp/utility/functional/plus_void.html",
            "wgPageName": "cpp/utility/functional/plus_void",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<>\nclass plus<void>;"
        },
        {
            "title": "std::plus",
            "path": "en.cppreference.com/w/cpp/utility/functional/plus.html",
            "wgPageName": "cpp/utility/functional/plus",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class T>\nstruct plus;",
            "other_declarations": 1
        },
        {
            "title": "std::pointer_to_binary_function",
            "path": "en.cppreference.com/w/cpp/utility/functional/pointer_to_binary_function.html",
            "wgPageName": "cpp/utility/functional/pointer_to_binary_function",
            "sample_declaration": "template<class Arg1, class Arg2, class Result>\nclass pointer_to_binary_function\n    : public std::\n          binary_function<Arg1, Arg2, Result>;"
        },
        {
            "title": "std::pointer_to_unary_function",
            "path": "en.cppreference.com/w/cpp/utility/functional/pointer_to_unary_function.html",
            "wgPageName": "cpp/utility/functional/pointer_to_unary_function",
            "sample_declaration": "template<class Arg, class Result>\nclass pointer_to_unary_function\n    : public std::unary_function<Arg, Result>;"
        },
        {
            "title": "std::ptr_fun",
            "path": "en.cppreference.com/w/cpp/utility/functional/ptr_fun.html",
            "wgPageName": "cpp/utility/functional/ptr_fun",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class Arg, class Result>\nstd::pointer_to_unary_function<Arg, Result>\n    ptr_fun(Result (*f)(Arg));",
            "other_declarations": 1
        },
        {
            "title": "std::ranges::equal_to",
            "path": "en.cppreference.com/w/cpp/utility/functional/ranges/equal_to.html",
            "wgPageName": "cpp/utility/functional/ranges/equal_to",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "struct equal_to;"
        },
        {
            "title": "std::ranges::greater_equal",
            "path": "en.cppreference.com/w/cpp/utility/functional/ranges/greater_equal.html",
            "wgPageName": "cpp/utility/functional/ranges/greater_equal",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "struct greater_equal;"
        },
        {
            "title": "std::ranges::greater",
            "path": "en.cppreference.com/w/cpp/utility/functional/ranges/greater.html",
            "wgPageName": "cpp/utility/functional/ranges/greater",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "struct greater;"
        },
        {
            "title": "std::ranges::less_equal",
            "path": "en.cppreference.com/w/cpp/utility/functional/ranges/less_equal.html",
            "wgPageName": "cpp/utility/functional/ranges/less_equal",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "struct less_equal;"
        },
        {
            "title": "std::ranges::less",
            "path": "en.cppreference.com/w/cpp/utility/functional/ranges/less.html",
            "wgPageName": "cpp/utility/functional/ranges/less",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "struct less;"
        },
        {
            "title": "std::ranges::not_equal_to",
            "path": "en.cppreference.com/w/cpp/utility/functional/ranges/not_equal_to.html",
            "wgPageName": "cpp/utility/functional/ranges/not_equal_to",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "struct not_equal_to;"
        },
        {
            "title": "std::ref, std::cref",
            "path": "en.cppreference.com/w/cpp/utility/functional/ref.html",
            "wgPageName": "cpp/utility/functional/ref",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class T>\nstd::reference_wrapper<T> ref(T& t) noexcept;",
            "other_declarations": 9
        },
        {
            "title": "std::reference_wrapper",
            "path": "en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html",
            "wgPageName": "cpp/utility/functional/reference_wrapper",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class T>\nclass reference_wrapper;"
        },
        {
            "title": "deduction guides for std::reference_wrapper",
            "path": "en.cppreference.com/w/cpp/utility/functional/reference_wrapper/deduction_guides.html",
            "wgPageName": "cpp/utility/functional/reference_wrapper/deduction_guides",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<typename T>\nreference_wrapper(T&) -> reference_wrapper<T>;"
        },
        {
            "title": "std::reference_wrapper<T>::get, std::reference_wrapper<T>::operator T&",
            "path": "en.cppreference.com/w/cpp/utility/functional/reference_wrapper/get.html",
            "wgPageName": "cpp/utility/functional/reference_wrapper/get",
            "sample_declaration": "operator T&() const noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::reference_wrapper<T>::operator()",
            "path": "en.cppreference.com/w/cpp/utility/functional/reference_wrapper/operator().html",
            "wgPageName": "cpp/utility/functional/reference_wrapper/operator()",
            "sample_declaration": "template<class... ArgTypes>\ntypename std::result_of<T&(ArgTypes&&...)>::type\noperator()(ArgTypes&&... args) const;",
            "other_declarations": 2
        },
        {
            "title": "std::reference_wrapper<T>::operator=",
            "path": "en.cppreference.com/w/cpp/utility/functional/reference_wrapper/operator=.html",
            "wgPageName": "cpp/utility/functional/reference_wrapper/operator=",
            "sample_declaration": "reference_wrapper& operator=(\n    const reference_wrapper& other) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::reference_wrapper<T>::reference_wrapper",
            "path": "en.cppreference.com/w/cpp/utility/functional/reference_wrapper/reference_wrapper.html",
            "wgPageName": "cpp/utility/functional/reference_wrapper/reference_wrapper",
            "sample_declaration": "template<class U>\nreference_wrapper(U&& x) noexcept(\n    /*see below*/);",
            "other_declarations": 3
        },
        {
            "title": "std::unary_function",
            "path": "en.cppreference.com/w/cpp/utility/functional/unary_function.html",
            "wgPageName": "cpp/utility/functional/unary_function",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<\n    typename ArgumentType,\n    typename ResultType>\nstruct unary_function;"
        },
        {
            "title": "std::unary_negate",
            "path": "en.cppreference.com/w/cpp/utility/functional/unary_negate.html",
            "wgPageName": "cpp/utility/functional/unary_negate",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class Predicate>\nstruct unary_negate\n    : public std::unary_function<\n          Predicate::argument_type,\n          bool>;",
            "other_declarations": 1
        },
        {
            "title": "std::unwrap_reference, std::unwrap_ref_decay",
            "path": "en.cppreference.com/w/cpp/utility/functional/unwrap_reference.html",
            "wgPageName": "cpp/utility/functional/unwrap_reference",
            "headers": [
                "<type_traits>",
                "<functional>"
            ],
            "sample_declaration": "template<class T>\nstruct unwrap_reference;",
            "other_declarations": 1
        },
        {
            "title": "std::hash",
            "path": "en.cppreference.com/w/cpp/utility/hash.html",
            "wgPageName": "cpp/utility/hash",
            "headers": [
                "<functional>"
            ],
            "sample_declaration": "template<class Key>\nstruct hash;"
        },
        {
            "title": "std::hash::hash",
            "path": "en.cppreference.com/w/cpp/utility/hash/hash.html",
            "wgPageName": "cpp/utility/hash/hash"
        },
        {
            "title": "std::hash<Key>::operator()",
            "path": "en.cppreference.com/w/cpp/utility/hash/operator().html",
            "wgPageName": "cpp/utility/hash/operator()"
        },
        {
            "title": "std::in_place, std::in_place_type, std::in_place_index, std::in_place_t, std::in_place_type_t, std::in_place_index_t",
            "path": "en.cppreference.com/w/cpp/utility/in_place.html",
            "wgPageName": "cpp/utility/in_place",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "struct in_place_t {\n  explicit in_place_t() = default;\n};\ninline constexpr in_place_t in_place{};",
            "other_declarations": 2
        },
        {
            "title": "std::in_range",
            "path": "en.cppreference.com/w/cpp/utility/in_range.html",
            "wgPageName": "cpp/utility/in_range",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "template<class R, class T>\nconstexpr bool in_range(T t) noexcept;"
        },
        {
            "title": "std::initializer_list",
            "path": "en.cppreference.com/w/cpp/utility/initializer_list.html",
            "wgPageName": "cpp/utility/initializer_list",
            "headers": [
                "<initializer_list>"
            ],
            "sample_declaration": "template<class T>\nclass initializer_list;"
        },
        {
            "title": "std::initializer_list<T>::begin",
            "path": "en.cppreference.com/w/cpp/utility/initializer_list/begin.html",
            "wgPageName": "cpp/utility/initializer_list/begin",
            "sample_declaration": "const T* begin() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::begin(std::initializer_list)",
            "path": "en.cppreference.com/w/cpp/utility/initializer_list/begin2.html",
            "wgPageName": "cpp/utility/initializer_list/begin2",
            "headers": [
                "<initializer_list>"
            ],
            "sample_declaration": "template<class E>\nconst E* begin(\n    std::initializer_list<E> il) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::initializer_list<T>::end",
            "path": "en.cppreference.com/w/cpp/utility/initializer_list/end.html",
            "wgPageName": "cpp/utility/initializer_list/end",
            "sample_declaration": "const T* end() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::end(std::initializer_list)",
            "path": "en.cppreference.com/w/cpp/utility/initializer_list/end2.html",
            "wgPageName": "cpp/utility/initializer_list/end2",
            "headers": [
                "<initializer_list>"
            ],
            "sample_declaration": "template<class E>\nconst E* end(\n    std::initializer_list<E> il) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::initializer_list<T>::initializer_list",
            "path": "en.cppreference.com/w/cpp/utility/initializer_list/initializer_list.html",
            "wgPageName": "cpp/utility/initializer_list/initializer_list",
            "sample_declaration": "initializer_list() noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::initializer_list<T>::size",
            "path": "en.cppreference.com/w/cpp/utility/initializer_list/size.html",
            "wgPageName": "cpp/utility/initializer_list/size",
            "sample_declaration": "size_type size() const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::cmp_equal, cmp_not_equal, cmp_less, cmp_greater, cmp_less_equal, cmp_greater_equal",
            "path": "en.cppreference.com/w/cpp/utility/intcmp.html",
            "wgPageName": "cpp/utility/intcmp",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "template<class T, class U>\nconstexpr bool cmp_equal(T t, U u) noexcept;",
            "other_declarations": 5
        },
        {
            "title": "std::integer_sequence",
            "path": "en.cppreference.com/w/cpp/utility/integer_sequence.html",
            "wgPageName": "cpp/utility/integer_sequence",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "template<class T, T... Ints>\nclass integer_sequence;"
        },
        {
            "title": "std::launder",
            "path": "en.cppreference.com/w/cpp/utility/launder.html",
            "wgPageName": "cpp/utility/launder",
            "headers": [
                "<new>"
            ],
            "sample_declaration": "template<class T>\nconstexpr T* launder(T* p) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::make_from_tuple",
            "path": "en.cppreference.com/w/cpp/utility/make_from_tuple.html",
            "wgPageName": "cpp/utility/make_from_tuple",
            "headers": [
                "<tuple>"
            ],
            "sample_declaration": "template<class T, class Tuple>\nconstexpr T make_from_tuple(Tuple&& t);"
        },
        {
            "title": "std::move_if_noexcept",
            "path": "en.cppreference.com/w/cpp/utility/move_if_noexcept.html",
            "wgPageName": "cpp/utility/move_if_noexcept",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "template<class T>\ntypename std::conditional<\n    !std::is_nothrow_move_constructible<\n        T>::value &&\n        std::is_copy_constructible<T>::value,\n    const T&,\n    T&&>::type\nmove_if_noexcept(T& x) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::move",
            "path": "en.cppreference.com/w/cpp/utility/move.html",
            "wgPageName": "cpp/utility/move",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "template<class T>\ntypename std::remove_reference<T>::type&& move(\n    T&& t) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::optional",
            "path": "en.cppreference.com/w/cpp/utility/optional.html",
            "wgPageName": "cpp/utility/optional",
            "headers": [
                "<optional>"
            ],
            "sample_declaration": "template<class T>\nclass optional;"
        },
        {
            "title": "std::optional<T>::~optional",
            "path": "en.cppreference.com/w/cpp/utility/optional/~optional.html",
            "wgPageName": "cpp/utility/optional/~optional",
            "sample_declaration": "~optional();",
            "other_declarations": 1
        },
        {
            "title": "std::optional<T>::and_then",
            "path": "en.cppreference.com/w/cpp/utility/optional/and_then.html",
            "wgPageName": "cpp/utility/optional/and_then",
            "sample_declaration": "template<class F>\nconstexpr auto and_then(F&& f) &;",
            "other_declarations": 3
        },
        {
            "title": "std::bad_optional_access",
            "path": "en.cppreference.com/w/cpp/utility/optional/bad_optional_access.html",
            "wgPageName": "cpp/utility/optional/bad_optional_access",
            "headers": [
                "<optional>"
            ],
            "sample_declaration": "class bad_optional_access;"
        },
        {
            "title": "deduction guides for std::optional",
            "path": "en.cppreference.com/w/cpp/utility/optional/deduction_guides.html",
            "wgPageName": "cpp/utility/optional/deduction_guides",
            "headers": [
                "<optional>"
            ],
            "sample_declaration": "template<class T>\noptional(T) -> optional<T>;"
        },
        {
            "title": "std::optional<T>::emplace",
            "path": "en.cppreference.com/w/cpp/utility/optional/emplace.html",
            "wgPageName": "cpp/utility/optional/emplace",
            "sample_declaration": "template<class... Args>\nT& emplace(Args&&... args);",
            "other_declarations": 3
        },
        {
            "title": "std::hash <std::optional>",
            "path": "en.cppreference.com/w/cpp/utility/optional/hash.html",
            "wgPageName": "cpp/utility/optional/hash",
            "headers": [
                "<optional>"
            ],
            "sample_declaration": "template<class T>\nstruct hash<std::optional<T>>;"
        },
        {
            "title": "std::make_optional",
            "path": "en.cppreference.com/w/cpp/utility/optional/make_optional.html",
            "wgPageName": "cpp/utility/optional/make_optional",
            "headers": [
                "<optional>"
            ],
            "sample_declaration": "template<class T>\nconstexpr std::optional<std::decay_t<T>>\nmake_optional(T&& value);",
            "other_declarations": 2
        },
        {
            "title": "std::nullopt_t",
            "path": "en.cppreference.com/w/cpp/utility/optional/nullopt_t.html",
            "wgPageName": "cpp/utility/optional/nullopt_t",
            "headers": [
                "<optional>"
            ],
            "sample_declaration": "struct nullopt_t;"
        },
        {
            "title": "std::nullopt",
            "path": "en.cppreference.com/w/cpp/utility/optional/nullopt.html",
            "wgPageName": "cpp/utility/optional/nullopt",
            "headers": [
                "<optional>"
            ],
            "sample_declaration": "inline constexpr nullopt_t nullopt{\n    /*unspecified*/};"
        },
        {
            "title": "std::optional<T>::operator bool, std::optional<T>::has_value",
            "path": "en.cppreference.com/w/cpp/utility/optional/operator_bool.html",
            "wgPageName": "cpp/utility/optional/operator_bool",
            "sample_declaration": "constexpr explicit operator bool()\n    const noexcept;",
            "other_declarations": 1
        },
        {
            "title": "operator==, !=, <, <=, >, >=, <=>(std::optional)",
            "path": "en.cppreference.com/w/cpp/utility/optional/operator_cmp.html",
            "wgPageName": "cpp/utility/optional/operator_cmp",
            "headers": [
                "<optional>"
            ],
            "sample_declaration": "template<class T, class U>\nconstexpr bool operator==(\n    const optional<T>& lhs,\n    const optional<U>& rhs);",
            "other_declarations": 32
        },
        {
            "title": "std::optional<T>::operator->, std::optional<T>::operator*",
            "path": "en.cppreference.com/w/cpp/utility/optional/operator*.html",
            "wgPageName": "cpp/utility/optional/operator*",
            "sample_declaration": "constexpr const T* operator->() const noexcept;",
            "other_declarations": 5
        },
        {
            "title": "std::optional<T>::operator=",
            "path": "en.cppreference.com/w/cpp/utility/optional/operator=.html",
            "wgPageName": "cpp/utility/optional/operator=",
            "sample_declaration": "optional& operator=(std::nullopt_t) noexcept;",
            "other_declarations": 9
        },
        {
            "title": "std::optional<T>::optional",
            "path": "en.cppreference.com/w/cpp/utility/optional/optional.html",
            "wgPageName": "cpp/utility/optional/optional",
            "sample_declaration": "constexpr optional() noexcept;\nconstexpr optional(std::nullopt_t) noexcept;",
            "other_declarations": 9
        },
        {
            "title": "std::optional<T>::or_else",
            "path": "en.cppreference.com/w/cpp/utility/optional/or_else.html",
            "wgPageName": "cpp/utility/optional/or_else",
            "sample_declaration": "template<class F>\nconstexpr optional or_else(F&& f) const&;",
            "other_declarations": 1
        },
        {
            "title": "std::optional<T>::reset",
            "path": "en.cppreference.com/w/cpp/utility/optional/reset.html",
            "wgPageName": "cpp/utility/optional/reset",
            "sample_declaration": "void reset() noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::optional<T>::swap",
            "path": "en.cppreference.com/w/cpp/utility/optional/swap.html",
            "wgPageName": "cpp/utility/optional/swap",
            "sample_declaration": "void swap(optional& other) noexcept(\n    /* see below */);",
            "other_declarations": 1
        },
        {
            "title": "std::swap(std::optional)",
            "path": "en.cppreference.com/w/cpp/utility/optional/swap2.html",
            "wgPageName": "cpp/utility/optional/swap2",
            "headers": [
                "<optional>"
            ],
            "sample_declaration": "template<class T>\nvoid swap(\n    std::optional<T>& lhs,\n    std::optional<T>&\n        rhs) noexcept(/* see below */);",
            "other_declarations": 1
        },
        {
            "title": "std::optional<T>::transform",
            "path": "en.cppreference.com/w/cpp/utility/optional/transform.html",
            "wgPageName": "cpp/utility/optional/transform",
            "sample_declaration": "template<class F>\nconstexpr auto transform(F&& f) &;",
            "other_declarations": 3
        },
        {
            "title": "std::optional<T>::value_or",
            "path": "en.cppreference.com/w/cpp/utility/optional/value_or.html",
            "wgPageName": "cpp/utility/optional/value_or",
            "sample_declaration": "template<class U>\nconstexpr T value_or(U&& default_value) const&;",
            "other_declarations": 1
        },
        {
            "title": "std::optional<T>::value",
            "path": "en.cppreference.com/w/cpp/utility/optional/value.html",
            "wgPageName": "cpp/utility/optional/value",
            "sample_declaration": "constexpr T& value() &;\nconstexpr const T& value() const&;",
            "other_declarations": 1
        },
        {
            "title": "std::pair",
            "path": "en.cppreference.com/w/cpp/utility/pair.html",
            "wgPageName": "cpp/utility/pair",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "template<class T1, class T2>\nstruct pair;"
        },
        {
            "title": "std::basic_common_reference<std::pair>",
            "path": "en.cppreference.com/w/cpp/utility/pair/basic_common_reference.html",
            "wgPageName": "cpp/utility/pair/basic_common_reference",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "template<\n    class T1,\n    class T2,\n    class U1,\n    class U2,\n    template<class>\n    class TQual,\n    template<class>\n    class UQual>\nrequires requires {\n  typename std::pair<\n      std::common_reference_t<\n          TQual<T1>, UQual<U1>>,\n      std::common_reference_t<\n          TQual<T2>, UQual<U2>>>;\n}\nstruct basic_common_reference<\n    std::pair<T1, T2>,\n    std::pair<U1, U2>,\n    TQual,\n    UQual>;"
        },
        {
            "title": "std::common_type<std::pair>",
            "path": "en.cppreference.com/w/cpp/utility/pair/common_type.html",
            "wgPageName": "cpp/utility/pair/common_type",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "template<class T1, class T2, class U1, class U2>\nrequires requires {\n  typename std::pair<\n      std::common_type_t<T1, U1>,\n      std::common_type_t<T2, U2>>;\n}\nstruct common_type<\n    std::pair<T1, T2>,\n    std::pair<U1, U2>>;"
        },
        {
            "title": "deduction guides for std::pair",
            "path": "en.cppreference.com/w/cpp/utility/pair/deduction_guides.html",
            "wgPageName": "cpp/utility/pair/deduction_guides",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "template<class T1, class T2>\npair(T1, T2) -> pair<T1, T2>;"
        },
        {
            "title": "std::get(std::pair)",
            "path": "en.cppreference.com/w/cpp/utility/pair/get.html",
            "wgPageName": "cpp/utility/pair/get",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "template<std::size_t I, class T1, class T2>\ntypename std::\n    tuple_element<I, std::pair<T1, T2> >::type&\n    get(std::pair<T1, T2>& p) noexcept;",
            "other_declarations": 15
        },
        {
            "title": "std::make_pair",
            "path": "en.cppreference.com/w/cpp/utility/pair/make_pair.html",
            "wgPageName": "cpp/utility/pair/make_pair",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "template<class T1, class T2>\nstd::pair<T1, T2> make_pair(T1 t, T2 u);",
            "other_declarations": 2
        },
        {
            "title": "operator==,!=,<,<=,>,>=,<=>(std::pair)",
            "path": "en.cppreference.com/w/cpp/utility/pair/operator_cmp.html",
            "wgPageName": "cpp/utility/pair/operator_cmp",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "template<class T1, class T2>\nbool operator==(\n    const std::pair<T1, T2>& lhs,\n    const std::pair<T1, T2>& rhs);",
            "other_declarations": 12
        },
        {
            "title": "std::pair<T1,T2>::operator=",
            "path": "en.cppreference.com/w/cpp/utility/pair/operator=.html",
            "wgPageName": "cpp/utility/pair/operator=",
            "sample_declaration": "pair& operator=(const pair& other);",
            "other_declarations": 11
        },
        {
            "title": "std::pair<T1,T2>::pair",
            "path": "en.cppreference.com/w/cpp/utility/pair/pair.html",
            "wgPageName": "cpp/utility/pair/pair",
            "sample_declaration": "pair();",
            "other_declarations": 18
        },
        {
            "title": "std::pair<T1,T2>::swap",
            "path": "en.cppreference.com/w/cpp/utility/pair/swap.html",
            "wgPageName": "cpp/utility/pair/swap",
            "sample_declaration": "void swap(pair& other) noexcept(\n    /* see below */);",
            "other_declarations": 2
        },
        {
            "title": "std::swap(std::pair)",
            "path": "en.cppreference.com/w/cpp/utility/pair/swap2.html",
            "wgPageName": "cpp/utility/pair/swap2",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "template<class T1, class T2>\nvoid swap(\n    std::pair<T1, T2>& x,\n    std::pair<T1, T2>&\n        y) noexcept(/* see below */);",
            "other_declarations": 2
        },
        {
            "title": "std::tuple_element<std::pair>",
            "path": "en.cppreference.com/w/cpp/utility/pair/tuple_element.html",
            "wgPageName": "cpp/utility/pair/tuple_element",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "template<std::size_t I, class T1, class T2>\nstruct tuple_element<I, std::pair<T1, T2>>;"
        },
        {
            "title": "std::tuple_size<std::pair>",
            "path": "en.cppreference.com/w/cpp/utility/pair/tuple_size.html",
            "wgPageName": "cpp/utility/pair/tuple_size",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "template<class T1, class T2>\nstruct tuple_size<std::pair<T1, T2>>\n    : std::integral_constant<std::size_t, 2> {};"
        },
        {
            "title": "std::piecewise_construct",
            "path": "en.cppreference.com/w/cpp/utility/piecewise_construct_t.html",
            "wgPageName": "cpp/utility/piecewise_construct",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "struct piecewise_construct_t {\n  explicit piecewise_construct_t() = default;\n};",
            "other_declarations": 2
        },
        {
            "title": "std::piecewise_construct",
            "path": "en.cppreference.com/w/cpp/utility/piecewise_construct.html",
            "wgPageName": "cpp/utility/piecewise_construct",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "struct piecewise_construct_t {\n  explicit piecewise_construct_t() = default;\n};",
            "other_declarations": 2
        },
        {
            "title": "Program support utilities",
            "path": "en.cppreference.com/w/cpp/utility/program.html",
            "wgPageName": "cpp/utility/program"
        },
        {
            "title": "std::_Exit",
            "path": "en.cppreference.com/w/cpp/utility/program/_Exit.html",
            "wgPageName": "cpp/utility/program/_Exit",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "[[noreturn]] void _Exit(int exit_code) noexcept;"
        },
        {
            "title": "std::abort",
            "path": "en.cppreference.com/w/cpp/utility/program/abort.html",
            "wgPageName": "cpp/utility/program/abort",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "void abort();",
            "other_declarations": 1
        },
        {
            "title": "std::at_quick_exit",
            "path": "en.cppreference.com/w/cpp/utility/program/at_quick_exit.html",
            "wgPageName": "cpp/utility/program/at_quick_exit",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "int at_quick_exit(\n    /*atexit-handler*/ *func) noexcept;\nint at_quick_exit(\n    /*c-atexit-handler*/ *func) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::atexit",
            "path": "en.cppreference.com/w/cpp/utility/program/atexit.html",
            "wgPageName": "cpp/utility/program/atexit",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "int atexit(/*c-atexit-handler*/ *func);\nint atexit(/*atexit-handler*/ *func);",
            "other_declarations": 2
        },
        {
            "title": "EXIT_SUCCESS, EXIT_FAILURE",
            "path": "en.cppreference.com/w/cpp/utility/program/EXIT_status.html",
            "wgPageName": "cpp/utility/program/EXIT_status",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "#define EXIT_SUCCESS /*implementation \\\n                        defined*/",
            "other_declarations": 1
        },
        {
            "title": "std::exit",
            "path": "en.cppreference.com/w/cpp/utility/program/exit.html",
            "wgPageName": "cpp/utility/program/exit",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "void exit(int exit_code);",
            "other_declarations": 1
        },
        {
            "title": "std::getenv",
            "path": "en.cppreference.com/w/cpp/utility/program/getenv.html",
            "wgPageName": "cpp/utility/program/getenv",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "char* getenv(const char* env_var);"
        },
        {
            "title": "std::jmp_buf",
            "path": "en.cppreference.com/w/cpp/utility/program/jmp_buf.html",
            "wgPageName": "cpp/utility/program/jmp_buf",
            "headers": [
                "<csetjmp>"
            ],
            "sample_declaration": "typedef /* unspecified */ jmp_buf;"
        },
        {
            "title": "std::longjmp",
            "path": "en.cppreference.com/w/cpp/utility/program/longjmp.html",
            "wgPageName": "cpp/utility/program/longjmp",
            "headers": [
                "<csetjmp>"
            ],
            "sample_declaration": "void longjmp(std::jmp_buf env, int status);",
            "other_declarations": 1
        },
        {
            "title": "std::quick_exit",
            "path": "en.cppreference.com/w/cpp/utility/program/quick_exit.html",
            "wgPageName": "cpp/utility/program/quick_exit",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "[[noreturn]] void quick_exit(\n    int exit_code) noexcept;"
        },
        {
            "title": "std::raise",
            "path": "en.cppreference.com/w/cpp/utility/program/raise.html",
            "wgPageName": "cpp/utility/program/raise",
            "headers": [
                "<csignal>"
            ],
            "sample_declaration": "int raise(int sig);"
        },
        {
            "title": "setjmp",
            "path": "en.cppreference.com/w/cpp/utility/program/setjmp.html",
            "wgPageName": "cpp/utility/program/setjmp",
            "headers": [
                "<csetjmp>"
            ],
            "sample_declaration": "#define setjmp(env) /* implementation-defined \\\n                     */"
        },
        {
            "title": "std::sig_atomic_t",
            "path": "en.cppreference.com/w/cpp/utility/program/sig_atomic_t.html",
            "wgPageName": "cpp/utility/program/sig_atomic_t",
            "headers": [
                "<csignal>"
            ],
            "sample_declaration": "typedef /* unspecified */ sig_atomic_t;"
        },
        {
            "title": "SIG_ERR",
            "path": "en.cppreference.com/w/cpp/utility/program/SIG_ERR.html",
            "wgPageName": "cpp/utility/program/SIG_ERR",
            "headers": [
                "<csignal>"
            ],
            "sample_declaration": "#define SIG_ERR /* implementation defined */"
        },
        {
            "title": "SIG_DFL, SIG_IGN",
            "path": "en.cppreference.com/w/cpp/utility/program/SIG_strategies.html",
            "wgPageName": "cpp/utility/program/SIG_strategies",
            "headers": [
                "<csignal>"
            ],
            "sample_declaration": "#define SIG_DFL /*implementation defined*/",
            "other_declarations": 1
        },
        {
            "title": "SIGTERM, SIGSEGV, SIGINT, SIGILL, SIGABRT, SIGFPE",
            "path": "en.cppreference.com/w/cpp/utility/program/SIG_types.html",
            "wgPageName": "cpp/utility/program/SIG_types",
            "headers": [
                "<csignal>"
            ],
            "sample_declaration": "#define SIGTERM /*implementation defined*/",
            "other_declarations": 5
        },
        {
            "title": "std::signal",
            "path": "en.cppreference.com/w/cpp/utility/program/signal.html",
            "wgPageName": "cpp/utility/program/signal",
            "headers": [
                "<csignal>"
            ],
            "sample_declaration": "/*signal-handler*/ *signal(\n    int sig,\n    /*signal-handler*/ *handler);",
            "other_declarations": 1
        },
        {
            "title": "std::system",
            "path": "en.cppreference.com/w/cpp/utility/program/system.html",
            "wgPageName": "cpp/utility/program/system",
            "headers": [
                "<cstdlib>"
            ],
            "sample_declaration": "int system(const char* command);"
        },
        {
            "title": "std::ranges::swap",
            "path": "en.cppreference.com/w/cpp/utility/ranges/swap.html",
            "wgPageName": "cpp/utility/ranges/swap",
            "headers": [
                "<concepts>"
            ],
            "sample_declaration": "namespace ranges {\ninline namespace /* unspecified */ {\ninline constexpr /* unspecified */ swap =\n    /* unspecified */;\n}\n}  // namespace ranges",
            "other_declarations": 1
        },
        {
            "title": "std::rel_ops::operator!=,>,<=,>=",
            "path": "en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html",
            "wgPageName": "cpp/utility/rel_ops/operator_cmp",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "template<class T>\nbool operator!=(const T& lhs, const T& rhs);",
            "other_declarations": 3
        },
        {
            "title": "std::source_location",
            "path": "en.cppreference.com/w/cpp/utility/source_location.html",
            "wgPageName": "cpp/utility/source_location",
            "headers": [
                "<source_location>"
            ],
            "sample_declaration": "struct source_location;"
        },
        {
            "title": "std::source_location::column",
            "path": "en.cppreference.com/w/cpp/utility/source_location/column.html",
            "wgPageName": "cpp/utility/source_location/column",
            "sample_declaration": "constexpr std::uint_least32_t column()\n    const noexcept;"
        },
        {
            "title": "std::source_location::current",
            "path": "en.cppreference.com/w/cpp/utility/source_location/current.html",
            "wgPageName": "cpp/utility/source_location/current",
            "sample_declaration": "static consteval source_location\ncurrent() noexcept;"
        },
        {
            "title": "std::source_location::file_name",
            "path": "en.cppreference.com/w/cpp/utility/source_location/file_name.html",
            "wgPageName": "cpp/utility/source_location/file_name",
            "sample_declaration": "constexpr const char* file_name()\n    const noexcept;"
        },
        {
            "title": "std::source_location::function_name",
            "path": "en.cppreference.com/w/cpp/utility/source_location/function_name.html",
            "wgPageName": "cpp/utility/source_location/function_name",
            "sample_declaration": "constexpr const char* function_name()\n    const noexcept;"
        },
        {
            "title": "std::source_location::line",
            "path": "en.cppreference.com/w/cpp/utility/source_location/line.html",
            "wgPageName": "cpp/utility/source_location/line",
            "sample_declaration": "constexpr std::uint_least32_t line()\n    const noexcept;"
        },
        {
            "title": "std::source_location::source_location",
            "path": "en.cppreference.com/w/cpp/utility/source_location/source_location.html",
            "wgPageName": "cpp/utility/source_location/source_location",
            "sample_declaration": "constexpr source_location() noexcept;",
            "other_declarations": 2
        },
        {
            "title": "std::stacktrace_entry",
            "path": "en.cppreference.com/w/cpp/utility/stacktrace_entry.html",
            "wgPageName": "cpp/utility/stacktrace_entry",
            "headers": [
                "<stacktrace>"
            ],
            "sample_declaration": "class stacktrace_entry;"
        },
        {
            "title": "std::stacktrace_entry::description",
            "path": "en.cppreference.com/w/cpp/utility/stacktrace_entry/description.html",
            "wgPageName": "cpp/utility/stacktrace_entry/description",
            "sample_declaration": "std::string description() const;"
        },
        {
            "title": "std::hash(std::stacktrace_entry)",
            "path": "en.cppreference.com/w/cpp/utility/stacktrace_entry/hash.html",
            "wgPageName": "cpp/utility/stacktrace_entry/hash",
            "headers": [
                "<stacktrace>"
            ],
            "sample_declaration": "template<>\nstruct hash<std::stacktrace_entry>;"
        },
        {
            "title": "std::stacktrace_entry::native_handle",
            "path": "en.cppreference.com/w/cpp/utility/stacktrace_entry/native_handle.html",
            "wgPageName": "cpp/utility/stacktrace_entry/native_handle",
            "sample_declaration": "constexpr native_handle_type native_handle()\n    const noexcept;"
        },
        {
            "title": "std::stacktrace_entry::operator bool",
            "path": "en.cppreference.com/w/cpp/utility/stacktrace_entry/operator_bool.html",
            "wgPageName": "cpp/utility/stacktrace_entry/operator_bool",
            "sample_declaration": "constexpr explicit operator bool()\n    const noexcept;"
        },
        {
            "title": "operator==, operator<=>(std::stacktrace_entry)",
            "path": "en.cppreference.com/w/cpp/utility/stacktrace_entry/operator_cmp.html",
            "wgPageName": "cpp/utility/stacktrace_entry/operator_cmp",
            "sample_declaration": "friend constexpr bool operator==(\n    const stacktrace_entry& lhs,\n    const stacktrace_entry& rhs) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::operator<<(std::stacktrace_entry)",
            "path": "en.cppreference.com/w/cpp/utility/stacktrace_entry/operator_ltlt.html",
            "wgPageName": "cpp/utility/stacktrace_entry/operator_ltlt",
            "headers": [
                "<stacktrace>"
            ],
            "sample_declaration": "template<class CharT, class Traits>\nstd::basic_ostream<CharT, Traits>& operator<<(\n    std::basic_ostream<CharT, Traits>& os,\n    const std::stacktrace_entry& f);"
        },
        {
            "title": "std::stacktrace_entry::operator=",
            "path": "en.cppreference.com/w/cpp/utility/stacktrace_entry/operator=.html",
            "wgPageName": "cpp/utility/stacktrace_entry/operator=",
            "sample_declaration": "constexpr stacktrace_entry& operator=(\n    const stacktrace_entry& other) noexcept;"
        },
        {
            "title": "std::stacktrace_entry::source_file",
            "path": "en.cppreference.com/w/cpp/utility/stacktrace_entry/source_file.html",
            "wgPageName": "cpp/utility/stacktrace_entry/source_file",
            "sample_declaration": "std::string source_file() const;"
        },
        {
            "title": "std::stacktrace_entry::source_line",
            "path": "en.cppreference.com/w/cpp/utility/stacktrace_entry/source_line.html",
            "wgPageName": "cpp/utility/stacktrace_entry/source_line",
            "sample_declaration": "std::uint_least32_t source_line() const;"
        },
        {
            "title": "std::stacktrace_entry::stacktrace_entry",
            "path": "en.cppreference.com/w/cpp/utility/stacktrace_entry/stacktrace_entry.html",
            "wgPageName": "cpp/utility/stacktrace_entry/stacktrace_entry",
            "sample_declaration": "constexpr stacktrace_entry() noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::to_string",
            "path": "en.cppreference.com/w/cpp/utility/stacktrace_entry/to_string.html",
            "wgPageName": "cpp/utility/stacktrace_entry/to_string",
            "headers": [
                "<stacktrace>"
            ],
            "sample_declaration": "std::string to_string(\n    const std::stacktrace_entry& f);"
        },
        {
            "title": "std::to_chars, std::to_chars_result",
            "path": "en.cppreference.com/w/cpp/utility/to_chars.html",
            "wgPageName": "cpp/utility/to_chars",
            "headers": [
                "<charconv>"
            ],
            "sample_declaration": "std::to_chars_result to_chars(\n    char* first,\n    char* last,\n    /*see below*/ value,\n    int base = 10);",
            "other_declarations": 6
        },
        {
            "title": "std::to_underlying",
            "path": "en.cppreference.com/w/cpp/utility/to_underlying.html",
            "wgPageName": "cpp/utility/to_underlying",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "template<class Enum>\nconstexpr std::underlying_type_t<Enum>\nto_underlying(Enum e) noexcept;"
        },
        {
            "title": "std::tuple_element",
            "path": "en.cppreference.com/w/cpp/utility/tuple_element.html",
            "wgPageName": "cpp/utility/tuple_element",
            "headers": [
                "<tuple>",
                "<array>",
                "<utility>",
                "<ranges>"
            ],
            "sample_declaration": "template<std::size_t I, class T>\nstruct tuple_element;  // not defined",
            "other_declarations": 3
        },
        {
            "title": "std::tuple_size",
            "path": "en.cppreference.com/w/cpp/utility/tuple_size.html",
            "wgPageName": "cpp/utility/tuple_size",
            "headers": [
                "<tuple>",
                "<array>",
                "<utility>",
                "<ranges>"
            ],
            "sample_declaration": "template<class T>\nstruct tuple_size;  // not defined",
            "other_declarations": 3
        },
        {
            "title": "std::tuple",
            "path": "en.cppreference.com/w/cpp/utility/tuple.html",
            "wgPageName": "cpp/utility/tuple",
            "headers": [
                "<tuple>"
            ],
            "sample_declaration": "template<class... Types>\nclass tuple;"
        },
        {
            "title": "std::basic_common_reference<tuple-like>",
            "path": "en.cppreference.com/w/cpp/utility/tuple/basic_common_reference.html",
            "wgPageName": "cpp/utility/tuple/basic_common_reference",
            "headers": [
                "<tuple>"
            ],
            "sample_declaration": "template<\n    /*tuple-like*/ TTuple,\n    /*tuple-like*/ UTuple,\n    template<class>\n    class TQual,\n    template<class>\n    class UQual>\nrequires /* see below */\n    struct basic_common_reference<\n        TTuple,\n        UTuple,\n        TQual,\n        UQual>;"
        },
        {
            "title": "std::common_type<tuple-like>",
            "path": "en.cppreference.com/w/cpp/utility/tuple/common_type.html",
            "wgPageName": "cpp/utility/tuple/common_type",
            "headers": [
                "<tuple>"
            ],
            "sample_declaration": "template<\n    /*tuple-like*/ TTuple,\n    /*tuple-like*/ UTuple>\nrequires /* see below */ struct common_type<\n    TTuple,\n    UTuple>;"
        },
        {
            "title": "deduction guides for std::tuple",
            "path": "en.cppreference.com/w/cpp/utility/tuple/deduction_guides.html",
            "wgPageName": "cpp/utility/tuple/deduction_guides",
            "headers": [
                "<tuple>"
            ],
            "sample_declaration": "template<class... UTypes>\ntuple(UTypes...) -> tuple<UTypes...>;",
            "other_declarations": 4
        },
        {
            "title": "std::forward_as_tuple",
            "path": "en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple.html",
            "wgPageName": "cpp/utility/tuple/forward_as_tuple",
            "headers": [
                "<tuple>"
            ],
            "sample_declaration": "template<class... Types>\ntuple<Types&&...> forward_as_tuple(\n    Types&&... args) noexcept;"
        },
        {
            "title": "std::get(std::tuple)",
            "path": "en.cppreference.com/w/cpp/utility/tuple/get.html",
            "wgPageName": "cpp/utility/tuple/get",
            "headers": [
                "<tuple>"
            ],
            "sample_declaration": "template<std::size_t I, class... Types>\ntypename std::\n    tuple_element<I, tuple<Types...> >::type&\n    get(tuple<Types...>& t) noexcept;",
            "other_declarations": 7
        },
        {
            "title": "std::ignore",
            "path": "en.cppreference.com/w/cpp/utility/tuple/ignore.html",
            "wgPageName": "cpp/utility/tuple/ignore",
            "headers": [
                "<tuple>"
            ],
            "sample_declaration": "const /*unspecified*/ ignore;",
            "other_declarations": 1
        },
        {
            "title": "std::make_tuple",
            "path": "en.cppreference.com/w/cpp/utility/tuple/make_tuple.html",
            "wgPageName": "cpp/utility/tuple/make_tuple",
            "headers": [
                "<tuple>"
            ],
            "sample_declaration": "template<class... Types>\nstd::tuple<VTypes...> make_tuple(\n    Types&&... args);"
        },
        {
            "title": "operator==,!=,<,<=,>,>=,<=>(std::tuple)",
            "path": "en.cppreference.com/w/cpp/utility/tuple/operator_cmp.html",
            "wgPageName": "cpp/utility/tuple/operator_cmp",
            "headers": [
                "<tuple>"
            ],
            "sample_declaration": "template<class... TTypes, class... UTypes>\nbool operator==(\n    const std::tuple<TTypes...>& lhs,\n    const std::tuple<UTypes...>& rhs);",
            "other_declarations": 12
        },
        {
            "title": "std::tuple<Types...>::operator=",
            "path": "en.cppreference.com/w/cpp/utility/tuple/operator=.html",
            "wgPageName": "cpp/utility/tuple/operator=",
            "sample_declaration": "tuple& operator=(const tuple& other);",
            "other_declarations": 17
        },
        {
            "title": "std::tuple<Types...>::swap",
            "path": "en.cppreference.com/w/cpp/utility/tuple/swap.html",
            "wgPageName": "cpp/utility/tuple/swap",
            "headers": [
                "<tuple>"
            ],
            "sample_declaration": "void swap(tuple& other) noexcept(\n    /* see below */);",
            "other_declarations": 2
        },
        {
            "title": "std::swap(std::tuple)",
            "path": "en.cppreference.com/w/cpp/utility/tuple/swap2.html",
            "wgPageName": "cpp/utility/tuple/swap2",
            "headers": [
                "<tuple>"
            ],
            "sample_declaration": "template<class... Types>\nvoid swap(\n    std::tuple<Types...>& lhs,\n    std::tuple<Types...>&\n        rhs) noexcept(/* see below */);",
            "other_declarations": 2
        },
        {
            "title": "std::tie",
            "path": "en.cppreference.com/w/cpp/utility/tuple/tie.html",
            "wgPageName": "cpp/utility/tuple/tie",
            "headers": [
                "<tuple>"
            ],
            "sample_declaration": "template<class... Types>\nstd::tuple<Types&...> tie(\n    Types&... args) noexcept;",
            "other_declarations": 1
        },
        {
            "title": "std::tuple_cat",
            "path": "en.cppreference.com/w/cpp/utility/tuple/tuple_cat.html",
            "wgPageName": "cpp/utility/tuple/tuple_cat",
            "headers": [
                "<tuple>"
            ],
            "sample_declaration": "template<class... Tuples>\nstd::tuple<CTypes...> tuple_cat(\n    Tuples&&... args);"
        },
        {
            "title": "std::tuple_element<std::tuple>",
            "path": "en.cppreference.com/w/cpp/utility/tuple/tuple_element.html",
            "wgPageName": "cpp/utility/tuple/tuple_element",
            "headers": [
                "<tuple>"
            ],
            "sample_declaration": "template<std::size_t I, class... Types>\nstruct tuple_element<I, std::tuple<Types...> >;"
        },
        {
            "title": "std::tuple_size<std::tuple>",
            "path": "en.cppreference.com/w/cpp/utility/tuple/tuple_size.html",
            "wgPageName": "cpp/utility/tuple/tuple_size",
            "headers": [
                "<tuple>"
            ],
            "sample_declaration": "template<class... Types>\nstruct tuple_size<std::tuple<Types...> >\n    : std::integral_constant<\n          std::size_t,\n          sizeof...(Types)> {};"
        },
        {
            "title": "std::tuple<Types...>::tuple",
            "path": "en.cppreference.com/w/cpp/utility/tuple/tuple.html",
            "wgPageName": "cpp/utility/tuple/tuple",
            "headers": [
                "<tuple>"
            ],
            "sample_declaration": "constexpr tuple();",
            "other_declarations": 25
        },
        {
            "title": "std::uses_allocator<std::tuple>",
            "path": "en.cppreference.com/w/cpp/utility/tuple/uses_allocator.html",
            "wgPageName": "cpp/utility/tuple/uses_allocator",
            "headers": [
                "<tuple>"
            ],
            "sample_declaration": "template<class... Types, class Alloc>\nstruct uses_allocator<\n    std::tuple<Types...>,\n    Alloc> : std::true_type {};"
        },
        {
            "title": "std::unreachable",
            "path": "en.cppreference.com/w/cpp/utility/unreachable.html",
            "wgPageName": "cpp/utility/unreachable",
            "headers": [
                "<utility>"
            ],
            "sample_declaration": "[[noreturn]] void unreachable();"
        },
        {
            "title": "Variadic functions",
            "path": "en.cppreference.com/w/cpp/utility/variadic.html",
            "wgPageName": "cpp/utility/variadic"
        },
        {
            "title": "va_arg",
            "path": "en.cppreference.com/w/cpp/utility/variadic/va_arg.html",
            "wgPageName": "cpp/utility/variadic/va_arg",
            "headers": [
                "<cstdarg>"
            ],
            "sample_declaration": "T va_arg(std::va_list ap, T);"
        },
        {
            "title": "va_copy",
            "path": "en.cppreference.com/w/cpp/utility/variadic/va_copy.html",
            "wgPageName": "cpp/utility/variadic/va_copy",
            "headers": [
                "<cstdarg>"
            ],
            "sample_declaration": "void va_copy(\n    std::va_list dest,\n    std::va_list src);"
        },
        {
            "title": "va_end",
            "path": "en.cppreference.com/w/cpp/utility/variadic/va_end.html",
            "wgPageName": "cpp/utility/variadic/va_end",
            "headers": [
                "<cstdarg>"
            ],
            "sample_declaration": "void va_end(std::va_list ap);"
        },
        {
            "title": "std::va_list",
            "path": "en.cppreference.com/w/cpp/utility/variadic/va_list.html",
            "wgPageName": "cpp/utility/variadic/va_list",
            "headers": [
                "<cstdarg>"
            ],
            "sample_declaration": "typedef /* unspecified */ va_list;"
        },
        {
            "title": "va_start",
            "path": "en.cppreference.com/w/cpp/utility/variadic/va_start.html",
            "wgPageName": "cpp/utility/variadic/va_start",
            "headers": [
                "<cstdarg>"
            ],
            "sample_declaration": "void va_start(std::va_list ap, parm_n);"
        },
        {
            "title": "std::variant",
            "path": "en.cppreference.com/w/cpp/utility/variant.html",
            "wgPageName": "cpp/utility/variant",
            "headers": [
                "<variant>"
            ],
            "sample_declaration": "template<class... Types>\nclass variant;"
        },
        {
            "title": "std::variant<Types...>::~variant",
            "path": "en.cppreference.com/w/cpp/utility/variant/~variant.html",
            "wgPageName": "cpp/utility/variant/~variant",
            "sample_declaration": "~variant();",
            "other_declarations": 1
        },
        {
            "title": "std::bad_variant_access",
            "path": "en.cppreference.com/w/cpp/utility/variant/bad_variant_access.html",
            "wgPageName": "cpp/utility/variant/bad_variant_access",
            "headers": [
                "<variant>"
            ],
            "sample_declaration": "class bad_variant_access : public std::exception"
        },
        {
            "title": "std::variant<Types...>::emplace",
            "path": "en.cppreference.com/w/cpp/utility/variant/emplace.html",
            "wgPageName": "cpp/utility/variant/emplace",
            "sample_declaration": "template<class T, class... Args>\nT& emplace(Args&&... args);",
            "other_declarations": 7
        },
        {
            "title": "std::get_if (std::variant)",
            "path": "en.cppreference.com/w/cpp/utility/variant/get_if.html",
            "wgPageName": "cpp/utility/variant/get_if",
            "headers": [
                "<variant>"
            ],
            "sample_declaration": "template<std::size_t I, class... Types>\nconstexpr std::add_pointer_t<\n    std::variant_alternative_t<\n        I,\n        std::variant<Types...>>>\nget_if(std::variant<Types...>* pv) noexcept;",
            "other_declarations": 3
        },
        {
            "title": "std::get (std::variant)",
            "path": "en.cppreference.com/w/cpp/utility/variant/get.html",
            "wgPageName": "cpp/utility/variant/get",
            "headers": [
                "<variant>"
            ],
            "sample_declaration": "template<std::size_t I, class... Types>\nconstexpr std::variant_alternative_t<\n    I,\n    std::variant<Types...>>&\nget(std::variant<Types...>& v);",
            "other_declarations": 7
        },
        {
            "title": "std::hash <std::variant>",
            "path": "en.cppreference.com/w/cpp/utility/variant/hash.html",
            "wgPageName": "cpp/utility/variant/hash",
            "headers": [
                "<variant>"
            ],
            "sample_declaration": "template<class... Types>\nstruct hash<std::variant<Types...>>;"
        },
        {
            "title": "std::holds_alternative",
            "path": "en.cppreference.com/w/cpp/utility/variant/holds_alternative.html",
            "wgPageName": "cpp/utility/variant/holds_alternative",
            "headers": [
                "<variant>"
            ],
            "sample_declaration": "template<class T, class... Types>\nconstexpr bool holds_alternative(\n    const std::variant<Types...>& v) noexcept;"
        },
        {
            "title": "std::variant<Types...>::index",
            "path": "en.cppreference.com/w/cpp/utility/variant/index.html",
            "wgPageName": "cpp/utility/variant/index",
            "sample_declaration": "constexpr std::size_t index() const noexcept;"
        },
        {
            "title": "std::monostate",
            "path": "en.cppreference.com/w/cpp/utility/variant/monostate.html",
            "wgPageName": "cpp/utility/variant/monostate",
            "headers": [
                "<variant>"
            ],
            "sample_declaration": "struct monostate {};"
        },
        {
            "title": "operator==, !=, <, <=, >, >=, <=>(std::variant)",
            "path": "en.cppreference.com/w/cpp/utility/variant/operator_cmp.html",
            "wgPageName": "cpp/utility/variant/operator_cmp",
            "headers": [
                "<variant>"
            ],
            "sample_declaration": "template< class... Types >\nconstexpr bool operator==( const std::variant<Types...>& v, \n\n                           const std::variant<Types...>& w );",
            "other_declarations": 6
        },
        {
            "title": "std::variant<Types...>::operator=",
            "path": "en.cppreference.com/w/cpp/utility/variant/operator=.html",
            "wgPageName": "cpp/utility/variant/operator=",
            "sample_declaration": "constexpr variant& operator=(\n    const variant& rhs);",
            "other_declarations": 3
        },
        {
            "title": "std::variant<Types...>::swap",
            "path": "en.cppreference.com/w/cpp/utility/variant/swap.html",
            "wgPageName": "cpp/utility/variant/swap",
            "sample_declaration": "void swap(variant& rhs) noexcept(\n    /* see below */);",
            "other_declarations": 1
        },
        {
            "title": "std::swap(std::variant)",
            "path": "en.cppreference.com/w/cpp/utility/variant/swap2.html",
            "wgPageName": "cpp/utility/variant/swap2",
            "headers": [
                "<variant>"
            ],
            "sample_declaration": "template<class... Types>\nvoid swap(\n    std::variant<Types...>& lhs,\n    std::variant<Types...>&\n        rhs) noexcept(/* see below */);",
            "other_declarations": 1
        },
        {
            "title": "std::variant<Types...>::valueless_by_exception",
            "path": "en.cppreference.com/w/cpp/utility/variant/valueless_by_exception.html",
            "wgPageName": "cpp/utility/variant/valueless_by_exception",
            "sample_declaration": "constexpr bool valueless_by_exception() const noexcept;"
        },
        {
            "title": "std::variant_alternative, std::variant_alternative_t",
            "path": "en.cppreference.com/w/cpp/utility/variant/variant_alternative.html",
            "wgPageName": "cpp/utility/variant/variant_alternative",
            "headers": [
                "<variant>"
            ],
            "sample_declaration": "template <std::size_t I, class T>\nstruct variant_alternative; /* undefined */",
            "other_declarations": 3
        },
        {
            "title": "std::variant_npos",
            "path": "en.cppreference.com/w/cpp/utility/variant/variant_npos.html",
            "wgPageName": "cpp/utility/variant/variant_npos",
            "headers": [
                "<variant>"
            ],
            "sample_declaration": "inline constexpr std::size_t variant_npos = -1;"
        },
        {
            "title": "std::variant_size, std::variant_size_v",
            "path": "en.cppreference.com/w/cpp/utility/variant/variant_size.html",
            "wgPageName": "cpp/utility/variant/variant_size",
            "headers": [
                "<variant>"
            ],
            "sample_declaration": "template <class T>\nstruct variant_size; /* undefined */",
            "other_declarations": 3
        },
        {
            "title": "std::variant<Types...>::variant",
            "path": "en.cppreference.com/w/cpp/utility/variant/variant.html",
            "wgPageName": "cpp/utility/variant/variant",
            "sample_declaration": "constexpr variant() noexcept(/* see below */);",
            "other_declarations": 7
        },
        {
            "title": "std::visit",
            "path": "en.cppreference.com/w/cpp/utility/variant/visit.html",
            "wgPageName": "cpp/utility/variant/visit",
            "headers": [
                "<variant>"
            ],
            "sample_declaration": "template <class Visitor, class... Variants>\nconstexpr /*see below*/ visit( Visitor&& vis, Variants&&... vars );",
            "other_declarations": 1
        }
    ]
}